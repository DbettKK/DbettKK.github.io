<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="JVMJVM的架构模型Java编译器输入的指令基本是一种基于栈的指令集架构，另外一种架构则是基于寄存器的指令集架构。">
<meta name="keywords" content="学习">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;03&#x2F;05&#x2F;jvm&#x2F;index.html">
<meta property="og:site_name" content="Dbettkk-Blog">
<meta property="og:description" content="JVMJVM的架构模型Java编译器输入的指令基本是一种基于栈的指令集架构，另外一种架构则是基于寄存器的指令集架构。">
<meta property="og:locale" content="en">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2021&#x2F;02&#x2F;17&#x2F;NuiwLdIh7CYcTxb.png">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2021&#x2F;02&#x2F;18&#x2F;Pf6Mkxzy1YAluLB.png">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2021&#x2F;02&#x2F;22&#x2F;XkhOpQFZ5VGNyKg.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;.com&#x2F;&#x2F;C:%5CUsers%5C34879%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210225184559735.png">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2021&#x2F;02&#x2F;27&#x2F;erKuL7W94NUfzDT.png">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2021&#x2F;02&#x2F;27&#x2F;N4uhJcVdFqR9BX2.png">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2021&#x2F;02&#x2F;28&#x2F;9uA7mCrLo1dXHID.png">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2021&#x2F;03&#x2F;03&#x2F;c8nYaLOTkhr3DlH.png">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2021&#x2F;03&#x2F;03&#x2F;w6mbDEpgxHdSyo2.png">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2021&#x2F;03&#x2F;04&#x2F;Idiyfvm8cHtTwxY.png">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2021&#x2F;03&#x2F;04&#x2F;qxfND297J8VGFip.png">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2021&#x2F;03&#x2F;04&#x2F;oFTlgyn5s2i61VQ.png">
<meta property="og:updated_time" content="2021-04-29T08:13:13.643Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2021&#x2F;02&#x2F;17&#x2F;NuiwLdIh7CYcTxb.png">

<link rel="canonical" href="http://yoursite.com/2021/03/05/jvm/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>JVM | Dbettkk-Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Dbettkk-Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/05/jvm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Bcutty Kmy">
      <meta itemprop="description" content="NO DEPENDENCE ONLY PRIDE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dbettkk-Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JVM
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-05 19:06:50" itemprop="dateCreated datePublished" datetime="2021-03-05T19:06:50+08:00">2021-03-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-29 16:13:13" itemprop="dateModified" datetime="2021-04-29T16:13:13+08:00">2021-04-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
            <span id="/2021/03/05/jvm/" class="post-meta-item leancloud_visitors" data-flag-title="JVM" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2021/03/05/jvm/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/03/05/jvm/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h3 id="JVM的架构模型"><a href="#JVM的架构模型" class="headerlink" title="JVM的架构模型"></a>JVM的架构模型</h3><p>Java编译器输入的指令基本是一种<strong>基于栈的指令集架构</strong>，另外一种架构则是基于寄存器的指令集架构。</p>
<a id="more"></a>
<blockquote>
<p>栈：跨平台性、指令集小，但指令较多。执行性能比寄存器架构差一些。<br>寄存器：性能较好、指令少但是和硬件耦合性强，无法实现跨平台。</p>
</blockquote>
<h3 id="JVM的生命周期"><a href="#JVM的生命周期" class="headerlink" title="JVM的生命周期"></a>JVM的生命周期</h3><p>启动：通过引导类加载器(bootstrap class loader)创建一个初始类来完成的，该类由虚拟机具体实现指定。</p>
<p>执行：执行java程序。程序执行的时候就运行，程序结束的时候就停止。执行一个Java程序时，真实在执行的时候是一个进程。</p>
<p>退出：以下几种情况：①程序正常执行结束；②程序执行过程中出现异常或错误；③OS出现错误导致Java虚拟机进程终止；④某线程调用Runtime类或者System类的exit()方法或者Runtime类的halt()方法，且Java安全管理器也允许此次操作。⑤除此之外，JNI ( Java Native Interface)规范描述了用JNI Invocation API来加载或卸载Java虚拟机时，Java虚拟机的退出情况。</p>
<h3 id="JVM发展历程"><a href="#JVM发展历程" class="headerlink" title="JVM发展历程"></a>JVM发展历程</h3><p>Sun Classic VM：世界上第一款商用Java虚拟机，JDK 1.4时被完全淘汰。内部只提供解释器而没有JIT。</p>
<p>Exact VM：准确式内存管理，可以知道内存中某个位置的数据具体是什么类型。也已经能够编译器解释器混合工作和具备热点检测的功能。JDK 1.2时提供该虚拟机。</p>
<p>HotSpot VM：JDK 1.3时，HotSpot称为默认虚拟机。其名称即热点代码检测技术，通过计数器来找到热点代码触发即时编译或栈上替换。</p>
<blockquote>
<p>解释器——保证响应时间，编译器——保证执行性能。</p>
</blockquote>
<p>JRockit ：专注于服务器端应用，内部不包含解释器实现，全部靠JIT编译执行。是世界上最快的JVM。</p>
<p>J9：与HotSpot市场定位相似，在自家产品上性能很好。</p>
<h2 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h2><h3 id="内存结构概述"><a href="#内存结构概述" class="headerlink" title="内存结构概述"></a>内存结构概述</h3><p>见图</p>
<h3 id="类加载器和类加载过程"><a href="#类加载器和类加载过程" class="headerlink" title="类加载器和类加载过程"></a>类加载器和类加载过程</h3><ul>
<li>类加载器子系统负责从文件系统或者网络中加载class文件，class文件在文件开头有特定的文件标识。</li>
<li>ClassLoader只负责class文件的加载，至于它是否可以运行，则由ExecutionEngine决定。</li>
<li>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射)</li>
</ul>
<p>加载(Loading)：</p>
<blockquote>
<p>1．通过一个类的全限定名获取定义此类的二进制字节流<br>2．将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构<br>3．<font color="red">在内存中生成一个代表这个类的java.lang.Class对象</font>，作为方法区这个类的各种数据的访问入口</p>
<p>笔者理解：加载阶段内存中已经存在Class对象。</p>
</blockquote>
<p>补充: 加载.class文件的方式</p>
<blockquote>
<ul>
<li>从本地系统中直接加载</li>
<li>通过网络获取，典型场景: web Applet</li>
<li>从zip压缩包中读取，成为日后jar、war格式的基础</li>
<li>运行时计算生成，使用最多的是:动态代理技术</li>
<li>由其他文件生成，典型场景：JSP应用</li>
<li>从专有数据库中提取.class文件，比较少见</li>
<li>从加密文件中获取，典型的防class文件被反编译的保护措施</li>
</ul>
</blockquote>
<p>链接(Linking)：</p>
<blockquote>
<p>验证(Verify):</p>
<blockquote>
<ul>
<li>目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，<br>不会危害虚拟机自身安全。</li>
<li>主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</li>
</ul>
</blockquote>
<p>准备(Prepare):</p>
<blockquote>
<ul>
<li>为类变量分配内存并且设置该类变量的默认初始值，即零值。</li>
<li>这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式<br>初始化;</li>
<li>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。</li>
</ul>
<p>笔者理解：将所有类变量初始化为默认值。</p>
</blockquote>
<p>解析(Resolve) :</p>
<blockquote>
<ul>
<li>将常量池内的符号引用转换为直接引用的过程。</li>
<li>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。</li>
<li>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</li>
<li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的<br>CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等</li>
</ul>
</blockquote>
</blockquote>
<p>初始化(initialization)：</p>
<blockquote>
<ul>
<li>初始化阶段就是执行类构造器方法&lt;clinit&gt;()的过程。</li>
<li>此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。</li>
<li>构造器方法中指令按语句在源文件中出现的顺序执行。</li>
<li>&lt;clinit&gt;()不同于类的构造器。(关联：构造器是虚拟机视角下的&lt;init&gt;())若该类具有父类，JVM会保证子类的&lt;clinit&gt;()执行前，父类的&lt;clinit&gt;()己经执行完毕。</li>
<li>虚拟机必须保证一个类的&lt;clinit&gt;()方法在多线程下被同步加锁。</li>
</ul>
<p>笔者理解：clinit方法即赋值类的所有静态变量以及执行静态代码块。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        num = <span class="number">10</span>;</span><br><span class="line">        number = <span class="number">20</span>;</span><br><span class="line">        System.println.out(number); <span class="comment">// 报错 非法前向引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">10</span>; </span><br><span class="line">    <span class="comment">// Linking的prepare阶段：number = 0 --&gt; initial: number = 20 --&gt; number = 10</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.println.out(number); <span class="comment">// 10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h3><p>JVM支持两种类型的类加载器，分别为引导类加载器(BootstrapClassLoader[由c、c++实现])和自定义类加载器(User-Defined classLoader） 。</p>
<p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。</p>
<p>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有4类，启动类加载器、扩展类加载器、系统类加载器、用户自定义加载器。且这里的四者之间的关系是包含关系。不是上层下层，也不是子父类的继承关系。</p>
<p>启动类加载器：</p>
<blockquote>
<p>这个类加载使用c/c++语言实现的，嵌套在JVM内部。</p>
<p>它用来加载Java的核心库（JAVA_HOME/jre/ lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类.</p>
<p>并不继承自java.lang.ClassLoader，没有父加载器。</p>
<p>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</p>
<p>出于安全考虑，Bootstrap启动类加载器只加载包名为java、 javax、sun等开头的类</p>
</blockquote>
<p>扩展类加载器（Extension classLoader)</p>
<blockquote>
<p>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</p>
<p>派生于classLoader类</p>
<p>父类加载器为启动类加载器</p>
<p>从java.ext.dirs系统属性所指定的目录加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录)下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</p>
</blockquote>
<p>应用程序类加载器（系统类加载器，AppclassLoader)</p>
<blockquote>
<p>java语言编写由sun.misc.Launcher$AppclassLoader实现</p>
<p>派生于classLoader类</p>
<p>父类加载器为扩展类加载器</p>
<p>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</p>
<p>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</p>
<p>通过ClassLoader.getSystemClassLoader()方法可以获取到该类加载器</p>
</blockquote>
<p>用户自定义类加载器</p>
<blockquote>
<p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。</p>
<p>为什么要自定义类加载器?</p>
<blockquote>
<p>隔离加载类(防止中间件和框架之间的冲突)</p>
<p>修改类加载的方式</p>
<p>扩展加载源</p>
<p>防止源码泄漏</p>
</blockquote>
<p>用户自定义类加载器实现步骤:</p>
<ul>
<li>开发人员可以通过继承抽象类java.lang.classLoader类的方式，实现自己的类加载器，以满足一些特殊的需求</li>
<li>在JDK1.2之前，在自定义类加载器时，总会去继承classLoader类并重写loadclass ()方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖loadclass ()方法，而是建议把自定义的类加载逻辑写在findclass()方法中</li>
<li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写findclass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li>
</ul>
</blockquote>
<h3 id="ClassLoader类"><a href="#ClassLoader类" class="headerlink" title="ClassLoader类"></a>ClassLoader类</h3><p>抽象类，其后所有类加载器都继承于该类(除了启动类加载器)。</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">getParent()</td>
<td align="center">返回该类加载器的超类加载器</td>
</tr>
<tr>
<td align="center">loadClass(String name)</td>
<td align="center">加载名称为name的类，返回结果为java.lang.Class类的实例</td>
</tr>
<tr>
<td align="center">findClass(String name)</td>
<td align="center">查找名称为name的类，返回结果为java.lang.Class类的实例</td>
</tr>
<tr>
<td align="center">findLoadedClass(String name)</td>
<td align="center">查找名称为name的已经被加载过的类，返回结果为java.lang.Class类的实例</td>
</tr>
<tr>
<td align="center">defineClass(String name, byte[] b, int off, int len)</td>
<td align="center">把字节数组b中的内容转换为一个Java类，返回结果为java.lang.Class类的实例</td>
</tr>
<tr>
<td align="center">resolveClass(Class&lt;?&gt; c)</td>
<td align="center">连接指定的一个Java类</td>
</tr>
</tbody></table>
<p>获取ClassLoader的途径</p>
<blockquote>
<p>获取当前类的类加载器：class.getClassLoader()</p>
<p>获取当前线程上下文的类加载器：Thread.currentThread().getContextClassLoader()</p>
<p>获取系统的类加载器：ClassLoader.getSystemClassLoader()</p>
<p>获取调用者的类加载器：DriverManager.getCallerClassLoader()</p>
</blockquote>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>Java虚拟机对class文件采用的是<font color="red">按需加载</font>的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是<font color="red">双亲委派模式</font>即把请求交由父类处理,它是一种任务委派模式。</p>
<p><font color="red">工作原理</font></p>
<blockquote>
<p>1)如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类豳加载器去执行;<br>2)如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器<br>3)如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</p>
</blockquote>
<p>双亲委派机制的优势</p>
<blockquote>
<p>避免类的重复加载</p>
<p>保护程序安全，防止核心API被随意篡改(java.lang.xxx是不允许自定义的)</p>
</blockquote>
<p>沙箱安全机制</p>
<blockquote>
<p>自定义java.lang.String类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件(rt.jar包中java\lang\String.class)，报错信息说没有main方法，就是因为加载的是rt.jar包中的String类。这样可以保证对java核心源代码的保护，这就是<strong>沙箱安全机制</strong>。</p>
</blockquote>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>在JVM中表示两个class对象是否为同一个类存在两个必要条件:</p>
<blockquote>
<p>类的完整类名必须一致，包括包名。<br>加载这个类的ClassLoader(指ClassLoader实例对象)必须相同。</p>
</blockquote>
<p>换句话说，在JVM中，即使这两个类对象(Class对象)来源同一个class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的。</p>
<p>对类加载器的引用</p>
<blockquote>
<p>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会<strong>将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</strong>。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。</p>
</blockquote>
<p>类的主动使用和被动使用</p>
<blockquote>
<p>主动使用，分为七种情况:</p>
<blockquote>
<p>创建类的实例<br>访问某个类或接口的静态变量，或者对该静态变量赋值<br>调用类的静态方法<br>反射（比如:Class.forName(“com.atguigu.Test”))<br>初始化一个类的子类<br>Java虚拟机启动时被标明为启动类的类<br>JDK 7 开始提供的动态语言支持:<br>java . lang.invoke.MethodHandle实例的解析结果<br>REF_getstatic、REF_putstatic、REF_invokestatic句柄对应的类没有初始化，则初始化</p>
</blockquote>
<p>除了以上七种情况，其他使用Java类的方式都被看作是对类的<strong>被动使用</strong>，都<strong>不会导致类的初始化</strong>。</p>
<p>即主动使用和被动使用的区别即是否会导致类的初始化(执行类构造器方法&lt;clinit&gt;())。</p>
</blockquote>
<h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><p>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。<strong>不同的JVM对于内存的划分方式和管理机制存在着部分差异</strong>。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。</p>
<p>线程私有：PC寄存器、栈、本地栈</p>
<p>线程间共享：堆、堆外内存(永久代、元空间、代码缓存)</p>
<p>每个JVM只有一个Runtime实例。即为运行时环境，相当于内存结构的中间的那个框框: 运行时环境。</p>
<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。</p>
<p>在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。</p>
<p>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法。</p>
<p>如果线程执行过程中发生异常退出，则java线程会直接退出，而本地线程则会根据当前是否全剩下守护线程决定jvm进程是否结束。</p>
<h3 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h3><p>JVM中的程序计数寄存器（Program counter Register)中，Register 的命名源于CPu的寄存器，寄存器存储指令相关的现场信息。CPu只有把数据装载到寄存器才能够运行。这里，并非是广义上所指的物理寄存器，或许将其翻译为pc计数器（或指令计数器）会更加贴切(也称为程序钩子)，并且也不容易引起一些不必要的误会。<strong>JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。</strong></p>
<p>作用:</p>
<blockquote>
<p>PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。然后由执行引擎读取下一条指令。</p>
</blockquote>
<p>它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。</p>
<p>在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</p>
<p>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址;或者，如果是在执行native方法，则是未指定值（undefined） 。</p>
<p>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
<p>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p>
<p>它是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p>
<h4 id="两个常见问题"><a href="#两个常见问题" class="headerlink" title="两个常见问题"></a>两个常见问题</h4><p>使用PC寄存器存储字节码指令地址有什么用呢？为什么使用PC寄存器记录当前线程的执行地址呢？</p>
<blockquote>
<p>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继维执行。<br>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p>
</blockquote>
<p>PC寄存器为何被设定为线程私有?</p>
<blockquote>
<p>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？<strong>为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器</strong>，这样一来各个线程之间便可以进行独立计算，从而不会出现相互千扰的情况。</p>
<p>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</p>
<p>这样必然导致经常中断或恢复，如何保证分毫无差呢﹖每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</p>
</blockquote>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p><font color="red">栈是运行时的单位，而堆是存储的单位。</font></p>
<blockquote>
<p>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。<br>堆解决的是数据存储的问题，即数据怎么放、放在哪儿。</p>
<p>例子–做菜：食材以及做菜的步骤 放在栈中；而具体的过程对菜的各种操作 放在堆中。</p>
</blockquote>
<p>Java虚拟机栈（Java virtual Machine stack)，早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧(Stack Frame)，对应着一次次的Java方法调用。<font color="red">是线程私有的</font>，生命周期和线程一致。</p>
<p>作用：主管Java程序的运行，它保存方法的局部变量(8种基本数据类型、对象的引用地址)、部分结果，并参与方法的调用和返回。</p>
<p>优点：</p>
<blockquote>
<p>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。<br>JVM直接对Java栈的操作只有两个:<br>    每个方法执行，伴随着进栈(入栈、压栈) &amp;&amp; 执行结束后的出栈工作<br>对于栈来说不存在垃圾回收问题</p>
</blockquote>
<p>栈中可能出现的异常</p>
<blockquote>
<p>Java虚拟机规范允许Java栈的大小是动态的或者是固定不变的。</p>
<p>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个StackOverflowError异常。</p>
<p>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法中请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈,那Java虚拟机将会抛出一个OutOfMemoryError异常。</p>
</blockquote>
<h4 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h4><ul>
<li><p>每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame)的格式存在。</p>
</li>
<li><p>在这个线程上正在执行的每个方法都各自对应一个栈帧(Stack Frame)。</p>
</li>
<li><p>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</p>
</li>
</ul>
<p>栈运行原理:</p>
<blockquote>
<p>JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循“先进后出”/“后进先出”原则。</p>
<p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为<strong>当前栈帧</strong>(current Frame)，与当前栈帧相对应的方法就是<strong>当前方法</strong>（CurrentMethod)，定义这个方法的类就是<strong>当前类</strong>(current class) 。</p>
<p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</p>
<p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</p>
<p>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。</p>
<p>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</p>
<p>Java方法有两种返回函数的方式，<strong>一种是正常的函数返回，使用return指令;另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</strong></p>
</blockquote>
<h4 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h4><p>每个栈帧中存储着：</p>
<blockquote>
<p>局部变量表<br>操作数栈(或表达式栈)<br>动态链接(或指向运行时常量池的方法引用)<br>方法返回地址(或方法正常退出或者异常退出的定义)<br>附加信息</p>
</blockquote>
<h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>局部变量表也被称之为局部变量数组或本地变量表</p>
<p>定义为一个<strong>数字数组</strong>，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型。</p>
<p>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题。</p>
<p><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。</p>
<p>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</p>
<p>局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后.随着方法栈帧的销毁，局部变量表也会随之销毁。</p>
<h5 id="关于slot的理解"><a href="#关于slot的理解" class="headerlink" title="关于slot的理解"></a>关于slot的理解</h5><p>参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束。</p>
<p>局部变量表，最基本的存储单元是slot（变量槽)</p>
<p>局部变量表中存放编译期可知的各种基本数据类型(8种)，引用类型(reference)，returnAddress类型的变量。</p>
<p>在局部变量表里，<strong>32位以内的类型只占用一个slot(包括returnAddress类型)，64位的类型(long和double)占用两个slot。</strong></p>
<blockquote>
<p>byte、short、char在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true。<br>long和double则占据两个slot。</p>
</blockquote>
<p>JVM会为局部变量表中的每一个slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</p>
<p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个slot上</p>
<p>如果需要访问局部变量表中一个64bit的局部变量值时，只需要<strong>使用前一个索引</strong>即可。(比如:访问long或double类型变量)</p>
<p>如果当前帧是由<strong>构造方法</strong>或者<strong>实例方法</strong>创建的，<strong>那么该对象引用this将会存放在index为0的slot处</strong>，其余的参数按照参数表顺序继续排列。</p>
<p>slot的重复利用</p>
<blockquote>
<p>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p>
</blockquote>
<p>局部变量和静态变量的对比</p>
<blockquote>
<p>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</p>
<p>我们知道类变量表有两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。</p>
<p>和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</p>
</blockquote>
<p>补充</p>
<blockquote>
<p>在栈帧中，方性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</p>
<p><font color="red">局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</font></p>
</blockquote>
<h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p>每一个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出(Last-In-First-Out)的操作数栈，也可以称之为表达式栈(Expression Stack) 。</p>
<p>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈(push)/出栈(pop) .</p>
<blockquote>
<p>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。 </p>
<p>比如: 执行复制、交换、求和等操作</p>
</blockquote>
<p>操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。</p>
<p>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。</p>
<p>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为max_stack的值。</p>
<p>栈中的任何一个元素都是可以任意的Java数据类型。</p>
<blockquote>
<p>32bit的类型占用一个栈单位深度<br>64bit的类型占用两个栈单位深度。</p>
</blockquote>
<p>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈(push)和出栈(pop)操作来完成一次数据访问。</p>
<p>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。</p>
<p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</p>
<p>另外，我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。</p>
<h5 id="栈顶缓存技术"><a href="#栈顶缓存技术" class="headerlink" title="栈顶缓存技术"></a>栈顶缓存技术</h5><p>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派(instruction dispatch）次数和内存读/写次数。</p>
<p>由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，<strong>将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。</strong></p>
<h4 id="动态链接-指向运行时常量池中的方法引用"><a href="#动态链接-指向运行时常量池中的方法引用" class="headerlink" title="动态链接(指向运行时常量池中的方法引用)"></a>动态链接(指向运行时常量池中的方法引用)</h4><p>帧数据区的概念：方法返回地址、动态链接和一些附加信息称为帧数据区</p>
<p><strong>每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用</strong>。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接( Dynamic Linking)。比如: invokedynamic指令</p>
<p>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用(symbolic Reference)保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。</p>
<h4 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h4><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关。</p>
<p>静态链接:</p>
<blockquote>
<p>当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。</p>
</blockquote>
<p>动态链接:</p>
<blockquote>
<p>如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。</p>
</blockquote>
<p>对应的方法的绑定机制为:早期绑定（Early Binding）和晚期绑定(Late Binding)。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</p>
<p>早期绑定:</p>
<blockquote>
<p>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</p>
</blockquote>
<p>晚期绑定:</p>
<blockquote>
<p>如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。</p>
</blockquote>
<p>随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</p>
<p>Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</p>
<p>非虚方法:</p>
<blockquote>
<p>如果方法在编译期就确定了具体的调用版本，这个版木在运行时是不可变的。这样的方法称为非虚方法。|</p>
<ul>
<li>静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。</li>
<li>其他方法称为虚方法。</li>
</ul>
</blockquote>
<p>虚拟机中提供了以下几条方法调用指令:</p>
<ul>
<li>普通调用指令:</li>
</ul>
<blockquote>
<p>invokestatic: 调用静态方法，解析阶段确定唯一方法版本</p>
<p>invokespecial: 调用&lt;init&gt;方法、私有及父类方法，解析阶段确定唯一方法版本</p>
<p>invokeviltual: 调用所有虚方法</p>
<p>invokeinterface: 调用接口方法</p>
</blockquote>
<ul>
<li>动态调用指令:</li>
</ul>
<blockquote>
<p>invokedynamic: 动态解析出需要调用的方法，然后执行</p>
</blockquote>
<p>前四条指令固化在虚拟机内部，方法的调用执行不可人为千预，而invokedynamic指令则支持由用户确定方法版本。<strong>其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。</strong></p>
<hr>
<p>JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现<strong>『动态类型语言』</strong>支持而做的一种改进。</p>
<p>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。</p>
<p>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。</p>
<p>动态类型语言和静态类型语言</p>
<blockquote>
<p>动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。</p>
<p>说的再直白一点就是，静态类型语言是判断变量自身的类型信息; 动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。</p>
</blockquote>
<p>Java 语言中方法重写的本质:</p>
<blockquote>
<p>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作 C。</p>
<p>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束;如果不通过，则返回java.lang.illegalAccessError异常。</p>
<p>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</p>
<p>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</p>
<p>illegalAccessError介绍:</p>
<p>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</p>
</blockquote>
<p>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，JVM采用在类的方法区建立一个虚方法表(virtual method table）(非虚方法不会出现在表中)来实现。使用索引表来代替查找。</p>
<p>每个类中都有一个<strong>虚方法表</strong>，表中存放着各个方法的实际入口。如果是重写父类的方法，则该方法入口则为本身，如果使用父类的方法，则方法入口为父类。</p>
<p>那么虚方法表什么时候被创建?</p>
<blockquote>
<p>虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。</p>
</blockquote>
<h4 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h4><p>存放调用该方法的pc寄存器的值。</p>
<p>一个方法的结束，有两种方式:</p>
<blockquote>
<p>正常执行完成<br>出现未处理的异常，非正常退出</p>
</blockquote>
<p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的PC计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</p>
<blockquote>
<p>一个方法在正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定。</p>
<p>在字节码指令中，返回指令包含ireturn (当返回值是boolean、byte、char、short和int类型时使用）、lreturn、 freturn、dreturn以及areturn，另外还有一个return指令供声明为void的方法、实例初始化方法、类和接口的初始化方法使用。</p>
</blockquote>
<p>在方法执行的过程中遇到了异常（Exception)，并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称<strong>异常完成出口</strong>。</p>
<p>方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码。</p>
<p><img src="https://i.loli.net/2021/02/17/NuiwLdIh7CYcTxb.png" alt="image.png"></p>
<p>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、<strong>将返回值压入调用者栈帧的操作数栈</strong>、设置Pc寄存器值等，让调用者方法继续执行下去。</p>
<p>正常完成出口和异常完成出口的区别在于: <strong>通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</strong></p>
<h4 id="一些附加信息"><a href="#一些附加信息" class="headerlink" title="一些附加信息"></a>一些附加信息</h4><p>无</p>
<h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><ul>
<li>举例栈溢出的情况？(StackOverFlowError)</li>
</ul>
<blockquote>
<p>递归，栈深度大于所分配</p>
</blockquote>
<ul>
<li>调整栈大小，就能保证不出现溢出吗?</li>
</ul>
<blockquote>
<p>不能，可以延迟</p>
</blockquote>
<ul>
<li>分配的栈内存越大越好吗?</li>
</ul>
<blockquote>
<p>不是，总内存是一定的</p>
</blockquote>
<ul>
<li>垃圾回收是否会涉及到虚拟机栈?</li>
</ul>
<blockquote>
<p>不会，但会出现OOM异常</p>
</blockquote>
<ul>
<li>方法中定义的局部变量是否线程安全?</li>
</ul>
<blockquote>
<p>具体问题具体分析。看是否关联到共享资源、是否将局部变量作为返回值进行返回了、是否作为参数。即是否在内部消亡。可判断是否安全。</p>
</blockquote>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><h4 id="本地方法接口"><a href="#本地方法接口" class="headerlink" title="本地方法接口"></a>本地方法接口</h4><p>简单地讲，一个Native Method就是一个Java调用非Java代码的接口。一个Native Method是这样一个Java方法:该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern “C”告知C++编译器去调用一个c的函数。</p>
<p>“A native method is a Java method whose implementation is provided by non-java code .”</p>
<p>在定义一个native method时，并不提供实现体（有些像定义一个Java interface) ，因为其实现体是由非java语言在外面实现的。</p>
<p>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序</p>
<p>为什么要使用Native Method ?</p>
<blockquote>
<p>Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</p>
<ul>
<li>与Java环境外交互:</li>
</ul>
<p>有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制:它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</p>
<ul>
<li>与操作系统交互:</li>
</ul>
<p>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用c写的。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</p>
<ul>
<li>sun’s Java</li>
</ul>
<p>sun的解释器是用c实现的，这使得它能像一些普通的c一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。例如:类java.lang.Thread的setPriority()方法是用Java实现的，但是它实现调用的是该类里的本地方法setPriority0()。这个本地方法是用c实现的，并被植入JVM内部，在windows 95的平台上，这个本地方法最终将调用win32 setPriority() API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库(external dynamic link library）提供，然后被JVM调用。</p>
<p>目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用socket通信，也可以使用web service等等，不多做介绍。</p>
</blockquote>
<hr>
<p>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。</p>
<p>本地方法栈，也是线程私有的。</p>
<p>允许被实现成固定或者是可动态扩展的内存大小。(在内存溢出方面是相同的)</p>
<blockquote>
<p>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个StackOverflowError异常。</p>
<p>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个OutOfMemoryError异常。</p>
</blockquote>
<p>本地方法是使用c语言实现的。</p>
<p>它的具体做法是Native Method Stack中登记native方法，在Execution Engine执行时加载本地方法库。</p>
<p>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</p>
<blockquote>
<p>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区。</p>
<p>它甚至可以直接使用本地处理器中的寄存器</p>
<p>直接从本地内存的堆中分配任意数量的内存。</p>
</blockquote>
<p>并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。</p>
<p>在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。</p>
<p>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。</p>
<blockquote>
<p>堆内存的大小是可以调节的。</p>
</blockquote>
<p>《Java虚拟机规范》规定，堆可以处于<strong>物理上不连续</strong>的内存空间中，但在<strong>逻辑上</strong>它应该被视为<strong>连续的</strong>。</p>
<p> 所有的线程共享Java堆，在这里还可以划分<strong>线程私有的缓冲区</strong>(Thread Local Allocation Buffer，TLAB)。</p>
<p>《Java虚拟机规范》中对Java堆的描述是: 所有的对象实例以及数组都应当在运行时分配在堆上。(The heap is the run-time data area from which memory for all class instances and arrays is allocated）</p>
<blockquote>
<p>我要说的是: “几乎”所有的对象实例都在这里分配内存。—从实际使用角度看的。</p>
</blockquote>
<p>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</p>
<p>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</p>
<p>堆，是GC (Garbage collection，垃圾收集器）执行垃圾回收的重点区域。</p>
<hr>
<p><strong>现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为:</strong></p>
<p>Java 7及之前堆内存逻辑上分为三部分：新生区+养老区+<strong>永久区</strong></p>
<blockquote>
<p>Young Generation Space    新生区    Young/New （又被划分为Eden区和Survivor区）</p>
<p>Tenure generation Space    养老区    old/Tenure</p>
<p>Permanent Space    永久区    Perm</p>
</blockquote>
<p>Java 8及之后堆内存逻辑上分为三部分：新生区+养老区+<strong>元空间</strong></p>
<blockquote>
<p>Young Generation Space    新生区    Young/New（又被划分为Eden区和Survivor区）</p>
<p>Tenure generation Apace    养老区    old/Tenure</p>
<p>Meta Space    元空间    Meta</p>
</blockquote>
<p>约定：新生区&lt;-&gt;新生代&lt;-&gt;年轻代    养老区&lt;-&gt;老年区&lt;-&gt;老年代    永久区&lt;-&gt;永久代</p>
<h4 id="设置堆内存大小和OOM"><a href="#设置堆内存大小和OOM" class="headerlink" title="设置堆内存大小和OOM"></a>设置堆内存大小和OOM</h4><p>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”-Xmx”和”-Xms”来进行设置。</p>
<blockquote>
<p>“-Xms”用于表示堆区的起始内存，等价于-XX:InitialHeapSize（-X是指jvm的运行参数，ms指memory start）</p>
<p>“-Xmx”则用于表示堆区的最大内存，等价于-XX:MaxHeapSize</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;查看设置的参数</span><br><span class="line">1、jps / jstat -gc 进程号</span><br><span class="line">2、-XX:+PrintGCDetails (需要程序执行完以后)</span><br></pre></td></tr></table></figure>

<p>注意：设置的值和实际通过Runtime实例获取的值可能存在差异，因为幸存者区S0和S1区只会有一个工作，所以有一个在计算时不会计算。</p>
</blockquote>
<p>一旦堆区中的内存大小超过“-Xmx”所指定的最大内存时，将会抛出OutOfMemoryError异常。</p>
<p>通常会将-Xms和-Xmx两个参数配置相同的值，其目的是为了能够在<strong>java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小</strong>，从而提高性能。</p>
<p>默认情况下，初始内存大小：物理电脑内存大小 / 64；最大内存大小：物理电脑内存大小 / 4</p>
<h4 id="年轻代和老年代"><a href="#年轻代和老年代" class="headerlink" title="年轻代和老年代"></a>年轻代和老年代</h4><p>存储在JVM中的Java对象可以被划分为两类:</p>
<blockquote>
<p>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速。</p>
<p>另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致。</p>
</blockquote>
<p>Java堆区进一步细分的话，可以划分为年轻代(YoungGen）和老年代（OldGen)</p>
<p>其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间(有时也叫做from区、to区）。</p>
<p>配置新生代与老年代在堆结构的占比：</p>
<blockquote>
<p>默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3</p>
<p>可以修改-XX:NewRatio=4，表示新生代占老年代占4，新生代占整个堆的1/5</p>
</blockquote>
<p>在HotSpot中，Eden空间和另外两个Survivor空间缺省所占的比例是8:1:1（但可能默认值并非为8）</p>
<blockquote>
<p>当然开发人员可以通过选项”-XX:SurvivorRatio”调整这个空间比例。比如-XX:SurvivorRatio=8</p>
<p><strong>几乎所有</strong>的Java对象都是在Eden区被new出来的。</p>
<p>绝大部分的Java对象的销毁都在新生代进行了。（IBM公司的专门研究表明，新生代中80%的对象都是”朝生夕死”的）</p>
<p>可以使用选项”-Xmn”设置新生代最大内存大小。（这个参数一般使用默认值就可以了，且该参数优先级比XX:NewRatio优先级更高）</p>
</blockquote>
<h4 id="对象分配过程"><a href="#对象分配过程" class="headerlink" title="对象分配过程"></a>对象分配过程</h4><p>为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p>
<p>①new的对象先放伊甸园区。此区有大小限制。<br>②当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收(Minor GC/Young GC)，将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区<br>③然后将伊甸园中的剩余对象移动到幸存者0区。<br>④如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。<br>⑤如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。<br>⑥啥时候能去养老区呢？可以设置次数。默认是15次。</p>
<blockquote>
<p>可以设置参数:-XX:MaxTenuringThreshold=&lt;N&gt;进行设置。</p>
<p>注意：在Eden区满时，YGC不仅会对Eden区进行GC，还会对对应的幸存者区进行GC。同时幸存者区满时，并不会触发YGC，即幸存者区是被动进行垃圾回收的。<br>同时，如果幸存者区中的对象还未达到阈值15就已经装不下了，则其中的一些”老”对象会直接进入老年区。</p>
</blockquote>
<p>总结:</p>
<blockquote>
<p>针对幸存者s0、s1区的总结：复制之后有交换，谁空谁是to。</p>
<p>关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不在永久区 / 元空间收集。</p>
</blockquote>
<img src="https://i.loli.net/2021/02/18/Pf6Mkxzy1YAluLB.png" alt="对象分配.png" style="zoom:50%;">

<h4 id="Minor-GC、Full-GC、Major-GC"><a href="#Minor-GC、Full-GC、Major-GC" class="headerlink" title="Minor GC、Full GC、Major GC"></a>Minor GC、Full GC、Major GC</h4><p>JVM在进行Gc时，并非每次都对上面三个内存(新生代、老年代、方法区)区域一起回收的，大部分时候回收的都是指新生代。</p>
<p>针对HotSpot VM的实现，它里面的GC按照回收区域又分为两大种类型:一种是部分收集(Partial GC)，一种是整堆收集（Full GC)</p>
<p>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为:</p>
<blockquote>
<p>新生代收集(Minor GC / Young GC)：只是新生代的垃圾收集</p>
<p>老年代收集(Major GC / Old GC)：只是老年代的垃圾收集。</p>
<blockquote>
<p>目前，只有<strong>CMS GC</strong>会有单独收集老年代的行为。<br><font color="red">注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</font></p>
</blockquote>
<p>混合收集（Mixed GC)：收集整个新生代以及部分老年代的垃圾收集。</p>
<blockquote>
<p>目前，只有<strong>G1 GC</strong>会有这种行为</p>
</blockquote>
</blockquote>
<p>整堆收集(Full GC)：收集整个java堆和<strong>方法区</strong>的垃圾收集。</p>
<hr>
<p>年轻代GC(Minor GC)触发机制：</p>
<blockquote>
<p>当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden区满，Survivor区满不会引发GC。(每次Minor GC会清理年轻代的内存。)</p>
<p>因为Java 对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</p>
<p>Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行。</p>
</blockquote>
<p>老年代GC (Major GC/Full GC)触发机制:</p>
<blockquote>
<p>指发生在老年代的GC，对象从老年代消失时，我们说“Major GC”或“Full GC”发生了。</p>
<p>出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。</p>
<blockquote>
<p>也就是在老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足，则触发Major GC。</p>
</blockquote>
<p>Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。<br>如果Major GC后，内存还不足，就报OOM了。</p>
</blockquote>
<p>触发Full GC执行的情况有如下五种:</p>
<blockquote>
<p>①调用System.gc()时，系统建议执行Full GC，但是不必然执行<br>②老年代空间不足<br>③方法区空间不足<br>④通过Minor GC后进入老年代的平均大小大于老年代的可用内存<br>⑤由Eden区、Survivor space（From Space）区向Survivor space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</p>
<p>说明: <font color="red">full gc是开发或调优中尽量要避免的。这样暂时时间会短一些。</font></p>
</blockquote>
<h4 id="堆空间分代思想"><a href="#堆空间分代思想" class="headerlink" title="堆空间分代思想"></a>堆空间分代思想</h4><p>为什么需要把Java堆分代?不分代就不能正常工作了吗?</p>
<blockquote>
<p>经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。</p>
<p>新生代: 有Eden、两块大小相同的survivor (又称为from/to，s0/s1)构成，to总为空。<br>老年代: 存放新生代中经历多次Gc仍然存活的对象。</p>
</blockquote>
<p>为什么需要把Java堆分代?不分代就不能正常工作了吗?</p>
<blockquote>
<p>其实不分代完全可以，分代的唯一理由就是优化<strong>GC</strong>性能。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用,这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收,这样就会腾出很大的空间出来。</p>
</blockquote>
<h4 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h4><p>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1 。对象在Survivor区中每熬过一次Minor GC ,年龄就增加岁，当它的年龄增加到一定程度（默认为15 岁，其实每个JVM、每个GC都有所不同)时，就会被晋升到老年代中。</p>
<p>针对不同年龄段的对象分配原则如下所示:</p>
<ul>
<li><p>优先分配到Eden</p>
</li>
<li><p>大对象直接分配到老年代</p>
<blockquote>
<p>尽量避免程序中出现过多的大对象</p>
</blockquote>
</li>
<li><p>长期存活的对象分配到老年代</p>
</li>
<li><p>动态对象年龄判断</p>
<blockquote>
<p>如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</p>
</blockquote>
</li>
<li><p>空间分配担保</p>
<blockquote>
<p>-xx: HandlePromotionFailure</p>
</blockquote>
</li>
</ul>
<h4 id="TLAB（Thread-Local-Allocation-Buffer）"><a href="#TLAB（Thread-Local-Allocation-Buffer）" class="headerlink" title="TLAB（Thread Local Allocation Buffer）"></a>TLAB（Thread Local Allocation Buffer）</h4><p>为了避免多个线程访问同一地址。</p>
<p>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。</p>
<p>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为<strong>快速分配策略</strong>。</p>
<p>据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。</p>
<p>TLAB简单说明：</p>
<blockquote>
<p>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是<font color="red">将TLAB作为内存分配的首选</font>。</p>
<p>在程序中，开发人员可以通过选项“-XX:UseTLAB”设置是否开启TLAB空间。</p>
<p>默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然我们可以通过选项“-XX:TLABWasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小。</p>
<p>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过<strong>使用加锁机制</strong>确保数据操作的原子性，从而直接在Eden空间中分配内存。</p>
</blockquote>
<h4 id="堆空间常用参数设置"><a href="#堆空间常用参数设置" class="headerlink" title="堆空间常用参数设置"></a>堆空间常用参数设置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintFlagsInitial: 查看所有的参数的默认初始值</span><br><span class="line">-XX:+PrintFlagsFinal: 查看所有的参数的最终值(可能会存在修改，不再是初始值)</span><br><span class="line">	具体查看某个参数的指令: jps查看进程号 -&gt; jinfo -flag SurvivalRatio 进程号</span><br><span class="line">-Xms: 初始堆空间内存(默认为物理内存的1/64)</span><br><span class="line">-Xmx: 最大堆空间内存(默认为物理内存的1/4)</span><br><span class="line">-Xmn: 设置新生代的大小。(初始值及最大值)</span><br><span class="line">-Xx:NewRatio: 配置新生代与老年代在堆结构的占比</span><br><span class="line">-Xx:SurvivorRatio: 设置新生代中Eden和s0/s1空间的比例</span><br><span class="line">-XX:MaxTenuringThreshold: 设置新生代垃圾的最大年龄</span><br><span class="line">-XX:+PrintGCDetails: 输出详细的GC处理日志</span><br><span class="line">	* 打印gc简要信息:1) -XX:+PrintGC 2)-verbose:gc</span><br><span class="line">-Xx:HandlePromotionFailure: 是否设置空间分配担保</span><br></pre></td></tr></table></figure>

<p>在发生Minor GC之前，虚拟机会检查老年代最大可用的<strong>连续空间</strong>是否大于新生代所有对象的总空间。</p>
<blockquote>
<p>如果大于，则此次Minor GC是安全的</p>
<p>如果小于，则虚拟机会查看-XX:HandlePromotionFailure设置值是否允许担保失败。如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于<strong>历次晋升到老年代的对象的平均大小</strong>。</p>
<ul>
<li>如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的;</li>
<li>如果小于，则改为进行一次Full Gc。</li>
</ul>
<p>如果HandlePromotionFailure=false，则改为进行一次Full GC.</p>
</blockquote>
<p>在JDK6 Update24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6 Update24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC.</p>
<h4 id="堆是对象存储的唯一选择吗？"><a href="#堆是对象存储的唯一选择吗？" class="headerlink" title="堆是对象存储的唯一选择吗？"></a>堆是对象存储的唯一选择吗？</h4><p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过<strong>逃逸分析(Escape Analysis)</strong>后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p>
<p>此外，前面提到的基于OpenJDK深度定制的TaoBaoVM，其中创新的GCIH (GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</p>
<p>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</p>
<p>通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p>
<p>逃逸分析的基本行为就是分析对象动态作用域:</p>
<blockquote>
<p>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。<br>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</p>
</blockquote>
<h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><p>使用逃逸分析,编译器可以对代码做如下优化:</p>
<p>一、栈上分配。将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。</p>
<blockquote>
<p>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</p>
<p>常见的逃逸的场景</p>
<blockquote>
<p>在逃逸分析中，已经说明了。分别是给成员变量赋值、方法返回值、实例引用传涕。</p>
</blockquote>
</blockquote>
<p>二、同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</p>
<blockquote>
<p>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</p>
<p>在动态编译同步块的时候，JIT编译器可以<strong>借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问</strong>而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。</p>
</blockquote>
<p>三、分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分(或全部）可以不存储在内存，而是存储在CPU寄存器中。</p>
<blockquote>
<p>标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</p>
<p>相对的，那些还可以分解的数据叫做聚合量(Aggregate), Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p>
<p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是<strong>标量替换</strong>。</p>
</blockquote>
<p><font color="red">但是栈上分配只是理论可行，hotspot虚拟机并没有实际应用，而能看到效果的原因是标量替换产生的效果。所以，还是可以认为，对象实例都是分配在堆空间中的。</font></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</p>
<p>老年代放置长生命周期的对象，通常都是从Survivor区域筛选拷贝过来的Java对象。当然，也有特殊情况，我们知道普通的对象会被分配在TLAB上:如果对象较大，JVM会试图直接分配在Eden其他位置上;如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代</p>
<p>当Gc只发生在年轻代中，回收年轻代对象的行为被称为Minor GC。当GC发生在老年代时则被称为Major GC或者Full GC。一般的，Minor GC的发生频率要比Major GC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区看作是一块独立于Java堆的内存空间。</p>
<p><img src="https://i.loli.net/2021/02/22/XkhOpQFZ5VGNyKg.png" alt="image.png"></p>
<p>且对于栈内存储的对象的referrence，指向堆中的对象实例，而堆中的对象实例中还存在对象类型的指针，而该指针则指向方法区。</p>
<p>方法区(Method Area)与Java堆一样，是各个线程共享的内存区域。</p>
<p>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。</p>
<p>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</p>
<p>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误: java.lang.outOfMemoryError: <strong>PermGen space</strong>或者java.lang.outofMemoryError: <strong>Metaspace</strong></p>
<p>关闭JVM就会释放这个区域的内存。</p>
<h4 id="设置方法区大小"><a href="#设置方法区大小" class="headerlink" title="设置方法区大小"></a>设置方法区大小</h4><p>方法区的大小不必是固定的，jvm可以根据应用的需要动态调整。</p>
<p>jdk7及以前:</p>
<blockquote>
<p>通过-XX:PermSize来设置永久代初始分配空间。默认值是20.75M</p>
<p>-XX:MaxPermsize来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M</p>
<p>当JVM加载的类信息容量超过了这个值，会报异常outofMemoryError: PermGen space 。</p>
</blockquote>
<p>jdk8及以后:</p>
<blockquote>
<p>元数据区大小可以使用参数-XX:MetaspaceSize和-XX:MaxMetaspaceSize指定，替代上述原有的两个参数。</p>
<p>默认值依赖于平台。windows下，-XX:Metaspacesize是21M，-XX:MaxMetaspacesize的值是-1，即没有限制。</p>
<p>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError: Metaspace </p>
<p>-XX:MetaspaceSize:设置初始的元空间大小。对于一个64位的服务器端JVM来说, 其默认的-XX:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类(即这些类对应的类加载器不再存活),然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspacesize时，适当提高该值。如果释放空间过多，则适当降低该值。</p>
<p>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC，建议将-XC: Metaspacesize设置为一个相对较高的值。</p>
</blockquote>
<p>如何解决OOM</p>
<blockquote>
<p>1、要解决OOM异常或heap space的异常，一般的手段是首先通过内存映像分析工具(如Eclipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（MemoryLeak）还是内存溢出(Memory Overflow)。</p>
<p>2、如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置。</p>
<p>3、如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数(-Xmx与-Xms)，与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</p>
</blockquote>
<h4 id="方法区内部结构"><a href="#方法区内部结构" class="headerlink" title="方法区内部结构"></a>方法区内部结构</h4><p>它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</p>
<p>类型信息：</p>
<blockquote>
<p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation)，JVM必须在方法区中存储以下类型信息:<br>①这个类型的完整有效名称(全名=包名.类名)<br>②这个类型直接父类的完整有效名(对于interface或是java.lang.0bject，都没有父类)<br>③这个类型的修饰符(public,abstract, final的某个子集)<br>④这个类型直接接口的一个有序列表</p>
</blockquote>
<p>域(Field)信息：</p>
<blockquote>
<p>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</p>
<p>域的相关信息包括：域名称、域类型、域修饰符(public, private,protected,static,final, volatile, transient的某个子集)</p>
</blockquote>
<p>方法(Method)信息：</p>
<blockquote>
<p>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序:</p>
<ul>
<li>方法名称</li>
<li>方法的返回类型(或void)</li>
<li>方法参数的数量和类型(按顺序)</li>
<li>方法的修饰符(public, private,protected,static, final, synchronized, native,abstract的一个子集)</li>
<li>方法的字节码、bytecodes操作数栈、局部变量表及大小(abstract和native方法除外）</li>
<li>异常表(abstract和native方法除外)<br>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li>
</ul>
</blockquote>
<p>补充说明:全局常量: <code>static final</code></p>
<blockquote>
<p>被声明为final的类变量的处理方法则不同，每个全局常量在<strong>编译</strong>的时候就会被分配了。</p>
</blockquote>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>方法区包含了<strong>运行时常量池</strong>，而字节码文件又包含了<strong>常量池</strong>。常量池包含了各种字面量和对类型、域、方法的符号引用。</p>
<p>为什么需要常量池?</p>
<blockquote>
<p>一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，需要换另一种方式，也就是可以存到<strong>常量池</strong>。同时字节码文件中也存储了该常量池。在真正进行加载执行的时候，才会进行动态链接，加载真正的引用。</p>
</blockquote>
<p>小结:</p>
<blockquote>
<p>常量池，可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。</p>
</blockquote>
<p>运行时常量池（Runtime constant Poo1）是方法区的一部分。</p>
<p>常量池表（Constant Pool Table）是class文件的一部分，用于存放编译期生成的各种字面量与符号引用，<strong>这部分内容将在类加载后存放到方法区的运行时常量池中。</strong></p>
<p>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</p>
<p>JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。</p>
<p>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为<strong>真实地址</strong>。</p>
<blockquote>
<p>运行时常量池，相对于class文件常量池的另一重要特征是：具备<strong>动态性</strong>。</p>
<p>比如：一些方法 String.intern()等等</p>
</blockquote>
<p>运行时常量池类似于传统编程语言中的符号表(symbol table)，但是它所包含的数据却比符号表要更加丰富一些。</p>
<p>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛OutOfMemoryError异常。</p>
<p>注意：(方法区实例演示过程中)</p>
<blockquote>
<p>在调用实例方法时，先入栈对象实例，然后入栈参数，然后invoke…..调用方法。</p>
</blockquote>
<h4 id="方法区演变细节"><a href="#方法区演变细节" class="headerlink" title="方法区演变细节"></a>方法区演变细节</h4><p>1、首先明确：只有HotSpot才有永久代。BEA、JRockit、IBM9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一。</p>
<p>2、Hotspot中方法区的变化:</p>
<table>
<thead>
<tr>
<th align="center">jdk版本</th>
<th align="center">方法区情况</th>
</tr>
</thead>
<tbody><tr>
<td align="center">jdk1.6及之前</td>
<td align="center">有永久代(permanent generation)，<strong>静态变量存放在永久代上</strong></td>
</tr>
<tr>
<td align="center">jdk1.7</td>
<td align="center">有永久代，但已经逐步“去永久代”，<strong>字符串常量池、静态变量移除，保存在堆中</strong></td>
</tr>
<tr>
<td align="center">jdk1.8及之后</td>
<td align="center">无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但<strong>字符串常量池、静态变量仍在堆</strong></td>
</tr>
</tbody></table>
<p>改动的原因：</p>
<p>①为永久代设置多大空间是很难确定（如web工程，需要动态加载的类很多，容易出现OOM）<br>②对永久代进行调优很困难</p>
<p>有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK 11时期的ZGC收集器就不支持类卸载)。</p>
<p>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前Sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的Hotspot虚拟机对此区域未完全回收而导致内存泄漏。方法区的垃圾收集主要回收两部分内容: 常量池中废弃的常量和不再使用的类型。</p>
<blockquote>
<p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“还再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件:</p>
<p>①该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。<br>②加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、SP的重加载等，否则通常是很难达成的。<br>③该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>
<p>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收,HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class以及-XX:+Traceclass-Loading、-XX:+TraceClassUnLoading查看类加载和卸载信息·在大量使用反射、动态代理、cGLib等字节码框架，动态生成JSP以及osGi这类频繁</p>
<p>自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</p>
</blockquote>
<p>StringTable为什么要调整?</p>
<blockquote>
<p>jdk7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在full gc的时候才会触发。而full gc是老年代的空间不足、永久代不足时才会触发。<br>这就导致StringTable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p>
</blockquote>
<p>需要注意：</p>
<blockquote>
<p>静态引用所对应的<strong>对象实体</strong>始终是存在于堆中，无论是jdk6还是jdk8，只要是对象实例，都在堆中分配。</p>
</blockquote>
<h4 id="方法区的垃圾收集"><a href="#方法区的垃圾收集" class="headerlink" title="方法区的垃圾收集"></a>方法区的垃圾收集</h4><p>有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在(如JDK 11时期的zGC收集器就不支持类卸载)。</p>
<p>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</p>
<p><strong>方法区的垃圾收集主要回收两部分内容:常量池中废弃的常量和不再使用的类型。</strong></p>
<p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量:</p>
<blockquote>
<p>1、类和接口的全限定名</p>
<p>2、字段的名称和描述符</p>
<p>3、方法的名称和描述符</p>
</blockquote>
<p>HotSpot虚拟机对常量池的回收策略是很明确的，<strong>只要常量池中的常量没有被任何地方引用，就可以被回收。</strong><br>回收废弃常量与回收Java堆中的对象非常类似。</p>
<p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件:</p>
<blockquote>
<p>①该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。<br>②加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。<br>③该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>
</blockquote>
<p>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收,HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class以及-XX:+TraceClass-Loading、-XX:+TraceClassUnLoading查看类加载和卸载信息</p>
<p>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><img src="/.com//C:%5CUsers%5C34879%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210225184559735.png" alt="image-20210225184559735"></p>
<h2 id="对象相关"><a href="#对象相关" class="headerlink" title="对象相关"></a>对象相关</h2><h4 id="对象的实例化"><a href="#对象的实例化" class="headerlink" title="对象的实例化"></a>对象的实例化</h4><p>创建对象的方式：</p>
<blockquote>
<p>new：①常用的，直接new对象 ②构造器私有，调用Xxx的静态方法获取 ③XxxBuilder/XxxFactory工厂模式</p>
<p>Class.newInstance()：反射，只能调用空参构造器，且权限要求public</p>
<p>Constructor.newInstance(Xxx)：反射，可以调用空参、带参的构造器，对权限无要求</p>
<p>clone()：不调用任何构造器，当前类需要实现Cloneable接口，重写clone()方法</p>
<p>反序列化：从文件中、网络中获取一个对象的二进制流</p>
<p>第三方库Objenesis</p>
</blockquote>
<p>创建对象的步骤</p>
<blockquote>
<p>①判断对象对应的类是否加载、链接、初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。(即判断类元信息是否存在)。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader+包名+类名为Key进行查找对应的.class文件。如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class类对象</span><br></pre></td></tr></table></figure>

<p>②为对象分配内存（计算对象占用空间大小，如果实例成员变量是引用类型，只占4个字节）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果内存规整 -&gt; 直接在空闲空间中放入对象，并将指针后移(指针碰撞)</span><br><span class="line">如果不规整 -&gt; 即已经使用的和没有使用的内存的互相交错，虚拟机将采用空闲列表法，即虚拟机维护了一个列表，记录那些内存可用，在分配时从列表中找到一块空间划分给对象，并更新列表。</span><br></pre></td></tr></table></figure>

<p>③处理并发安全问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">采用CAS配上失败重试保证更新的原子性</span><br><span class="line">为每个线程预先分配一块TLAB</span><br></pre></td></tr></table></figure>

<p>④初始化分配到的空间（对象属性默认初始化）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所有非静态属性设置默认值，保证对象实例字段在未赋值时可以直接使用。</span><br></pre></td></tr></table></figure>

<p>⑤设置对象的对象头</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">记录类信息、HashCode、GC信息、锁信息等数据</span><br></pre></td></tr></table></figure>

<p>⑥执行init方法进行初始化（显式初始化）</p>
</blockquote>
<h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><p>对象头</p>
<blockquote>
<p>①运行时元数据(Mark Word)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">包含：</span><br><span class="line">哈希值、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳</span><br></pre></td></tr></table></figure>

<p>②类型指针——指向方法区中的类元数据，确定该对象所属的类型(如obj.getClass()方法)</p>
<p>③如果是数组，还需记录数组长度</p>
</blockquote>
<p>实例数据</p>
<blockquote>
<p>是对象真正存储的有效信息，包括字段、以及父类继承的字段等等</p>
<p>存放规则</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">相同宽度的字段存放在一起</span><br><span class="line">父类定义的变量会放在子类之前</span><br><span class="line">如果CompactFields参数为true(默认为true)：子类的窄变量可能插入到父类变量的空隙</span><br></pre></td></tr></table></figure>
</blockquote>
<p>对齐填充</p>
<blockquote>
<p>非必须的，占位符</p>
</blockquote>
<h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><p>JVM是如何通过栈帧中的对象引用访问到其内部的对象实例的呢?</p>
<p>对象访问的方式有两种：①句柄访问    ②直接指针(HotSpot采用)</p>
<p>句柄访问的好处：reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改。‘</p>
<p>直接指针的好处：访问效率更高、速度快，也不用在堆空间中开辟一块内存存储句柄。</p>
<p><img src="https://i.loli.net/2021/02/27/erKuL7W94NUfzDT.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2021/02/27/N4uhJcVdFqR9BX2.png" alt="image.png"></p>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>来源于NIO，通过DirectByteBuffer操作本地内存。性能优于Java堆。读写效率高。</p>
<p>也同样可能引起OOM（Direct Buffer Memory），由OS提供的内存大小限制。</p>
<p>且分配回收的成本较高、不受JVM内存管理。</p>
<blockquote>
<p>直接内存大小可以通过MaxDirectMemorysize设置</p>
<p>如果不指定，默认与堆的最大值-xmx参数值一致</p>
</blockquote>
<h2 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h2><p><img src="https://i.loli.net/2021/02/28/9uA7mCrLo1dXHID.png" alt="image.png"></p>
<p>Java语言是半解释半编译的语言。</p>
<h3 id="JIT"><a href="#JIT" class="headerlink" title="JIT"></a>JIT</h3><p>将方法编译成机器码后执行。</p>
<p>首先明确:</p>
<blockquote>
<p>当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。<br>而编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。</p>
</blockquote>
<p>所以:</p>
<blockquote>
<p>尽管JRockit VM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。在此模式下，<strong>当Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。</strong></p>
<p>同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”。</p>
</blockquote>
<p>一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此也被称之为<strong>栈上替换</strong>，或简称为OSR (on StackReplacement）编译。</p>
<p>一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准?必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠热点探测功能。</p>
<p>目前HotSpot VM所采用的热点探测方式是<strong>基于计数器的热点探测。</strong></p>
<p>采用基于计数器的热点探测，HotSpot VM将会为每一个方法都建立2个不同类型的计数器，分别为方法调用计数器（Invocation Counter）和回边计数器(BackEdge Counter) 。</p>
<blockquote>
<p>方法调用计数器用于统计方法的调用次数</p>
<p>回边计数器则用于统计循环体执行的循环次数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当一个方法被调用时，首先会检查该方法是否存在已经被JIT编译好的版本，如果存在则直接使用本地代码；如果不存在则将方法的调用计数器加1，然后判断方法调用计数器和回边计数器之和是否超过阈值。如果超过阈值，则向JIT编译器提交一个该方法的代码编译请求。</span><br></pre></td></tr></table></figure>

<p><strong>热度衰减</strong></p>
<blockquote>
<p>如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个<strong>相对的执行频率</strong>，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的<strong>衰减(Counter Decay)</strong>，而这段时间就称为此方法统计的<strong>半衰周期(counter Half Tife Time)</strong>。</p>
<p>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数-XX:-UseCounterDecay来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。</p>
<p>另外，可以使用-XX:CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。</p>
</blockquote>
<p><strong>设置HotSpot执行模式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Xint：纯解释器</span><br><span class="line">-Xcomp：纯编译器</span><br><span class="line">-Xmixed：混合模式</span><br></pre></td></tr></table></figure>

<p>HotSpot中内置两个编译器C1和C2，分别对应Client Compiler和Server Compiler</p>
<blockquote>
<p>C1编译器会对字节码进行<strong>简单和可靠的优化</strong>，耗时短。以达到更快的编译速度。</p>
<p>C2进行<strong>耗时较长的优化，以及激进优化</strong>。但优化的代码执行效率更高。</p>
</blockquote>
<hr>
<p><strong>C1和C2编译器不同的优化策略∶</strong></p>
<p>在不同的编译器上有不同的优化策略，C1编译器上主要有方法内联，去虚拟化、冗余消除。</p>
<blockquote>
<p>方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程</p>
<p>去虚拟化：对唯一的实现类进行内联</p>
<p>冗余消除：在运行期间把一些不会执行的代码折叠掉</p>
</blockquote>
<p>C2的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在C2上有如下几种优化:</p>
<blockquote>
<p>标量替换：用标量值代替聚合对象的属性值</p>
<p>栈上分配：对于未逃逸的对象分配对象在栈而不是堆</p>
<p>同步消除：清除同步操作，通常指synchronized</p>
</blockquote>
<p>且在Java 7之后，server模式下默认开启分层编译策略，C1和C2协同工作来执行编译任务。</p>
<hr>
<p>自JDK10起，HotSpot又加入一个全新的即时编译器:：Graal编译器。编译效果短短几年时间就追评了C2编译器。未来可期。<br>目前，带着“实验状态”标签，需要使用开关参数-XX:+UnlockExperimentalvMoptions -XX:+UseJVMCICompiler去激活，才可以使用。</p>
<p><strong>AOT编译器(ahead of time)</strong></p>
<blockquote>
<p>在jdk9引入</p>
<p>所谓AOT编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而AOT编译指的则是，<strong>在程序运行之前，便将字节码转换为机器码的过程</strong>。</p>
</blockquote>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>jdk8及之前使用char数组存储字符串，jdk9及以后采用byte数组存储同时加以字符编码标识进行辅助。</p>
<blockquote>
<p>因为大部分String字符串存储的字符用1个字节就能存储，char在Java中占两个字节，会导致很多空间的浪费。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"abc"</span> <span class="comment">// 通过字面量定义的方式，"abc"存放于字符串常量池中</span></span><br><span class="line"><span class="comment">// 注意：字符串常量池中不允许重复字符串</span></span><br></pre></td></tr></table></figure>

<p>String的不可变性</p>
<blockquote>
<p>①对字符串重新赋值，会重写内存区域赋值。<br>②对现有字符串进行连接操作，也需要重新指定内存区域赋值<br>③当调用String的replace()方法修改字符串时，也需要重新指定内存区域赋值。</p>
</blockquote>
<p><strong>字符串常量池中不允许重复字符串</strong></p>
<p>字符串常量池底层也是由一个固定大小的HashTable实现的(jdk6默认长度为1009、jdk7默认大小为60013)。</p>
<blockquote>
<p>可使用-XX:StringTableSize进行设置。且从jdk8开始，可设置的最小值为1009。</p>
</blockquote>
<p>在Java语言中有8种基本数据类型和一种比较特殊的类型string。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。</p>
<p>常量池就类似一个Java系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的，String类型的常量池比较特殊。它的主要使用方法有两种。</p>
<blockquote>
<p>直接使用双引号声明出来的String对象会直接存储在常量池中。比如:string info = “atguigu .com” ;</p>
<p>如果不是用双引号声明的String对象，可以使用String提供的intern()方法。这个后面重点谈。</p>
</blockquote>
<p>？toString()方法返回的字符串来自哪里？常量池 or 堆</p>
<h3 id="字符串的拼接操作"><a href="#字符串的拼接操作" class="headerlink" title="字符串的拼接操作"></a>字符串的拼接操作</h3><p>1.常量与常量的拼接结果在常量池，原理是编译期优化<br>2.常量池中不会存在相同内容的常量。<br>3.只要其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder<br>4.如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址。</p>
<p>字符串拼接(a = a + “xxx”)的底层操作相当于new了一个StringBuilder对象和一个String对象，和StringBuilder的append()方法相比，效率差的非常多，且后者至始至终只创建过一个对象，前者每一次拼接都会创建两个新对象。</p>
<h3 id="intern-方法"><a href="#intern-方法" class="headerlink" title="intern()方法"></a>intern()方法</h3><p>new String(“aba”)会创建几个对象？</p>
<blockquote>
<p>①如果常量池中存在”aba”字符串常量，则会创建一个对象，即new出来的<br>②如果不存在，则会创建两个对象，一个”aba”字符串，一个new的String对象</p>
</blockquote>
<p>那对于String str = new String(“a”) + new String(“b”)呢？</p>
<blockquote>
<p>对象1：new StringBuilder()<br>对象2：常量池中的”a”<br>对象3：new String(“a”)<br>对象4：常量池中的”b”<br>对象5：new String(“b”)</p>
<p>StringBuilder的toString()方法<br>对象6：new String(“ab”)</p>
<p>注意：在字符串常量池中没有生成”ab”</p>
</blockquote>
<p>对于上文的str，调用str.intern()方法，发生了什么？</p>
<blockquote>
<p>因为此时常量池中没有”ab”，所以应该在常量池中进行生成一个。但是根据jdk版本不同存在差异。</p>
<p>对于jdk6：字符串常量池处于永久代。所以会在常量池中生成一个”ab”对象，且该对象!=str<br>对于jdk7/8：字符串常量池移到堆中，为了节省空间，不会在常量池中新创建”ab”对象，而是在常量池中创建一个引用指向str，并且返回的也是该地址，因为是str调用的intern方法，所以此时该引用==str。</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"a"</span>) + <span class="keyword">new</span> String(<span class="string">"b"</span>)</span><br><span class="line">str.intern();</span><br><span class="line">String s2 = <span class="string">"ab"</span>;</span><br><span class="line">System.out.println(str == s2);	<span class="comment">// jdk6: false	jdk7/8: true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"a"</span>) + <span class="keyword">new</span> String(<span class="string">"b"</span>);</span><br><span class="line">String s2 = str.intern();</span><br><span class="line">String s3 = <span class="string">"ab"</span>;</span><br><span class="line">System.out.println(str == s2);	<span class="comment">// jdk6: false	jdk7/8: true</span></span><br><span class="line">System.out.println(s3 == s2);	<span class="comment">// jdk6: true	jdk7/8: true</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>当需要存储大量字符串在内存中时，可以恰当的使用intern()方法，节省空间，促进GC。</p>
<p><strong>G1的String去重操作</strong></p>
<blockquote>
<p>当垃圾收集器工作的时候，会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的String对象。</p>
<p>如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的String对象。</p>
<p>使用一个hashtable来记录所有的被String对象使用的不重复的char数组。当去重的时候，会查这个hashtable，来看堆上是否已经存在一个一模一样的char数组。</p>
<p>如果存在，String对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。<br>如果查找失败，char数组会被插入到hashtable，这样以后的时候就可以共享这个数组了。</p>
<p>UseStringDeduplication (bool):开启String去重，默认是不开启的，需要手动开启。</p>
</blockquote>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="垃圾回收算法-标记阶段"><a href="#垃圾回收算法-标记阶段" class="headerlink" title="垃圾回收算法-标记阶段"></a>垃圾回收算法-标记阶段</h3><p>首先需在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为<strong>垃圾标记阶段</strong>。</p>
<p>那么在JVM中究竟是如何标记一个死亡对象呢?简单来说，当一个对象已经<strong>不再被任何的存活对象继续引用时</strong>，就可以宣判为已经死亡。</p>
<p>判断对象存活一般有两种方式：<strong>引用计数算法</strong>和<strong>可达性分析算法</strong>。</p>
<h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>引用计数算法(Reference Counting)比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。</p>
<p>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</p>
<blockquote>
<p>优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</p>
<p>缺点：①它需要单独的字段存储计数器，这样的做法增加了存储空间的开销。②每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。③引用计数器有一个严重的问题，即无法处理<strong>循环引用</strong>的情况。这是一条致命缺陷,导致在Java的垃圾回收器中没有使用这类算法。</p>
</blockquote>
<h4 id="可达性分析算法-根搜索算法、追踪性垃圾收集"><a href="#可达性分析算法-根搜索算法、追踪性垃圾收集" class="headerlink" title="可达性分析算法(根搜索算法、追踪性垃圾收集)"></a>可达性分析算法(根搜索算法、追踪性垃圾收集)</h4><p>所谓”GC Roots”根集合就是一组必须活跃的引用。</p>
<p>基本思路：可达性分析算法是以根对象集合(GC Roots)为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。</p>
<blockquote>
<p>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为<strong>引用链(Reference Chain)</strong></p>
<p>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。</p>
<p>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</p>
</blockquote>
<p>在Java语言中，G Roots包括以下几类元素：</p>
<p>①虚拟机栈中引用的对象。比如：各个线程被调用的方法中使用到的参数、局部变量等。<br>②本地方法栈内JNI(通常说的本地方法)引用的对象<br>③方法区中类静态属性引用的对象。比如: Java类的引用类型静态变量<br>④方法区中常量引用的对象。比如:字符串常量池（string Table）里的引用<br>⑤所有被同步锁synchronized持有的对象<br>⑥Java虚拟机内部的引用。基本数据类型对应的class对象，一些常驻的异常对象（如:NullPointerException、OutOfMemoryError）、系统类加载器<br>⑦反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。<br>⑧在某些特殊情况下，还可能存在一些对象临时加入到Root中的情况。(如：在分代垃圾收集时，如果只回收新生代的对象，那么一些老年代的对象也可以作为Root)</p>
<blockquote>
<p>如果一个指针，它指向堆内存里面的对象，但是其本身又不存放在堆内存里面，那它就是一个Root。</p>
</blockquote>
<p>因此采用此方法进行垃圾收集时，需要处于一个一致性的快照环境下。也就是STW的由来。</p>
<h4 id="对象的finalization机制"><a href="#对象的finalization机制" class="headerlink" title="对象的finalization机制"></a>对象的finalization机制</h4><p>Java语言提供了对象终止(finalization)机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，<strong>总会先调用这个对象的finalize()方法。</strong></p>
<p>永远不要主动调用某个对象的finalize()方法，应该交给垃圾回收机制调用。理由包括下面三点:</p>
<p>①在finalize()时可能会导致对象复活。<br>②finalize()方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则finalize()方法将没有执行机会。<br>③一个糟糕的finalize()会严重影响Gc的性能。</p>
<p>从功能上来说，finalize()方法与C++中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize()方法在本质上不同于C++中的析构函数。</p>
<p>由于finalize()方法的存在，虚拟机中的对象一般处于三种可能的状态。</p>
<blockquote>
<p>可触及的：从根节点开始，可以到达这个对象。<br>可复活的：对象的所有引用都被释放，但是对象有可能在finalize()中复活。且之后也无法再次调用finalize方法<br>不可触及的:对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为finalize ()只会被调用一次。</p>
<p>以上3种状态中，是由于finalize()方法的存在，进行的区分。只有在对象不可触及时才可以被回收。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">判定一个对象objA是否可回收，至少要经历两次标记过程:</span><br><span class="line">	1．如果对象objA到GC Roots没有引用链，则进行第一次标记。</span><br><span class="line">	2．进行筛选，判断此对象是否有必要执行finalize()方法</span><br><span class="line">		* 如果对象objA没有finalize()方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，obj重写finalize()方法,或者A被判定为不可触及的。</span><br><span class="line">		* 如果对象objA重写了finalize()方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize()方法执行。</span><br><span class="line">		* finalize()方法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的况。在这个情况下，finalize方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize方法只会被调用一次。</span><br></pre></td></tr></table></figure>

<h3 id="垃圾回收算法-清除阶段"><a href="#垃圾回收算法-清除阶段" class="headerlink" title="垃圾回收算法-清除阶段"></a>垃圾回收算法-清除阶段</h3><p>当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。</p>
<p>目前在JVM中比较常见的三种垃圾收集算法是标记一清除算法( Mark-Sweep )、复制算法（ copying )、标记–压缩算法( Mark-Compact )。</p>
<h4 id="标记-清除方法"><a href="#标记-清除方法" class="headerlink" title="标记-清除方法"></a>标记-清除方法</h4><p>执行过程：当堆中的有效内存空间(available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world)，然后进行两项工作，第一项则是标记，第二项则是清除。</p>
<blockquote>
<p>标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。(未标记的为垃圾)<br>清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。</p>
</blockquote>
<p>缺点：</p>
<blockquote>
<p>①效率不算高<br>②在进行GC的时候，需要停止整个应用程序，导致用户体验差<br>③这种方式清理出来的空闲内存是不连续的，产生内存碎片I需要维护一个空闲列表</p>
</blockquote>
<blockquote>
<p>补充：何为清除，即将需要被清除的对象的地址添加到空闲列表中接口，而没有“置空”之类的说法。</p>
</blockquote>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</p>
<blockquote>
<p>优点：没有标记和清除过程,实现简单，运行高效；复制过去以后保证空间的连续性，不会出现“碎片”问题。</p>
<p>缺点：此算法的缺点也是很明显的，就是需要两倍的内存空间。对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小。</p>
<p>特别的：如果系统中的非垃圾对象很多，复制算法不会太理想。因为复制算法需要复制的存活对象数量需要不能太大，或者说非常低才行。（所以可以应用到新生代中）</p>
</blockquote>
<h4 id="标记-压缩算法"><a href="#标记-压缩算法" class="headerlink" title="标记-压缩算法"></a>标记-压缩算法</h4><p>执行过程：</p>
<p>第一阶段和标记-清除算法一样，从根节点开始标记所有被引用对象。第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间。</p>
<blockquote>
<p>二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策（引用的修改）。</p>
<p>可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</p>
</blockquote>
<blockquote>
<p>优点：消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。<br>消除了复制算法当中，内存减半的高额代价。</p>
<p>缺点：从效率上来说，标记-整理算法要低于复制算法。移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址。_·移动过程中，需要全程暂停用户应用程序。即：STW</p>
</blockquote>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。</p>
<p>而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。</p>
<h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>分代收集算法，是基于这样一个事实:不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p>
<p>目前几乎所有的GC都是采用分代收集(Generational Collecting)算法执行垃圾回收的。</p>
<p>在Hotspot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。</p>
<blockquote>
<p>年轻代(Young Gen)：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</p>
<p>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</p>
<p>老年代(Tenured Gen)：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</p>
<p>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。</p>
<p>Mark阶段的开销与存活对象的数量成正比。<br>Sweep阶段的开销与所管理区域的大小成正相关。<br>Compact阶段的开销与存活对象的数据成正比。</p>
</blockquote>
<p>以Hotspot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于Mark-compact算法的Serial old回收器作为补偿措施:当内存回收不佳（碎片导致的doncurrent Mode Failure时)，将采用Serial old执行Full GC以达到对老年代内存的整理。</p>
<p>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代。</p>
<h4 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h4><p>基本思想：如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</p>
<p>总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。</p>
<blockquote>
<p>缺点：使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞叶量的下降。</p>
</blockquote>
<h4 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h4><p>一般来说，在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。</p>
<p>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间region。每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</p>
<h3 id="垃圾回收的相关概念"><a href="#垃圾回收的相关概念" class="headerlink" title="垃圾回收的相关概念"></a>垃圾回收的相关概念</h3><h4 id="System-gc"><a href="#System-gc" class="headerlink" title="System.gc()"></a>System.gc()</h4><p>在默认情况下，通过System.gc()或者Runtime. getRuntime( ).gc()的调用，会显式触发Full GC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</p>
<p>然而System.gc()调用附带一个免责声明，无法保证对垃圾收集器的调用。</p>
<p>JVM实现者可以通过System.gc()调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc()。</p>
<p>System.runFinalization()方法会强制调用失去引用的对象的finalize()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	System.gc(); <span class="comment">// 此时 b数组并不会被回收，虽然作用域已经结束，但是因为局部变量表中仍然存在一个插槽指向该对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">1</span>;</span><br><span class="line">	System.gc(); <span class="comment">// 此时 b数组会被回收，因为其之前在局部变量表中的插槽被val变量所占用了，所以属于垃圾对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="内存溢出与内存泄漏"><a href="#内存溢出与内存泄漏" class="headerlink" title="内存溢出与内存泄漏"></a>内存溢出与内存泄漏</h4><p>javadoc中对OutOfMemoryError的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。也就是在OOM之前通常会执行垃圾回收(除了分配超大对象时，垃圾收集也无济于事的情况)。</p>
<p>没有空闲内存的情况：①Java虚拟机的堆内存设置不够；②代码中创建了大量对象，且长时间不能被垃圾收集器收集（存在被引用）</p>
<hr>
<p>只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫<strong>内存泄漏</strong>。</p>
<p>但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致OOM，也可以叫做宽泛意义上的“内存泄漏”。</p>
<blockquote>
<p>eg. 当一个对象的引用属于类的静态成员时，该对象的生命周期就很长，随着类的消亡才会消亡。</p>
</blockquote>
<p>举例:</p>
<blockquote>
<p>1、单例模式<br>单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。</p>
<p>2、一些提供close的资源未关闭导致内存泄漏<br>数据库连接（dataSourse.getConnection())，网络连接(socket)和io连接必须手动close，否则是不能被回收的。</p>
</blockquote>
<h4 id="StopTheWord"><a href="#StopTheWord" class="headerlink" title="StopTheWord"></a>StopTheWord</h4><p>stop-the-world，简称STW，指的是GC事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW。</p>
<blockquote>
<p>可达性分析算法中枚举根节点(GC Roots）会导致所有Java执行线程停顿。</p>
<ul>
<li>分析工作必须在一个能确保一致性的快照中进行</li>
<li>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</li>
<li>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证</li>
</ul>
<p>被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少STW的发生。</p>
</blockquote>
<p>STW事件和采用哪款GC无关，所有的GC都有这个事件。</p>
<p>哪怕是G1也不能完全避免stop-the-world 情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。</p>
<p>STW是JVM在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的工作线程全部停掉。</p>
<p>开发中不要用System.gc();会导致stop-the-world的发生。</p>
<h4 id="垃圾回收的并行和并发"><a href="#垃圾回收的并行和并发" class="headerlink" title="垃圾回收的并行和并发"></a>垃圾回收的并行和并发</h4><p>并发：在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，即都在运行中，且这几个程序都是在同一个处理备上运行。</p>
<p>并行：当系统有一个以上CPU时，当一个CPu执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，我们称之为并行(Parallel)。其实决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以并行。</p>
<p>并发，指的是多个事情,在同一时间段内同时发生了。并发的多个任务之间是互相抢占资源的。<br>并行，指的是多个事情,在同一时间点上同时发生了。并行的多个任务之间是不互相抢占资源的。</p>
<hr>
<p>并行(Parallel)：指<strong>多条垃圾收集线程</strong>并行工作，但此时用户线程仍处于等待状态。如ParNew、Parallel scavenge、Parallel old;</p>
<p>串行(Serial)：相较于并行的概念,单线程执行。如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。</p>
<p>并发(Concurrent)：指用户线程与垃圾收集线程同时执行(但不一定是并行的，可能会交替执行)，垃圾回收线程在执行时不会停顿用户程序的运行。</p>
<blockquote>
<p>用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上；如：CMS、G1</p>
</blockquote>
<h4 id="安全点和安全区域"><a href="#安全点和安全区域" class="headerlink" title="安全点和安全区域"></a>安全点和安全区域</h4><p>程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点(Safe Point) ”。</p>
<p>Safe Point的选择很重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，通常会根据“是否具有让程序长时间执行的特征”为标准。比如:：选择一些执行时间较长的指令作为Safe Point，如方法调用、循环跳转和异常跳转等。</p>
<p>如何在GC发生时,检查所有线程都跑到最近的安全点停顿下来呢?</p>
<blockquote>
<p>抢先式中断：首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。（目前没有虚拟机采用了)</p>
<p>主动式中断：设置一个中断标志，各个线程运行到safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。</p>
</blockquote>
<p>安全区域</p>
<blockquote>
<p>Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safe Point 。但是，程序“不执行”的时候呢?例如线程处于sleep状态或Blocked状态，这时候线程无法响应JVM的中断请求，“走”到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域(Safe Region)来解决。</p>
<p>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的。我们也可以把Safe Region看做是被扩展了的Safe Point。</p>
</blockquote>
<p>实际执行时:<br>1、当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region,如果这段时间内发生GC，JVM会忽略标识为Safe Region状态的线程;</p>
<p>2、当线程即将离开Safe Region时，会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止。</p>
<h4 id="java引用"><a href="#java引用" class="headerlink" title="java引用"></a>java引用</h4><p>强引用——软引用——弱引用——虚引用，引用强度逐级递减。</p>
<p>强引用(Strong Reference)：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj=new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</p>
<p>软引用(Soft Reference)：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。</p>
<p>弱引用(Weak Reference)：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。</p>
<p>虚引用(Phantom Reference)：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。<strong>为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</strong>（对象回收跟踪）</p>
<h5 id="强引用——不回收"><a href="#强引用——不回收" class="headerlink" title="强引用——不回收"></a>强引用——不回收</h5><blockquote>
<p>在Java程序中，最常见的引用类型是强引用（普通系统99%以上都是强引用)，也就是我们最常见的普通对象引用，也是默认的引用类型。</p>
<p>当在]ava语言中使用new操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。</p>
<p>强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。</p>
<p>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应(强)引用赋值为null，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。</p>
<p>相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的（<font color="red">均为可达的</font>），在一定条件下，都是可以被回收的。<strong>所以，强引用是造成Java内存泄漏的主要原因之一</strong>。</p>
</blockquote>
<h5 id="软引用——内存不足即回收"><a href="#软引用——内存不足即回收" class="headerlink" title="软引用——内存不足即回收"></a>软引用——内存不足即回收</h5><blockquote>
<p>软引用是用来描述一些还有用，但非必需的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p>
<p>软引用通常用来实现内存敏感的缓存。比如：高速缓存就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p>
<p>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列(Reference Queue)。</p>
<p>类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。</p>
</blockquote>
<h5 id="弱引用——发现即回收"><a href="#弱引用——发现即回收" class="headerlink" title="弱引用——发现即回收"></a>弱引用——发现即回收</h5><blockquote>
<p>弱引用也是用来描述那些非必需对象，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。</p>
<p>但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。</p>
<p>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</p>
<p>软引用、弱引用都非常适合来保存那些可有可无的缓存数据。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用</p>
</blockquote>
<h5 id="虚引用——对象回收跟踪"><a href="#虚引用——对象回收跟踪" class="headerlink" title="虚引用——对象回收跟踪"></a>虚引用——对象回收跟踪</h5><blockquote>
<p>也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个。</p>
<p>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</p>
<p>它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get()方法取得对象时，总是null。</p>
<p>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。</p>
<p>虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用就会在回收对象后，<strong>将这个虚引用加入引用队列</strong>，以通知应用程序对象的回收情况，我们可以操作该队列来完成一个通知的机制。</p>
</blockquote>
<h5 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h5><blockquote>
<p>它用以实现对象的finalize()方法，也可以称为终结器引用。</p>
<p>无需手动编码,其内部配合引用队列使用。</p>
<p>在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象并调用它的finalize()方法，第二次GC时才能回收被引用对象。</p>
</blockquote>
<h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><h4 id="GC分类与性能指标"><a href="#GC分类与性能指标" class="headerlink" title="GC分类与性能指标"></a>GC分类与性能指标</h4><p>吞吐量：运行用户代码的时间占总运行时间的比例</p>
<blockquote>
<p>（总运行时间：程序的运行时间＋内存回收的时间)</p>
</blockquote>
<p>垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。<br>暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间。<br>收集频率：相对于应用程序的执行，收集操作发生的频率。<br>内存占用：Java 堆区所占的内存大小。<br>快速：一个对象从诞生到被回收所经历的时间。</p>
<p>暂停时间的重要性逐渐凸显。</p>
<h4 id="垃圾回收器和分代关系"><a href="#垃圾回收器和分代关系" class="headerlink" title="垃圾回收器和分代关系"></a>垃圾回收器和分代关系</h4><p>新生代收集器: Serial、ParNew、Parallel scavenge;<br>老年代收集器: serial old、Parallel old、CMS;<br>整堆收集器:G1;</p>
<p><img src="https://i.loli.net/2021/03/03/c8nYaLOTkhr3DlH.png" alt="image.png"></p>
<p>其中虚线为JDK8及以前的搭配。</p>
<p>且Serrial Old GC是作为CMS GC的后备方案。因为CMS需要在老年代未满时进行并发回收，如果老年代满了，只能通过Serial Old GC来收集。</p>
<h5 id="Serial-GC（串行回收）"><a href="#Serial-GC（串行回收）" class="headerlink" title="Serial GC（串行回收）"></a>Serial GC（串行回收）</h5><p>单线程。</p>
<p>新生代复制算法、老年代标记-整理算法。都需要STW。</p>
<h5 id="ParNew-GC（并行回收）"><a href="#ParNew-GC（并行回收）" class="headerlink" title="ParNew GC（并行回收）"></a>ParNew GC（并行回收）</h5><p>Serial的多线程版本。</p>
<p>New代表处理的是新生代，采用复制算法。也需要STW。、</p>
<p>可以和CMS和Serial Old搭配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UserParNewGC 启用ParNew GC</span><br><span class="line">-XX:PareallelGCThreads 限制线程数量 默认和CPU相同</span><br></pre></td></tr></table></figure>

<h5 id="Parallel-Scavenge回收器（吞吐量优先、并行）"><a href="#Parallel-Scavenge回收器（吞吐量优先、并行）" class="headerlink" title="Parallel Scavenge回收器（吞吐量优先、并行）"></a>Parallel Scavenge回收器（吞吐量优先、并行）</h5><p>同样新生代采用复制算法，需要STW。</p>
<p>且存在动态自适应调节策略。</p>
<p>Parallel Old采用标记压缩算法处理老年代，需要STW。</p>
<p>java8默认收集器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UserParallelGC 启用Parallel GC</span><br><span class="line">-XX:+UserParallelOldGC 且这两个参数互相激活</span><br><span class="line">-XX:PareallelGCThreads 年轻代垃圾收集的线程数</span><br><span class="line">-XX:GCTimeRatio 垃圾收集时间占总时间的比例</span><br><span class="line">-XX:MaxGCPauseMillis 慎用 设置最大暂停时间</span><br><span class="line">-XX:+UseAdaptivesizePolicy 自适应调节策略</span><br></pre></td></tr></table></figure>

<h5 id="CMS-GC（低延迟）"><a href="#CMS-GC（低延迟）" class="headerlink" title="CMS GC（低延迟）"></a>CMS GC（低延迟）</h5><p>concurrent-mark-sweep 并发-标记-清除 也会STW，为了能在并发清除时不用STW，所以使用mark-sweep</p>
<p>垃圾收集线程和用户线程同时工作</p>
<p>只能和Serial、ParNew配合工作。jdk14删除</p>
<p>CNS整个过程比之前的收集器要复杂,整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段。</p>
<blockquote>
<p>初始标记(Initial-Mark)阶段：在这个阶段中，程序中所有的工作线程都将会因为“Stop-the-world”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是标记出GC Roots能<strong>直接关联到的对象</strong>。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。</p>
<p>并发标记(Concurrent-Mark)阶段：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是<strong>不需要停顿用户线程</strong>，可以与垃圾收集线程一起并发运行。（耗时）</p>
<p>重新标记(Remark)阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</p>
<p>并发清除(Concurrent-Sweep)阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。（耗时）</p>
</blockquote>
<p><img src="https://i.loli.net/2021/03/03/w6mbDEpgxHdSyo2.png" alt="image.png"></p>
<p>在并发标记时，需要保证用户线程仍然有足够的内存可以使用。不能在老年代满的时候再收集。否则需要Serial Old GC作为后备方案。</p>
<p>也会产生内存碎片。需要空闲列表。</p>
<p>弊端：</p>
<blockquote>
<p>1)会产生内存碎片，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发Full GC。<br>2)CMS收集器对cPu资源非常敏感。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。<br>3)CMS收集器无法处理浮动垃圾。可能出现“concurrent Mode Failure”失败而导致另一次 Full cC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在<strong>并发标记阶段如果产生新的垃圾对象</strong>，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行Gc时释放这些之前未被回收的内存空间。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UserConcMarkSweepGC 老年代 默认新生代使用ParNew GC</span><br><span class="line">-XX:CMSInitiatingOccupyFraction 设置堆内存使用率的阈值 %65 jdk6+：%92</span><br><span class="line">还有参数设置多久执行一次内存碎片的整理</span><br></pre></td></tr></table></figure>

<h5 id="G1-GC（区域化分代式）"><a href="#G1-GC（区域化分代式）" class="headerlink" title="G1 GC（区域化分代式）"></a>G1 GC（区域化分代式）</h5><p>官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望。</p>
<p>G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1 跟踪各个Region里面的垃圾堆积的价值大小(回收所获得的空间大小以佟以收所需可间的约城值)，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。</p>
<p>特点</p>
<blockquote>
<p>并行与并发：</p>
<p>并行性: G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW。<br>并发性: G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况。</p>
<p>分代收集：</p>
<p>①从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。<br>②将堆空间分为若干个区域(Region)，这些区域中包含了逻辑上的年轻代和老年代。<br>③和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代。</p>
<p>空间整合：</p>
<p>CMS：“标记-清除”算法、内存碎片、若干次GC后进行一次碎片整理<br>G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。Region之间是复制算法，但整体上实际可看作是标记-压缩(Mark-Compact)算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。</p>
<p>可预测的停顿时间模型(即：软实时soft real-time)：</p>
<p>这是G1 相对于CMS 的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</p>
<p>①由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。<br>②G1 跟踪各个Region里面的垃圾堆积的价值大小(回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了G1 收集器在有限的时间内可以获取尽可能高的收集效率。<br>③相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseG1GC 手动指定使用G1收集器执行内存回收任务。</span><br><span class="line">-XX:G1HeapRegionSize设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000.</span><br><span class="line">-XX:MaxGCPauseMillis设置期望达到的最大Gc停顿时间指标(JVM会尽力实现，但不保证达到)。默认值是200ms</span><br><span class="line">-XX:Paralle1GCThread 设置STW工作线程数的值。最多设置为8</span><br><span class="line">-XX:ConcGChreads设置并发标记的线程数。将n设置为并行垃圾回收线程数(ParallelGCThreads)的1/4左右。</span><br><span class="line">-XX:InitiatingHeapOccupancyPercent 设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发Gc。默认值是45。</span><br></pre></td></tr></table></figure>

<p>G1的设计原则就是简化VM性能调优，开发人员只需要简单的三步即可完成调优:</p>
<p>第一步:开启G1垃圾收集器<br>第二步:设置堆的最大内存<br>第三步:设置最大的停顿时间</p>
<p>G1中提供了三种垃圾回收模式: YoungGc、Mixed Gc和Full Gc，在不同的条件下被触发。</p>
<p>设置H的原因:</p>
<blockquote>
<p>对于堆中的大对象，默认直接会被分配到老年代,I但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动Full Gc。G1的大多数行为都把H区作为老年代的一部分来看待。</p>
</blockquote>
<p>在region内部分配内存采用指针碰撞，还可以分配TLAB。</p>
<p><strong>垃圾回收细节</strong></p>
<p>G1垃圾回收主要包含三个环节：</p>
<p>①年轻代GC(Young GC)<br>②老年代并发标记过程(Concurrent Marking)<br>③混合回收(Mixed Gc)<br>(如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。)</p>
<p><img src="https://i.loli.net/2021/03/04/Idiyfvm8cHtTwxY.png" alt="image.png"></p>
<blockquote>
<p>应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程; G1的年轻代收集阶段是一个并行的独占式收集器。在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。</p>
<p>当堆内存使用达到一定值(默认45%)时，开始老年代并发标记过程。</p>
<p>标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了。同时，这个老年代Region是和年轻代一起被回收的。</p>
<p>举个例子：一个web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</p>
</blockquote>
<p><strong>Remebered Set</strong></p>
<p>一个对象被不同区域引用的问题</p>
<blockquote>
<p>一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时,是否需要扫描整个Java堆才能保证准确?</p>
<p>在其他的分代收集器，也存在这样的问题(而G1更突出)</p>
<p>回收新生代也不得不同时扫描老年代?</p>
<p>这样的话会降低Minor GC的效率?</p>
</blockquote>
<p>解决方法:</p>
<blockquote>
<p>无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描</p>
<p>每个Region都有一个对应的Remembered set;</p>
<p>每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作;</p>
<p>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region(其他收集器:检查老年代对象是否引用了新生代对象);</p>
<p>如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered set中;</p>
<p>当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set，就可以保证不进行全局扫描，也不会有遗漏。</p>
<p>笔者理解：即在回收某一个region时，如果该region中的对象仍然存在其他region的对象引用他们，则这些引用的对象肯定是存在于Remebered Set中的，这样就能够很好的进行标记了，也不会遗漏。</p>
</blockquote>
<p><img src="https://i.loli.net/2021/03/04/qxfND297J8VGFip.png" alt="image.png"></p>
<p><strong>垃圾回收过程</strong></p>
<p>YGC：</p>
<blockquote>
<p>JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。</p>
<p>年轻代垃圾回收只会回收Eden区和Survivor区。</p>
<p>YGC时，首先G1停止应用程序的执行(stop-The-world) ，G1创建回收集（collection Set)，回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区<strong>所有</strong>的内存分段。</p>
</blockquote>
<p>具体过程</p>
<blockquote>
<p>然后开始如下回收过程:</p>
<p>第一阶段，扫描根。<br>根是指static变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同RSet记录的外部引用作为扫描存活对象的入口。</p>
<p>第二阶段，更新RSet。<br>处理dirty card queue(见备注)中的card，更新RSet。此阶段完成后，RSet可以准确的反映老年代对所在的内存分段中对象的引用。</p>
<p>第三阶段，处理RSet。<br>识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。</p>
<p>第四阶段，复制对象。<br>此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到survivor区中空的内存分段survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到o1d区中空的内存分段。如果survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。</p>
<p>第五阶段,处理引用。<br>处理Soft，weak，Phantom，Final，JNI weak 等引用。最终Eden空间的数据为空，Gc停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果．减少碎片</p>
</blockquote>
<p>并发标记阶段：</p>
<blockquote>
<p>1、初始标记阶段：标记从根节点直接可达的对象。这个阶段是STW的，并且会触发一次年轻代GC。<br>2、根区域扫描（Root Region Scanning)：G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在Young GC之前完成。<br>3、并发标记(Concurrent Marking)：在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被Young GC中断。在并发标记阶段，<strong>若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收</strong>。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。<br>4、再次标记(Remark)：由于应用程序持续进行，需要修正上一次的标记结果是STW的。G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。<br>5、独占清理(cleanup,STW)：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。(这个阶段并不会实际上去做垃圾的收集)<br>6、并发清理阶段：识别并清理完全空闲的区域。</p>
</blockquote>
<p>混合回收</p>
<blockquote>
<p>当越来越多的对象晋升到老年代old region时,为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个old Gc，除了回收整个Young Region,还会回收一部分的old Region。这里需要注意：是一部分老年代，而不是全部老年代。可以选择哪些old Region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed Gc并不是Full Gc。</p>
</blockquote>
<p>导致G1Full GC的原因可能有两个:</p>
<p>①Evacuation的时候没有足够的to-space来存放晋升的对象<br>②并发处理过程完成之前空间耗尽。</p>
<p>优化建议</p>
<blockquote>
<p>年轻代大小：避免使用-Xmn或-XX;NewRatio等相关选项显式设置年轻代大小&gt;固定年轻代的大小会覆盖暂停时间目标<br>暂停时间目标不要太过严苛</p>
<p>G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间<br>评估G1 Gc的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</p>
</blockquote>
<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p><img src="https://i.loli.net/2021/03/04/oFTlgyn5s2i61VQ.png" alt="image.png"></p>
<p>怎么选择垃圾回收器?</p>
<blockquote>
<p>Java垃圾收集器的配置对于VM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一个很大的提升。</p>
<p>优先调整堆的大小让JVM自适应完成。</p>
<p>如果内存小于100M，使用串行收集器</p>
<p>如果是单核、单机程序，并且没有停顿时间的要求，串行收集器</p>
<p>如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择</p>
<p>如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用)，使用并发收集器，官方推荐G1，性能高。现在互联网的项目，基本都是使用G1。</p>
</blockquote>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>Bcutty Kmy
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="http://yoursite.com/2021/03/05/jvm/" title="JVM">http://yoursite.com/2021/03/05/jvm/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag"># 学习</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/03/04/Java%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/" rel="prev" title="Java面试准备">
      <i class="fa fa-chevron-left"></i> Java面试准备
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/03/31/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/" rel="next" title="Java面经整理">
      Java面经整理 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM"><span class="nav-number">1.</span> <span class="nav-text">JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM的架构模型"><span class="nav-number">1.0.1.</span> <span class="nav-text">JVM的架构模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM的生命周期"><span class="nav-number">1.0.2.</span> <span class="nav-text">JVM的生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM发展历程"><span class="nav-number">1.0.3.</span> <span class="nav-text">JVM发展历程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类加载子系统"><span class="nav-number">1.1.</span> <span class="nav-text">类加载子系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内存结构概述"><span class="nav-number">1.1.1.</span> <span class="nav-text">内存结构概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类加载器和类加载过程"><span class="nav-number">1.1.2.</span> <span class="nav-text">类加载器和类加载过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类加载器分类"><span class="nav-number">1.1.3.</span> <span class="nav-text">类加载器分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ClassLoader类"><span class="nav-number">1.1.4.</span> <span class="nav-text">ClassLoader类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#双亲委派机制"><span class="nav-number">1.1.5.</span> <span class="nav-text">双亲委派机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他"><span class="nav-number">1.1.6.</span> <span class="nav-text">其他</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运行时数据区"><span class="nav-number">1.2.</span> <span class="nav-text">运行时数据区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#线程"><span class="nav-number">1.2.0.1.</span> <span class="nav-text">线程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PC寄存器"><span class="nav-number">1.2.1.</span> <span class="nav-text">PC寄存器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#两个常见问题"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">两个常见问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟机栈"><span class="nav-number">1.2.2.</span> <span class="nav-text">虚拟机栈</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#栈的存储单位"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">栈的存储单位</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#栈帧的内部结构"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">栈帧的内部结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#局部变量表"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">局部变量表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#关于slot的理解"><span class="nav-number">1.2.2.3.1.</span> <span class="nav-text">关于slot的理解</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#操作数栈"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">操作数栈</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#栈顶缓存技术"><span class="nav-number">1.2.2.4.1.</span> <span class="nav-text">栈顶缓存技术</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态链接-指向运行时常量池中的方法引用"><span class="nav-number">1.2.2.5.</span> <span class="nav-text">动态链接(指向运行时常量池中的方法引用)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法的调用"><span class="nav-number">1.2.2.6.</span> <span class="nav-text">方法的调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法返回地址"><span class="nav-number">1.2.2.7.</span> <span class="nav-text">方法返回地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#一些附加信息"><span class="nav-number">1.2.2.8.</span> <span class="nav-text">一些附加信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#面试题"><span class="nav-number">1.2.2.9.</span> <span class="nav-text">面试题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#本地方法栈"><span class="nav-number">1.2.3.</span> <span class="nav-text">本地方法栈</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#本地方法接口"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">本地方法接口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#堆"><span class="nav-number">1.2.4.</span> <span class="nav-text">堆</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#概述"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#设置堆内存大小和OOM"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">设置堆内存大小和OOM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#年轻代和老年代"><span class="nav-number">1.2.4.3.</span> <span class="nav-text">年轻代和老年代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象分配过程"><span class="nav-number">1.2.4.4.</span> <span class="nav-text">对象分配过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Minor-GC、Full-GC、Major-GC"><span class="nav-number">1.2.4.5.</span> <span class="nav-text">Minor GC、Full GC、Major GC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#堆空间分代思想"><span class="nav-number">1.2.4.6.</span> <span class="nav-text">堆空间分代思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内存分配策略"><span class="nav-number">1.2.4.7.</span> <span class="nav-text">内存分配策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TLAB（Thread-Local-Allocation-Buffer）"><span class="nav-number">1.2.4.8.</span> <span class="nav-text">TLAB（Thread Local Allocation Buffer）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#堆空间常用参数设置"><span class="nav-number">1.2.4.9.</span> <span class="nav-text">堆空间常用参数设置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#堆是对象存储的唯一选择吗？"><span class="nav-number">1.2.4.10.</span> <span class="nav-text">堆是对象存储的唯一选择吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码优化"><span class="nav-number">1.2.4.11.</span> <span class="nav-text">代码优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-number">1.2.4.12.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法区"><span class="nav-number">1.2.5.</span> <span class="nav-text">方法区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#设置方法区大小"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">设置方法区大小</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法区内部结构"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">方法区内部结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#运行时常量池"><span class="nav-number">1.2.5.3.</span> <span class="nav-text">运行时常量池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法区演变细节"><span class="nav-number">1.2.5.4.</span> <span class="nav-text">方法区演变细节</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法区的垃圾收集"><span class="nav-number">1.2.5.5.</span> <span class="nav-text">方法区的垃圾收集</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-1"><span class="nav-number">1.2.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象相关"><span class="nav-number">1.3.</span> <span class="nav-text">对象相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#对象的实例化"><span class="nav-number">1.3.0.1.</span> <span class="nav-text">对象的实例化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象的内存布局"><span class="nav-number">1.3.0.2.</span> <span class="nav-text">对象的内存布局</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象的访问定位"><span class="nav-number">1.3.0.3.</span> <span class="nav-text">对象的访问定位</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#直接内存"><span class="nav-number">1.4.</span> <span class="nav-text">直接内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#执行引擎"><span class="nav-number">1.5.</span> <span class="nav-text">执行引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JIT"><span class="nav-number">1.5.1.</span> <span class="nav-text">JIT</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String"><span class="nav-number">1.6.</span> <span class="nav-text">String</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串的拼接操作"><span class="nav-number">1.6.1.</span> <span class="nav-text">字符串的拼接操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#intern-方法"><span class="nav-number">1.6.2.</span> <span class="nav-text">intern()方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾回收"><span class="nav-number">1.7.</span> <span class="nav-text">垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#垃圾回收算法-标记阶段"><span class="nav-number">1.7.1.</span> <span class="nav-text">垃圾回收算法-标记阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#引用计数算法"><span class="nav-number">1.7.1.1.</span> <span class="nav-text">引用计数算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可达性分析算法-根搜索算法、追踪性垃圾收集"><span class="nav-number">1.7.1.2.</span> <span class="nav-text">可达性分析算法(根搜索算法、追踪性垃圾收集)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象的finalization机制"><span class="nav-number">1.7.1.3.</span> <span class="nav-text">对象的finalization机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#垃圾回收算法-清除阶段"><span class="nav-number">1.7.2.</span> <span class="nav-text">垃圾回收算法-清除阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#标记-清除方法"><span class="nav-number">1.7.2.1.</span> <span class="nav-text">标记-清除方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#复制算法"><span class="nav-number">1.7.2.2.</span> <span class="nav-text">复制算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#标记-压缩算法"><span class="nav-number">1.7.2.3.</span> <span class="nav-text">标记-压缩算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结-2"><span class="nav-number">1.7.2.4.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分代收集算法"><span class="nav-number">1.7.2.5.</span> <span class="nav-text">分代收集算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#增量收集算法"><span class="nav-number">1.7.2.6.</span> <span class="nav-text">增量收集算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分区算法"><span class="nav-number">1.7.2.7.</span> <span class="nav-text">分区算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#垃圾回收的相关概念"><span class="nav-number">1.7.3.</span> <span class="nav-text">垃圾回收的相关概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#System-gc"><span class="nav-number">1.7.3.1.</span> <span class="nav-text">System.gc()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内存溢出与内存泄漏"><span class="nav-number">1.7.3.2.</span> <span class="nav-text">内存溢出与内存泄漏</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#StopTheWord"><span class="nav-number">1.7.3.3.</span> <span class="nav-text">StopTheWord</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#垃圾回收的并行和并发"><span class="nav-number">1.7.3.4.</span> <span class="nav-text">垃圾回收的并行和并发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#安全点和安全区域"><span class="nav-number">1.7.3.5.</span> <span class="nav-text">安全点和安全区域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#java引用"><span class="nav-number">1.7.3.6.</span> <span class="nav-text">java引用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#强引用——不回收"><span class="nav-number">1.7.3.6.1.</span> <span class="nav-text">强引用——不回收</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#软引用——内存不足即回收"><span class="nav-number">1.7.3.6.2.</span> <span class="nav-text">软引用——内存不足即回收</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#弱引用——发现即回收"><span class="nav-number">1.7.3.6.3.</span> <span class="nav-text">弱引用——发现即回收</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#虚引用——对象回收跟踪"><span class="nav-number">1.7.3.6.4.</span> <span class="nav-text">虚引用——对象回收跟踪</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#终结器引用"><span class="nav-number">1.7.3.6.5.</span> <span class="nav-text">终结器引用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#垃圾回收器"><span class="nav-number">1.7.4.</span> <span class="nav-text">垃圾回收器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GC分类与性能指标"><span class="nav-number">1.7.4.1.</span> <span class="nav-text">GC分类与性能指标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#垃圾回收器和分代关系"><span class="nav-number">1.7.4.2.</span> <span class="nav-text">垃圾回收器和分代关系</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Serial-GC（串行回收）"><span class="nav-number">1.7.4.2.1.</span> <span class="nav-text">Serial GC（串行回收）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ParNew-GC（并行回收）"><span class="nav-number">1.7.4.2.2.</span> <span class="nav-text">ParNew GC（并行回收）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Parallel-Scavenge回收器（吞吐量优先、并行）"><span class="nav-number">1.7.4.2.3.</span> <span class="nav-text">Parallel Scavenge回收器（吞吐量优先、并行）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CMS-GC（低延迟）"><span class="nav-number">1.7.4.2.4.</span> <span class="nav-text">CMS GC（低延迟）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#G1-GC（区域化分代式）"><span class="nav-number">1.7.4.2.5.</span> <span class="nav-text">G1 GC（区域化分代式）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结-3"><span class="nav-number">1.7.4.3.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Bcutty Kmy</p>
  <div class="site-description" itemprop="description">NO DEPENDENCE ONLY PRIDE</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bcutty Kmy</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              leancloudSelector(url).innerText = 'Counter not initialized! More info at console err msg.';
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"2z9X7Dx6RjzhCEydcpBXNAF5-gzGzoHsz","app_key":"d4qtySNKtCjyy1f975pQrdgB","server_url":null,"security":true};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : '2z9X7Dx6RjzhCEydcpBXNAF5-gzGzoHsz',
      appKey     : 'd4qtySNKtCjyy1f975pQrdgB',
      placeholder: "Please leave your comments here.",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
