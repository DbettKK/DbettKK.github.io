<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="学习," />










<meta name="description" content="Java面经整理数据结构几种常见的数据结构  树、图、链表、优先队列(堆)、跳表(链表+多级索引) 跳表(redis的zset使用跳表)： 1234567&amp;gt;跳表的查询的时间复杂度为 O(logn)，因为找到位置之后插入和删除的时间复杂度很低，为 O(1)，所以最终插入和删除的时间复杂度也为 O(logn)&amp;gt;删除操作:* 如果这个结点在索引中也有出现，我们除了要删除原始链表中的结点，还要">
<meta name="keywords" content="学习">
<meta property="og:type" content="article">
<meta property="og:title" content="Java面经整理">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;03&#x2F;31&#x2F;%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86&#x2F;index.html">
<meta property="og:site_name" content="BBBBBlog">
<meta property="og:description" content="Java面经整理数据结构几种常见的数据结构  树、图、链表、优先队列(堆)、跳表(链表+多级索引) 跳表(redis的zset使用跳表)： 1234567&amp;gt;跳表的查询的时间复杂度为 O(logn)，因为找到位置之后插入和删除的时间复杂度很低，为 O(1)，所以最终插入和删除的时间复杂度也为 O(logn)&amp;gt;删除操作:* 如果这个结点在索引中也有出现，我们除了要删除原始链表中的结点，还要">
<meta property="og:locale" content="en">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2021&#x2F;03&#x2F;10&#x2F;O3Kf8HcTyFd69kz.png">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2021&#x2F;03&#x2F;12&#x2F;T5aPvYtkK9zIefD.png">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2021&#x2F;03&#x2F;10&#x2F;qU1w9tpoERWl45b.png">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2021&#x2F;03&#x2F;22&#x2F;CAafT92nKwky5jU.png">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2021&#x2F;03&#x2F;22&#x2F;ycSbiXY1DC9edHO.png">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2021&#x2F;03&#x2F;22&#x2F;gAHwEQy36MCmIZ8.png">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2021&#x2F;03&#x2F;22&#x2F;MIchbjWmDHw1S5E.png">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2021&#x2F;03&#x2F;22&#x2F;dZbBafAUTePKVno.png">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2021&#x2F;03&#x2F;22&#x2F;Q5VpZYUBADC2IfG.png">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2021&#x2F;03&#x2F;22&#x2F;p53zlmPV8FIBZHE.png">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2021&#x2F;03&#x2F;12&#x2F;1cXe8UoavICM5Ws.png">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2021&#x2F;02&#x2F;05&#x2F;6zs9MQZ4KPrLpFc.png">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2021&#x2F;03&#x2F;14&#x2F;xqXi9wM2LfDs3ok.png">
<meta property="og:updated_time" content="2021-03-31T12:10:22.366Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2021&#x2F;03&#x2F;10&#x2F;O3Kf8HcTyFd69kz.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/03/31/面试题整理/"/>





  <title>Java面经整理 | BBBBBlog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">BBBBBlog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" target="_blank" rel="noopener" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/31/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bcutty Kmy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BBBBBlog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java面经整理</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-03-31T20:09:50+08:00">
                2021-03-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/03/31/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2021/03/31/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2021/03/31/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/" class="leancloud_visitors" data-flag-title="Java面经整理">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  39.7k words
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  144 minutues
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Java面经整理"><a href="#Java面经整理" class="headerlink" title="Java面经整理"></a>Java面经整理</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>几种常见的数据结构</p>
<blockquote>
<p>树、图、链表、优先队列(堆)、跳表(链表+多级索引)</p>
<p>跳表(redis的zset使用跳表)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;跳表的查询的时间复杂度为 O(logn)，因为找到位置之后插入和删除的时间复杂度很低，为 O(1)，所以最终插入和删除的时间复杂度也为 O(logn)</span><br><span class="line">&gt;删除操作:</span><br><span class="line">* 如果这个结点在索引中也有出现，我们除了要删除原始链表中的结点，还要删除索引中的。</span><br><span class="line">* 同时我们删除节点时需要获得前驱节点(双向链表除外)</span><br><span class="line">&gt;插入操作</span><br><span class="line">* 插入元素过多，可能导致两个索引间节点过多，效率降低。我们需要维护索引与原始链表的大小平衡。。</span><br><span class="line">* 跳表是通过一个随机函数来维护这个平衡的，当我们向跳表中插入数据时，我们可以选择同时把这个数据插入到索引里，那我们插入到哪一级的索引呢，这就需要随机函数，来决定我们插入到哪一级的索引中。这样可以很有效的防止跳表退化，而造成效率变低。</span><br></pre></td></tr></table></figure>

<p>优先队列实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 清楚大顶堆、小顶堆定义</span></span><br><span class="line">&gt;<span class="comment">// Java PriorityQueue 通过数组实现</span></span><br><span class="line">&gt;<span class="comment">// 插入元素 从末尾开始找</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123; <span class="comment">// k代表当前元素个数、x为需要插入的元素</span></span><br><span class="line">  Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;) x;</span><br><span class="line">  <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 找到父节点下标</span></span><br><span class="line">      <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">      Object e = queue[parent];</span><br><span class="line">      <span class="comment">// 如果是小顶堆 则判断 x &gt;= queue[parent] 如果符合说明找到了需要插入的位置 break</span></span><br><span class="line">      <span class="comment">// 进行插入该节点，并将该parent节点放入index为k的位置</span></span><br><span class="line">      <span class="keyword">if</span> (key.compareTo((E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// 否则 将该节点下降 并令k为parent继续循环</span></span><br><span class="line">      queue[k] = e;</span><br><span class="line">      k = parent;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 插入到找到的位置</span></span><br><span class="line">  queue[k] = key;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// poll方法 移除最小元素</span></span><br><span class="line">&gt;<span class="comment">// 传入index为size的元素 此时根节点为空 k从0开始</span></span><br><span class="line">&gt;<span class="comment">// 即index为k的元素被取走后，拿出数组最后的元素x 不断寻找位置进行插入 如果不满足 会将空节点的子节点放入空节点 然后对其子节点进行继续操作直到找到能插入的位置或者循环结束</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123; <span class="comment">// x为堆中最后的元素</span></span><br><span class="line">  Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;)x;</span><br><span class="line">  <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;        <span class="comment">// loop while a non-leaf</span></span><br><span class="line">  <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">      <span class="comment">// x 从根节点开始 每次和 index为2k+1和2k+2中更小的元素进行比较</span></span><br><span class="line">      <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// assume left child is least</span></span><br><span class="line">      Object c = queue[child];</span><br><span class="line">      <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">          ((Comparable&lt;? <span class="keyword">super</span> E&gt;) c).compareTo((E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">          <span class="comment">// 小顶堆：c为2k+1和2k+2中较小的一个 也就是k对应节点的左右节点中小的那个</span></span><br><span class="line">          c = queue[child = right];</span><br><span class="line">      <span class="comment">// 小顶堆：如果x比较c大，我们就和c交换位置 否则我们的数就应该在k位置上，k从0开始。</span></span><br><span class="line">      <span class="keyword">if</span> (key.compareTo((E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// 交换位置</span></span><br><span class="line">      queue[k] = c;</span><br><span class="line">      k = child;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 找到了位置</span></span><br><span class="line">  queue[k] = key;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// remove方法 移除指定元素</span></span><br><span class="line">&gt;<span class="function">E <span class="title">removeAt</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="comment">// i为指定元素的index 是通过循环遍历得到的</span></span><br><span class="line">  <span class="comment">// assert i &gt;= 0 &amp;&amp; i &lt; size;</span></span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="keyword">int</span> s = --size; <span class="comment">// s为最后一个元素的下标</span></span><br><span class="line">  <span class="keyword">if</span> (s == i) <span class="comment">// removed last element</span></span><br><span class="line">      queue[i] = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 将s对应的节点也就是最后一个节点拿到 需要进行树的修复</span></span><br><span class="line">      E moved = (E) queue[s];</span><br><span class="line">      <span class="comment">// 将其置为null</span></span><br><span class="line">      queue[s] = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// 以queue[i]为根节点的树(堆) 进行树的修复</span></span><br><span class="line">      <span class="comment">// 小顶堆：将moved元素作为上文的x元素 和上文的poll方法类似 </span></span><br><span class="line">      <span class="comment">// 只是此处不是k=0开始，而是k=i开始 因为移除的是index=i的元素</span></span><br><span class="line">      siftDown(i, moved);</span><br><span class="line">      <span class="comment">// 此时以queue[i]为根节点的树(堆)已经修复完成了</span></span><br><span class="line">      <span class="keyword">if</span> (queue[i] == moved) &#123;</span><br><span class="line">          <span class="comment">// 如果moved在i位置上 说明moved元素较小 还可以继续向上调整</span></span><br><span class="line">          siftUp(i, moved); <span class="comment">// 向上调整 ？？？？</span></span><br><span class="line">          <span class="keyword">if</span> (queue[i] != moved)</span><br><span class="line">              <span class="keyword">return</span> moved;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

</blockquote>
<p>判断链表是否存在环</p>
<blockquote>
<p>快慢指针判断是否重合（如果需要找到入环点，在第一次相遇后一指针指向头部，然都保持慢指针速度继续前进，再次相遇的地方即为入环点）</p>
</blockquote>
<p>二叉搜索树、平衡二叉树、红黑树</p>
<blockquote>
<p>搜索二叉树：左节点 &lt; 根节点 &lt; 右节点，且左子树所有节点 &lt; 根节点 &lt; 右子树所有节点</p>
<p>平衡二叉树：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。对于插入节点和删除节点，如果破坏了平衡，那么都需要进行旋转以重新平衡。AVL树的查找、插入、删除操作在平均和最坏的情况下都是O（logn），代码可参考下方：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 只会存在4种旋转方式：左旋、右旋、先左再右、先右再左。</span></span><br><span class="line">&gt;<span class="comment">// 递归进行判断即可</span></span><br><span class="line">&gt;<span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">&gt;<span class="keyword">int</span> val;</span><br><span class="line">&gt;Node left, right;</span><br><span class="line"><span class="comment">// 构造方法...</span></span><br><span class="line">&gt;<span class="comment">/* 左旋，右旋省略 */</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Node newNode = <span class="keyword">new</span> Node(<span class="keyword">this</span>.val);</span><br><span class="line">  newNode.left = <span class="keyword">this</span>.left;</span><br><span class="line">  newNode.right = <span class="keyword">this</span>.right.left;</span><br><span class="line">  <span class="keyword">this</span>.val = <span class="keyword">this</span>.right.val;</span><br><span class="line">  <span class="keyword">this</span>.left = newNode;</span><br><span class="line">  <span class="keyword">this</span>.right = <span class="keyword">this</span>.right.right;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">/* 添加节点 */</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 首先进行节点添加</span></span><br><span class="line">  <span class="keyword">if</span> (node.val &lt; <span class="keyword">this</span>.lval) &#123;</span><br><span class="line">  	<span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) <span class="keyword">this</span>.left = node;</span><br><span class="line">  	<span class="keyword">else</span> <span class="keyword">this</span>.left.add(node);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.val &gt; <span class="keyword">this</span>.lval) &#123;</span><br><span class="line">  	<span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) <span class="keyword">this</span>.right = node;</span><br><span class="line">  	<span class="keyword">else</span> <span class="keyword">this</span>.right.add(node);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// 判断是否需要旋转</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.getLeftHeight() - <span class="keyword">this</span>.getRightHeight() &gt; <span class="number">1</span>) &#123; <span class="comment">// 获得子树高度的get方法 略</span></span><br><span class="line">      <span class="comment">// 需要右旋 但需要先判断左子树是否需要先左旋</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.getLeftHeight() &lt; <span class="keyword">this</span>.left.getRightHeight()) &#123;</span><br><span class="line">          <span class="keyword">this</span>.left.leftRotate();</span><br><span class="line">      &#125;</span><br><span class="line">    	<span class="keyword">this</span>.rightRotate();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 左旋同理...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 删除节点</span></span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">  	1、查找到对应节点</span></span><br><span class="line"><span class="comment">  	2、判断该节点是否为叶节点，如果为叶节点，则直接删除</span></span><br><span class="line"><span class="comment">  		如果不是叶节点，则判断该节点是否存在左右子树</span></span><br><span class="line"><span class="comment">  			如果只有左子树 则获得左子树的最大值leftMax 并将需要删除的节点的值置为leftMax 然后递归删除左子树中的该节点</span></span><br><span class="line"><span class="comment">  			如果只有右子树 则获得右子树的最小值rigthMin 并将需要删除的节点的值置为rigthMin 然后递归删除右子树中的该节点</span></span><br><span class="line"><span class="comment">  			如果左右子树均存在，也一样获得右子树的最小值rigthMin 并将需要删除的节点的值置为rigthMin 然后递归删除右子树中的该节点</span></span><br><span class="line"><span class="comment">  	3、删除完成后 判断是否平衡 即和上面add方法的后半部分类似 然后进行旋转平衡接即可</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>==红黑树==：</p>
<ol>
<li><strong>任何一个节点都有颜色，黑色或者红色</strong></li>
<li><strong>根节点是黑色的</strong></li>
<li><strong>空节点被认为是黑色的</strong>(即NIL结点)</li>
<li><strong>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</strong></li>
<li><strong>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</strong>(这也叫做完美黑色平衡，与2-3树的完美平衡有些不同)</li>
</ol>
<p><strong>只有黑色节点的红黑树其实就是平衡二叉树</strong>。我们将<strong>红色点想成是填充节点</strong>。即每次插入都以红色插入，且将<strong>黑色想成主要节点</strong>。红色节点做填充。红色节点的作用就是使得树的高度更加灵活，不至于像平衡二叉树那样每次插入都需要 做平衡操作（减少了需要平衡的概率）。<strong>（红色节点的子节点是黑色节点）</strong>条件就使得高度受到限制，极限情况就是一个红色一个黑色串联。最多的查找次数 不会超过2倍的 最少的查找数。</p>
<p>红黑树其实就是 二叉查找树和平衡二叉树 两者优缺点的一种折中。可以防止出现二叉查找树那种极差的情况，也可以减少插入时平衡的次数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 旋转操作和平衡树保持一致</span></span><br><span class="line">&gt;<span class="comment">/* </span></span><br><span class="line"><span class="comment">&gt;插入操作有三种情况是不会破坏性质的 且插入的节点一定是红色</span></span><br><span class="line"><span class="comment">  1、插入节点作为根节点</span></span><br><span class="line"><span class="comment">  2、插入节点作为根节点的子节点</span></span><br><span class="line"><span class="comment">  3、插入节点的父结点是黑色的</span></span><br><span class="line"><span class="comment">&gt;如果会破坏性质 则说明不满足以上情况 也就是说明 新节点必定存在祖父节点、新节点父节点为红色</span></span><br><span class="line"><span class="comment">1、叔节点为红色——重绘，父节点和叔节点绘制为黑色，祖父节点绘制为红色</span></span><br><span class="line"><span class="comment">2、叔节点为黑色，祖-父-子节点在同侧——将父绘黑，祖绘红，然后以祖为枢纽进行向相反侧的方向旋转</span></span><br><span class="line"><span class="comment">3、叔节点为黑色，祖-父-子节点不在同侧——先根据子父所在的那一侧的方向，以父为枢向相反方向旋转，这样就实现了将子父祖异侧转换为了父子祖同侧，第二步是发现它符合上一种情况了，那就将现在的父(原来的子)绘黑，祖(原来的祖)绘红，然后再次旋转。</span></span><br><span class="line"><span class="comment">&gt;注意：需要修复时，还需要递归进行，即在一次修复后将指针指向此次操作的祖父节点 然后继续判断是否需要修复	</span></span><br><span class="line"><span class="comment">&gt;最后仍然需要将根节点绘制为红色。</span></span><br><span class="line"><span class="comment">&gt;*/</span></span><br></pre></td></tr></table></figure>

<img src="https://i.loli.net/2021/03/10/O3Kf8HcTyFd69kz.png" alt="红黑树remove.png" style="zoom: 33%;">
</blockquote>
<p>线段树、树状数组</p>
<blockquote>
<p>树状数组是一种特殊的线段树</p>
</blockquote>
<p>B树、B+树</p>
<blockquote>
<p>每个节点不止一个数据</p>
<p>B树：每个节点上都存了key-data</p>
<p>B+树：只有叶子节点存了data，其他节点可存更多key，且所有叶子节点之间存在顺序指针关系。</p>
</blockquote>
<h2 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h2><p>开机过程</p>
<blockquote>
<p>BIOS自检-&gt;加载bootloader到内存-&gt;bootloader加载OS到内存-&gt;从OS起始位置开始执行指令</p>
<p>BIOS位于RAM；bootstrap位于磁盘第一个主引导扇区；OS位于磁盘</p>
<p>以x86为例，bootloader一般会被加载到于内存0x7c00处</p>
</blockquote>
<p>内存管理</p>
<blockquote>
<p>段页式存储、虚拟内存、系统抖动。</p>
</blockquote>
<p>进程和线程区别，什么是协程</p>
<blockquote>
<p>进程是资源分配的基本单位。线程是CPU调度的基本单位。一个进程中可包含多个线程。</p>
<p>协程是轻量级的用户线程，一个线程可包含多个协程，只在用户态运行，开销小。</p>
</blockquote>
<p>进程调度的方式(CFS?)</p>
<blockquote>
<p><em>Linux*的调度器类主要实现两类进程调度算法：实时调度算法和完全公平调度算法</em>(CFS)*，实时调度算法SCHED_FIFO和SCHED_RR，按优先级执行，一般不会被抢占。直到实时进程执行完，才会执行普通进程。而大多数的普通进程，用的就是CFS算法。</p>
<p>CFS 调度程序并不采用严格规则来为一个优先级分配某个长度的时间片，而是为每个任务分配一定比例的 CPU 处理时间。每个任务分配的具体比例是根据友好值来计算的。友好值的范围从 -20 到 +19，数值较低的友好值表示较高的相对优先级。具有较低友好值的任务，与具有较高友好值的任务相比，会得到更高比例的处理器处理时间。默认友好值为 0。</p>
<blockquote>
<p>友好一词源自如下想法：当一个任务增加了它的友好值，如从 0 至 +10，该任务通过降低优先级，进而对其他任务更加友好。</p>
</blockquote>
<p>CFS 没有使用离散的时间片，而是采用目标延迟，这是每个可运行任务应当运行一次的时间间隔。根据目标延迟，按比例分配 CPU 时间。除了默认值和最小值外，随着系统内的活动任务数量超过了一定阈值，目标延迟可以增加。</p>
<p>CFS 调度程序没有直接分配优先级。相反，它通过每个任务的变量 vruntime 以便维护虚拟运行时间，进而记录每个任务运行多久。虚拟运行时间与基于任务优先级的衰减因子有关，更低优先级的任务比更高优先级的任务具有更高衰减速率。对于正常优先级的任务（友好值为 0），虚拟运行时间与实际物理运行时间是相同的。</p>
<p>因此，如果一个默认优先级的任务运行 200ms，则它的虚拟运行时间也为 200ms。然而，如果一个较低优先级的任务运行 200ms，则它的虚拟运行时间将大于 200ms。同样，如果一个更高优先级的任务运行 200ms，则它的虚拟运行时间将小于 200ms。当决定下步运行哪个任务时，调度程序只需选择具有最小虚拟运行时间的任务。此外，一个更高优先级的任务如成为可运行，就会抢占低优先级任务。</p>
<p>下面分析一下 CFS 调度程序是如何工作的。假设有两个任务，它们具有相同的友好值。一个任务是 I/O 密集型而另一个为 CPU 密集型。通常，I/O 密集型任务在运行很短时间后就会阻塞以便等待更多的 I/O；而 CPU 密集型任务只要有在处理器上运行的机会，就会用完它的时间片。</p>
<p>因此，I/O 密集型任务的虚拟运行时间最终将会小于 CPU 密集型任务的，从而使得 I/O 密集型任务具有更高的优先级。这时，如果 CPU 密集型任务在运行，而 I/O 密集型任务变得有资格可以运行（如该任务所等待的 I/O 已成为可用)，那么 I/O 密集型任务就会抢占 CPU 密集型任务。</p>
</blockquote>
<p>死锁</p>
<blockquote>
<p>两个线程互相持有对方所需要的资源，互相等待，谁也无法继续执行下去。</p>
<p>条件：互斥、持有并等待、不可抢占、循环等待</p>
<p>处理方法：死锁预防(破坏四个条件中的一个)、死锁避免(银行家)、死锁检测与消除</p>
</blockquote>
<p>进程、线程、协程的区别（详细）</p>
<blockquote>
<p>进程、线程，都是有内核进行调度，有 CPU 时间片的概念，进行 抢占式调度。</p>
<p>协程(用户级线程)完全由用户自己的程序进行调度（协作式调度），需要协程自己主动把控制权转让出去之后，其他协程才能被执行到。</p>
<p>协程，是在应用层模拟的线程，他避免了上下文切换的额外耗费，兼顾了多线程的优点。简化了高并发程序的复杂度。协程还是通过共享内存通讯.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;目前的协程框架一般都是设计成 1:N 模式。</span><br><span class="line">&gt;所谓 1:N 就是一个线程作为一个容器里面放置多个协程。</span><br><span class="line">&gt;那么谁来适时的切换这些协程？答案是有协程自己主动让出CPU，</span><br><span class="line">&gt;也就是每个协程池里面有一个调度器，这个调度器是被动调度的。</span><br><span class="line">&gt;意思就是他不会主动调度。</span><br><span class="line">&gt;而且当一个协程发现自己执行不下去了(比如异步等待网络的数据回来，但是当前还没有数据到)，</span><br><span class="line">&gt;这个时候就可以由这个协程通知调度器，</span><br><span class="line">&gt;这个时候执行到调度器的代码，调度器根据事先设计好的调度算法找到当前最需要CPU的协程。</span><br><span class="line">&gt;切换这个协程的CPU上下文把CPU的运行权交个这个协程，直到这个协程出现执行不下去需要等等的情况，</span><br><span class="line">&gt;或者它调用主动让出CPU的API之类，触发下一次调度。对的没错就是类似于 领导人模式那么这个实现有没有问题？</span><br><span class="line">&gt;其实是有问题的，假设这个线程中有一个协程是CPU密集型的他没有IO操作，也就是自己不会主动触发调度器调度的过程，</span><br><span class="line">&gt;那么就会出现其他协程得不到执行的情况，所以这种情况下需要程序员自己避免。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>深拷贝、浅拷贝（java）</p>
<blockquote>
<p>浅拷贝：只是增加了一个指针指向原内存。</p>
<p>深拷贝：深拷贝是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存。</p>
</blockquote>
<p>写时复制</p>
<blockquote>
<p>系统调用 fork() 创建了父进程的一个复制，以作为子进程。传统上，fork() 为子进程创建一个父进程地址空间的副本，复制属于父进程的页面。然而，考虑到许多子进程在创建之后立即调用系统调用 exec()，父进程地址空间的复制可能没有必要。</p>
<p>因此，可以采用一种称为写时复制的技术，它通过允许父进程和子进程最初共享相同的页面来工作。这些共享页面标记为写时复制，这意味着如果任何一个进程写入共享页面，那么就创建共享页面的副本。</p>
<p>当使用写时复制技术时，仅复制任何一进程修改的页面，所有未修改的页面可以由父进程和子进程共享。</p>
<p>注意：采用 vfork()，父进程被挂起，子进程使用父进程的地址空间。因为 vfork() 不采用写时复制，如果子进程修改父地址空间的任何页面，那么这些修改过的页面对于恢复的父进程是可见的。因此，应谨慎使用 vfork()，以确保子进程不会修改父进程的地址空间。</p>
</blockquote>
<p>mmap内存映射</p>
<blockquote>
<p>内存映射，简而言之就是将用户空间的一段内存区域映射到内核空间，映射成功后，用户对这段内存区域的修改可以直接反映到内核空间，同样，内核空间对这段区域的修改也直接反映用户空间。那么对于内核空间&lt;—-&gt;用户空间两者之间需要大量数据传输等操作的话效率是非常高的。</p>
</blockquote>
<p>缓冲区溢出</p>
<blockquote>
<p>例如栈溢出导致返回值或者方法返回地址被修改，进而导致被攻击。</p>
</blockquote>
<p>为何需要用户态、内核态</p>
<blockquote>
<p>应用程序不能直接访问外设，需要内核在其中充当被信任的第三方，只有内核才能执行特权指令。同时也是方便应用程 序通过内核提供的接口来更方便编写操作外设的程序。即不用关注和外设具体打交道的细节，其应该由操作系统来完成。</p>
</blockquote>
<p>read ahead文件预读</p>
<blockquote>
<p>所谓预读，是指文件系统为应用程序一次读出比预期更多的文件内容并缓存在page cache中，这样下一次读请求到来时部分页面直接从page cache读取即可。当然，这个细节对应用程序透明，应用程序可能的感觉就是下次读的速度会更快</p>
</blockquote>
<p>x86是大端还是小端，为什么</p>
<blockquote>
<p>小端</p>
</blockquote>
<p>select、poll、epoll</p>
<blockquote>
<p>select：bitmap、遍历bitmap获取数据、bitmap不可重用</p>
<p>poll：结构体数组(三个字段存在状态位)、遍历判断状态位获取数据、结构体数组可重用</p>
<p>epoll：类似poll结构体(两个字段 不存在状态位)、由内核对其进行排序并返回数量，直接遍历数量即可获得socket</p>
</blockquote>
<p>管道底层实现</p>
<blockquote>
<p>无名管道：内存中实现(内核中的缓存)，如<kbd>|</kbd>，有名管道：磁盘实现，如<kbd>mkfifo</kbd>。只有父子进程之间可以通过匿名管道。</p>
<p>管道采用半双工通信，使用一个管道一般的规则是<strong>读管道数据的进程关闭管道写入端,而写管道进程关<br>闭其读出端</strong>。</p>
<p>管道传输的数据是无格式的且大小受限。</p>
<p>父子进程之间的匿名管道，因为子进程复制父进程创建的文件描述符，所以各自拥有两个fd[0]、fd[1]，这样就实现了进程间通信。</p>
</blockquote>
<p>系统调用的具体过程，如何实现</p>
<blockquote>
<p>应用程序主动向操作系统发起服务请求，应用程序请求操作系统提供服务，切换到内核态，内核态响应服务然后完成后返回。</p>
</blockquote>
<p>select、poll、epoll机制</p>
<blockquote>
<p>select采用轮询机制，耗时较大，且监听的socket有限(可以改变)</p>
<p>select和poll只支持LT工作模式，epoll的默认的工作模式是LT模式，还支持ET（边缘触发）模式。</p>
<p>水平触发：①对于读操作，只要缓冲内容不为空，LT模式返回读就绪。②对于写操作，只要缓冲区还不满，LT模式会返回写就绪。</p>
<p>边缘触发：在ET模式下， 缓冲区从不可读变成可读，会唤醒应用进程，缓冲区数据变少的情况，则不会再唤醒应用进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">举例1：</span><br><span class="line">读缓冲区刚开始是空的</span><br><span class="line">读缓冲区写入2KB数据</span><br><span class="line">水平触发和边缘触发模式此时都会发出可读信号</span><br><span class="line">收到信号通知后，读取了1KB的数据，读缓冲区还剩余1KB数据</span><br><span class="line">水平触发会再次进行通知，而边缘触发不会再进行通知</span><br><span class="line">举例2：（以脉冲的高低电平为例）</span><br><span class="line">水平触发：0为无数据，1为有数据。缓冲区有数据则一直为1，则一直触发。</span><br><span class="line">边缘触发发：0为无数据，1为有数据，只要在0变到1的上升沿才触发。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>epoll红黑树</p>
<blockquote>
<p>epoll和poll的一个很大的区别在于，poll每次调用时都会存在一个将pollfd结构体数组中的每个结构体元素从用户态向内核态中的一个链表节点拷贝的过程，而内核中的这个链表并不会一直保存，当poll运行一次就会重新执行一次上述的拷贝过程，这说明一个问题：poll并不会在内核中为要监听的文件描述符长久的维护一个数据结构来存放他们，而epoll内核中维护了一个内核事件表，它是将所有的文件描述符全部都存放在内核中，系统去检测有事件发生的时候触发回调，当你要添加新的文件描述符的时候也是调用epoll_ctl函数使用EPOLL_CTL_ADD宏来插入，epoll_wait也不是每次调用时都会重新拷贝一遍所有的文件描述符到内核态。当我现在要在内核中长久的维护一个数据结构来存放文件描述符，并且时常会有插入，查找和删除的操作发生，这对内核的效率会产生不小的影响，因此需要一种插入，查找和删除效率都不错的数据结构来存放这些文件描述符，那么红黑树当然是不二的人选。</p>
</blockquote>
<p>epoll与select、poll的对比</p>
<blockquote>
<p><strong>1. 用户态将文件描述符传入内核的方式</strong></p>
<p>select：创建3个文件描述符集并拷贝到内核中，分别监听读、写、异常动作。这里受到单个进程可以打开的fd数量限制，默认是1024。poll：将传入的struct pollfd结构体数组拷贝到内核中进行监听。epoll：执行epoll_create会在内核的高速cache区中建立一颗红黑树以及就绪链表(该链表存储已经就绪的文件描述符)。接着用户执行的epoll_ctl函数添加文件描述符会在红黑树上增加相应的结点。</p>
<p><strong>2. 内核态检测文件描述符读写状态的方式</strong></p>
<p>select：采用轮询方式，遍历所有fd，最后返回一个描述符读写操作是否就绪的mask掩码，根据这个掩码给fd_set赋值。poll：同样采用轮询方式，查询每个fd的状态，如果就绪则在等待队列中加入一项并继续遍历。epoll：采用回调机制。在执行epoll_ctl的add操作时，不仅将文件描述符放到红黑树上，而且也注册了回调函数，内核在检测到某文件描述符可读/可写时会调用回调函数，该回调函数将文件描述符放在就绪链表中。</p>
<p><strong>3. 找到就绪的文件描述符并传递给用户态的方式</strong></p>
<p>select：将之前传入的fd_set拷贝传出到用户态并返回就绪的文件描述符总数。用户态并不知道是哪些文件描述符处于就绪态，需要遍历来判断。poll：将之前传入的fd数组拷贝传出用户态并返回就绪的文件描述符总数。用户态并不知道是哪些文件描述符处于就绪态，需要遍历来判断。epoll：epoll_wait只用观察就绪链表中有无数据即可，最后将链表的数据返回给数组并返回就绪的数量。内核将就绪的文件描述符放在传入的数组中，所以只用遍历依次处理即可。这里返回的文件描述符是通过mmap让内核和用户空间共享同一块内存实现传递的，减少了不必要的拷贝。</p>
<p><strong>4. 重复监听的处理方式</strong></p>
<p>select：将新的监听文件描述符集合拷贝传入内核中，继续以上步骤。poll：将新的struct pollfd结构体数组拷贝传入内核中，继续以上步骤。epoll：无需重新构建红黑树，直接沿用已存在的即可。</p>
<p><strong>epoll更高效的原因</strong></p>
<p>select和poll的动作基本一致，只是poll采用链表来进行文件描述符的存储，而select采用fd标注位来存放，所以select会受到最大连接数的限制，而poll不会。select、poll、epoll虽然都会返回就绪的文件描述符数量。但是select和poll并不会明确指出是哪些文件描述符就绪，而epoll会。造成的区别就是，系统调用返回后，调用select和poll的程序需要遍历监听的整个文件描述符找到是谁处于就绪，而epoll则直接处理即可。select、poll都需要将有关文件描述符的数据结构拷贝进内核，最后再拷贝出来。而epoll创建的有关文件描述符的数据结构本身就存于内核态中，系统调用返回时利用mmap()文件映射内存加速与内核空间的消息传递：即epoll使用mmap减少复制开销。select、poll采用轮询的方式来检查文件描述符是否处于就绪态，而epoll采用回调机制。造成的结果就是，随着fd的增加，select和poll的效率会线性降低，而epoll不会受到太大影响，除非活跃的socket很多。epoll的边缘触发模式效率高，系统不会充斥大量不关心的就绪文件描述符虽然epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</p>
</blockquote>
<h2 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h2><p>TCP</p>
<blockquote>
<p>特点：可靠、面向连接、点对点通信、全双工通信、拥塞控制、流量控制。（ARQ）</p>
<p>close_wait：防止被动关闭方仍然存在数据没有发送完。</p>
<p>time_wait为何等待两个MSL：①保证自己发送的ACK能够到达被动方，2MSL保证能够超时重传；②保证本次连接中产生的所有报文都已经在网络中消失，不会影响下一个连接。</p>
<p>time_wait太多：调整内核参数。即：①重用处于time_wait的socket；②快速回收处于time_wait的socket；③降低socket处于time_wait的时间④降低系统默认设置的time_wait的socket最大数量；⑤扩大可用于socket的端口范围</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_syncookies = 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭； --用于防御半连接攻击</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME_WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；</span><br><span class="line">net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME_WAIT sockets的快速回收，默认为0，表示关闭。</span><br><span class="line">net.ipv4.tcp_fin_timeout 修改系统默认的 TIMEOUT 时间</span><br></pre></td></tr></table></figure>

<p>流量控制：发送窗口不能大于接收窗口。</p>
<p>拥塞控制：慢开始(小于门限，指数增长)、拥塞避免(大于门限、线性增长)、快重传(收到三个重复确认时，直接重传丢失报文而非等待超时)、快恢复(门限值减半，拥塞窗口减半，直接开始拥塞避免)。对于超时的情况，门限减半，拥塞窗口直接从0开始执行慢开始算法。</p>
</blockquote>
<p>拥塞控制为何是3个ACK才快重传</p>
<blockquote>
<p>TCP segment乱序有2/5= 40%的概率会造成A收到三次duplicated ACK(N)；而如果N丢了，则会100%概率A会收到三次duplicated ACK(N);</p>
</blockquote>
<p>UDP</p>
<blockquote>
<p>不可靠、无连接、RIP协议使用、实现可靠传输需要上层应用层帮助(RUDPS、RTP、UDT模仿TCP)。不对数据包做任何操作，直接将其发送，也不考虑接收方。</p>
</blockquote>
<p>丢包问题一般发生在哪一层</p>
<blockquote>
</blockquote>
<p>ICMP协议作用</p>
<blockquote>
<p>类型：目标不可到达、源抑制和超时报文</p>
<p>是ip报文的组成部分。</p>
</blockquote>
<p>电脑联网失败，发生在哪一层</p>
<blockquote>
</blockquote>
<p>TCP和UDP的报头长度</p>
<blockquote>
<p>udp8字节，tcp20字节</p>
</blockquote>
<p>SCTP了解过吗, 介绍一下</p>
<blockquote>
<p>流控制传输协议（SCTP，Stream Control Transmission Protocol）是一种在网络连接两端之间同时传输多个数据流的协议。</p>
<p>SCTP是面向消息的（message-oriented）。它提供各个记录的按序递送服务。与UDP一样，由发送端写入的每一条记录的长度随数据一道传递给接收端应用。</p>
<p>SCTP能给在所连接的端点之间提供多个流，每个流各自可靠地按序递送消息。一个流上某个消息的丢失不会阻塞同一关联其他流上消息的投递。这种做法与TCP正好相反，就TCP而言，在单一字节流中任何位置的字节丢失都将在阻塞该连接上其后所有数据的递送，直到该丢失被修复为止。</p>
</blockquote>
<p>TELNET</p>
<blockquote>
<p>Telnet协议是TCP/IP协议家族中的一员，是Internet远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用telnet程序，用它连接到服务器。终端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制服务器。要开始一个telnet会话，必须输入用户名和密码来登录服务器。Telnet是常用的远程控制Web服务器的方法。</p>
<p>需要连接的机器开启telnet服务。</p>
</blockquote>
<p>半连接攻击（SYN_FLOOD）</p>
<blockquote>
<p>半连接就是通过不断地构造客户端的SYN连接数据包发向服务端，等到服务端的半连接队列满的时候，后续的正常用户的连接请求将会被丢弃，从而无法连接到服务端。此为半连接攻击方式。</p>
<p>可通过开启SYN Cookies来解决，即通过发送方的信息(端口、ip)和接收方的信息计算出一个cookie，并将其作为序列号进行回复，然后cookie对应一个时间范围，在时间范围内的ack都是合法的，不进入半连接队列，直接完成三次握手。</p>
</blockquote>
<p>全连接攻击</p>
<blockquote>
<p>全连接攻击：是通过消费服务端进程数和连接数，只连接而不进行发送数据的一种攻击方式。当客户端连接到服务端，仅仅只是连接，此时服务端会为每一个连接创建一个进程来处理客户端发送的数据。但是客户端只是连接而不发送数据，此时服务端会一直阻塞在recv或者read的状态，如此一来，多个连接，服务端的每个连接都是出于阻塞状态从而导致服务端的崩溃。</p>
<p>可通过设置超时时间来解决。</p>
</blockquote>
<p>为何需要三次握手而不是两次？四次挥手而不是三次？</p>
<blockquote>
<p>个人理解：三次握手分别保证客户端发送数据的能力、服务端发送数据和接收数据的能力以及客户端接收数据的能力。如果没有第三次握手，就无法保证客户端有接收数据的能力。同时三次握手保证了序列号的一致性以及双方连接建立的完整性(两次握手可能存在服务端的ack延迟到达客户端，此时客户端已经放弃连接了而服务端却以为建立好了连接)。而四次挥手则是因为被动关闭方可能还存在数据未发送完全，需要等待被动方发送完数据并主动发出FIN才能保证数据发送完毕。</p>
</blockquote>
<p>http：</p>
<blockquote>
<p>状态码：1xx信息、2xx成功、3xx重定向、4xx客户端错误、5xx服务端错误</p>
<p>100——继续、200——成功、301永久重定向、302临时重定向、400 Bad Request、404找不到页面、401未授权、403拒绝请求、500服务器内部错误。</p>
<p>301 302区别：301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），<strong>搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址</strong>；302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，<strong>搜索引擎会抓取新的内容而保存旧的网址。</strong></p>
<p>400——1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。2、请求参数有误。</p>
<p>403——服务器理解了请求但是拒绝执行</p>
</blockquote>
<p>http头部</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">通用头部：</span><br><span class="line">cache-control：请求和响应遵循的缓存机制</span><br><span class="line">pragma：Pragma头域用来包含实现特定的指令，最常用的是Pragma:no-cache</span><br><span class="line">connection：是否保持长连接 keep-alive等等</span><br><span class="line">date：时间</span><br><span class="line">请求头：</span><br><span class="line">accept：接收什么类型 text/html等等</span><br><span class="line">accept-encoding、accept-language</span><br><span class="line">referer：从何而来 如何跳转过来的</span><br><span class="line">user-agent：浏览器表明自己身份</span><br><span class="line">响应头：</span><br><span class="line">age：当代理服务器用自己缓存的实体去响应请求时，用该头部表明该实体从产生到现在经过多长时间了。</span><br><span class="line">server：表明自身是什么软件 Server：Apache/2.0.61 (Unix)</span><br><span class="line">Accept-Ranges：bytes表示接受、none表示不接受</span><br><span class="line">实体头：</span><br><span class="line">allow：支持哪些方法</span><br><span class="line">content-length：响应对象长度</span><br><span class="line">content-type：响应对象的类型</span><br><span class="line">last-modified：对象的最后修改时间</span><br></pre></td></tr></table></figure>


</blockquote>
<p>http各版本</p>
<blockquote>
<p><strong>1）HTTP 1.0：</strong></p>
<ul>
<li>请求与响应支持 HTTP 头，响应含状态行，增加了状态码，</li>
<li>支持 HEAD，POST 方法</li>
<li>支持传输 HTML 文件以外其他类型的内容</li>
</ul>
<p>HTTP1.0 使用的是非持久连接，主要缺点是客户端必须为每一个待请求的对象建立并维护一个新的连接，即每请求一个文档就要有两倍RTT的开销。因为同一个页面可能存在多个对象，所以非持久连接可能使一个页面的下载变得十分缓慢，而且这种短连接增加了网络传输的负担。（RTT(Round Trip Time)：一个连接的往返时间，即数据发送时刻到接收到确认的时刻的差值）</p>
<p><strong>2）HTTP 1.1：</strong></p>
<ul>
<li>支持长连接。</li>
<li>在HTTP1.0的基础上引入了更多的缓存控制策略。</li>
<li>引入了请求范围设置，优化了带宽。</li>
<li>在错误通知管理中新增了错误状态响应码。</li>
<li>增加了Host头处理，可以传递主机名（hostname）。</li>
</ul>
<p><strong>缺点：</strong>传输内容是明文，不够安全</p>
<p><strong>3）HTTPS</strong></p>
<ul>
<li>HTTPS运行在安全套接字协议(Secure Sockets Layer，SSL )或传输层安全协议（Transport Layer Security，TLS）之上，所有在TCP中传输的内容都需要经过加密。</li>
<li>连接方式不同，HTTP的端口是80，HTTPS的端口是443。</li>
<li>HTTPS可以有效防止运营商劫持。</li>
</ul>
<p>注：SSL运行在TCP之上</p>
<p><strong>4）HTTP 1.x优化（SPDY）</strong><br>SPDY 并不是新的一种协议，而是在 HTTP 之前做了一层会话层。为了达到减少页面加载时间的目标，SPDY 引入了一个新的二进制分帧数据层，以实现优先次序、最小化及消除不必要的网络延迟，目的是更有效地利用底层 TCP 连接。</p>
<ul>
<li>多路复用，为多路复用设立了请求优先级。</li>
<li>对header部分进行了压缩。</li>
<li>引入了HTTPS加密传输。</li>
<li>客户端可以在缓存中取到之前请求的内容。</li>
</ul>
<p><strong>5）HTTP2.0（SPDY的升级版）：</strong></p>
<ul>
<li>HTTP2.0支持明文传输，而HTTP 1.X强制使用SSL/TLS加密传输。</li>
<li>和HTTP 1.x使用的header压缩方法不同。</li>
<li>HTTP2.0 基于二进制格式进行解析，而HTTP 1.x基于文本格式进行解析。</li>
<li>多路复用，HTTP1.1是多个请求串行化单线程处理，HTTP 2.0是并行执行，一个请求超时并不会影响其他请求。</li>
</ul>
<p>HTTP2.0的多路复用提升了网页性能：</p>
<ul>
<li>在 HTTP1 中浏览器限制了同一个域名下的请求数量（Chrome下一般是六个），当在请求很多资源的时候，由于队头阻塞，当浏览器达到最大请求数量时，剩余的资源需等待当前的六个请求完成后才能发起请求。</li>
<li>HTTP2 中引入了多路复用的技术，这个技术可以只通过一个TCP连接就可以传输所有的请求数据。多路复用可以绕过浏览器限制同一个域名下的请求数量的问题，进而提高了网页的性能。</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>主流浏览器只支持基于TLS部署的HTTP 2.0协议，所以要将网站升级为HTTP 2.0，就需要先升级为HTTPS。</li>
<li>HTTP 2.0完全兼容HTTP 1.x,所以对于部署了HTTP 2.0的网站可以自动向下兼容HTTP 1.X。</li>
</ul>
<p><strong>6） HTTP 3.0 (QUIC)：</strong></p>
<p>QUIC (Quick UDP Internet Connections)，快速 UDP 互联网连接。QUIC是基于UDP协议的。</p>
<p>两个主要特性：</p>
<p>（1）线头阻塞(HOL)问题的解决更为彻底：</p>
<p>基于TCP的HTTP/2，尽管从逻辑上来说，不同的流之间相互独立，不会相互影响，但在实际传输方面，数据还是要一帧一帧的发送和接收，一旦某一个流的数据有丢包，则同样会阻塞在它之后传输的流数据传输。而基于UDP的QUIC协议则可以更为彻底地解决这样的问题，让不同的流之间真正的实现相互独立传输，互不干扰。</p>
<p>（2）切换网络时的连接保持：</p>
<p>当前移动端的应用环境，用户的网络可能会经常切换，比如从办公室或家里出门，WiFi断开，网络切换为3G或4G。基于TCP的协议，由于切换网络之后，IP会改变，因而之前的连接不可能继续保持。而基于UDP的QUIC协议，则可以内建与TCP中不同的连接标识方法，从而在网络完成切换之后，恢复之前与服务器的连接。</p>
</blockquote>
<p>线头阻塞(HOL)</p>
<blockquote>
<p>TCP协议中，序号为1、3的数据包接收到后，不能直接传递给上层，需要等待到序号为2的数据包到达，这种等待的情况称为线头阻塞。</p>
</blockquote>
<p>https身份认证</p>
<blockquote>
<p>身份认证（CA数字证书）：</p>
<p>https协议中身份认证的部分是由数字证书来完成的，证书由<strong>公钥、证书主题、数字签名</strong>等内容组成，在客户端发起SSL请求后，服务端会将数字证书发给客户端，客户端对证书进行验证，并获取用于秘钥交换的非对称秘钥</p>
<p>数字证书作用：</p>
<ul>
<li>身份授权 确保浏览器访问的网站是经过CA验证的可信任网站</li>
<li>分发公钥 每个数字证书都包含了注册者生成的公钥。在SSL握手时通过certificate消息传输给客户端</li>
</ul>
<p>数字证书验证：</p>
<p>申请者拿到CA的证书并部署在网站服务器端，浏览器发起握手接收到证书后，如何确认这个证书就是CA签发的呢？怎样避免第三方伪造这个证书？答案就是数字签名（digital signature）。数字签名是证书的防伪标签，目前使用最广泛的是SHA-RSA（SHA用于哈希算法，RSA用于非对称加密算法）数字签名</p>
</blockquote>
<p>浏览器如何验证CA证书</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">首先，浏览器通过URL网址去请求服务端，服务端接收到请求后，就会给浏览器发送一个自己的CA数字证书</span><br><span class="line">然后，浏览器接收到证书以后，开始验证。首先从证书中得知证书的颁发机构，然后从浏览器系统中去寻找此颁发机构的根证书(世界上权威CA机构的根证书都是预先嵌入到浏览器中的)，如果在浏览器系中没有找到对应的根证书，就代表此机构不是受信任的，那么就会警告无法确认证书的真假，比如以前打开12360网站就会提示。</span><br><span class="line">之后，如果找到了证书颁发机构的根证书，那么就从根证书中取得那个根公钥，用根公钥去解密此证书的数字签名，成功解密的话就得到证书的指纹和指纹算法，指纹是证书内容通过指纹算法计算得到的一个hash值，这里我们称之为h1，h1代表证书的原始内容；然后用指纹算法对当前接收到的证书内容再进行一次hash计算得到另一个值h2，h2则代表当前证书的内容，如果此时h1和h2是相等的，就代表证书没有被修改过。如果证书被篡改过，h2和h1是不可能相同的。</span><br><span class="line"></span><br><span class="line">假如证书上的指纹是不法分子伪造的，伪造是没有用的，因为你伪造的指纹不可能用CA机构的根私钥去加密（根私钥是CA机构绝对保密的），伪造者只能拿自己的秘钥去加密这个伪造的指纹，但当我们拿机构的根公钥去解密伪造指纹的时候是不可能成功的（加密内容只能由一对公钥私钥解密）</span><br><span class="line"></span><br><span class="line">在证书没有被修改过的基础上，再检查证书上的使用者的URL（比如csdn.net）和我们请求的URL是否相等，如果相等，那么就可以证明当前浏览器链接的网址也是正确的，而不是一些钓鱼网之类的。</span><br><span class="line"></span><br><span class="line">但如果浏览器的连接被某个中间人截取了，中间人也可以发一个由权威的CA机构颁发的证书给浏览器，然后也可以通过证书没有被篡改的验证，但是在证书没有被篡改的前提下，通过对比证书上的URL和我们请求的URL是否相同，我们还是可以判断当前证书是不是服务器发的证书。可以这么理解，因为URL具有唯一性，所以中间人的证书的上的URL和我们的证书的URL是不可能相同的，如果中间人修改了自己证书上的URL，那么就通过不了证书没有被篡改的验证，所以中间人的证书也是欺骗不了我们的。</span><br><span class="line">然后生成对称密钥即可。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>https密钥协商机制</p>
<blockquote>
<p>1）非对称加密：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">客户端发送 ClientHello（包含支持的协议版本、加密算法和 随机数A (Client random)）到服务端</span><br><span class="line">服务端返回 ServerHello、公钥、证书、随机数B (Server random) 到客户端</span><br><span class="line">客户端使用CA证书验证返回证书无误后。生成 随机数C (Premaster secret)，用公钥对其加密，发送到服务端</span><br><span class="line">服务端用 私钥 解密得到 随机数C (Premaster secret)，随后根据已经得到的 随机数ABC生成对称密钥（hello的时候确定的加密算法），并对需要发送的数据进行对称加密发送</span><br><span class="line">客户端使用对称密钥（客户端也用随机数ABC生成对称密钥）对数据进行解密。</span><br><span class="line">双方手持对称密钥 使用对称加密算法通讯</span><br></pre></td></tr></table></figure>

<p>2）DH密钥协商：可以做到——“通讯双方在完全没有对方任何预先信息的条件下通过不安全信道创建起一个密钥”</p>
<p>但无法防止中间人篡改。需要和RSA配合签名机制使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 客户端先连上服务端</span><br><span class="line">2. 服务端生成一个随机数 s 作为自己的私钥，然后根据算法参数计算出公钥 S（算法参数通常是固定的）</span><br><span class="line">3. 服务端使用某种签名算法把“算法参数（模数p，基数g）和服务端公钥S”作为一个整体进行签名</span><br><span class="line">4. 服务端把“算法参数（模数p，基数g）、服务端公钥S、签名”发送给客户端</span><br><span class="line">5. 客户端收到后验证签名是否有效</span><br><span class="line">6. 客户端生成一个随机数 c 作为自己的私钥，然后根据算法参数计算出公钥 C</span><br><span class="line">7. 客户端把 C 发送给服务端</span><br><span class="line">8. 客户端和服务端（根据上述 DH 算法）各自计算出 k 作为会话密钥</span><br></pre></td></tr></table></figure>

<p>如何防范偷窥（嗅探）:</p>
<p>嗅探者可以通过监视网络传输，得到算法参数（模数p，基数g）以及双方的公钥，但是【无法】推算出双方的私钥，也【无法】推算出会话密钥（这是由 DH 算法在数学上保证的）</p>
<p>如何防范篡改（假冒身份）</p>
<p>攻击方式1：攻击者可以第4步篡改数据（修改算法参数或服务端公钥）。但因为这些信息已经进行过数字签名。篡改之后会被客户端发现。</p>
<p>攻击方式2：攻击者可以在第7步篡改客户端公钥。这步没有签名，服务端收到数据后不会发现被篡改。但是，攻击者篡改之后会导致“服务端与客户端生成的会话密钥【不一致】”。在后续的通讯步骤中会发现这点，并导致通讯终止。</p>
</blockquote>
<p>TLS</p>
<blockquote>
<p>整个TLS传输的过程如下：<br>(1）TCP三次握手<br>(2）SSL的ClientHello和ServerHello和对应的秘钥交换KeyExchange<br>(3）Client和Server互相ChangeCipherSpec通知进入加密模式，此时可以进入数据传输状态<br>(4）应用数据传输过程<br>(5）应用数据传输完成，TCP两次挥手<br>抛开TCP连接和数据包文传输的部分，TLS握手部分将使用2个RTT。</p>
</blockquote>
<p>前向安全性</p>
<blockquote>
<p>指的是长期使用的主密钥泄漏不会导致过去的会话密钥泄漏</p>
</blockquote>
<p>http一些参数</p>
<blockquote>
<p>Content-Length：指明响应体的数据大小</p>
<p>content-type：数据格式。</p>
<ul>
<li>application/json:JSON数据格式</li>
<li>text/html:HTML格式</li>
<li>text/xml:XML格式</li>
</ul>
<p>Connection: keep-alive：保持长连接</p>
</blockquote>
<p>http——chunk</p>
<blockquote>
<p>当客户端向服务器请求一个静态页面或者一张图片时，服务器可以很清楚的知道内容大小，然后通过Content-Length消息首部字段告诉客户端需要接收多少数据。但是如果是动态页面等时，服务器是不可能预先知道内容大小，这时就可以使用Transfer-Encoding：chunk模式来传输数据了。即如果要一边产生数据，一边发给客户端，服务器就需要使用”Transfer-Encoding: chunked”这样的方式来代替Content-Length。</p>
<p>在进行chunked编码传输时，在回复消息的头部有Transfer-Encoding: chunked</p>
<p>编码使用若干个chunk组成，由一个标明长度为0的chunk结束。每个chunk有两部分组成，第一部分是该chunk的长度，第二部分就是指定长度的内容，每个部分用CRLF隔开。在最后一个长度为0的chunk中的内容是称为footer的内容，是一些没有写的头部内容。</p>
<blockquote>
<p>chunk编码格式如下：</p>
<p>[chunk size][\r\n][chunk data][\r\n][chunk size][\r\n][chunk data][\r\n][chunk size = 0][\r\n][\r\n]</p>
<p>chunk size是以十六进制的ASCII码表示，比如：头部是3134这两个字节，表示的是1和4这两个ascii字符，被http协议解释为十六进制数14，也就是十进制的20，后面紧跟[\r\n](0d 0a)，再接着是连续的20个字节的chunk正文。chunk数据以0长度的chunk块结束，也就是（30 0d 0a 0d 0a）。</p>
</blockquote>
<p>原理</p>
<p>HTTP 1.1引入分块传输编码提供了以下几点好处：</p>
<p>HTTP分块传输编码允许服务器为动态生成的内容维持HTTP持久链接。通常，持久链接需要服务器在开始发送消息体前发送Content-Length消息头字段，但是对于动态生成的内容来说，在内容创建完之前是不可知的。</p>
<p>分块传输编码允许服务器在最后发送消息头字段。对于那些头字段值在内容被生成之前无法知道的情形非常重要，例如消息的内容要使用散列进行签名，散列的结果通过HTTP消息头字段进行传输。没有分块传输编码时，服务器必须缓冲内容直到完成后计算头字段的值并在发送内容前发送这些头字段的值。</p>
</blockquote>
<p>DNS</p>
<blockquote>
<p>浏览器输入一个地址，发生了什么？</p>
<p>根据域名查找ip地址(浏览器缓存——本机host缓存——DNS系统调用——本地DNS服务器缓存——递归查询直到获得ip地址——可能因为负载均衡每次获得不同的ip地址)，然后向该ip发送http请求，服务器响应回复html文档，浏览器解析html并根据content-type判断如何处理(显示、下载等等)，浏览器获取html文档内嵌的图片、音频、js等等，最后浏览器还可以发送ajax异步请求。</p>
<p>DNS区域传输的时候使用TCP协议：辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。</p>
<p>域名解析时使用UDP协议</p>
</blockquote>
<p>DNS over TLS / HTTPS</p>
<blockquote>
<p>加密的DNS协议。但是延时也很高，需要耗费4 RTT来保证安全。</p>
</blockquote>
<p>cookie和session、token</p>
<blockquote>
<p>cookie：客户端会话技术，存储数据在客户端浏览器，默认浏览器关闭后清除，能存放的数据有限且安全性较低。存放sessionID，之后的请求默认携带。</p>
<p>session：服务端会话技术，存储在服务端，用来保存状态，依赖于cookie，存放的数据无限制且安全性高，但需要单独存储，耗费空间。</p>
<p>token：无状态的令牌。采用签名的方式来验证(私钥签名、公钥验证)，每次传输过来的数据再次进行签名以对比。再次请求需要手动添加token。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当用户首次与Web服务器建立连接的时候，服务器会给用户分发一个 SessionID作为标识。SessionID是一个由24个字符组成的随机字符串。用户每次提交页面，浏览器都会把这个SessionID包含在 HTTP头中提交给Web服务器，这样Web服务器就能区分当前请求页面的是哪一个客户端。这个SessionID就是保存在客户端的，属于客户端Session。</span><br><span class="line">其实客户端Session默认是以cookie的形式来存储的，所以当用户禁用了cookie的话，服务器端就得不到SessionID。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>http和rpc区别</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RPC:可以基于TCP协议，也可以基于HTTP协议</span><br><span class="line">HTTP:基于HTTP协议</span><br><span class="line"></span><br><span class="line">RPC:可以基于thrift实现高效的二进制传输</span><br><span class="line">HTTP:大部分是通过json来实现的，字节大小和序列化耗时都比thrift要更消耗性能</span><br><span class="line"></span><br><span class="line">RPC：基本都自带了负载均衡策略</span><br><span class="line">HTTP：需要配置Nginx，HAProxy来实现</span><br><span class="line"></span><br><span class="line">RPC主要用于公司内部的服务调用，性能消耗低，传输效率高，服务治理方便。</span><br><span class="line">HTTP主要用于对外的异构环境，浏览器接口调用，APP接口调用，第三方接口调用等。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>nginx</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">工作流程：</span><br><span class="line">1、用户通过域名发出访问Web服务器的请求，该域名被DNS服务器解析为反向代理服务器的IP地址；</span><br><span class="line">2、反向代理服务器接受用户的请求；</span><br><span class="line">3、反向代理服务器在本地缓存中查找请求的内容，找到后直接把内容发送给用户；</span><br><span class="line">4、如果本地缓存里没有用户所请求的信息内容，反向代理服务器会代替用户向源服务器请求同样的信息内容，并把信息内容发给用户，如果信息内容是非缓存的还会把它保存到缓存中。</span><br><span class="line">--------</span><br><span class="line">Nginx模块：</span><br><span class="line">Nginx有五大优点：模块化、事件驱动、异步、非阻塞、多进程单线程。由内核和模块组成的，其中内核完成的工作比较简单，仅仅通过查找配置文件将客户端请求映射到一个location block，然后又将这个location block中所配置的每个指令将会启动不同的模块去完成相应的工作。</span><br><span class="line">--------</span><br><span class="line">作用：</span><br><span class="line">* 保护了真实的web服务器，保证了web服务器的资源安全</span><br><span class="line">* 节约了有限的IP地址资源</span><br><span class="line">* 减少WEB服务器压力，提高响应速度</span><br><span class="line"> 	- 反向代理就是通常所说的web服务器加速，它是一种通过在繁忙的web服务器和外部网络之间增加一个高速的web缓冲服务器来降低实际的web服务器的负载的一种技术。反向代理是针对web服务器提高加速功能，作为代理缓存，它并不是针对浏览器用户，而针对一台或多台特定的web服务器，它可以代理外部网络对内部网络的访问请求。</span><br><span class="line">	- 反向代理服务器会强制将外部网络对要代理的服务器的访问经过它，这样反向代理服务器负责接收客户端的请求，然后到源服务器上获取内容，把内容返回给用户，并把内容保存到本地，以便日后再收到同样的信息请求时，它会把本地缓存里的内容直接发给用户，以减少后端web服务器的压力，提高响应速度。因此Nginx还具有缓存功能。</span><br><span class="line">* 请求的统一控制，包括设置权限、过滤规则等；</span><br><span class="line">* 区分动态和静态可缓存内容；</span><br><span class="line">* 实现负载均衡，内部可以采用多台服务器来组成服务器集群，外部还是可以采用一个地址访问；</span><br><span class="line">* 解决Ajax跨域问题；</span><br><span class="line">* 作为真实服务器的缓冲，解决瞬间负载量大的问题；</span><br></pre></td></tr></table></figure>

</blockquote>
<p>接口幂等性</p>
<blockquote>
<p>接口幂等用于表示任意多次请求执行的结果均与一次请求执行的结果相同</p>
<p>实现幂等性的关键步骤分为以下三个：</p>
<p>（1）每个请求操作必须有唯一的 ID，而这个 ID 就是用来表示此业务是否被执行过的关键凭证，例如，订单支付业务的请求，就要使用订单的 ID 作为幂等性验证的 Key；</p>
<p>（2）每次执行业务之前必须要先判断此业务是否已经被处理过；</p>
<p>（3）第一次业务处理完成之后，要把此业务处理的状态进行保存，比如存储到 Redis 中或者是数据库中，这样才能防止业务被重复处理</p>
<p>get请求为幂等、post则不是</p>
</blockquote>
<p>理解restful(Representational State Transfer)</p>
<blockquote>
<p>（1）每一个URI代表一种资源；</p>
<p>（2）客户端和服务器之间，传递这种资源的某种表现层；</p>
<p>（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RESTful 架构的核心规范与约束：统一接口</span><br><span class="line">分为四个子约束：</span><br><span class="line">1.每个资源都拥有一个资源标识，每个资源的资源标识可以用来唯一地标明该资源</span><br><span class="line">2.消息的自描述性</span><br><span class="line">3.资源的自描述性。</span><br><span class="line">4.HATEOAS Hypermedia As The Engine Of Application State(超媒体作为应用状态引擎)</span><br><span class="line">即客户只可以通过服务端所返回各结果中所包含的信息来得到下一步操作所需要的信息，如到底是向哪个URL发送请求等。也就是说，一个典型的REST服务不需要额外的文档标示通过哪些URL访问特定类型的资源，而是通过服务端返回的响应来标示到底能在该资源上执行什么样的操作</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/03/12/T5aPvYtkK9zIefD.png" alt="image.png"></p>
<p>使用标准的状态码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">GET</span><br><span class="line">安全且幂等、获取表示、变更时获取表示（缓存）</span><br><span class="line">200（OK） - 表示已在响应中发出</span><br><span class="line">204（无内容） - 资源有空表示</span><br><span class="line">301（Moved Permanently） - 资源的URI已被更新</span><br><span class="line">303（See Other） - 其他（如，负载均衡）</span><br><span class="line">304（not modified）- 资源未更改（缓存）</span><br><span class="line">400 （bad request）- 指代坏请求（如，参数错误）</span><br><span class="line">404 （not found）- 资源不存在</span><br><span class="line">406 （not acceptable）- 服务端不支持所需表示</span><br><span class="line">500 （internal server error）- 通用错误响应</span><br><span class="line">503 （Service Unavailable）- 服务端当前无法处理请求</span><br><span class="line"></span><br><span class="line">POST</span><br><span class="line">不安全且不幂等</span><br><span class="line">使用服务端管理的（自动产生）的实例号创建资源</span><br><span class="line">创建子资源</span><br><span class="line">部分更新资源</span><br><span class="line">如果没有被修改，则不过更新资源（乐观锁）</span><br><span class="line">200（OK）- 如果现有资源已被更改</span><br><span class="line">201（created）- 如果新资源被创建</span><br><span class="line">202（accepted）- 已接受处理请求但尚未完成（异步处理）</span><br><span class="line">301（Moved Permanently）- 资源的URI被更新</span><br><span class="line">303（See Other）- 其他（如，负载均衡）</span><br><span class="line">400（bad request）- 指代坏请求</span><br><span class="line">404 （not found）- 资源不存在</span><br><span class="line">406 （not acceptable）- 服务端不支持所需表示</span><br><span class="line">409 （conflict）- 通用冲突</span><br><span class="line">412 （Precondition Failed）- 前置条件失败（如执行条件更新时的冲突）</span><br><span class="line">415 （unsupported media type）- 接受到的表示不受支持</span><br><span class="line">500 （internal server error）- 通用错误响应</span><br><span class="line">503 （Service Unavailable）- 服务当前无法处理请求</span><br><span class="line"></span><br><span class="line">PUT</span><br><span class="line">不安全但幂等</span><br><span class="line">用客户端管理的实例号创建一个资源</span><br><span class="line">通过替换的方式更新资源</span><br><span class="line">如果未被修改，则更新资源（乐观锁）</span><br><span class="line">200 （OK）- 如果已存在资源被更改</span><br><span class="line">201 （created）- 如果新资源被创建</span><br><span class="line">301（Moved Permanently）- 资源的URI已更改</span><br><span class="line">303 （See Other）- 其他（如，负载均衡）</span><br><span class="line">400 （bad request）- 指代坏请求</span><br><span class="line">404 （not found）- 资源不存在</span><br><span class="line">406 （not acceptable）- 服务端不支持所需表示</span><br><span class="line">409 （conflict）- 通用冲突</span><br><span class="line">412 （Precondition Failed）- 前置条件失败（如执行条件更新时的冲突）</span><br><span class="line">415 （unsupported media type）- 接受到的表示不受支持</span><br><span class="line">500 （internal server error）- 通用错误响应</span><br><span class="line">503 （Service Unavailable）- 服务当前无法处理请求</span><br><span class="line"></span><br><span class="line">DELETE</span><br><span class="line">不安全但幂等</span><br><span class="line">删除资源</span><br><span class="line">200 （OK）- 资源已被删除</span><br><span class="line">301 （Moved Permanently）- 资源的URI已更改</span><br><span class="line">303 （See Other）- 其他，如负载均衡</span><br><span class="line">400 （bad request）- 指代坏请求</span><br><span class="line">404 （not found）- 资源不存在</span><br><span class="line">409 （conflict）- 通用冲突</span><br><span class="line">500 （internal server error）- 通用错误响应</span><br><span class="line">503 （Service Unavailable）- 服务端当前无法处理请求</span><br></pre></td></tr></table></figure>
</blockquote>
<p>路由器和交换机具体实现了什么功能，路由选择如何实现</p>
<blockquote>
<p>路由器属于网络层，使用ip地址通信，连接局域网和外网。</p>
<p>交换机属于数据链路层，使用mac地址通信，工作在局域网内部。 </p>
</blockquote>
<p>介绍下IPV6</p>
<blockquote>
<p>128位，16字节，16进制</p>
</blockquote>
<p>jwt(JSON Web Token)</p>
<blockquote>
<p>JSON Web Token由三部分组成，它们之间用圆点(.)连接。这三部分分别是：</p>
<ul>
<li>Header、Payload、Signature</li>
</ul>
<p><strong>header</strong>典型的由两部分组成：token的类型（“JWT”）和算法名称（比如：HMAC SHA256或者RSA等等）。例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    'alg': "HS256",</span><br><span class="line">    'typ': "JWT"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用Base64对这个JSON编码就得到JWT的第一部分</p>
<p><strong>payload</strong>，它包含声明（要求）。声明是关于实体(通常是用户)和其他数据的声明。声明有三种类型: registered, public 和 private。</p>
<p>Registered claims : 这里有一组预定义的声明，它们不是强制的，但是推荐。比如：iss (issuer), exp (expiration time), sub (subject), aud (audience)等。</p>
<p>Public claims : 可以随意定义。</p>
<p>Private claims : 用于在同意使用它们的各方之间共享信息，并且不是注册的或公开的声明。 下面是一个例子：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"sub"</span>: '<span class="number">1234567890</span>',</span><br><span class="line">    <span class="attr">"name"</span>: 'john',</span><br><span class="line">    <span class="attr">"admin"</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对payload进行Base64编码就得到JWT的第二部分</p>
<p>注意，不要在JWT的payload或header中放置敏感信息，除非它们是加密的。</p>
<p><strong>Signature</strong></p>
<p>为了得到签名部分，你必须有编码过的header、编码过的payload、一个秘钥，签名算法是header中指定的那个，然对它们签名即可。例如：</p>
<blockquote>
<p>HMACSHA256(base64UrlEncode(header) + “.” + base64UrlEncode(payload), secret)</p>
</blockquote>
<p>签名是用于验证消息在传递过程中有没有被更改，并且，对于使用私钥签名的token，它还可以验证JWT的发送方是否为它所称的发送方。</p>
</blockquote>
<p>CSRF跨站点请求伪造(Cross—Site Request Forgery)</p>
<blockquote>
<p>攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 </p>
</blockquote>
<p>反爬策略</p>
<blockquote>
<ol>
<li>限制IP地址单位时间的访问次数</li>
<li>用户登录才能访问网站内容, 若识别为爬虫账号,封禁IP</li>
<li>header, User-Agent检查用户所用客户端的种类和版本, 在请求头中加入CSRF_token识别用户请求(参考form表单验证)</li>
<li>Referer, 检查请求由哪里来，通常可以做图片的盗链判断</li>
<li>Cookies,检测Cookie中session_id 的使⽤用次数，如果超过限制，就触发反爬策略略</li>
<li>动态加载,网站使用ajax动态加载内容</li>
<li>对前端请求的API的参数进行加密</li>
<li>对网站JS进行混淆加密(适用于对API参数加密的情况,对用于加密的JS进行混淆)</li>
<li>在用户登录时,进行验证码验证(图片验证码或滑动验证码或短信验证码等)</li>
<li>对网页数据展示的总页数进行限制,比如用户只能浏览200页</li>
</ol>
</blockquote>
<h2 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h2><p>包装类自动拆箱、自动装箱</p>
<blockquote>
<p>c == a + b    c.equals(a + b)</p>
</blockquote>
<p>注解</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">* 作用分类</span><br><span class="line">	* 编写文档：生成文档【doc文档】</span><br><span class="line">    * 代码分析：通过注解对代码进行分析【使用反射】</span><br><span class="line">    * 编译检查：让编辑器能实现基本的编译检查【@Override】</span><br><span class="line"></span><br><span class="line">* JDK中预定义的一些注解</span><br><span class="line">	* @Override：检测被该注解标注的方法是否是继承自父类(接口)的</span><br><span class="line">    * @Deprecated：将该注解标注的内容，表示已过时</span><br><span class="line">    * @SuppressWarnings：压制警告</span><br><span class="line">    	* 一般传递参数all	@SuppressWarnings(&quot;all&quot;)</span><br><span class="line">  </span><br><span class="line">* 自定义注解</span><br><span class="line">	* 格式：</span><br><span class="line">		* 元注解</span><br><span class="line">        * public @interface 注解名称() &#123;</span><br><span class="line">        	属性列表;</span><br><span class="line">        &#125;</span><br><span class="line">	* 本质：注解本质上就是一个接口，该接口默认继承Annotation</span><br><span class="line">		* public interface 注解名称 extends java.lang.annotation.Annotation &#123;&#125;</span><br><span class="line">	* 属性：接口中的抽象方法</span><br><span class="line">		* 要求：</span><br><span class="line">			1. 属性的返回值类型有下列取值：</span><br><span class="line">				* 基本数据类型</span><br><span class="line">				* String</span><br><span class="line">                * 枚举</span><br><span class="line">                * 注解</span><br><span class="line">                * 以上类型的数组</span><br><span class="line">			2. 定义了属性，在使用时需要给属性赋值</span><br><span class="line">				1. 如果定义属性时，使用default关键字给属性默认初始值，则使用注解时可以不进行属性的赋值</span><br><span class="line">                2. 如果只有一个属性需要赋值，并且属性的名称为value，则value可以省略，直接定义值即可【@SuppressWarnings】</span><br><span class="line">                3. 数组赋值时，值使用&#123;&#125;包裹，如果数组中只有一个值，则&#123;&#125;可以省略</span><br><span class="line"></span><br><span class="line">* 元注解：用于描述注解的注解</span><br><span class="line">	* @Target：描述注解能够作用的位置</span><br><span class="line">        * ElementType取值：</span><br><span class="line">        * TYPE：可以作用于类上</span><br><span class="line">        * METHOD：可以作用于方法上</span><br><span class="line">        * FIELD：可以作用于成员变量上</span><br><span class="line">	* @Retention：描述注解被保留的一个阶段</span><br><span class="line">		* @Rentention(RententionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到</span><br><span class="line">	* @Documented：描述注解是否被抽取到api文档中</span><br><span class="line">	* @Inherited：描述注解是否被子类继承</span><br><span class="line">  </span><br><span class="line">* 在程序中使用(解析)注解：获取注解中定义的属性值</span><br><span class="line">	1. 获取注解定义的位置的对象	【Class，Method，Field】</span><br><span class="line">	2. 获取指定的注解</span><br><span class="line">		* getAnnotation(Class)</span><br><span class="line">		* public class ProImpl implements Pro&#123;</span><br><span class="line">              public String className()&#123;</span><br><span class="line">                  return &quot;day01.annotation.Demo1&quot;;</span><br><span class="line">              &#125;</span><br><span class="line">              public String methodName()&#123;</span><br><span class="line">                  return &quot;show&quot;;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">	3. 调用注解中的抽象方法，获取配置的属性值</span><br></pre></td></tr></table></figure>


</blockquote>
<ul>
<li>RPC（Remote Procedure Call）远程过程调用，简单的理解是一个节点请求另一个节点提供的服务</li>
</ul>
<p>继承和多态</p>
<blockquote>
<p>继承：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。</p>
<p>多态：允许将子类类型的指针赋值给父类类型的指针。</p>
</blockquote>
<p>重写和重载</p>
<blockquote>
<p>重写：子类重写父类方法，返回值和形参都不能改变</p>
<p>重载：方法名字相同，而参数不同。返回类型可以相同也可以不同。每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</p>
</blockquote>
<p>TCP UDP对应的socket编程的API</p>
<blockquote>
<p>socket()：创建socket<br>bind()：绑定socket到本地地址和端口，通常由服务端调用<br>listen()：TCP专用，开启监听模式<br>accept()：TCP专用，服务器等待客户端连接，一般是阻塞态<br>connect()：TCP专用，客户端主动连接服务器<br>send()：TCP专用，发送数据<br>recv()：TCP专用，接收数据<br>sendto()：UDP专用，发送数据到指定的IP地址和端口<br>recvfrom()：UDP专用，接收数据，返回数据远端的IP地址和端口<br>closesocket()：关闭socket</p>
</blockquote>
<p>函数式编程</p>
<blockquote>
<p>示例：<code>Function&lt;Integer, Integer&gt; f = x -&gt; x + 1;</code></p>
<p>和匿名内部类的区别：</p>
<p>①this指向不同，lambda指向当前类，匿名内部类指向其本身<br>②lambda表达式并没有生成.class文件，匿名内部类则生成了</p>
</blockquote>
<p>RBAC模型</p>
<blockquote>
<p>权限控制？</p>
</blockquote>
<p>transient</p>
<blockquote>
<p>不进行序列化</p>
</blockquote>
<p>NIO</p>
<blockquote>
<p>BytebBuffer——HeapByteBuffer：在堆中创建的缓冲区。MappedByteBuffer：直接缓冲区。</p>
<p>allocate方法创建的直接缓冲区是创建的DirectByteBuffer实例。</p>
</blockquote>
<h2 id="java集合"><a href="#java集合" class="headerlink" title="java集合"></a>java集合</h2><p>HashMap源码、实现原理、转红黑树的时机(为何是7)、多线程优化、多线程失败的场景</p>
<blockquote>
<p>jdk7，数组加链表，hash冲突插入首部；jdk8，数组+链表+红黑树。hash冲突插入尾部，在链表长度大于7且数组长度大于64时转换为红黑树，否则先扩容。为何是7呢，因为链表中节点数是8的概率已经接近千分之一，而且此时链表的性能已经很差了。所以在这种比较罕见和极端的情况下，才会把链表转变为红黑树。而同时树节点的占用空间约为链表的两倍，占用空间较大。且在红黑树节点数为6时退化为链表。</p>
<p>容量：默认容量16，可自定义容量，如果不是2的幂次系统会默认设置为2的幂次，如果容量超过initial * loadFactor(默认0.75)会进行扩容(两倍)。(hash &amp; (len - 1) —— 10101001  00001111)</p>
<p>为何线程不安全：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">jdk7中由于头插法，会存在resize后链表中形成环的情况。</span><br><span class="line">    线程1阻塞前链表情况：a-&gt;b-&gt;null</span><br><span class="line">    线程2此时执行，会采用头插法将该链表放入新的table，放入后变成b-&gt;a-&gt;null</span><br><span class="line">    线程1此时返回，同样采用头插法插入该线程自己的新的table中，两次循环后变为b-&gt;a，但是由于线程2执行时的后果会导致b的next不是null而是a，所以循环多执行一次，e此时变为a会导致a.next = newTable[i](也就是b)然后发生循环。</span><br><span class="line"></span><br><span class="line">jdk8中采用尾插法会导致数据的覆盖。</span><br><span class="line">	假设两个线程A、B都在进行put操作，并且hash函数计算出的插入下标是相同的，当线程A执行完第13行代码后(hash碰撞判断，此时判断是没有碰撞的但还没有进行插入)由于时间片耗尽导致被挂起，而线程B得到时间片后在该下标处插入了元素，完成了正常的插入，然后线程A获得时间片，由于之前已经进行了hash碰撞的判断，所有此时不会再进行判断，而是直接进行插入，这就导致了线程B插入的数据被线程A覆盖了，从而线程不安全。</span><br><span class="line">	除此之外还存在一个++size的线程安全问题。</span><br><span class="line"></span><br><span class="line">jdk8解决成环问题：</span><br><span class="line">	采用两组指针loHead、loTail、hiHead、hiTail</span><br><span class="line">	这两组指针将链表分成了两部分，高位指针指向哪些扩容后下标变为(旧下标+扩容大小)，低位指针指向哪些扩容后下标还保持不变的节点。分成两条链表今次那个迁移，迁移后节点的前后顺序保持不变，不会出现环的情况。(扩容后链表节点的情况只有两种下标不变 or 旧下标+扩容的大小)</span><br><span class="line">	红黑树的拆分和链表的逻辑基本一致，不同的地方在于，重新映射后，会将红黑树拆分成两条链表，根据链表的长度，判断需不需要把链表重新进行树化。</span><br></pre></td></tr></table></figure>

<p>多线程优化：和读写锁配合。</p>
</blockquote>
<p>ConcurrentHashMap原理</p>
<blockquote>
<p>jdk7，Segment数组 + HashEntry数组 + ReentrantLock(对每个Segment上锁)；jdk8，Node数组 + CAS + Synchronized(只对每个node上锁)</p>
<p>具体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jdk7：保证segment数组为2的幂次、会再散列来获取下标</span><br><span class="line">初始化有三个参数：</span><br><span class="line">	initialCapacity：初始容量大小 ，默认16。</span><br><span class="line">	loadFactor, 扩容因子，默认0.75，当一个Segment存储的元素数量大于initialCapacity* loadFactor时，该Segment会进行一次扩容。</span><br><span class="line">	concurrencyLevel：并发度，默认16。Segment[]的数组长度。如果并发度设置的过小，会带来严重的锁竞争问题；如果并发度设置的过大，原本位于同一个Segment内的访问会扩散到不同的Segment中，CPU cache命中率会下降，从而引起程序性能下降。</span><br><span class="line">segment不扩容，扩容的是hashentry数组</span><br><span class="line"></span><br><span class="line">扩容时的get操作访问的是旧链表，对于put以及其他更新操作会阻塞直到扩容完成。</span><br></pre></td></tr></table></figure>

<p>get不需要加锁，除非读到的是null，原理是get方法中的变量都使用volatile关键字修饰。且对volatile字段的写入操作先于读取操作，所以即使两个线程同时修改和获取volatile变量，get操作也能保证拿到最新的值。</p>
</blockquote>
<p>ArrayList和LinkedList插入效率比较</p>
<blockquote>
<p>插入到最后，效率相当。插入到中间，LinkedList效率高。数据量过大，ArrayList动态扩容，LinkedList效率更高。</p>
</blockquote>
<p>ArrayList</p>
<blockquote>
<p>懒加载(但在jdk7及以前会直接初始化一个容量为10的数组)，需要扩容时，会首先扩容置原容量的1.5倍左右(<code>new = old + old &gt;&gt; 1</code>)，然后如果new满足需求，则会直接用new作为新容量，否则会将当前所需容量作为新容量。</p>
</blockquote>
<p>Java最顶层集合有哪些</p>
<blockquote>
<p>Collection、Map</p>
</blockquote>
<p>抽象类和接口的区别：</p>
<blockquote>
<p>抽象类更多是对事物的抽象，如人，是一种模板的设计；而接口则是对行为的抽象，如：运动，是一种行为的规范。</p>
<p>抽象类可以有静态方法、成员变量可以为任意类型。</p>
</blockquote>
<h2 id="java并发"><a href="#java并发" class="headerlink" title="java并发"></a>java并发</h2><p>synchronized和lock区别以及底层原理</p>
<blockquote>
<p>区别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;1.首先synchronized是java内置关键字，在jvm层面，Lock是个java类；</span><br><span class="line">&gt;2.synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；</span><br><span class="line">&gt;3.synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；</span><br><span class="line">&gt;4.用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；</span><br><span class="line">&gt;5.synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可中断、可公平（两者皆可）</span><br><span class="line">&gt;6.Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。</span><br></pre></td></tr></table></figure>

<p>底层原理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt;synchronized:</span><br><span class="line">&gt;原子性：保证语句块内是原子的</span><br><span class="line">&gt;可见性：通过在unlock前需要将变量同步回主存，其他线程需要重新获取</span><br><span class="line">&gt;有序性：一个变量在同一时刻只允许一条线程对其操作</span><br><span class="line">&gt;方法级的同步是通过方法调用和返回中实现的，方法常量池的ACC_SYNCHRONIZED标志是否为同步方法，如果方法是同步方法，则执行线程需要先持有monitor然后执行方法，返回后释放。</span><br><span class="line">&gt;代码块的同步是通过monitorenter和monitorexit实现的。遇到monitorenter试图获取monitor对象，如果未加锁或者已经被自己持有，则锁计数器+1，执行，遇到monitorexit则锁计数-1.计数器为0代表锁释放。如果获取monitor对象失败会进入阻塞。且是可重入的。</span><br><span class="line">&gt;1.6前慢的原因：对象内部的监视器锁是通过底层OS的Mutex实现的，存在用户态到内核态的切换，成本极高</span><br><span class="line">&gt;1.6后的优化：四种锁状态 无锁——偏向锁——轻量级锁——重量级锁。(不可降级)</span><br><span class="line">&gt;--</span><br><span class="line">&gt;偏向锁：无实际竞争，且将来只有第一个申请锁的线程会使用锁。只有一次CAS</span><br><span class="line">&gt;锁对象第一次被获取时，jvm将对象头锁标志位设为01偏向模式，然后通过CAS将线程id记录到对象的markword中。如果成功，该线程在以后每次进入该同步块时，jvm不进行任何操作。如果不是第一次获取锁，则判断偏向线程id是否为当前线程，是的话就进入同步块。否则则根据当前偏向的线程是否存活，未存活则取消锁到无锁状态，存活则升级为轻量级锁。</span><br><span class="line">&gt;--</span><br><span class="line">&gt;轻量级锁：无实际竞争，多个线程交替使用锁；允许短时间的锁竞争。申请和释放需要CAS</span><br><span class="line">&gt;轻量级锁是相对于重量级锁而言的。使用轻量级锁时，不需要申请互斥量，而是在当前线程栈帧中开辟空间Lock Record用来记录当前对象markword的拷贝。然后将Mark Word中的部分字节CAS更新指向线程栈中的Lock Record，如果更新成功，则轻量级锁获取成功，记录锁状态为00轻量级锁；否则，说明已经有线程获得了轻量级锁，如果指向的是当前线程的栈帧，则重入代码块，否则出现了竞争，会尝试几次CAS，如果不行，升级为重量级锁，标志位11，markword中指针指向重量级锁。</span><br><span class="line">&gt;--</span><br><span class="line">&gt;重量级锁：有实际竞争，且锁竞争时间长。monitor实现。</span><br><span class="line">&gt;Lock: 有三个实现类，ReentrantLock, ReentrantReadWriteLock类中的两个静态内部类ReadLock和WriteLock。</span><br><span class="line">&gt;底层实现为AQS。</span><br><span class="line">&gt;AQS：CLH锁队列(双向链表)+state状态变量，线程通过CAS去改变状态，成功则获取锁成功，失败则进入等待队列，等待被唤醒。</span><br><span class="line">&gt;lock的存储结构：一个int类型状态值（用于锁的状态变更），一个双向链表（用于存储等待中的线程）</span><br><span class="line">&gt;lock获取锁的过程：本质上是通过 CAS 来获取状态值修改，如果当场没获取到，会将该线程放在线程等待链表中。</span><br><span class="line">&gt;lock释放锁的过程：修改状态值，调整等待链表。</span><br><span class="line">&gt;lock()-acquire()-tryAcquire()-未成功获取锁-addwaiter()-acquireQueued()</span><br><span class="line">&gt;acquireQueued的主要作用是把已经追加到队列的线程节点进行阻塞，但阻塞前又通过tryAccquire重试是否能获得锁，如果重试成功能则无需阻塞，直接返回。</span><br></pre></td></tr></table></figure>
</blockquote>
<img src="https://i.loli.net/2021/03/10/qU1w9tpoERWl45b.png" alt="image.png" style="zoom:200%;">

<p>ReebtrantLock</p>
<blockquote>
<p>可重入的互斥锁。可公平可非公平(公平锁会判断当前线程前是否有其他等待线程，有的话就进入等待队列，没有的话才会尝试获取锁，而非公平锁则是直接尝试获取锁)</p>
</blockquote>
<p>ReebtrantReadWriteLock</p>
<blockquote>
<p>支持公平和非公平、可重入、锁降级(获得写锁—获得读锁—释放写锁)，不支持锁升级。</p>
<p>状态变量：高16位标识读，低16位表示写。通过位运算来获得读写的状态。</p>
</blockquote>
<p>BlockingQueue原理</p>
<blockquote>
<p>ArrayBlockingxxx, LinkedBlockingxxx, PriorityBlockingxxx, Delayxxx(延时获取元素), Synchronousxxx(不存储元素), LinkedTransferxxx(无界), LinkedBlockingDeque</p>
<p>处理方式：抛出异常(add)、返回特殊值(offer)、一直阻塞(put、超时退出(offer(e, time, unit))</p>
<p>使用Condition + LockSupport实现。</p>
</blockquote>
<p>线程池</p>
<blockquote>
<p>Executors的几个静态方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">newFixedThreadPool() 阻塞队列无限，会OOM</span><br><span class="line">newSingleThreadExecutor() 阻塞队列无限，会OOM</span><br><span class="line">newCachedThreadPool() 最大线程数为Integer.MAX 也会OOM</span><br></pre></td></tr></table></figure>

<p>自定义线程池参数的设置(cpu密集 or io密集)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cpu使用率较高（也就是一些复杂运算，逻辑处理），所以线程数一般只需要cpu核数的线程就可以了，减少上下文切换</span><br><span class="line">cpu使用率较低，程序中会存在大量I/O操作占据时间，导致线程空余时间出来，所以通常就需要开cpu核数的两倍的线程， 当线程进行I/O操作cpu空暇时启用其他线程继续使用cpu，提高cpu使用率 </span><br></pre></td></tr></table></figure>

<p>核心线程数、最大线程数、存活时间、时间单位、阻塞队列、创建线程的工厂、拒绝策略</p>
<p>拒绝策略：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AbortPolicy：默认的策略，直接抛出 RejectedExecutionException 异常，阻⽌系统正常运⾏。</span><br><span class="line">CallerRunsPolicy：既不会抛出异常，也不会终⽌任务，⽽是将任务返回给调⽤者，从⽽降低新任务的流量。</span><br><span class="line">DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加⼊队列中尝试再次提交任务。</span><br><span class="line">DiscardPolicy：该策略默默地丢弃⽆法处理的任务，不予任何处理也不抛出异常。如果允许任务丢失，这是最好的⼀种策略。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>读写锁的实现类</p>
<blockquote>
<p>ReentrantReadWriteLock、ReadWriteLockView in StampedLock</p>
</blockquote>
<p>公平锁和非公平锁</p>
<blockquote>
<p>公平锁保证了FIFO原则但是耗费大量资源在上下文切换，而非公平锁则保证了极大的吞吐量和效率，但可能造成饥饿。</p>
</blockquote>
<p>CAS</p>
<blockquote>
<p>compareAndSet，自旋保证原子操作，和volatile关键字配合使用。</p>
</blockquote>
<p>重排序</p>
<blockquote>
<p>volatile，内存屏障。final</p>
</blockquote>
<p>AQS</p>
<blockquote>
<p>acquire方法中：tryAcquire()—失败—addWaiter()加入等待队列—addQueued()再尝试一次失败就阻塞。</p>
<p>只有前节点唤醒或者中断才会继续执行。</p>
</blockquote>
<p>volatile</p>
<blockquote>
<p>内存屏障保证有序性，总线嗅探机制保证可见性。</p>
<p>伪共享：volatile修饰变量需要更新时，其他和volatile修饰变量在同一缓存行的变量也需要重新获取，性能降低。通过添加一些long的变量来填充缓存行。</p>
</blockquote>
<p>创建线程的方式</p>
<blockquote>
<p>①继承自Thread重写run方法②实现Runnable接口并实现run方法③实现Callerable接口，实现call方法，可有返回值</p>
</blockquote>
<p>TLAB</p>
<blockquote>
<p>缺省情况下仅占有整个Eden空间的1%</p>
</blockquote>
<p>LockSupport</p>
<blockquote>
<p>park()、unpark(Thread t)、parkNaos、parkUtil</p>
</blockquote>
<p>Condition接口</p>
<blockquote>
<p>await方法原理：将当前获得锁的线程从同步队列移到等待队列最后，并且释放同步状态。</p>
<p>signal：将当前condition对应的等待队列的首节点放入到同步队列最后，然后通过unpark唤醒线程，进而线程通过acquireQueued方法尝试获取同步状态。</p>
</blockquote>
<p>乐观锁、悲观锁：</p>
<blockquote>
<p>容易发生冲突且冲突量大时使用悲观锁，否则乐观锁(多读少写)。</p>
<p>数据库等适合悲观锁。</p>
</blockquote>
<p>concurrent包下有哪些：</p>
<blockquote>
<p>java.util.concurrent包下包含：tools、locks、collections、executor、atomic</p>
<p>其中tools包含CountDownLatch、Semaphore、Executors、Exchanger等等</p>
<p>locks则是包含了Lock、Condition、LockSupport、ReadWriteLock</p>
<p>collections则是一些支持并发的集合：阻塞队列、ConcurrentHashMap、ConcurrentSkipList等等</p>
<p>executors则是线程池，atomic为原子类。</p>
</blockquote>
<p>Java线程的通信方式</p>
<blockquote>
<p>volatile</p>
<p>等待/通知机制</p>
<p>join方式</p>
<p>threadLocal</p>
</blockquote>
<p>ThreadLoacl 类、内存泄漏（key是弱引用 ，value是强引用） 每次使用后remove。</p>
<blockquote>
<p>由于Thread中包含变量ThreadLocalMap，因此ThreadLocalMap与Thread的生命周期是一样长，如果都没有手动删除对应key，都会导致内存泄漏。</p>
<p>但是使用<strong>弱引用</strong>可以多一层保障：弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用set(),get(),remove()【源码保证】的时候会被清除。</p>
<p>因此，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。</p>
<p>解决方案：</p>
<ul>
<li>每次使用完ThreadLocal都调用它的remove()方法清除数据</li>
<li>将ThreadLocal变量定义成private static，这样就一直存在ThreadLocal的强引用，也就能保证任何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进而清除掉 。</li>
</ul>
</blockquote>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>JVM内存结构</p>
<blockquote>
<p>class文件——类加载子系统——运行时数据区(方法区、堆、虚拟机栈、本地方法栈、PC寄存器)——执行引擎——本地方法库</p>
</blockquote>
<p>垃圾回收算法</p>
<blockquote>
<p>标记-清除、标记-整理、复制算法</p>
<p>垃圾回收器：CMS、G1、ParNew、Serial Old、Parellel Old</p>
</blockquote>
<p>类加载过程</p>
<blockquote>
<p>加载(已经存在Class对象)——链接(验证、准备、解析，准备阶段对类变量赋默认值)——初始化(clinit方法)</p>
</blockquote>
<p>类加载机制</p>
<blockquote>
<ul>
<li>隐式加载 new 创建类的实例,</li>
<li>显式加载：loaderClass,forName等</li>
<li>访问类的静态变量，或者为静态变量赋值</li>
<li>调用类的静态方法</li>
<li>使用反射方式创建某个类或者接口对象的Class对象。</li>
<li>初始化某个类的子类</li>
<li>直接使用<code>java.exe</code>命令来运行某个主类</li>
</ul>
</blockquote>
<p>双亲委派模型</p>
<blockquote>
<p>1) 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类豳加载器去执行;<br>2) 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器<br>3) 如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。 </p>
</blockquote>
<p>破坏双亲委派机制</p>
<blockquote>
<p>在Java应用中存在着很多服务提供者接口（Service Provider Interface，SPI），这些接口允许第三方为它们提供实现，如常见的 SPI 有 JDBC、JNDI等，这些 SPI 的接口属于 Java 核心库，一般存在rt.jar包中，由Bootstrap类加载器加载，而 SPI 的第三方实现代码则是作为Java应用所依赖的 jar 包被存放在classpath路径下，由于SPI接口中的代码经常需要加载具体的第三方实现类并调用其相关方法，但SPI的核心接口类是由引导类加载器来加载的，而Bootstrap类加载器无法直接加载SPI的实现类，同时由于双亲委派模式的存在，Bootstrap类加载器也无法反向委托AppClassLoader加载器SPI的实现类。在这种情况下，我们就需要一种特殊的类加载器来加载第三方的类库，而线程上下文类加载器就是很好的选择。</p>
<p>线程上下文类加载器（contextClassLoader）是从 JDK 1.2 开始引入的，我们可以通过java.lang.Thread类中的getContextClassLoader()和 setContextClassLoader(ClassLoader cl)方法来获取和设置线程的上下文类加载器。如果没有手动设置上下文类加载器，线程将继承其父线程的上下文类加载器，初始线程的上下文类加载器是系统类加载器（AppClassLoader）,在线程中运行的代码可以通过此类加载器来加载类和资源</p>
</blockquote>
<p>沙箱安全机制</p>
<blockquote>
<p>假如自定义java.lang.String类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件(rt.jar包中java\lang\String.class)，报错信息说没有main方法，就是因为加载的是rt.jar包中的String类。这样可以保证对java核心源代码的保护，这就是<strong>沙箱安全机制</strong>。</p>
</blockquote>
<p>ClassLoader的方法</p>
<blockquote>
<p>getParent()获取父加载器、loadClass(String name)加载指定name的类并返回Class对象、findClass(String name)查找指定name的类并返回Class对象、 findLoadedClass(String name)查找已经加载的类并返回、defineClass(String name, byte[] b, int off, int len)将字节数组中的内容转换为一个类、resolveClass(Class&lt;?&gt; c)链接指定的一个类。</p>
<p>遵循双亲委派——重写findClass方法即可、打破双亲委派——重写loadClass方法</p>
</blockquote>
<p>OOM如何分析，一些分析工具，常用命令</p>
<blockquote>
<p>jvisualVM、jprofiler</p>
<p>jmap、jflag、jinfo、jstate</p>
</blockquote>
<p>堆和栈的区别</p>
<blockquote>
<p>堆中存在OOM和GC，栈中只存在OOM。堆是存储的单位，栈是运行时的单位。</p>
</blockquote>
<p>对象头</p>
<blockquote>
<p>MarkWord(hashcode、锁标志位、分代年龄、是否偏向锁、偏向线程id等等)</p>
<p>元数据指针(指向方法区的类型数据信息)</p>
<p>数组长度(如果是数组的话)</p>
</blockquote>
<p>对象实例化过程</p>
<blockquote>
<p>①查看对应的类信息是否加载②计算所需内存并分配空间③并发问题(CAS)分配TLAB④默认初始化⑤设置对象头⑥显示初始化</p>
</blockquote>
<p>NIO</p>
<blockquote>
<p>直接内存，DirectByteBuffer操作本地内存，没有中间状态。IO多路复用</p>
</blockquote>
<p>String不可变原理：</p>
<blockquote>
<p>final修饰char数组(jdk9后采用byte数组)。</p>
<p>原因：①字符串常量池②String缓存了自身的hashcode，如果可变但hash没变，散列会存在问题③String会作为参数</p>
<p>StringBuffer线程安全，synchronized修饰，StringBuilder性能更高。</p>
</blockquote>
<p>String str1=”a”；String str2=”a”+”bc”;</p>
<blockquote>
<p>都在字符串常量池中创建一个对象。</p>
<p>String a = new String(“11”)+new String(“22”);创建了几个对象？</p>
<p>new String(“xx”)都会创建两个对象，然后如果+两边存在变量，那么都会存在一个StringBuilder对象，StirngBuilder还会通过toString方法再创建一个对象。</p>
</blockquote>
<p>ClassNotFoundException场景</p>
<blockquote>
<p>1、调用class的forName方法时，找不到指定的类<br>2、ClassLoader 中的 findSystemClass() 方法时，找不到指定的类<br>3、ClassLoader 中的 loadClass() 方法时，找不到指定的类</p>
</blockquote>
<p>GC ROOTS</p>
<blockquote>
<p>在Java语言中，GC Roots包括以下几类元素：</p>
<p>①虚拟机栈中引用的对象。比如：各个线程被调用的方法中使用到的参数、局部变量等。<br>②本地方法栈内JNI(通常说的本地方法)引用的对象<br>③方法区中类静态属性引用的对象。比如: Java类的引用类型静态变量<br>④方法区中常量引用的对象。比如:字符串常量池（string Table）里的引用<br>⑤所有被同步锁synchronized持有的对象<br>⑥Java虚拟机内部的引用。基本数据类型对应的class对象，一些常驻的异常对象（如:NullPointerException、OutOfMemoryError）、系统类加载器<br>⑦反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。<br>⑧在某些特殊情况下，还可能存在一些对象临时加入到Root中的情况。(如：在分代垃圾收集时，如果只回收新生代的对象，那么一些老年代的对象也可以作为Root)</p>
</blockquote>
<p>OOM排查</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1、先查看应用进程号pid: ps -ef | grep 应用名</span><br><span class="line">2、查看pid垃圾回收情况: jstat -gc pid 5000（时间间隔）</span><br><span class="line">3、开启OOM快照: </span><br><span class="line">	-XX：+HeapDumpOnOutOfMemoryError（开启堆快照）</span><br><span class="line">	-XX：HeapDumpPath=C:/m.hprof（保存文件到哪个目录）</span><br><span class="line">4、dump 查看方法栈信息：</span><br><span class="line">	jstack -l pid &gt; /home/test/jstack.txt</span><br><span class="line">5、dump 查看JVM内存分配以及使用情况</span><br><span class="line">	jmap -heap pid &gt; /home/test/jmapHeap.txt</span><br><span class="line">6、dump jvm二进制的内存详细使用情况 </span><br><span class="line">	jmap -dump:format=b,file=/home/test/oom.hprof pid</span><br></pre></td></tr></table></figure>


</blockquote>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>java连接数据库 jdbc原生</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">conn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String URL = <span class="string">"jdbc:mysql://127.0.0.1:3306/Supermarket?characterEncoding=utf-8"</span>;</span><br><span class="line">		String USER = <span class="string">"root"</span>;</span><br><span class="line">		String PASSWORD = <span class="string">"123"</span>;</span><br><span class="line">		<span class="comment">// 1.加载驱动程序</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">			<span class="comment">// 2.获得数据库链接</span></span><br><span class="line">			Connection conn = DriverManager.getConnection(URL, USER, PASSWORD);</span><br><span class="line">			<span class="comment">// 3.通过数据库的连接操作数据库，实现增删改查（使用Statement类）</span></span><br><span class="line">			String name=<span class="string">"张三"</span>;</span><br><span class="line">			<span class="comment">//预编译</span></span><br><span class="line">			String sql=<span class="string">"select * from userinfo where UserName=?"</span>;</span><br><span class="line">			PreparedStatement statement = conn.prepareStatement(sql);</span><br><span class="line">			statement.setString(<span class="number">1</span>, name);</span><br><span class="line">			ResultSet rs = statement.executeQuery();</span><br><span class="line"><span class="comment">//			String sql="select * from userinfo where UserName='"+name+"'";</span></span><br><span class="line"><span class="comment">//			Statement statement = conn.createStatement();			</span></span><br><span class="line"><span class="comment">//			ResultSet rs = statement.executeQuery(sql);</span></span><br><span class="line">			<span class="comment">// 4.处理数据库的返回结果(使用ResultSet类)</span></span><br><span class="line">			<span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">				System.out.println(rs.getString(<span class="string">"UserName"</span>) + <span class="string">" "</span> + rs.getString(<span class="string">"Password"</span>));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">		conn.close();</span><br><span class="line">		rs.close();</span><br><span class="line">		statement.close();			</span><br><span class="line">	&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;			</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (SQLException e) &#123;			</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<p>IOC AOP</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">IOC: Inversion of Control，控制反转</span><br><span class="line">DI: Dependency Injection，依赖注入</span><br><span class="line">关系：IOC是一种面向编程设计思想，DI是IOC思想的实现方式，即：DI实现IOC这一思想</span><br><span class="line">A需要B，A不直接控制B，A给IOC容器需要的信息，然后IOC容器为A创建B。</span><br><span class="line">主动获取反转为被动获取，解耦。</span><br><span class="line"></span><br><span class="line">AOP: jdk or cglib</span><br><span class="line">JDK动态代理主要涉及java.lang.reflect包下边的两个类：Proxy和InvocationHandler。其中，InvocationHandler是一个接口，可以通过实现该接口定义横切逻辑，并通过反射机制调用目标类的代码，动态地将横切逻辑和业务逻辑贬值在一起。</span><br><span class="line">所以使用JDK动态代理的话，他有一个限制，就是它只能为接口创建代理实例，而对于没有通过接口定义业务方法的类，如何创建动态代理实例呢？答案就是CGLib。</span><br><span class="line">CGLib采用底层的字节码技术，全称是：Code Generation Library，CGLib可以为一个类创建一个子类，在子类中采用方法拦截的技术拦截所有父类方法的调用并顺势织入横切逻辑。</span><br><span class="line">在spring中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">JDK的动态代理</span><br><span class="line">	final Advice advice = new Advice();   // 获得增强对象</span><br><span class="line">    final Target target = new Target();</span><br><span class="line">    // 返回值就是生成的动态代理对象</span><br><span class="line">    TargetInterface proxy = (TargetInterface) Proxy.newProxyInstance(</span><br><span class="line">            target.getClass().getClassLoader(), // 目标对象的类加载器</span><br><span class="line">            target.getClass().getInterfaces(),  // 目标对象相同的接口字节码对象数组</span><br><span class="line">            new InvocationHandler() &#123;</span><br><span class="line">                // 调用代理对象的任何方法，实质执行的为invoke方法</span><br><span class="line">                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">                    advice.before();// 前置增强</span><br><span class="line">                    method.invoke(target, args);// 执行目标方法</span><br><span class="line">                    advice.after();</span><br><span class="line">                    return null; // 该返回值对于方法本身而言 无意义</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    );</span><br><span class="line">    proxy.save();   // 调用代理对象的方法</span><br><span class="line">cglib的动态代理</span><br><span class="line">	final Advice advice = new Advice();   // 获得增强对象</span><br><span class="line">    final Target target = new Target();</span><br><span class="line">    // 返回值就是生成的动态代理对象 基于cglib</span><br><span class="line">    // 1.创建增强器</span><br><span class="line">    Enhancer enhancer = new Enhancer();</span><br><span class="line">    // 2.设置父类 (目标)</span><br><span class="line">    enhancer.setSuperclass(Target.class);</span><br><span class="line">    // 3.设置回调</span><br><span class="line">    enhancer.setCallback(new MethodInterceptor() &#123;</span><br><span class="line">        public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">            advice.before(); // 执行前置</span><br><span class="line">            Object invoke = method.invoke(target, args);</span><br><span class="line">            advice.after(); // 执行后置</span><br><span class="line">            return invoke;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    // 4.生成代理对象</span><br><span class="line">    Target proxy = (Target) enhancer.create();</span><br><span class="line"></span><br><span class="line">    proxy.save();</span><br></pre></td></tr></table></figure>


</blockquote>
<p>Spring加载bean的流程</p>
<blockquote>
<p>class对象——实例化得到原始bean对象——属性注入——初始化——放入单例池——销毁</p>
</blockquote>
<p>三级缓存与循环依赖</p>
<blockquote>
<p>class对象——实例化——放入三级缓存——属性注入——需要的属性先查找一级缓存、然后查找二级缓存、然后查找三级缓存，放入二级缓存、删除三级缓存。</p>
<p>三级缓存内存存的是函数式接口。</p>
<p>构造器的循环依赖和prototype的循环依赖无法解决。(?)</p>
</blockquote>
<p>Spring、MyBatis整合</p>
<blockquote>
<p>通过注解对mapper接口进行扫描并获得对应包名和接口，然后进行BD的注册，注册完后根据接口类型等信息对BD进行处理，即改变BD生成bean的方式(通过实现BeanFactory的方式来生成)，通过MapperBeanFactory进行后续的bean的生成。</p>
</blockquote>
<p>BeanFactory和FactoryBean</p>
<blockquote>
<p>FactoryBean是一个接口，当在IOC容器中的Bean实现了FactoryBean后，通过getBean(String BeanName)获取到的Bean对象并不是FactoryBean的实现类对象，而是这个实现类中的实现的getObject()方法返回的对象，如下图的MapperFactoryBean。而如果要想获取FactoryBean的实现类，就要getBean(&amp;BeanName)，在BeanName之前加上&amp;。</p>
<p>BeanFactory是一个接口，Spring内部实现了很多类，存放很多东西，如definitionmap、singletonmap等等。BeanFactory是个Factory，也就是IOC容器或对象工厂。在Spring中，所有的Bean都是由BeanFactory(也就是IOC容器)来进行管理的</p>
</blockquote>
<p>@Autowired和@Resource区别</p>
<blockquote>
<p>@Autowired//默认按type注入<br>@Qualifier(“cusInfoService”)//一般作为@Autowired()的修饰用<br>@Resource(name=”cusInfoService”)//默认按name注入，可以通过name和type属性进行选择性注入</p>
</blockquote>
<p>@Inject和@Autowired</p>
<blockquote>
<p>@Inject是Java EE 6（JSR-299）中引入的Java CDI（上下文和依赖项注入）标准的一部分</p>
<p>@Autowired则是Spring框架的一部分。</p>
<p>前者自动装配的bean范围是singleton，后者则是原型</p>
<p>前者和@Named一起使用，后者和@Qualifier一起使用。</p>
</blockquote>
<p>全局异常处理</p>
<blockquote>
<p>继承HandlerExceptionResolver接口，并将实现类作为bean进行注册到Spring，在resolveException中实现处理逻辑。</p>
</blockquote>
<p>SpringBoot怎么在服务端接收到HTTP请求后，再转发到控制层？</p>
<blockquote>
<p>filter-&gt;dispatchServlet(doService-&gt;doDispath)-&gt;intercepter(prehandle拦截器)-&gt;RequestMappingHandler(查找映射)-&gt;ServletInvocableHandlerMethod: invokeAndHandle(参数处理)-&gt;通过java 反射机制动态调用目标API方法进入相对应具体的controller-&gt;执行 handleReturnValue 方法， 首先会判断是否需要对response entity 进行二次处理（ResponseBodyAdvice: beforeBodyWrite）， 处理完成后， 调用注册进来的MessageConvertor 对返回信息进行转换处理， 比如使用faster Jackson 把对象类型转成 json 字符串，并以application/json 的形式返回 http response -&gt; 拦截器 postHandle 方法， 最后执行拦截器的afterCompletion 方法。</p>
<p>按照 Servlet 规范，所有请求都会被tomcat容器交到 dispatchServlet 的 doService 方法中去处理。跟到这个方法中去，我们发现其中设置了变量进 request 对象，然后执行了 doDispatch 方法，这个方法才是真正实现请求处理的核心。</p>
<p>该doDispatch方法中调用 getHandler 找到 url 匹配的 handler 方法（示例代码中的 hello 方法）。然后调用 ha.handle() 来获得处理结果。</p>
<p>对于getHandler 方法，是通过 HandlerMapping 接口对象的集合对象来操作的。HandlerMapping 接口要求实现类实现从请求到处理对象的映射的方法。以 RequestMappingHandlerMapping 实现为例，它底层注册了一个 url -&gt; handler方法的 map，每当请求过来，就会根据请求的url 去 map 中匹配，匹配到对应的handler 方法。</p>
</blockquote>
<p>Spring中的设计模式</p>
<blockquote>
<p>简单工厂模式——BeanFactory</p>
<p>工厂方法模式——FactoryBean</p>
<p>单例模式——单例池，bean(singleton)</p>
<p>适配器模式——AOP</p>
<p>包装器模式——Wrapper、Decorator</p>
<p>代理模式——AOP动态代理</p>
<p>观察者模式——</p>
<p>策略模式——</p>
</blockquote>
<h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><p>什么是MVC</p>
<blockquote>
<p>Controller（控制器）、Model（业务模型）、View（用户视图）实现代码分离，Controller用于同步Model和View</p>
</blockquote>
<p>SpringMVC流程</p>
<blockquote>
<p>（1）用户发送请求至前端控制器DispatcherServlet；<br>（2） DispatcherServlet收到请求后，调用HandlerMapping处理器映射器，请求获取Handle；<br>（3）处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet；<br>（4）DispatcherServlet 调用 HandlerAdapter处理器适配器；<br>（5）HandlerAdapter 经过适配调用 具体处理器(Handler，也叫后端控制器)；<br>（6）Handler执行完成返回ModelAndView；<br>（7）HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet；<br>（8）DispatcherServlet将ModelAndView传给ViewResolver视图解析器进行解析；<br>（9）ViewResolver解析后返回具体View；<br>（10）DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）<br>（11）DispatcherServlet响应用户。</p>
<p><img src="https://i.loli.net/2021/03/22/CAafT92nKwky5jU.png" alt="image.png"></p>
</blockquote>
<p>SpringMVC实现返回json</p>
<blockquote>
<p>通过一些json框架如(Jackson)，并在方法前加上@ResponseBody即可</p>
</blockquote>
<p>解决post、get乱码问题</p>
<blockquote>
<p>post：在web.xml中配置一个CharacterEncodingFilter过滤器，设置成utf-8；</p>
<p>get：①修改tomcat配置文件添加编码与工程编码一致；②对传过来的参数进行重新编码</p>
</blockquote>
<p>SpringMVC异常处理</p>
<blockquote>
<p>可以将异常抛给Spring框架，由Spring框架来处理；我们只需要配置简单的异常处理器，在异常处理器中添视图页面即可。</p>
</blockquote>
<p>SpringMVC控制器</p>
<blockquote>
<p>是单例的，多线程存在线程安全问题，不使用同步，会影响性能，在控制器中不写字段来保证线程安全。</p>
</blockquote>
<p>SpringMVC常用注解</p>
<blockquote>
<p>@RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。<br>@RequestBody：注解实现接收http请求的json数据，将json转换为java对象。<br>@ResponseBody：注解实现将conreoller方法返回对象转化为json对象响应给客户。</p>
<p>@Controller、@RestController(@Controller + @ResponseBody)</p>
</blockquote>
<p>如何在方法中得到session、request对象</p>
<blockquote>
<p>直接在方法中声明这个对象，SpringMvc就自动会把属性赋值到这个对象里面。</p>
</blockquote>
<p>SpringMvc用什么对象从后台向前台传递数据的？</p>
<blockquote>
<p>通过ModelMap对象，可以在这个对象里面调用put方法，把对象加到里面,前台就可以通过el表达式拿到。</p>
</blockquote>
<p>怎么样把ModelMap里面的数据放入Session里面？</p>
<blockquote>
<p>可以在类上面加上@SessionAttributes注解，里面包含的字符串就是要放入session里面的key。</p>
</blockquote>
<p>SpringMvc里面拦截器是怎么写的？</p>
<blockquote>
<p>有两种写法，一种是实现HandlerInterceptor接口，另外一种是继承适配器类，接着在接口方法当中，实现处理逻辑；然后在SpringMVC的配置文件中配置拦截器即可</p>
</blockquote>
<p>注解原理</p>
<blockquote>
<p>注解本质是一个继承了<code>Annotation</code>的特殊接口，其具体实现类是<code>Java</code>运行时生成的动态代理类。我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象。通过代理对象调用自定义注解的方法，会最终调用<code>AnnotationInvocationHandler</code>的<code>invoke</code>方法。该方法会从<code>memberValues</code>这个<code>Map</code>中索引出对应的值。而<code>memberValues</code>的来源是<code>Java</code>常量池。</p>
</blockquote>
<p>Controller局部异常处理</p>
<blockquote>
<p>①在某个方法上方使用@ExceptionHandler()注解，并给出想要处理的异常类型，然后该方法就会作为该Controller的异常处理方法</p>
<p>②定义一个异常处理类，并使用@ControllerAdvice()注解修饰，并给出想要处理的Controller，可以传入一个接口class对象，表示实现了该接口的Controller的异常都由该异常类处理，内部的exceptionHandler和方法①一致。</p>
</blockquote>
<h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><p>配置文件装载顺序</p>
<blockquote>
<p>①application.properties优先级大于application.yml<br>②先去项目根目录找config文件夹下找配置文件件；再去根目录下找配置文件；去resources下找cofnig文件夹下找配置文件；去resources下找配置文件<br>③如果高优先级的配置文件和低优先级的配置文件中属性不冲突，则可以实现互补配置。<br>④外部配置：如cmd命令，或者系统属性System.getProperties()；同样可以形成互补配置</p>
</blockquote>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>单线程原因：</p>
<blockquote>
<ol>
<li>单线程编程容易并且更容易维护；</li>
<li>Redis 的性能瓶颈不再 CPU ，主要在内存和网络；</li>
<li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li>
</ol>
</blockquote>
<p>缓存淘汰策略</p>
<blockquote>
<p>lru(最近最少未使用)、ttl(时间)、lfu(使用频率)、不驱逐</p>
</blockquote>
<p>布隆过滤器原理</p>
<blockquote>
<p>bitmap + 多次hash</p>
<p>对于hash结果不正确的，一定不存在。反之则不是，可能存在也可能不存在。</p>
</blockquote>
<p>一致性hash</p>
<blockquote>
<p>hash环(对2^32而不是一个固定值进行hash)，保证即使hash结果数要求发生变化，只用改变hash环上的分割即可。可使用虚拟节点进行hash环分配不均的改良。</p>
<p>虚拟节点即将单个节点虚拟为多个节点，使得数据能够平均分布在各个节点上。</p>
</blockquote>
<p>持久化机制</p>
<blockquote>
<p>AOF、RDB</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;RDB其实就是把数据以快照的形式保存在磁盘上。什么是快照呢，你可以理解成把当前时刻的数据拍成一张照片保存下来。Redis调forks。同时拥有父进程和子进程。子进程将数据集写入到一个临时RDB文件中。当子进程完成对新RDB文件的写入时，Redis用新RDB文件替换原来的RDB文件，并删除旧的RDB文件。</span><br><span class="line">&gt;RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。也是默认的持久化方式，这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为dump.rdb。</span><br><span class="line">&gt;三种触发机制save、bgsave、自动化。</span><br><span class="line">save: 阻塞redis，用新的RDB替换旧的并直到过程完成才继续</span><br><span class="line">bgsave: Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。具体操作是Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。基本上 Redis 内部所有的RDB操作都是采用bgsave命令。</span><br><span class="line">自动化：更改配置文件，它在“N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动进行数据集保存操作。</span><br><span class="line">&gt;RDB是一个非常紧凑的文件，方便传输</span><br><span class="line">&gt;快照持久化期间修改的数据不会被保存，可能丢失数据。</span><br><span class="line">&gt;----------------------------------------------------------------------------------------------------</span><br><span class="line">&gt;AOF：redis会将每一个收到的写命令都通过write函数追加到文件中。通俗的理解就是日志记录。每当Redis执行一个改变数据集的命令时（比如 SET）， 这个命令就会被追加到AOF文件的末尾。这样的话， 当Redis重新启时， 程序就可以通过重新执行AOF文件中的命令来达到重建数据集的目的</span><br><span class="line">&gt;为了压缩aof的持久化文件。redis提供了bgrewriteaof命令。将内存中的数据以命令的方式保存到临时文件中，同时会fork出一条新进程来将文件重写。</span><br><span class="line">&gt;每次修改同步always：同步持久化，每次发生数据变更会被立即记录到磁盘，性能较差但数据完整性比较好</span><br><span class="line">&gt;每秒同步everysec：异步操作，每秒记录 如果一秒内宕机，有数据丢失</span><br><span class="line">&gt;不同no：从不 fsync ：将数据交给操作系统来处理，由操作系统来决定什么时候同步数据。更快，也更不安全的选择。</span><br><span class="line">&gt;AOF重写：因为 AOF 的运作方式是不断地将命令追加到文件的末尾， 所以随着写入命令的不断增加， AOF 文件的体积也会变得越来越大。举个例子， 如果你对一个计数器调用了 100 次 INCR ， 那么仅仅是为了保存这个计数器的当前值， AOF 文件就需要使用 100 条记录（entry）。然而在实际上， 只使用一条 SET 命令已经足以保存计数器的当前值了， 其余 99 条记录实际上都是多余的。</span><br><span class="line">&gt;为了处理这种情况， Redis 支持一种有趣的特性： 可以在不打断服务客户端的情况下， 对 AOF 文件进行重建（rebuild）。执行 bgrewriteaof 命令， Redis 将生成一个新的 AOF 文件， 这个文件包含重建当前数据集所需的最少命令。</span><br></pre></td></tr></table></figure>

<p>Redis 持久化 之 AOF 和 RDB 同时开启，Redis听谁的？</p>
<blockquote>
<p>AOF</p>
</blockquote>
</blockquote>
<p>缓存雪崩、缓存击穿、缓存穿透</p>
<blockquote>
<p>缓存雪崩是指缓存同一时间大面积的失效（也可能为redis重启），所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p>缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。(一般出现于被攻击或者电商中高并发的场景)</p>
<p>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发<strong>查同一条数据</strong>，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p>
</blockquote>
<p>底层数据结构</p>
<blockquote>
<p><strong>字符串</strong>：SDS（char数组buf + len + 未使用的空间大小free），可以动态扩容(预分配)，惰性空间释放(改变free的值而非回收内存)。</p>
<p><strong>链表</strong>：双向链表，表头前置为null，表尾后置为null</p>
<p><img src="https://i.loli.net/2021/03/22/ycSbiXY1DC9edHO.png" alt="image.png"></p>
<p><strong>字典</strong>：新增时，先根据键值对的键计算出哈希值，然后根据 sizemask 属性和哈希值，计算索引值——即落入数组中的哪个位置。之后如果有一个位置多个键值对要存入时，组成单向链表即可。</p>
<p>这里和 HashMap 的不同之处在于，链表添加时总是添加在表头位置。因为 dictEntry 节点组成的链表没有指向链表表尾的指针，为了速度考虑，总是将新节点加在链表的表头位置。（为什么要这样，而不是遍历完整个链表后加在链表尾部，不遍历出现重复键怎么办？）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;rehash:</span><br><span class="line">&gt;rehash 也可以参考 Java 中 HashMap 的原理。</span><br><span class="line">&gt;负载因子 = 哈希表中已保存的节点数量 / 哈希表数组大小。</span><br><span class="line">&gt;当哈希表中存放的键值对不断增多或减少，为了让负载因子在一个合理的范围内，需要对大小进行扩展或者收缩。（这里类似 HashMap 中的重新散列方法）</span><br><span class="line">&gt;1. 字典的 ht[1] 分配空间，空间的大小由 ht[0] 已经使用的键值对数量以及执行的扩张和收缩来决定。</span><br><span class="line">- 扩展操作，那么 ht[1] 分配的空间大小应是比当前 ht[0].used 值的二倍大的第一个 2 的整数幂。（比如当前使用空间 14，那么找 28 的下一个 2 的整数幂，为 32）</span><br><span class="line">- 收缩操作，取 ht[0].used 的第一个大于等于的 2 的整数幂。（比如 14，那么就是 16）</span><br><span class="line">&gt;2. 将 ht[0] 中的所有键值对，rehash 到 ht[1] 上面：根据新的大小来重新计算所有键的哈希和索引，映射到新数组的指定位置上。</span><br><span class="line">&gt;3. ht[0] 的所有键值对都迁移到 ht[1] 之后，释放 ht[0] ，然后将 ht[1] 设置为 ht[0] ，然后在 ht[1] 处新创建空白哈希表，为下一次 rehash 做准备。</span><br><span class="line">&gt;扩展的条件</span><br><span class="line">服务器没有执行 BGSAVE 或者 BGREWRITEAOF 命令，并且哈希表的负载因子大于等于 1 。</span><br><span class="line">服务器正在执行 BGSAVE 或者 BGREWRITEAOP 命令，并且哈希表的负载因子大于等于 5 。</span><br><span class="line">&gt;这两种情况根据是否有后台命令执行来区分，是因为在执行 BGSAVE 或者 BGREWRITEAOF 的过程中，Redis 需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制（copy-on-write）技术来优化子进程的使用效率。所以在子进程存在期间，服务器会提高执行扩展操作所需的负载因子，尽可能避免在子进程存在期间进行哈希表的扩展操作，来避免不必要的内存写入操作，最大限度的节省内存。</span><br><span class="line">&gt;收缩的条件</span><br><span class="line">&gt;当哈希表的负载因子小于 0.1 时，自动开始对哈希表进行收缩操作。</span><br><span class="line">&gt;渐进式rehash:</span><br><span class="line">&gt;如果键值对量巨大时，一次性全部 rehash 必然造成一段时间的停止服务。所以要分多次、渐进式的将键值对从 ht[0] 慢慢的 rehash 到 ht[1] 中。</span><br><span class="line">&gt;具体过程：</span><br><span class="line">&gt;1. 为 ht[1] 分配空间，同时有 ht[0] 和 ht[1] 两个哈希表。</span><br><span class="line">&gt;2. 在字典中维持一个索引计数器变量 rehashindex ，并将其置为 0 ，表示 rehash 正式开始。</span><br><span class="line">&gt;3. 在 rehash 期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作之外，还会顺便将 ht[0] 哈希表在 rehashindex 索引上的所有键值对 rehash 到 ht[1] 上，当 rehash 工作完成之后，程序将 rehashindex 的值加一。</span><br><span class="line">&gt;4. 随着字典操作的不断进行，最终在某个时间点，ht[0] 的所有键值对都被 rehash 到 ht[1] ，这时程序将 rehashindex 的值置为 -1 ，表示 rehash 工作完成。</span><br><span class="line">&gt;渐进式 rehash 的过程中，更新删除查找等都会在两个哈希表上进行，比如查找，先在 ht[0] 中查找，如果没找到，就去 ht[1] 中查找。而新增操作，直接新增在 ht[1] 中，ht[0] 不会进行任何的新增操作。保证 ht[0] 的数量只减不增，最终变为空表。</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/03/22/gAHwEQy36MCmIZ8.png" alt="image.png"></p>
<p><strong>跳表</strong>：跳跃表是一种有序数据结构，通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。Redis 使用跳跃表作为有序集合键的底层实现之一。<br>跳跃表在 Redis 中，只有两个地方用到：一个是实现有序集合对象，另一个是在集群节点中用作内部数据结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;head：指向跳跃表的表头节点。</span><br><span class="line">&gt;tail：指向跳跃表的表尾节点。</span><br><span class="line">&gt;level：记录当前跳跃表中，层数最高的节点的层数（表头节点的层数不计算）。</span><br><span class="line">&gt;length：记录跳跃表的长度，即包含节点的数量。</span><br><span class="line">&gt;level：每一层都有前进指针和跨度，从头到尾遍历时，访问会沿着层的前进指针进行。</span><br><span class="line">&gt;BW：后退指针，指向前一个节点，从尾到头遍历时使用。</span><br><span class="line">&gt;score：分值，跳跃表中的分值按从小到大排列。</span><br><span class="line">&gt;obj：成员对象，各个节点保存有各个成员对象。</span><br></pre></td></tr></table></figure>



<p><img src="https://i.loli.net/2021/03/22/MIchbjWmDHw1S5E.png" alt="image.png"></p>
<p><strong>整数集合</strong>：整数集合是集合键的底层实现之一。当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis 就会使用整数集合作为集合键的底层实现。<br>整数集合是 Redis 保存整数值的集合的抽象数据结构，可以保存 int16_t ，int32_t ，int64_t 的整数值，并且集合中不会出现重复元素。<br>底层由数组实现，整数集合的每个元素都是数组的一个数组项，各个项在数组中按从小到大排列。length 属性记录了包含的元素数量，即数组的长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;升级:</span><br><span class="line">&gt;当一个新元素添加到整数集合中时，如果新元素类型比整数集合现有的所有元素的类型都要长时，整数集合要先进行升级，然后才能将新元素添加到整数集合中。</span><br><span class="line">&gt;1. 根据新元素类型，扩展整数集合底层数组的大小，并为新元素分配空间。</span><br><span class="line">&gt;2. 将底层数组现有的所有元素都转换成新元素相同的类型，并将类型转换后的元素放置到正确位置上，而且放置过程中需要维持底层数组的有序。</span><br><span class="line">&gt;3. 将新元素添加到底层数组中。</span><br><span class="line">&gt;因为引发升级的新元素的长度肯定比现有所有元素都大，才会出现升级的情况，所以这个值要么大于所有元素，放置的位置就对应新数组的末尾；要么小于所有元素，放置的位置在数组的开头。</span><br><span class="line">&gt;升级可以提高灵活性，不用担心类型错误，可以随意添加不同类型的元素。另外，可以节约内存，只在有需要的时候进行升级。</span><br><span class="line">&gt;另外，整数集合不支持降级操作。</span><br></pre></td></tr></table></figure>

<p><strong>压缩列表</strong></p>
<p>压缩列表（ziplist）是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项并且每个都是小整数值或者长度比较短的字符串时，Redis 就采用压缩列表做底层实现。当一个哈希键只包含少量键值对，并且每个键值对的键和值也是小整数值或者长度比较短的字符串时，Redis 就采用压缩列表做底层实现。</p>
<p>压缩列表是 Redis 为了节约内存而实现的，是一系列特殊编码的连续内存块组成的顺序型数据结构。<br><img src="https://i.loli.net/2021/03/22/dZbBafAUTePKVno.png" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;zlbytes ：4 字节。记录整个压缩列表占用的内存字节数，在内存重分配或者计算 zlend 的位置时使用。</span><br><span class="line">&gt;zltail ：4 字节。记录压缩列表表尾节点记录压缩列表的起始地址有多少个字节，可以通过该属性直接确定表尾节点的地址，无需遍历。</span><br><span class="line">&gt;zllen ：2 字节。记录了压缩列表包含的节点数量，由于只有 2 字节大小，那么小于 65535 时，表示节点数量。等于 65535 时，需要遍历得到总数。</span><br><span class="line">&gt;entry ：列表节点，长度不定，由内容决定。</span><br><span class="line">&gt;zlend ：1 字节，特殊值 0xFF ，用于标记压缩列表的结束。</span><br></pre></td></tr></table></figure>

<p>压缩列表节点保存一个字节数组或者一个整数值。<br>字节数组可以是下列值：</p>
<ul>
<li>长度小于等于 2^6-1 字节的字节数组</li>
<li>长度小于等于 2^14-1 字节的字节数组</li>
<li>长度小于等于 2^32-1 字节的字节数组</li>
</ul>
<p>整数可以是六种长度：</p>
<ul>
<li>4 位长，介于 0 到 12 之间的无符号整数</li>
<li>1 字节长的有符号整数</li>
<li>3 字节长的有符号整数</li>
<li>int16_t 类型整数</li>
<li>int32_t 类型整数</li>
<li>int64_t 类型整数</li>
</ul>
<p>每个压缩列表节点的结构如图：<br><img src="https://i.loli.net/2021/03/22/Q5VpZYUBADC2IfG.png" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;previous_entry_length 属性以字节为单位，记录了压缩列表中前一个节点的长度。该属性的长度可以是 1 字节或者 5 字节。如果前一个节点的长度小于 254 字节，那么该属性长度为 1 字节，保存小于 254 的值。如果前一节点的长度大于等于 254 字节，那么长度需要为 5 字节，属性的第一字节会被设置为 0xFE (254) 之后的 4 个字节保存其长度。</span><br><span class="line">&gt;压缩列表的从表尾到表头遍历：</span><br><span class="line">&gt;1. 首先，有指向压缩列表表尾节点起始地址的指针 p1 （指向表尾节点的指针可以通过指向压缩列表起始地址的指针加上 zltail 属性的值得出）；</span><br><span class="line">&gt;2. 通过用 p1 减去节点的 previous_entry_length 属性，得到前一个节点的起始地址的指针。</span><br><span class="line">&gt;3. 如此循环，最终从表尾遍历到表头节点。</span><br><span class="line">&gt;encoding 属性记录了节点的 content 属性所保存的数据的类型和长度：</span><br><span class="line">&gt;- 一字节、两字节或五字节长，值的最高位为 00、01 或者 10 的是字节数组编码，字节数组的长度由编码除去最高两位之后的其他位记录；</span><br><span class="line">&gt;- 一字节长，值的最高位以 11 开头的是整数编码，这种编码表示保存是整数值，整数值的类型和长度由其他位记录。</span><br><span class="line">&gt;出现新增或删除节点导致 previous_entry_length 1 字节或者 5 字节的长度变化，是连锁更新的问题，但出现几率比较小，而且数量不多的情况下不会对性能造成影响。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>数据结构底层实现</p>
<blockquote>
<p>字符串：①整数——int；②长字符串(大于44【64 - 19(头部) - 1(‘/0’)】字节)——raw；③短字符串(小于44字节)——embstr</p>
<p><img src="https://i.loli.net/2021/03/22/p53zlmPV8FIBZHE.png" alt="image.png"></p>
<p>列表：①满足列表对象所有字符串元素长度都小于64个字节且元素数量小于512——ziplist；②其他使用双向链表</p>
<p>hash：①满足元素数量小于512且所有元素长度小于64字节——ziplist；②哈希表</p>
<p>set：①所有元素都是整数，元素数量小于512——整数列表；②哈希表</p>
<p>zset：①所有元素都是整数，元素数量小于512——整数列表；②跳表</p>
</blockquote>
<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>Docker是一个容器化平台，它以容器的形式将您的应用程序及其所有依赖项打包在一起，以确保您的应用程序在任何环境中无缝运行。</p>
<p>Docker不是虚拟化方法。docker四种状态：运行、已暂停、重新启动、已退出。</p>
<p>DockerFile：FROM—指定基础镜像；LABEL—功能是为镜像指定标签；RUN—运行指定的命令；CMD—容器启动时要运行的命令。</p>
<blockquote>
<p>虽然ADD并且COPY在功能上类似，但是首选COPY。</p>
<p>那是因为它比ADD更易懂。COPY仅支持将本地文件复制到容器中，而ADD具有一些功能（如仅限本地的tar提取和远程URL支持），这些功能并不是很明显。因此，ADD的最佳用途是将本地tar文件自动提取到镜像中</p>
</blockquote>
<p>Docker镜像是Docker容器的源代码，类和对象实例的关系。</p>
<p>docker镜像本质：</p>
<blockquote>
<p>分层文件系统。</p>
<p>centos的镜像很小，复用了os的bootfs，只有其他层。tomcat镜像很大，因为依赖于其他的镜像。</p>
</blockquote>
<h2 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h2><p>选型</p>
<blockquote>
<table>
<thead>
<tr>
<th>MQ</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>RabbitMQ</td>
<td>erlang开发，对消息堆积的支持并不好，当大量消息积压的时候，会导致 RabbitMQ 的性能急剧下降。每秒钟可以处理几万到十几万条消息。</td>
</tr>
<tr>
<td>RocketMQ</td>
<td>java开发，面向互联网集群化功能丰富，对在线业务的响应时延做了很多的优化，大多数情况下可以做到毫秒级的响应，每秒钟大概能处理几十万条消息。</td>
</tr>
<tr>
<td>Kafka</td>
<td>Scala开发，面向日志功能丰富，性能最高。当你的业务场景中，每秒钟消息数量没有那么多的时候，Kafka 的时延反而会比较高。所以，Kafka 不太适合在线业务场景。</td>
</tr>
<tr>
<td>ActiveMQ</td>
<td>java开发，简单，稳定，性能不如前面三个。小型系统用也ok，但是不推荐。推荐用互联网主流的。</td>
</tr>
</tbody></table>
</blockquote>
<p>底层实现</p>
<blockquote>
<p>netty</p>
</blockquote>
<p>文件上传</p>
<blockquote>
<p>断点传输、文件秒传(已经上传过的不再上传)：hash</p>
</blockquote>
<p>文件传输粘包问题</p>
<blockquote>
<p>为何粘包：</p>
<p>A. TCP协议为了提高传输效率，发送方往往需要收集定量的数据才会封装给底层并发送，若出现连续send(data)，TCP会把该数据进行整合(直到装满数据缓冲区），这样就造成了粘包数据；<br>B. 接收方接收方的粘包是由于接收用户相关进程不及时接收数据，从而导致粘包问题，这是因为接收方先把接收到的数据放在系统接受缓冲区，用户进程从该缓冲区取定量的数据，但若下一包数据到达前，缓冲区的数据没有及时的被用户进程取走，则下一包数据与前一包部分数据在系统缓冲区，就可能导致用户设定的进程缓冲区从系统缓冲区取走两个包的部分数据，从而导致粘包</p>
<p>解决方案：</p>
<p>A 发送方在send()之前，先向接收方发送数据总量大小，并通过双端确认，server端发送数据包，然后接收方通过按数据量大小循环设立缓冲区接收数据;；<br>B: TCP提供了PUSH（强制数据立即传送）操作，但影响性能；</p>
</blockquote>
<p>传输文件的方式</p>
<blockquote>
<p>ftp、sftp</p>
</blockquote>
<p>事务消息：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">问题：</span><br><span class="line">1、账号服务扣款成功了，通知积分系统也成功了，但是积分增加的时候失败了，数据不一致了。</span><br><span class="line">2、账号服务扣款成功了，但是通知积分系统失败了，所以积分不会增加，数据不一致了。</span><br><span class="line">rocketmq的解决方案：</span><br><span class="line">针对问题1：如果消费失败了，是会自动重试的，如果重试几次后还是消费失败，那么这种情况就需要人工解决了，比如放到死信队列里然后手动查原因进行处理等。</span><br><span class="line">针对问题2：RocketMQ针对第二个问题解决方案是：如果你扣款成功了，但是往mq写消息的时候失败了，那么RocketMQ会进行回滚消息的操作，这时候我们也能回滚我们扣款的操作。（通过半消息实现）</span><br></pre></td></tr></table></figure>
</blockquote>
<p>顺序消息：</p>
<blockquote>
<p>方案1：发送消息到一个queue中来保证顺序消费(MessageQueueSelector)。<br>方案2：线程数设置为1，且通过消息体判断到哪个queue进行消费。</p>
</blockquote>
<p>消息持久化</p>
<blockquote>
<p>Broker端拿到消息后先将消息、topic、queue等内容存到ByteBuffer里，然后去持久化到commitlog文件中。commitlog文件大小为1G，超出大小会新创建commitlog文件来存储，采取的nio方式。</p>
</blockquote>
<p>如何保证消息不丢失</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">消息消费的流程：</span><br><span class="line">生产阶段：Producer通过网络将消息发送给Broker，这个发送可能会发生丢失，比如网络延迟不可达等。</span><br><span class="line">存储阶段：Broker肯定是先把消息放到内存的，然后根据刷盘策略持久化到硬盘中，刚收到Producer的消息，在内存中了，但是异常宕机了，导致消息丢失。(持久化位置为commitlog)</span><br><span class="line">消费阶段：消费失败了其实也是消息丢失的一种变体吧。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">解决方案：</span><br><span class="line">生产阶段：</span><br><span class="line">	1、通过同步发送来保证消息的成功送达。</span><br><span class="line">	2、如果发送失败会重试，默认为三次，可通过api调整。producer.setRetryTimesWhenSendFailed(10);</span><br><span class="line">	3、如果broker宕机，producer会重试发送到另一台broker</span><br><span class="line">	同步发送+自动重试机制+多个Master节点</span><br><span class="line">存储阶段：</span><br><span class="line">	1、同步刷盘来保证消息的不丢失，同样会损失一部分性能。（默认为异步）</span><br><span class="line">	2、集群部署保证高可用。等Master和Slave都刷完盘后才去通知Producer说消息ok了。brokerRole=SYNC_MASTER</span><br><span class="line">消费阶段：</span><br><span class="line">	1、手动ack</span><br><span class="line">	2、自动重试15次，进入死信队列</span><br></pre></td></tr></table></figure>
</blockquote>
<p>发消息的时候选择queue的算法</p>
<blockquote>
<p>random、hash、自定义</p>
</blockquote>
<p>为什么同一个消费组设置不同tag会出现奇怪现象</p>
<blockquote>
<p>两个相同组的消费者c1,c2相同topic，订阅tag1,tag2。此时往这个topic的两个tag分别发送10条消息。会发现c1没有收到消息，c2只收到了不到10条消息。消息能够正常发送。</p>
<p>原因：broker的问题。<br>Consumer端发心跳给Broker，Broker收到后存到consumerTable里（就是个Map），key是GroupName，value是ConsumerGroupInfo。<br>ConsumerGroupInfo里面是包含topic等信息的，但是问题就出在上一步骤，key是groupName，你同GroupName的话Broker心跳最后收到的Consumer会覆盖前者的。</p>
<p>所以c1的tag1被覆盖，无法接收到消息。为何c2没有收到10条消息呢，因为是集群模式消费，所以会有负载均衡，有一部分消息到达了c1但tag为tag2，无法消费，所以c2只收到了几条消息而非10条。如果换为广播模式，则c2能接收到10条消息。</p>
<p>注意：一个consumer可以订阅多个topic(存在一个map以topic为键)</p>
</blockquote>
<p>消费者负载均衡策略</p>
<blockquote>
<ul>
<li>queue个数大于Consumer个数，且queue个数能整除Consumer个数的话， 那么Consumer会平均分配queue。（比如上面表格的<strong>Consumer有2个 可以整除</strong>部分）</li>
<li>queue个数大于Consumer个数，且queue个数不能整除Consumer个数的话， 那么会有一个Consumer多消费1个queue，其余Consumer平均分配。（比如上面表格的<strong>Consumer有3个 不可整除</strong>部分）</li>
<li>queue个数小于Consumer个数，那么会有Consumer闲置，就是浪费掉了，其余Consumer平均分配到queue上。（比如上面表格的<strong>Consumer有5个 无法都分配</strong>部分）</li>
</ul>
</blockquote>
<h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><p>单服务器抗压</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1.对socket方面的优化</span><br><span class="line">1）操作系统（linux）的设置：</span><br><span class="line">增大socket的最大连接数</span><br><span class="line">echo 50000 &gt; /proc/sys/net/core/somaxconn   (系统默认的值是128，现在改成50000)</span><br><span class="line">加快系统的tcp回收机制 （系统默认tcp在断开后还会存活一段时间） 方法如下</span><br><span class="line">echo  1 &gt; /proc/sys/net/ipv4/tcp_tw_recycle  (系统默认是0，修改为1)</span><br><span class="line">允许空的tcp回收利用 方法如下</span><br><span class="line">echo 1 &gt;/proc/sys/net/ipv4/tcp_tw_reuse  (系统默认为0，修改为1)</span><br><span class="line">让系统不做洪水抵御保护，（当系统检测到80端口在大量的请求时，会自动给返回信息中增加 cookie ,还验证客户端身份，从而避免受到攻击，但这时只是高并发，并不是攻击，所以要把这个抵御机制给关闭） 方法如下</span><br><span class="line">echo 0 &gt;/proc/sys/net/ipv4/tcp_syncookie (系统默认为1，修改为0) </span><br><span class="line"></span><br><span class="line">2）nginx的设置：</span><br><span class="line">增大子进程打开的连接 ，在event段中   worker_connections 1024;  nginx默认能打开1024个连接</span><br><span class="line">修改worker_connections 10000;  修改为可以打开10000个socket连接</span><br><span class="line"></span><br><span class="line">2.对文件系统方面的优化</span><br><span class="line">1）操作系统方面：</span><br><span class="line">让操作系统允许打开更多的文件 ulimit -n(设置一个比较大的值)</span><br><span class="line">ulimit -n 10240;     (把操作系统允许打开文件的最大值设为10240，原本的默认值是1024)</span><br><span class="line"></span><br><span class="line">2）nginx 配置子进程可以打开的文件个数</span><br><span class="line">在nginx全局的配置中  worker_processes 1;下面加上worker_limit_nofile 10240;</span><br><span class="line">work_limit_nofile 10240  ;  (nginx的子进程可以打开10240个文件)</span><br></pre></td></tr></table></figure>


</blockquote>
<p>进程模型</p>
<blockquote>
<p>nginx模型有两种进程，master进程和worker进程。master进程主要用来管理worker进程，管理包含：接收来自外界的信号，向各worker进程发送信号，监控worker进程的运行状态，当worker进程退出后(异常情况下)，会自动重新启动新的worker进程。</p>
<p>而基本的网络事件，则是放在worker进程中来处理了。多个worker进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的。一个请求，只可能在一个worker进程中处理，一个worker进程，不可能处理其它进程的请求。worker进程的个数是可以设置的，一般我们会设置与机器cpu核数一致.</p>
</blockquote>
<p>启动方式</p>
<blockquote>
<p>Nginx的启动方式有两种：</p>
<p>单进程启动：此时系统中只有一个进程，这个进程既是master进程，也是worker进程。</p>
<p>多进程启动：此时系统中有且仅有一个master进程，有多个worker进程，master进程主要是用来管理worker进程的。</p>
</blockquote>
<p><img src="https://i.loli.net/2021/03/12/1cXe8UoavICM5Ws.png" alt="image.png"></p>
<p>如何处理请求</p>
<blockquote>
<p>worker进程之间是平等的，每个进程，处理请求的机会也是一样的。</p>
<p>当我们提供80端口的http服务时，一个连接请求过来，每个进程都有可能处理这个连接。首先，每个worker进程都是从master进程fork过来，在master进程里面，先建立好需要listen的socket之后，然后再fork出多个worker进程，这样每个worker进程都可以去accept这个socket。</p>
<p>一般来说，当一个连接进来后，所有在accept在这个socket上面的进程，都会收到通知，而只有一个进程可以accept这个连接，其它的则accept失败，这是所谓的惊群现象（<strong>惊群现象（thundering herd）就是当多个进程和线程在同时阻塞等待同一个事件时，如果这个事件发生，会唤醒所有的进程，但最终只可能有一个进程/线程对该事件进行处理，其他进程/线程会在失败后重新休眠，这种性能浪费就是惊群。</strong>）</p>
<p>当然，nginx也不会视而不见，所以nginx提供了一个accept_mutex这个东西，从名字上，我们可以看这是一个加在accept上的一把共享锁。有了这把锁之后，同一时刻，就只会有一个进程在accpet连接，这样就不会有惊群问题了。accept_mutex是一个可控选项，我们可以显示地关掉，默认是打开的。</p>
<p>当一个worker进程在accept这个连接之后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才断开连接，这样一个完整的请求就是这样的了。我们可以看到，一个请求，完全由worker进程来处理，而且只在一个worker进程中处理。</p>
</blockquote>
<p>通信</p>
<blockquote>
<p>linux与nginx之间通过信号进行通信。<br>master进程与worker进程通过sockpair（全双工通信）进行通信（channel）<br>worker进程间则是通过比较快速的共享内存进行通信。（mmap内存映射、通过文件、通过system v）</p>
</blockquote>
<h2 id="数据库MySQL"><a href="#数据库MySQL" class="headerlink" title="数据库MySQL"></a>数据库MySQL</h2><p>脏读、不可重复读、幻读</p>
<blockquote>
<p>脏读：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个被修改的数据，然后使用了这个数据。事务读取到了其他事务修改并且未提交的数据。</p>
<p>不可重复读：一个事务多次读取同一数据，该数据记录会改变。(其他事务进行了数据的修改)</p>
<p>幻读：多次读取，后面读取时数据记录数量发生改变。(其他事务进行了数据的插入、删除操作)</p>
</blockquote>
<p>四种隔离级别：</p>
<blockquote>
<p>读未提交、读已提交、可重复读、串行化。</p>
<p>读已提交解决脏读；可重复读解决脏读和不可重复读；串行化解决所有问题</p>
</blockquote>
<p>索引、索引类型(Hash、B+、全文索引)</p>
<blockquote>
<p>innodb、MyIsam——数据节点存储数据 or 存储数据地址(指针) </p>
<p>MyISAM索引文件和数据文件分开——非聚集索引、InnoDB则是索引文件和数据文件在一起——聚集索引。</p>
<p>主键索引、辅助索引。</p>
<p>最左前缀匹配。</p>
<p>索引类型：</p>
<p>1.普通索引；2.唯一索引；3.主键索引；4.组合索引；5.全文索引（innodb不支持）</p>
</blockquote>
<p>聚簇索引和非聚簇索引</p>
<blockquote>
<p>聚簇索引：索引和数据一起存放(innodb)，非聚簇索引：索引的叶节点是指针指向对应的数据，分开存放(myisam)</p>
<p>插入数据时，聚簇索引需要排序，非聚簇索引则需要维护索引到数据的指针。非聚集索引会存在索引和数据的两次io，更耗时。</p>
</blockquote>
<p>innodb四大特性</p>
<blockquote>
<p>插入缓存、两次写、自适应hash、提前读<a href="https://note.youdao.com/ynoteshare1/index.html?id=a6004953a0a7c80073ac74d8e76f1ebd&type=note" target="_blank" rel="noopener">click here</a> or <a href="https://www.jianshu.com/p/dcc0dc450a2c" target="_blank" rel="noopener">there</a></p>
</blockquote>
<p>innodb底层详解</p>
<blockquote>
<p>InnoDB的内存架构主要分为三大块，<strong>缓冲池</strong>（Buffer Pool）、<strong>重做缓冲池</strong>（Redo Log Buffer）和<strong>额外内存池</strong></p>
<p>缓冲池采用了<strong>LRU</strong>算法，但可能导致缓冲池污染。</p>
<p>mysql在写入记录前，会先记录到redo log，用于刷盘。</p>
<p>插入缓存：等数据达到某个阈值（例如50条）才批量的写入磁盘，降低io。</p>
<p>两次写：<strong>插入缓冲</strong>提高了MySQL的性能，而<strong>两次写</strong>则在此基础上提高了数据的可靠性。我们知道，当数据还在缓冲池中的时候，当机器宕机了，发生了<strong>写失效</strong>，有Redo Log来进行恢复。但是如果是在从缓冲池中将数据刷回磁盘的时候宕机了呢？这种情况叫做<strong>部分写失效</strong>，此时重做日志就无法解决问题。</p>
<p>在刷脏页时，并不是直接刷入磁盘，而是copy到内存中的Doublewrite Buffer中，然后再拷贝至磁盘共享表空间（你可以就理解为磁盘）中，每次写入1M，等copy完成后，再将Doublewrite Buffer中的页写入磁盘文件。有了两次写机制，即使在刷脏页时宕机了，在实例恢复的时候也可以从共享表空间中找到Doublewrite Buffer的页副本，直接将其覆盖原来的数据页即可。</p>
<p>自适应哈希索引：参考jit热点代码，对热点索引进行hash。</p>
<p>提前读：innodb中将64个页划分为一个extent，当一个extent中的页，被顺序读超过了多少个，比如50个，这个值是可以通过nnodb_read_ahead_threshold设置的，那么就会认为顺序读到下一个extent的可能性很大，会提前将下一个extent中的所有页都加载到buffer pool中，这叫线性预读</p>
</blockquote>
<p>间隙锁</p>
<blockquote>
<p>Innodb在<strong>可重复读</strong>提交下为了解决<strong>幻读</strong>问题时引入的锁机制。</p>
<p>针对范围查询，例如查询id为1-9之间的所有数据（前提，数据库中没有id为2 4 6的数据），但是范围锁就会将1-9的所有都锁上，如果此时想要插入一条id为2的数据，是无法插入的，会导致阻塞。</p>
<p>间隙锁可能导致死锁，间隙锁之间并不是互斥的。</p>
</blockquote>
<p>解决mysql读写效率</p>
<blockquote>
<p>sql优化、索引、缓存、主从复制+读写分离、垂直拆分（分布式）、水平拆分（解决主键问题）、分区</p>
</blockquote>
<p>MVCC原理</p>
<blockquote>
<p>多版本并发控制技术。保存数据的历史版本。可以通过比较版本号决定数据是否显示出来。读取数据的时候不需要加锁可以保证事务的隔离效果。</p>
<p>innodb：更新前建立undo log，根据各种策略读取时非阻塞就是MVCC，undo log中的行就是MVCC中的多版本。即：事务更新某记录时，先用排他锁锁定，然后copy一份记录到undo log然后让roll_ptr指向undo log，然后进行更新并填写事务编号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">解决读写之间阻塞的问题，通过 MVCC 可以让读写互相不阻塞，读不相互阻塞，写不阻塞读，这样可以提升数据并发处理能力。</span><br><span class="line">降低了死锁的概率，这个是因为 MVCC 采用了乐观锁的方式，读取数据时，不需要加锁，写操作，只需要锁定必要的行。</span><br><span class="line">解决了一致性读的问题，当我们朝向某个数据库在时间点的快照是，只能看到这个时间点之前事务提交更新的结果，不能看到时间点之后事务提交的更新结果。</span><br></pre></td></tr></table></figure>
<p><strong>InnoDB 的 MVCC 是如何实现的？</strong></p>
<p>InnoDB 是如何存储记录多个版本的？这些数据是 事务版本号，行记录中的隐藏列(row_id, tx_id, roll_ptr)和Undo Log。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">事务查询行记录：</span><br><span class="line">当前事务的 creator_trx_id 想要读取某个行记录，这个行记录ID的trx_id ，这样会有以下的情况：</span><br><span class="line">如果 trx_id &lt; 活跃的最小事务ID（up_limit_id）,也就是说这个行记录在这些活跃的事务创建前就已经提交了，那么这个行记录对当前事务是可见的。</span><br><span class="line">如果trx_id &gt; 活跃的最大事务ID（low_limit_id），这个说明行记录在这些活跃的事务之后才创建，说明这个行记录对当前事务是不可见的。</span><br><span class="line">如果 up_limit_id &lt; trx_id &lt;low_limit_id,说明该记录需要在 trx_ids 集合中，可能还处于活跃状态，因此我们需要在 trx_ids 集合中遍历，如果trx_id 存在于 trx_ids 集合中，证明这个事务 trx_id 还处于活跃状态，不可见，否则 ，trx_id 不存在于 trx_ids 集合中，说明事务trx_id 已经提交了，这行记录是可见的。</span><br><span class="line"></span><br><span class="line">如何查询一条记录</span><br><span class="line">1、获取事务自己的版本号，即事务ID</span><br><span class="line">2、获取 Read View</span><br><span class="line">3、查询得到的数据，然后 Read View 中的事务版本号进行比较。</span><br><span class="line">4、如果不符合 ReadView 规则， 那么就需要 UndoLog 中历史快照；</span><br><span class="line">5、最后返回符合规则的数据</span><br><span class="line">InnoDB 实现多版本控制 （MVCC）是通过 ReadView + UndoLog 实现的，UndoLog 保存了历史快照，ReadView 规则帮助判断当前版本的数据是否可见。</span><br></pre></td></tr></table></figure>

<p>innodb如何保证崩溃恢复能力</p>
<blockquote>
<p>两阶段日志提交</p>
</blockquote>
</blockquote>
<p>MVCC下的一些操作</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">增删查改</span><br><span class="line">在InnoDB中，给每行增加两个隐藏字段来实现MVCC，一个用来记录数据行的创建时间，另一个用来记录行的过期时间（删除时间）。在实际操作中，存储的并不是时间，而是事务的版本号，每开启一个新事务，事务的版本号就会递增。</span><br><span class="line">于是乎，默认的隔离级别（REPEATABLE READ）下，增删查改变成了这样：</span><br><span class="line"></span><br><span class="line">SELECT：读取创建版本小于或等于当前事务版本号，并且删除版本为空或大于当前事务版本号的记录。这样可以保证在读取之前记录是存在的。</span><br><span class="line">INSERT：将当前事务的版本号保存至行的创建版本号</span><br><span class="line">UPDATE：新插入一行，并以当前事务的版本号作为新行的创建版本号，同时将原记录行的删除版本号设置为当前事务版本号</span><br><span class="line">DELETE：将当前事务的版本号保存至行的删除版本号</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">快照读和当前读</span><br><span class="line">快照读：读取的是快照版本，也就是历史版本</span><br><span class="line">当前读：读取的是最新版本</span><br><span class="line">普通的SELECT就是快照读，而UPDATE、DELETE、INSERT、SELECT ...  LOCK IN SHARE MODE、SELECT ... FOR UPDATE是当前读。</span><br></pre></td></tr></table></figure>

</blockquote>
<p>read-view(一致性视图)</p>
<blockquote>
<p>未提交的事务id数组以及当前已经创建(不论是否提交)的最大事务id。(【未提交事务id】，max_id)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">当执行查询sql时会生成一致性视图read-view，它由执行查询时所有未提交事务id数组(数组里最小的id为min_id)和已创建的最大事务id (max_id)组成，查询的数据结果需要跟read-view做比对从而得到快照结果</span><br><span class="line">版本链比对规则:</span><br><span class="line">1.如果落在绿色部分( trx_id &lt; min_id )，表示这个版本是已提交的事务生成的，这个数据是可见的;</span><br><span class="line">2.如果落在红色部分( trx id &gt; max_id )，表示这个版本是由将来启动的事务生成的，是肯定不可见的;</span><br><span class="line">3.如果落在黄色部分(min_ id &lt;= trx_id &lt;= max_id)，那就包括两种情况</span><br><span class="line">	a.若row的trx_id在数组中，表示这个版本是由还没提交的事务生成的，不可见，当前自己的事务是可见的;</span><br><span class="line">	b.若row的trx_id不在数组中，表示这个版本是已经提交了的事务生成的，可见。</span><br><span class="line">对于删除的情况可以认为是update的特殊情况，会将版本链上最新的数据复制一份，然后将trx_id修改成删除操作的trx_id，同时在该条记录的头信（record header)里的(deleted_flag)标记位写上true，来表示当前记录已经被删除，在查间时按照上面的规则查到对应的记录如果delete flag标记位为true，意味着记录已被删除，则不返回数据。</span><br></pre></td></tr></table></figure>

<p>如果是可重复读的隔离级别，则MVCC中每个select记录使用的是之前select的read-view，即进行延用而非重新创建。（当一个session发起第一个查询时，此刻对应的全表的read-view已经确定了，之后的查询都会使用该read-view）</p>
<p>而如果是读已提交的隔离界别，则MVCC中每个select记录都会重新生成read-view。</p>
</blockquote>
<p>行锁和表锁(具体)</p>
<blockquote>
<p>行锁：锁定一行或者多行记录，<strong>行锁是基于索引加载的</strong>，可能死锁。<br>表锁：没有触发索引，则会锁表。<strong>表锁响应的是非索引字段，即全表扫描</strong>，不会死锁。</p>
</blockquote>
<p>如何实现的隔离级别</p>
<blockquote>
<p>读写锁 or MVCC。</p>
<p>事务看到的是自己查询时候的快照ReadView。</p>
</blockquote>
<p>回表查询</p>
<blockquote>
<p>第一遍定位主键值，再定位行记录，它的性能较扫一遍索引树更低。</p>
</blockquote>
<p>索引覆盖</p>
<blockquote>
<p>查询时不需要回表查询，直接通过索引就可以获取查询的结果数据，extra：using index代表索引覆盖</p>
</blockquote>
<p>mysql，数据查询慢怎么办</p>
<blockquote>
<p>慢查询抓取sql语句，然后用explain执行计划判断，建索引，B+树，为什么可以增快速度。</p>
</blockquote>
<p>explain</p>
<blockquote>
<p>id、select_type、table、partitions、type、possible_keys、key、key_len、ref、row、filtered、Extra</p>
</blockquote>
<p>分库、分表、分区</p>
<blockquote>
<p>就搞一个主库，挂多个从库，然后我们就单单只是写主库，然后主库会自动把数据给同步到从库上去。读从库。主从复制，binlog。</p>
<p>分库：垂直按功能模块切分、水平减少数据库压力、数据隔离、功能切分。</p>
<p>分表：数据冗余问题、热点数据等等。</p>
</blockquote>
<p>mysql主从复制原理</p>
<blockquote>
<p>①为何需要主从复制？</p>
<blockquote>
<p>并发量大时，需要读写分离，主库负责写，从库负责读，即使需要锁表，对读的性能也没有影响。<br>数据的预热。<br>降低单机IO压力。</p>
</blockquote>
<p>②主从复制原理(bin log)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">原理：</span><br><span class="line">	1)、在master机器上的操作：</span><br><span class="line">	当master上的数据发生变化时，该事件变化会按照顺序写入bin-log中。当slave链接到master的时候，master机器会为slave开启binlog dump线程。当master的binlog发生变化的时候，bin-log dump线程会通知slave，并将相应的binlog内容发送给slave。</span><br><span class="line">	2)、在slave机器上操作：</span><br><span class="line">	当主从同步开启的时候，slave上会创建两个线程：I\O线程。该线程连接到master机器，master机器上的binlog dump 线程会将binlog的内容发送给该I\O线程。该I/O线程接收到binlog内容后，再将内容写入到本地的relay log；sql线程。该线程读取到I/O线程写入的ralay log。并且根据relay log。并且根据relay log 的内容对slave数据库做相应的操作。</span><br><span class="line">	</span><br><span class="line">也就是说：</span><br><span class="line">    - 从库会生成两个线程,一个I/O线程,一个SQL线程;</span><br><span class="line">    - I/O线程会去请求主库的binlog,并将得到的binlog写到本地的relay-log(中继日志)文件中;</span><br><span class="line">    - 主库会生成一个log dump线程,用来给从库I/O线程传binlog;</span><br><span class="line">    - SQL线程,会读取relay log文件中的日志,并解析成sql语句逐一执行;</span><br></pre></td></tr></table></figure>

<p>③三种主要实现粒度</p>
<blockquote>
<p>详细的主从同步主要有三种形式：statement、row、mixed<br>1)、statement: 会将对数据库操作的sql语句写道binlog中<br>2)、row: 会将每一条数据的变化写道binlog中。<br>3)、mixed: statement与row的混合。Mysql决定何时写statement格式的binlog, 何时写row格式的binlog。</p>
</blockquote>
<p>④主从复制延迟问题</p>
<blockquote>
<p>原因：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1)、MySQL数据库主从同步延迟原理mysql主从同步原理：主库针对写操作，顺序写binlog，从库单线程去主库顺序读”写操作的binlog”，从库取到binlog在本地原样执行（随机写），来保证主从数据逻辑上一致。mysql的主从复制都是单线程的操作，主库对所有DDL和DML产生binlog，binlog是顺序写，所以效率很高，slave的Slave_IO_Running线程到主库取日志，效率比较高，下一步，问题来了，slave的Slave_SQL_Running线程将主库的DDL和DML操作在slave实施。DML和DDL的IO操作是随即的，不是顺序的，成本高很多，还可能可slave上的其他查询产生lock争用，由于Slave_SQL_Running也是单线程的，所以一个DDL卡主了，需要执行10分钟，那么所有之后的DDL会等待这个DDL执行完才会继续执行，这就导致了延时。有朋友会问：“主库上那个相同的DDL也需要执行10分，为什么slave会延时？”，答案是master可以并发，Slave_SQL_Running线程却不可以。</span><br><span class="line"></span><br><span class="line">2)、MySQL数据库主从同步延迟是怎么产生的？当主库的TPS并发较高时，产生的DDL数量超过slave一个sql线程所能承受的范围，那么延时就产生了，当然还有就是可能与slave的大型query语句产生了锁等待。首要原因：数据库在业务上读写压力太大，CPU计算负荷大，网卡负荷大，硬盘随机IO太高次要原因：读写binlog带来的性能影响，网络传输延迟。</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<p>①硬件方面；②禁用从库binlog；③分担压力等等</p>
</blockquote>
</blockquote>
<p>事务如何实现隔离性</p>
<blockquote>
<p>读写锁 or MVCC</p>
</blockquote>
<p>三大范式</p>
<blockquote>
<p>1NF：字段不可分<br>2NF：属性完全依赖于主键<br>3NF：属性不依赖于其它非主属性   属性直接依赖于主键<br>BCNF：无传递依赖</p>
</blockquote>
<p>事务特性</p>
<blockquote>
<p>ACID，原子性、一致性、隔离性、持久性</p>
<p>一致性：数据前后的完整性。</p>
</blockquote>
<p>sql很慢优化：</p>
<blockquote>
<p>索引、拆分表、大字段、减少函数运算、内存、cpu</p>
</blockquote>
<p>自增id用完</p>
<blockquote>
<p>id边界值使用后，越过此边界值插入数据会失败。主键冲突、无法插入。使用big int or 自己的主键</p>
</blockquote>
<p>mysql和redis数据一致性保证</p>
<blockquote>
</blockquote>
<p>索引下推</p>
<blockquote>
<p>即如果下图中<code>name</code>也有索引，则会将其过滤也放在底层进行过滤，进而增大效率。</p>
<p><img src="https://i.loli.net/2021/02/05/6zs9MQZ4KPrLpFc.png" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在不使用ICP的情况下，在使用非主键索引（又叫普通索引或者二级索引）进行查询时，存储引擎通过索引检索到数据，然后返回给MySQL服务器，服务器然后判断数据是否符合条件 。</span><br><span class="line">在使用ICP的情况下，如果存在某些被索引的列的判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器 。</span><br><span class="line">索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少MySQL服务器从存储引擎接收数据的次数。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>join和union区别</p>
<blockquote>
<p>join是通过on上面的条件进行的</p>
<p>union则是将两个结果集进行合并</p>
</blockquote>
<p>窗口函数(用于组内排名)</p>
<blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本语法</span></span><br><span class="line">&lt;窗口函数&gt; over (partition by &lt;用于分组的列名&gt; order by &lt;用于排序的列名&gt;)</span><br><span class="line"><span class="comment"># rank, dense_rank, row_number</span></span><br><span class="line"><span class="comment"># rank排名会间隔 如 1 2 2 4 5...</span></span><br><span class="line"><span class="comment"># 而dense_rank则不会间隔 如 1 2 2 3 4 5</span></span><br><span class="line"><span class="comment"># row_number则不考虑并列的情况</span></span><br></pre></td></tr></table></figure>

<p>&lt;窗口函数&gt;的位置，可以放以下两种函数：</p>
<p>1） 专用窗口函数，包括后面要讲到的rank, dense_rank, row_number等专用窗口函数。</p>
<p>2） 聚合函数，如sum. avg, count, max, min等</p>
<p>因为窗口函数是对where或者group by子句处理后的结果进行操作，所以<strong>窗口函数原则上只能写在select子句中</strong>。</p>
<p><strong>partition by用来对表分组</strong>，<strong>order by子句的功能是对分组后的结果进行排序(默认asc)</strong>。</p>
<p>partition by不会改变表的行数，而group by则会改变。</p>
<p>对于聚合函数，则会在分组内，按顺序进行。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select *,</span><br><span class="line">   sum(成绩) over (order by 学号) as current_sum,</span><br><span class="line">   avg(成绩) over (order by 学号) as current_avg,</span><br><span class="line">   count(成绩) over (order by 学号) as current_count,</span><br><span class="line">   max(成绩) over (order by 学号) as current_max,</span><br><span class="line">   min(成绩) over (order by 学号) as current_min</span><br><span class="line">from 班级表</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/03/14/xqXi9wM2LfDs3ok.png" alt="image.png"></p>
</blockquote>
<p>数据库分库分表主键处理</p>
<blockquote>
<p>①使用自增主键，适用于数据量大并发较小需要分表的情况。<br>②设置数据库 sequence 或者表自增字段步长。比如说，现在有 8 个服务节点，每个服务节点使用一个 sequence 功能来产生 ID，每个 sequence 的起始 ID 不同，并且依次递增，步长都是 8。方案简单，但是如果需要增加服务节点时，就较为麻烦。<br>③UUID，好处就是本地生成，不用基于数据库来了；不好之处就是，UUID 太长了、占用空间大，<strong>作为主键性能太差</strong>了，会导致索引效率低下<br>④snowflake 算法，把一个 64 位的 long 型的 id，1 个 bit 是不用的，用其中的 41 bit 作为毫秒数，用 10 bit 作为工作机器 id，12 bit 作为序列号。</p>
</blockquote>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>工厂模式、单例模式、原型模式、装饰器模式、代理模式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">工厂：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。</span><br><span class="line">单例：懒汉、饿汉、双重检验锁懒汉</span><br><span class="line"> public static Singleton getSingleton() &#123;  </span><br><span class="line">    if (singleton == null) &#123;  </span><br><span class="line">        synchronized (Singleton.class) &#123;  </span><br><span class="line">            if (singleton == null) &#123;  </span><br><span class="line">                singleton = new Singleton();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return singleton;  </span><br><span class="line">&#125;  </span><br><span class="line">原型模式：创建对象代价太大 采用实现Cloneable接口和重写clone方法</span><br><span class="line">装饰器模式：装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。</span><br><span class="line">代理模式：jdk代理和cglib代理</span><br></pre></td></tr></table></figure>

<h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>CAP</p>
<blockquote>
<ul>
<li>一致性(<strong>C</strong>onsistency)</li>
<li>可用性(<strong>A</strong>vailability)</li>
<li>分区容忍性(<strong>P</strong>artition tolerance)</li>
</ul>
</blockquote>
<p>BASE</p>
<blockquote>
<ul>
<li>Basically Availble –基本可用</li>
<li>Soft-state –软状态/柔性事务</li>
</ul>
<blockquote>
<p>“Soft state” 可以理解为”无连接”的, 而 “Hard state” 是”面向连接”的</p>
</blockquote>
<ul>
<li>Eventual Consistency –最终一致性</li>
</ul>
</blockquote>
<p>最终一致性（分布式事务）</p>
<blockquote>
<p>2PL，两阶段提交。</p>
<p>消息重试、补偿交易、事务消息、接口支持重入</p>
</blockquote>
<p>什么是可重入</p>
<blockquote>
</blockquote>
<h2 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h2><p>wc</p>
<blockquote>
<p>wc [-clw] 文件*</p>
<p>计算文件的行数 单词数 字节数</p>
<p>-c或–bytes或–chars 只显示Bytes数。-l或–lines 显示行数。-w或–words 只显示字数。</p>
<p>可以跟多个文件，则会都显示并进行汇总</p>
</blockquote>
<p>Linux查看内存, cpu的占有率的命令</p>
<blockquote>
<p>top</p>
</blockquote>
<p>netstat、find、cat、cp、mv、su、ftp（ftp+ip）</p>
<blockquote>
<p>netstat 命令用于显示网络状态。-a显示所有套接字和端口。例子：TCP    192.168.9.52:1299      60.210.8.160:https     CLOSE_WAIT</p>
<p>find命令格式：find path -xxx expression。将当前目录及其子目录下所有文件后缀为 <strong>.c</strong> 的文件列出来：find . -name “*.c”</p>
<p>把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：cat -n textfile1 &gt; textfile2 （-b和-n相似只是-b不会把空白行输出）</p>
</blockquote>
<p>chmod</p>
<blockquote>
<p>chmod [owner group others]<br>RWX——777</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 file</span><br></pre></td></tr></table></figure>
</blockquote>
<p>telnet</p>
<blockquote>
<p>telnet + ip登陆远程主机</p>
</blockquote>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>反转链表：递归、迭代</p>
<p>删除字符串中的空格，时间O(n)，空间O(1)</p>
<p>写一个程序判断机器是大端法还是小端法（什么是大端、什么是小端）</p>
<blockquote>
<p>小端法：低地址存放低位，高地址存放高位</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0x11223344</span>;</span><br><span class="line"><span class="keyword">char</span> *c = (<span class="keyword">char</span>*)(&amp;i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%x"</span>, *c); <span class="comment">// 0x44-小端 0x11-大端</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>很长的英文论文，统计出现最高频的k个单词。(hashmap + 堆)</p>
<p>一组无序的数，找出中位数。(快速选择，O(n))</p>
<p>熟悉的排序算法(归并、快排、冒泡、插入、选择) 从小到大</p>
<blockquote>
<p>插入排序：从第二个数开始，和前面的数进行比较，如果比前面的数小，则交换，直到没有比该数大的数。继续遍历下一个数。</p>
<p>选择排序：从当前遍历到的数开始遍历到结尾，找到最小的数，和当前数交换，直到遍历完数组。</p>
<p>冒泡排序：每一趟排序，将相邻的两个数进行比较，小的放在前面。重复len - 1趟，且每一趟都能确定len - 1 - i个数。</p>
<p>归并排序：分治 + 双指针。</p>
<p>快速排序：分治 + 选取枢纽。</p>
<p>稳定：插入、冒泡、归并</p>
<p>不稳定：选择、快排、堆排序</p>
</blockquote>
<p>10亿个数排序后打印，内存有限（拆分成小文件并排好序分别放入小文件，然后每个文件进行读取首数据然后关闭然后读取下一个文件，可以利用堆排序实现大文件的有序）</p>
<p>从100万个数中找出最大的前100个数（快速选择 or 维护最大堆）</p>
<p>java操作有500万数据的大表如何操作（多线程？分表？limit分页？）</p>
<p>两个线程交替打印1-100</p>
<p>分布锁？</p>
<p>下层层序序列的完全二叉树 打印前序遍历结果</p>
<p>找出一个字符串有多少回文字串，输出最大的</p>
<p>Leetcode 1438</p>
<p>最长上升子序列(需要输出子序列)</p>
<p>64匹马 8条赛道 找出跑的最快的4匹 最少需要几场比赛（11）</p>
<p>lru</p>
<p>高并发设计：</p>
<blockquote>
<p>拆分为服务、缓存、mq、分库分表、读写分离、分布式</p>
</blockquote>
<p>如果不用红黑树，怎么把hash后桶上的链表存入到磁盘空间内，要怎么设计 磁盘内的存储方式?</p>
<blockquote>
<p>桶上的链表再进行一次hash。<br>——————————<br>——————<br>————<br>———<br>—<br>👆这样划分磁盘的存储空间，使记录hash后的值时先在最大的那块记录，有冲突就往第二大的快记录。使最大的磁盘块能直接返回值，防止hash冲突。</p>
</blockquote>
<p>位运算实现加法</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">0 + 0 = 0 不进位</span><br><span class="line">1 + 0 = 1 不进位</span><br><span class="line">0 + 1 = 1 不进位</span><br><span class="line">1 + 1 = 0 进位1</span><br><span class="line">--------------</span><br><span class="line">加法本身：a ^ b</span><br><span class="line">进位：(a &amp; b) &lt;&lt; 1</span><br><span class="line">--------------</span><br><span class="line">结论：设a，b为两个二进制数，则a+b = a^b + (a&amp;b)&lt;&lt;1。</span><br><span class="line">证明：a^b是不考虑进位时加法结果。当二进制位同时为1时，才有进位，因此 (a&amp;b)&lt;&lt;1是进位产生的值，称为进位补偿。将两者相加便是完整加法结果。</span><br><span class="line">后续的加法通过递归即可</span><br><span class="line">public int add(int a, int b) &#123;</span><br><span class="line">    if (b == 0) return a; // 进位为0时退出递归</span><br><span class="line">    return add(a ^ b, (a &amp; b) &lt;&lt; 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>4亿个unsigned int型的数让你保存，然后给你一个数，判断它是否存在已经保存的数中。</p>
<blockquote>
<p>bitmap</p>
</blockquote>
<p>高考成绩查询高并发</p>
<blockquote>
<p>省份、成绩区间分库分表</p>
<p>redis预热数据</p>
<p>前端页面提前缓存CDN</p>
<p>nginx负载均衡</p>
<p>中间件</p>
</blockquote>
<p>三数之和</p>
<p>lc 678</p>
<p>lc 316(单调栈 + 贪心)</p>
<p>场景题：两堆大数，100亿个数和10亿个数，找交集</p>
<p>场景题：直播房间，一个大V发了一条消息，如何让上千万的粉丝收到这条消息，如果只是纯粹的广播会很耗资源</p>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:</strong>
    Bcutty Kmy
  </li>
  <li class="post-copyright-link">
    <strong>Post link:</strong>
    <a href="http://yoursite.com/2021/03/31/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/" title="Java面经整理">http://yoursite.com/2021/03/31/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice: </strong>
    All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> unless stating additionally.
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag"># 学习</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/03/05/jvm/" rel="next" title="JVM">
                <i class="fa fa-chevron-left"></i> JVM
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/04/22/Java%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/" rel="prev" title="Linux上Java相关环境变量配置">
                Linux上Java相关环境变量配置 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Bcutty Kmy</p>
              <p class="site-description motion-element" itemprop="description">NO DEPENDENCE ONLY PRIDE</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/DbettKK" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:394739138@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java面经整理"><span class="nav-number">1.</span> <span class="nav-text">Java面经整理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数据结构"><span class="nav-number">1.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OS"><span class="nav-number">1.2.</span> <span class="nav-text">OS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计网"><span class="nav-number">1.3.</span> <span class="nav-text">计网</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java基础"><span class="nav-number">1.4.</span> <span class="nav-text">java基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java集合"><span class="nav-number">1.5.</span> <span class="nav-text">java集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java并发"><span class="nav-number">1.6.</span> <span class="nav-text">java并发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM"><span class="nav-number">1.7.</span> <span class="nav-text">JVM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring"><span class="nav-number">1.8.</span> <span class="nav-text">Spring</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringMVC"><span class="nav-number">1.9.</span> <span class="nav-text">SpringMVC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringBoot"><span class="nav-number">1.10.</span> <span class="nav-text">SpringBoot</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis"><span class="nav-number">1.11.</span> <span class="nav-text">Redis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker"><span class="nav-number">1.12.</span> <span class="nav-text">Docker</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RocketMQ"><span class="nav-number">1.13.</span> <span class="nav-text">RocketMQ</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#nginx"><span class="nav-number">1.14.</span> <span class="nav-text">nginx</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库MySQL"><span class="nav-number">1.15.</span> <span class="nav-text">数据库MySQL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设计模式"><span class="nav-number">1.16.</span> <span class="nav-text">设计模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#git"><span class="nav-number">1.17.</span> <span class="nav-text">git</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他"><span class="nav-number">1.18.</span> <span class="nav-text">其他</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux命令"><span class="nav-number">1.19.</span> <span class="nav-text">Linux命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法"><span class="nav-number">1.20.</span> <span class="nav-text">算法</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bcutty Kmy</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">244.2k</span>
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  









  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three-waves.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: '2z9X7Dx6RjzhCEydcpBXNAF5-gzGzoHsz',
        appKey: 'd4qtySNKtCjyy1f975pQrdgB',
        placeholder: 'Welcome to leave your comments',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("2z9X7Dx6RjzhCEydcpBXNAF5-gzGzoHsz", "d4qtySNKtCjyy1f975pQrdgB");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
