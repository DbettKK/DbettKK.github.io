<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Java面试准备Java基础String、StringBuilder、StringBuffer String 类中使用 final 关键字修饰字符数组来保存字符串，private final char value[]，所以 String 对象是不可变的。补充（来自issue 675）：在 Java 9 之后，String 类的实现改用 byte 数组存储字符串 private final byte">
<meta name="keywords" content="学习">
<meta property="og:type" content="article">
<meta property="og:title" content="Java面试准备">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;03&#x2F;04&#x2F;Java%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87&#x2F;index.html">
<meta property="og:site_name" content="Dbettkk-Blog">
<meta property="og:description" content="Java面试准备Java基础String、StringBuilder、StringBuffer String 类中使用 final 关键字修饰字符数组来保存字符串，private final char value[]，所以 String 对象是不可变的。补充（来自issue 675）：在 Java 9 之后，String 类的实现改用 byte 数组存储字符串 private final byte">
<meta property="og:locale" content="en">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2021&#x2F;03&#x2F;04&#x2F;K8chDsaJLgeWFpU.png">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2021&#x2F;02&#x2F;05&#x2F;6zs9MQZ4KPrLpFc.png">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2021&#x2F;03&#x2F;04&#x2F;Y3mdEcJ64DyvZe2.png">
<meta property="og:image" content="https:&#x2F;&#x2F;img.rruu.net&#x2F;image&#x2F;601e6713dd864">
<meta property="og:image" content="https:&#x2F;&#x2F;img.rruu.net&#x2F;image&#x2F;601e6e43cd20a">
<meta property="og:image" content="https:&#x2F;&#x2F;img.rruu.net&#x2F;image&#x2F;601e6ec3e78e5">
<meta property="og:image" content="https:&#x2F;&#x2F;img.rruu.net&#x2F;image&#x2F;6021434267a6b">
<meta property="og:image" content="https:&#x2F;&#x2F;img.rruu.net&#x2F;image&#x2F;6021439fcabec">
<meta property="og:updated_time" content="2021-03-05T11:07:58.954Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2021&#x2F;03&#x2F;04&#x2F;K8chDsaJLgeWFpU.png">

<link rel="canonical" href="http://yoursite.com/2021/03/04/Java%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Java面试准备 | Dbettkk-Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Dbettkk-Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/04/Java%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Bcutty Kmy">
      <meta itemprop="description" content="NO DEPENDENCE ONLY PRIDE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dbettkk-Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java面试准备
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-04 13:48:50" itemprop="dateCreated datePublished" datetime="2021-03-04T13:48:50+08:00">2021-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-05 19:07:58" itemprop="dateModified" datetime="2021-03-05T19:07:58+08:00">2021-03-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          
            <span id="/2021/03/04/Java%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/" class="post-meta-item leancloud_visitors" data-flag-title="Java面试准备" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2021/03/04/Java%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/03/04/Java%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Java面试准备"><a href="#Java面试准备" class="headerlink" title="Java面试准备"></a>Java面试准备</h1><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="String、StringBuilder、StringBuffer"><a href="#String、StringBuilder、StringBuffer" class="headerlink" title="String、StringBuilder、StringBuffer"></a>String、StringBuilder、StringBuffer</h3><blockquote>
<p>String 类中使用 final 关键字修饰字符数组来保存字符串，<code>private final char value[]</code>，所以 String 对象是不可变的。补充（来自<a href="https://github.com/Snailclimb/JavaGuide/issues/675" target="_blank" rel="noopener">issue 675</a>）：在 Java 9 之后，String 类的实现改用 byte 数组存储字符串 <code>private final byte[] value</code>。</p>
<p>而 StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串<code>char[] value</code> 但是没有用 final 关键字修饰，所以这两种对象都是可变的。</p>
</blockquote>
<p><strong>线程安全性</strong></p>
<blockquote>
<p>String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p>
</blockquote>
<p><strong>性能</strong></p>
<blockquote>
<p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
</blockquote>
<p><strong>对于三者使用的总结：</strong></p>
<blockquote>
<p>操作少量的数据: 适用 String</p>
<p>单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder</p>
<p>多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer</p>
</blockquote>
<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(xxx);</span><br><span class="line">Integer i = xxx;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在通过valueOf方法创建Integer对象的时候，如果数值在[-128,127]之间，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。</p>
</blockquote>
<blockquote>
<p>同时：Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的。而Double、Float的valueOf方法的实现是类似的。而对于Boolean类，则是通过两个静态变量实现的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean TRUE = <span class="keyword">new</span> Boolean(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean FALSE = <span class="keyword">new</span> Boolean(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Integer a = <span class="number">1</span>;</span><br><span class="line">        Integer b = <span class="number">2</span>;</span><br><span class="line">        Integer c = <span class="number">3</span>;</span><br><span class="line">        Integer d = <span class="number">3</span>;</span><br><span class="line">        Integer e = <span class="number">321</span>;</span><br><span class="line">        Integer f = <span class="number">321</span>;</span><br><span class="line">        Long g = <span class="number">3L</span>;</span><br><span class="line">        Long h = <span class="number">2L</span>;</span><br><span class="line">    </span><br><span class="line">        System.out.println(c==d); <span class="comment">// true</span></span><br><span class="line">        System.out.println(e==f); <span class="comment">// false</span></span><br><span class="line">        System.out.println(c==(a+b)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(c.equals(a+b)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(g==(a+b)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(g.equals(a+b)); <span class="comment">// false</span></span><br><span class="line">        System.out.println(g.equals(a+h)); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第一个和第二个输出结果没有什么疑问。第三句由于 a+b包含了算术运算，因此会触发自动拆箱过程（会调用intValue方法），因此它们比较的是数值是否相等。而对于c.equals(a+b)会先触发自动拆箱过程，再触发自动装箱过程，也就是说a+b，会先各自调用intValue方法，得到了加法运算后的数值之后，便调用Integer.valueOf方法，再进行equals比较。同理对于后面的也是这样，不过要注意倒数第二个和最后一个输出的结果（如果数值是int类型的，装箱过程调用的是Integer.valueOf；如果是long类型的，装箱调用的Long.valueOf方法）。</p>
</blockquote>
<h3 id="equals-和hashCode-方法"><a href="#equals-和hashCode-方法" class="headerlink" title="equals()和hashCode()方法"></a>equals()和hashCode()方法</h3><blockquote>
<p>没重写了equals的类调用equals方法和使用<code>==</code>等价，比较两个对象的地址是否相同<br>重写equals方法时，需要注意满足其原生的一些特点，可参考下面代码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(obj == <span class="keyword">null</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果是同一个对象返回true，反之返回false</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span> == obj)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//判断是否类型相同</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.getClass() != obj.getClass())&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 最后制定自己想要的规则进行重写</span></span><br><span class="line">      Person person = (Person)obj;</span><br><span class="line">      <span class="keyword">return</span> name.equals(person.name) &amp;&amp; age == person.age;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>hashCode方法获取对象的一个哈希码，即一个整数值。且<strong>hashCode() 在散列表中才有用，在其它情况下没用。</strong>在散列表中hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。</p>
</blockquote>
<blockquote>
<p>由此可知，若两个元素相等，它们的散列码一定相等；但反过来确不一定。在散列表中，<br>1、如果两个对象相等，那么它们的hashCode()值一定要相同；<br>2、如果两个对象hashCode()相等，它们并不一定相等。<br>注意：这是在散列表中的情况。在非散列表中一定如此！</p>
</blockquote>
<p><strong>为什么重写 <code>equals</code> 时必须重写 <code>hashCode</code> 方法？</strong></p>
<blockquote>
<p>本质：为了遵守2个对象equals，那么其hashCode一定相同的规则。</p>
<p>如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等，对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。<strong>因此，equals 方法被覆盖过，则 <code>hashCode</code> 方法也必须被覆盖。</strong></p>
</blockquote>
<blockquote>
<p>且<code>hashCode()</code>的默认行为是对堆上的对象产生独特值。如果没有重写 <code>hashCode()</code>，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p>
</blockquote>
<h3 id="Java值传递"><a href="#Java值传递" class="headerlink" title="Java值传递"></a>Java值传递</h3><blockquote>
<p>Java 程序设计语言对对象采用的不是引用调用，实际上，对象引用也是按值传递的。</p>
<p>下面再总结一下 Java 中方法参数的使用情况：</p>
<ul>
<li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。</li>
<li>一个方法可以改变一个对象参数的状态。</li>
<li>一个方法不能让对象参数引用一个新的对象。</li>
</ul>
<p>可参考下面的代码理解</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person();</span><br><span class="line">        p1.name = <span class="string">"1"</span>;</span><br><span class="line">        p2.name = <span class="string">"2"</span>;</span><br><span class="line">        change(p1, p2);</span><br><span class="line">        System.out.println(p1.name);</span><br><span class="line">        <span class="comment">// 输出 1</span></span><br><span class="line">        changeName(p1, p2);</span><br><span class="line">        System.out.println(p1.name);</span><br><span class="line">        <span class="comment">// 输出 2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(Person p1, Person p2)</span> </span>&#123;</span><br><span class="line">        p1 = p2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changeName</span><span class="params">(Person p1, Person p2)</span> </span>&#123;</span><br><span class="line">        p1.name = p2.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>final 关键字主要用在三个地方：变量、方法、类。</p>
<blockquote>
<p>对于一个 final 变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</p>
<p>当用 final 修饰一个类时，表明这个类不能被继承。final 类中的所有成员方法都会被隐式地指定为 final 方法。</p>
<p>使用 final 方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的 Java 实现版本中，会将 final 方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的 Java 版本已经不需要使用 final 方法进行这些优化了）。类中所有的 private 方法都隐式地指定为 final。</p>
</blockquote>
<h3 id="I-O流"><a href="#I-O流" class="headerlink" title="I/O流"></a>I/O流</h3><p>流的种类：</p>
<blockquote>
<p>按照流的流向分，可以分为输入流和输出流；</p>
<p>按照操作单元划分，可以划分为字节流和字符流；</p>
<p>按照流的角色划分为节点流和处理流。</p>
</blockquote>
<p>对于所有相关类，都由下方四个抽象基类进行派生</p>
<blockquote>
<p>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</p>
<p>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</p>
</blockquote>
<p>BIO、NIO、AIO</p>
<blockquote>
<p><strong>BIO (Blocking I/O):</strong> 同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机 1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</p>
<p><strong>NIO (Non-blocking/New I/O):</strong> NIO 是一种同步非阻塞的 I/O 模型，在 Java 1.4 中引入了 NIO 框架，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 NIO 提供了与传统 BIO 模型中的 <code>Socket</code> 和 <code>ServerSocket</code> 相对应的 <code>SocketChannel</code> 和 <code>ServerSocketChannel</code> 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞 I/O 来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发</p>
<p><strong>AIO (Asynchronous I/O):</strong> AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步 IO 的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO 操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</p>
</blockquote>
<h2 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>ArrayList和LinkedList</p>
<blockquote>
<p>均不同步，均不保证线程安全。</p>
<p>ArrayList：底层由Object数组实现。插入元素到末尾O(1)，插入元素到指定位置O(n-i)。且支持高效的随机访问。</p>
<p>LinkedList：底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环)，插入元素到末尾O(1)，插入元素到指定位置O(n)，需要移动指针。</p>
<p>补充：<code>RandomAccess</code> 接口。里面没有任何定义，仅仅作为标识，是否支持快速随机访问。ArrayList实现了该接口而LinkedList没有。</p>
<p>Vector：List的古老实现类，底层使用Object数组实现，且保证线程安全。</p>
</blockquote>
<p>ArrayList扩容机制</p>
<blockquote>
<p>对于空参构造时，会初始化一个空数组，直到第一个元素被添加时，才会扩容到10。懒加载(但在jdk7及以前会直接初始化一个容量为10的数组)</p>
<p>对于需要扩容的过程。则是<code>ensureCapacityInternal()</code> -&gt; <code>ensureExplicitCapacity()</code> -&gt; <code>grow()</code></p>
<p>对于前两个方法，主要就是处理容量初始化和判断是否需要扩容。</p>
<p>对于核心<code>grow()</code>方法，需要扩容时，会首先扩容置原容量的1.5倍左右(<code>new = old + old &gt;&gt; 1</code>)，然后如果new满足需求，则会直接用new作为新容量，否则会将当前所需容量作为新容量。如果new已经大于了所给的<code>MAX_ARRAY_SIZE</code>即<code>Integer.MAX_VALUE - 8</code>，则会根据当前所需容量和<code>MAX_ARRAY_SIZE</code>进行比较吗，从而决定取<code>MAX_ARRAY_SIZE</code>或者<code>Integer.MAX_VALUE</code>。</p>
<p>tips：向 ArrayList 添加大量元素之前最好先使用<code>ensureCapacity</code> 方法，以减少增量重新分配的次数。</p>
</blockquote>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>HashMap vs HashTable</p>
<blockquote>
<p>HashMap: 线程不安全。支持<code>null</code>作为键和值，但只允许存在一个以<code>null</code>为键的键值对，允许多个键值对以<code>null</code>作为值。</p>
<p>HashTable: 线程安全(现在基本使用ConcurrentHashMap保证线程安全)，HashTable基本已经被淘汰。HashTable不允许<code>null</code>作为键或者值，会抛出<code>NullPointerException</code>异常。</p>
<p>① 创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证）。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</p>
</blockquote>
<p>HashSet</p>
<blockquote>
<p>底层由HashMap实现。</p>
<p>添加元素机制：当你把对象加入<code>HashSet</code>时，<code>HashSet</code> 会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p>
</blockquote>
<p>HashMap底层实现</p>
<blockquote>
<p>JDK1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。<strong>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</strong></p>
<p>JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</p>
</blockquote>
<p>HashMap长度为2的幂次方</p>
<blockquote>
<p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648到2147483647，前后加起来大概40亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个40亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ <code>(n - 1) &amp; hash</code>”。（n代表数组长度）。这也就解释了 HashMap 的长度为什么是2的幂次方。</p>
<p><code>(n - 1) &amp; hash</code>也就是<code>hash % (n - 1)</code>的快速版本。</p>
</blockquote>
<p>HashMap多线程情况下死循环的问题</p>
<blockquote>
<p>详情请查看：<a href="https://coolshell.cn/articles/9606.html" target="_blank" rel="noopener">https://coolshell.cn/articles/9606.html</a></p>
</blockquote>
<p>ConcurrentHashMap 和 Hashtable 的区别]</p>
<blockquote>
<p><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别主要体现在实现线程安全的方式上不同。</p>
<p><strong>底层数据结构：</strong> JDK1.7 的 <code>ConcurrentHashMap</code> 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，数组+链表/红黑二叉树。<code>Hashtable</code> 和 JDK1.8 之前的 <code>HashMap</code> 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</p>
<p><strong>实现线程安全的方式（重要）：</strong> ① <strong>在 JDK1.7 的时候，<code>ConcurrentHashMap</code>（分段锁）</strong> 对整个桶数组进行了分割分段(<code>Segment</code>)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 <strong>到了 JDK1.8 的时候已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。（JDK1.6 以后 对 <code>synchronized</code> 锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② <strong><code>Hashtable</code>(同一把锁)</strong> :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</p>
</blockquote>
<p>ConcurrentHashMap线程安全的具体实现方式/底层具体实现</p>
<blockquote>
<p>jdk1.7：首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p>
<p><strong><code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成</strong>。</p>
<p>Segment 实现了 <code>ReentrantLock</code>,所以 <code>Segment</code> 是一种可重入锁，扮演锁的角色。<code>HashEntry</code> 用于存储键值对数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个 <code>ConcurrentHashMap</code> 里包含一个 <code>Segment</code> 数组。<code>Segment</code> 的结构和 <code>HashMap</code> 类似，是一种数组和链表结构，一个 <code>Segment</code> 包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 是一个链表结构的元素，每个 <code>Segment</code> 守护着一个 <code>HashEntry</code> 数组里的元素，当对 <code>HashEntry</code> 数组的数据进行修改时，必须首先获得对应的 <code>Segment</code> 的锁。</p>
</blockquote>
<blockquote>
<p>jdk1.8：<code>ConcurrentHashMap</code> 取消了 <code>Segment</code> 分段锁，采用 CAS 和 <code>synchronized</code> 来保证并发安全。数据结构跟 HashMap1.8 的结构类似，数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）。<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>List</p>
<ul>
<li><code>Arraylist</code>： <code>Object[]</code>数组</li>
<li><code>Vector</code>：<code>Object[]</code>数组</li>
<li><code>LinkedList</code>： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</li>
</ul>
<p>Set</p>
<ul>
<li><code>HashSet</code>（无序，唯一）: 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素</li>
<li><code>LinkedHashSet</code>：<code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。有点类似于我们之前说的 <code>LinkedHashMap</code> 其内部是基于 <code>HashMap</code> 实现一样，不过还是有一点点区别的</li>
<li><code>TreeSet</code>（有序，唯一）： 红黑树(自平衡的排序二叉树)</li>
</ul>
<p>再来看看 <code>Map</code> 接口下面的集合。</p>
<p>Map</p>
<ul>
<li><code>HashMap</code>： JDK1.8 之前 <code>HashMap</code> 由数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li>
<li><code>LinkedHashMap</code>： <code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：<a href="https://www.imooc.com/article/22931" target="_blank" rel="noopener">《LinkedHashMap 源码详细分析（JDK1.8）》</a></li>
<li><code>Hashtable</code>： 数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的</li>
<li><code>TreeMap</code>： 红黑树（自平衡的排序二叉树</li>
</ul>
<h2 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h2><p>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</p>
<blockquote>
<p> new 一个 Thread，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<p><strong>总结： 调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</strong></p>
</blockquote>
<h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><p><strong>synchronized 关键字最主要的三种使用方式：</strong></p>
<blockquote>
<p><strong>1.修饰实例方法:</strong> 作用于当前对象实例加锁，进入同步代码前要获得 <strong>当前对象实例的锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.修饰静态方法:</strong> 也就是给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 <strong>当前 class 的锁</strong>。因为静态成员不属于任何一个实例对象，是类成员（ _static 表明这是该类的一个静态资源，不管 new 了多少个对象，只有一份_）。所以，如果一个线程 A 调用一个实例对象的非静态 <code>synchronized</code> 方法，而线程 B 需要调用这个实例对象所属类的静态 <code>synchronized</code> 方法，是允许的，不会发生互斥现象，<strong>因为访问静态 <code>synchronized</code> 方法占用的锁是当前类的锁，而访问非静态 <code>synchronized</code> 方法占用的锁是当前实例对象锁</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> staic <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.修饰代码块</strong> ：指定加锁对象，对给定对象/类加锁。<code>synchronized(this|object)</code> 表示进入同步代码库前要获得<strong>给定对象的锁</strong>。<code>synchronized(类.class)</code> 表示进入同步代码前要获得 <strong>当前 class 的锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">  <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ul>
<li><code>synchronized</code> 关键字加到 <code>static</code> 静态方法和 <code>synchronized(class)</code> 代码块上都是是给 Class 类上锁。</li>
<li><code>synchronized</code> 关键字加到实例方法上是给对象实例上锁。</li>
<li>尽量不要使用 <code>synchronized(String a)</code> 因为 JVM 中，字符串常量池具有缓存功能！</li>
</ul>
</blockquote>
<h3 id="MESI缓存一致性协议"><a href="#MESI缓存一致性协议" class="headerlink" title="MESI缓存一致性协议"></a>MESI缓存一致性协议</h3><p>多个cpu从主内存读取同一个数据到各自的高速缓存，当其中某个cpu修改了缓存里的数据，该数据会马上同步回主内存，其它cpu通过<strong>总线嗅探机制</strong>可以感知到数据的变化从而将自己缓存里的数据失效。从而使得cpu重新到主存中读取已经被更新的数据。</p>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><blockquote>
<p>是一种轻量级的同步机制，保证了可见性和有序性，通过内存屏障能够防止指令重排。</p>
</blockquote>
<p>保证可见性的原理：</p>
<blockquote>
<p>可见性：总线嗅探机制。</p>
<p>当volatile修饰的变量发生改变时，线程A会立刻将该变量从工作内存同步到共享内存中且强迫其他拥有该变量副本的线程(线程B)中的该变量失效，使其必须重新从主存中拷贝更新后的变量。</p>
<p>且有volatile修饰的共享变量进行写操作的时候多出一条带<code>lock</code>前缀的指令，且lock前缀的指令在多核处理器下会引发两件事情：</p>
<ol>
<li>将当前处理器缓存行的数据写回到系统内存。</li>
<li>这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。</li>
</ol>
</blockquote>
<p><strong>内存屏障</strong></p>
<p>内次屏障分为以下4类</p>
<table>
<thead>
<tr>
<th align="left">屏障类型</th>
<th align="left">指令示例</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">LoadLoad Barries</td>
<td align="left">Load1;LoadLoad;Load2</td>
<td align="left">确保Load1数据的装载先于Load2以及后续装载指令的装载。</td>
</tr>
<tr>
<td align="left">StoreStore Barries</td>
<td align="left">Store1;StoreStore;Store2</td>
<td align="left">确保Store1数据刷新到内存先于Store2以及后续存储指令的存储。</td>
</tr>
<tr>
<td align="left">LoadStore Barries</td>
<td align="left">Load1;LoadStore;Store2</td>
<td align="left">确保Load1数据的装载先于Store2数据刷新到内存以及后续存储指令的存储。</td>
</tr>
<tr>
<td align="left">StoreLoad Barries</td>
<td align="left">Store1;StoreLoad;Load2</td>
<td align="left">确保Store1数据刷新到内存先于Load2数据的装载以及后续装载指令的装载。</td>
</tr>
</tbody></table>
<p>volatile实现有序性：</p>
<blockquote>
<ul>
<li>在每个volatile写操作的前面插入一个StoreStore屏障。禁止前面的普通写和下面的volatile写重排序。</li>
<li>在每个volatile写操作的后面插入一个StoreLoad屏障。禁止前面的volatile写和下面可能有的volatile读的重排序。</li>
<li>在每个volatile读操作的后面插入一个LoadLoad屏障。禁止前面的volatile读和下面的普通读重排序。</li>
<li>在每个volatile读操作的后面再插入一个LoadStore屏障。禁止前面的volatile读和下面的普通写重排序。</li>
</ul>
</blockquote>
<p>synchronized保证可见性和有序性原理：</p>
<blockquote>
<p>可见性：</p>
<p>JMM关于synchronized的两条规定：</p>
<p>1）线程解锁前，必须把共享变量的最新值刷新到主内存中</p>
<p>2）线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新获取最新的值</p>
<p>（注意：加锁与解锁需要是同一把锁）</p>
<p>有序性：</p>
<p>因为synchronized是一种排他锁，所以同一时刻只有一个线程执行，保证加锁的代码是单线程的，遵循as-if-serial语义，因此能够保证有序性。</p>
</blockquote>
<p>volatile和synchronized同步使用的原因</p>
<blockquote>
<p>关于这个问题有一个很经典的例子，就是单例模式中的双重检查加锁对象初始化可能为null的问题，这个问题就是指令重排引起的。</p>
<p>具体来说就是synchronized虽然保证了原子性，但却没有保证指令重排序的正确性； </p>
<p>volatile使共享变量在线程的工作内存中修改后的值能够立即更新到进程主内存，即 volitile 可以保证共享变量值对所有线程的“可见性”，但是它不能保证原子性，</p>
<p>而且他还有一个很好的附加功能，那就是禁止指令重排。</p>
<p>将 synchronized 与 volatile 联合使用就可以解决这个问题</p>
</blockquote>
<h3 id="CAS-compare-and-swap"><a href="#CAS-compare-and-swap" class="headerlink" title="CAS(compare and swap)"></a>CAS(compare and swap)</h3><p>CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。</p>
<p>更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。</p>
<blockquote>
<p>缺点：会一直循环，开销较大。</p>
<p>对于一个共享变量执行操作时，可以通过循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS无法保证原子性，需要通过锁来保证原子性。</p>
</blockquote>
<h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><p>所谓ABA问题，就是CAS算法实现需要取出内存中某时刻的数据并在当下时刻比较并替换，这里存在一个时间差，使用AtomicStampedReference类可以解决ABA问题。这个类维护了一个“版本号”Stamp，在进行CAS操作的时候，不仅要比较当前值，还要比较版本号。只有两者都相等，才执行更新操作。</p>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><h2 id="MySQL调优"><a href="#MySQL调优" class="headerlink" title="MySQL调优"></a>MySQL调优</h2><p>redo log、undo log、binlog</p>
<p><img src="https://i.loli.net/2021/03/04/K8chDsaJLgeWFpU.png" alt="image.png"></p>
<ul>
<li>redo log是属于innoDB层面，binlog属于MySQL Server层面的，这样在数据库用别的存储引擎时可以达到一致性的要求。</li>
<li>redo log是物理日志，记录该数据页更新的内容；binlog是逻辑日志，记录的是这个更新语句的原始逻辑</li>
<li>redo log是循环写，日志空间大小固定；binlog是追加写，是指一份写到一定大小的时候会更换下一个文件，不会覆盖。</li>
<li>binlog可以作为恢复数据使用，主从复制搭建，redo log作为异常宕机或者介质故障后的数据恢复使用。</li>
</ul>
<p>事务特性：ACID。</p>
<p>事务隔离界别：</p>
<ol>
<li>读未提交（READ UNCOMMITTED）</li>
<li>读提交 （READ COMMITTED）</li>
<li>可重复读 （REPEATABLE READ）-&gt; 默认</li>
<li>串行化 （SERIALIZABLE）</li>
</ol>
<p>三范式：</p>
<p>1、不可分割    2、依赖于主键 主键约束    3、外键约束    BF、消除传递依赖</p>
<h3 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h3><p>存储引擎是针对<strong>表</strong>而言的，而不是针对<strong>整个数据库</strong>。即每个表可拥有不同的存储引擎。</p>
<p>种类：</p>
<blockquote>
<p>MyISAM：高速，在MySQL5.5版本前是作为默认存储引擎，但不支持事务。</p>
<p>InnoDB：作为MySQL 5.5版本后的默认存储引擎，支持事务和行级锁(行锁才能产生死锁)，比MyISAM稍慢。</p>
<p>Memory：内存存储引擎，效率很高，但数据容易丢失，用于临时表使用。</p>
</blockquote>
<p>顺序IO：追加操作。传输时间</p>
<p>随机IO：随机操作，可能写在随机的扇区。寻道时间+旋转时间+传输时间</p>
<p>MyISAM引擎：</p>
<blockquote>
<p><code>.frm</code>文件：存储表的结构定义</p>
<p><code>.MYD</code>文件：存储数据的文件</p>
<p><code>.MYI</code>文件：存储索引的文件</p>
<p>支持表锁，不支持行锁。不支持事务。</p>
<p>计算count：有专门存储count的地方。</p>
<p>主键索引为非聚集索引(索引文件和数据文件分离)</p>
</blockquote>
<p>InnoDB引擎：</p>
<blockquote>
<p><code>.frm</code>文件：存储表的结构定义</p>
<p><code>.ibd</code>文件：数据和索引均存储在该文件</p>
<p>支持表锁和行锁，也支持事务。</p>
<p>计算count：需要扫表。</p>
<p>因为数据文件本身就是按照B+树组织的索引结构文件。</p>
<p>主键索引为聚集索引。</p>
</blockquote>
<p>MyISAM索引B+树中的叶节点存储的data为：该索引对应数据的<strong>磁盘文件指针</strong></p>
<p>InnoDB索引B+树中的叶节点存储的data为：直接为该索引对应的数据，而不用再多一步指针</p>
<h3 id="MySQL性能分析"><a href="#MySQL性能分析" class="headerlink" title="MySQL性能分析"></a>MySQL性能分析</h3><ol>
<li>使用【慢查询功能】，获取查询时间较长的sql语句</li>
<li>【查看执行计划】，查看有问题的sql的执行计划</li>
<li>使用【<code>show profiles</code>】查看有问题的sql语句的性能使用情况</li>
</ol>
<h3 id="MySQL索引优化"><a href="#MySQL索引优化" class="headerlink" title="MySQL索引优化"></a>MySQL索引优化</h3><p>索引也很大，存储在磁盘上，且索引也就是一种数据结构(B+树)。</p>
<p>索引优劣</p>
<blockquote>
<p>优点：① 提高数据检索效率，降低IO成本；② 通过索引列对数据进行排序，降低排序成本和CPU消耗。(被索引的列会自动排序，对于<code>order by</code>等语句效率也会提高)</p>
<p>缺点：① 索引会占据磁盘空间；② 能提高查询效率但是会降低更新表的效率。比如每次对表进行增删改，需要对索引结构进行变更。</p>
</blockquote>
<p>常用索引：单列索引和组合索引。</p>
<blockquote>
<p>单列索引：<br>① 普通索引：MySQL基本索引类型，允许重复值和空值。<br>② 唯一索引：索引列值唯一，可包含空值。<br>③ 主键索引：特殊唯一索引，允许空值。</p>
<p>组合索引：<br>在表的多个字段组合上创建的一个索引。<br>组合索引的使用需要遵循最左前缀原则(最左匹配原则)。<br>且一般情况建议使用组合索引代替单列索引(主键索引除外)。</p>
</blockquote>
<p>MySQL的索引实现</p>
<blockquote>
<p><code>HASH</code>：无法进行范围查找，很少的存储引擎支持。Memory存储引擎支持。</p>
<p><code>B+ tree</code>：几乎都使用该数据结构存储索引。</p>
</blockquote>
<h4 id="聚集索引-IOT索引组织表-——InnoDB"><a href="#聚集索引-IOT索引组织表-——InnoDB" class="headerlink" title="聚集索引(IOT索引组织表)——InnoDB"></a>聚集索引(IOT索引组织表)——InnoDB</h4><p><strong>聚集索引即表数据和索引在一起的。</strong></p>
<p>MySQL在执行查询时，一般情况是通过<strong>优化器</strong>选择<strong>一个</strong>索引来进行使用的。</p>
<p>主键索引(聚簇索引)的叶子节点存储数据行，辅助索引只会存储主键值(不是地址值)。辅助索引可以有多个，主键索引有且只有一个。</p>
<p>即如果是非主键查询，需要搜索两次索引树(一次是辅助索引树，一次是主键索引树)，最终取得数据。</p>
<p>若没有主键：</p>
<blockquote>
<p>先寻找一个唯一非空列作为主键索引，如果还是没有。则自动生成一个隐藏列用作主键索引。</p>
</blockquote>
<p>InnoDB表为何必须要主键，且推荐使用整型自增主键而非UUID</p>
<blockquote>
<p>因为InnoDB需要<code>B+ tree</code>来存储数据，而<code>B+ tree</code>依赖于主键索引。</p>
<p>① <code>UUID</code>占据空间更大<br>② 查找或者插入时，<code>UUID</code>之间的比较和整型之间的比较相比效率较低<br>③ 当自增主键插入到<code>B+ tree</code>时，可以直接添加在叶子节点最右方，方便快捷分裂的可能也很小，而<code>UUID</code>插入时则可能会导致已经存储满的节点分裂和树的自动平衡，效率低。</p>
</blockquote>
<h4 id="非聚集索引-堆组织表-——MyISAM"><a href="#非聚集索引-堆组织表-——MyISAM" class="headerlink" title="非聚集索引(堆组织表)——MyISAM"></a>非聚集索引(堆组织表)——MyISAM</h4><p>由索引得到数据的地址然后从磁盘中进行读取。</p>
<h3 id="组合索引的使用"><a href="#组合索引的使用" class="headerlink" title="组合索引的使用"></a>组合索引的使用</h3><h4 id="为何使用组合索引"><a href="#为何使用组合索引" class="headerlink" title="为何使用组合索引"></a>为何使用组合索引</h4><p>为了<strong>节省mysql索引存储空间以及提升搜索性能</strong>，可建立组合索引(能使用组合索引就不使用单例索引)</p>
<p>例如：创建如下的一个组合索引，相当于建立了<code>col1 | col1 col2 | col1 col2 col3</code>三个索引∶</p>
<p>以下语句会创建—棵<code>B+ Tree</code> ，但是它相当于三棵索引树的功效</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">'table_name'</span> <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_name(<span class="string">'col1'</span>,<span class="string">'col2'</span>,<span class="string">'col3'</span>)</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<blockquote>
<p><strong>当查询条件为<code>... where col2 = xxx</code>时，是不会走索引的。</strong></p>
<p><strong>而查询条件为<code>... where col2 = xxx and col1 = xxx and col3 = xxx</code>是会由优化器优化查询条件的顺序从而走<code>col1 col2 col3</code>这个索引的。</strong></p>
</blockquote>
<h4 id="如何创建组合索引"><a href="#如何创建组合索引" class="headerlink" title="如何创建组合索引"></a>如何创建组合索引</h4><p>如何选择哪些列用来创建组合索引 ?</p>
<p>1．常出现在where条件中的列，建议用来创建组合索引，至于组合索引中的顺序，是很重要的。使用到最左前缀原则。但是因为MySQL中存在查询优化器，所以你的书写SQL条件的顺序，不一定是where条件顺序。</p>
<p>2．常出现在order by和group by语句中的列。最后按照顺序去创建组合索引。</p>
<p>3．常出现在select语句中的列，也建议按照顺序，创建组合索引。</p>
<h4 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h4><p>顾名思义，就是最左优先，这个最左是针对于组合索引和前缀索引，理解如下∶</p>
<ol>
<li><p>最左前缀匹配原则，非常重要的原则，MySQL会一直向右匹配直到遇到范围查询<code>(&gt;、&lt;、between、like)</code>就停止匹配，比如<code>a = 1 and b = 2 and c &gt; 3 and d = 4</code> 如果建立<code>(a, b, c, d)</code>顺序的索引，<code>d</code>是用不到索引的，如果建立<code>(a, b, d, c)</code>的索引，则都可以用到，<code>a, b, d</code>的顺序可以任意调整。</p>
</li>
<li><p><code>=</code>和<code>in</code>可以乱序，比如<code>a = 1 and b = 2 and c = 3</code>建立<code>(a, b, c)</code>索引可以任意顺序，MySQL的查询优化器会帮你优化成索引可以识别的形式</p>
</li>
</ol>
<h3 id="如何使用索引"><a href="#如何使用索引" class="headerlink" title="如何使用索引"></a>如何使用索引</h3><h4 id="哪些情况需要创建索引"><a href="#哪些情况需要创建索引" class="headerlink" title="哪些情况需要创建索引"></a>哪些情况需要创建索引</h4><ol>
<li>主键自动建立唯一索引</li>
<li>频繁作为查询条件的字段应该创建索引（业务）</li>
<li>多表关联查询中，关联字段应该创建索引</li>
<li>查询中统计或者分组字段，应该创建索引</li>
<li>查询中排序的字段，应该创建索引</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql创建组合索引的规先会对组合索引的最左边的，也就是第一个name字段的数据进行排序，在第一个字段的排序基础上，然后再对后面第二个的cid字段进行排序。其实就相当于实现了类似 order by name cid这样一种排序规则。</span><br></pre></td></tr></table></figure>

<h4 id="哪些情况不需要创建索引"><a href="#哪些情况不需要创建索引" class="headerlink" title="哪些情况不需要创建索引"></a>哪些情况不需要创建索引</h4><ol>
<li>表记录太少</li>
<li>经常进行增删改操作的表</li>
<li>更新的字段</li>
<li>where条件里使用频率不高的字段</li>
</ol>
<h3 id="查看执行计划"><a href="#查看执行计划" class="headerlink" title="查看执行计划"></a>查看执行计划</h3><h4 id="建表语句"><a href="#建表语句" class="headerlink" title="建表语句"></a>建表语句</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">create table user(</span><br><span class="line">	id int primary key,</span><br><span class="line">	name varchar(100),</span><br><span class="line">	age int,</span><br><span class="line">	sex char(1),</span><br><span class="line">	address varchar(100)</span><br><span class="line">);</span><br><span class="line">alter table user add index idx_name_age(name(10), age);</span><br><span class="line">alter table user add index idx_sex(sex);</span><br><span class="line"></span><br><span class="line">insert into user(id, name, age, sex, address) values (1, &apos;zhangsan&apos;, 20, &apos;0&apos;, &apos;致真大厦&apos;);</span><br></pre></td></tr></table></figure>

<p>特别说明</p>
<blockquote>
<p>name列的长度是varchar(100),但是创建索引的时候，指定的长度却是10，这是使用了<strong>前缀索引</strong>这个概念。</p>
<p>前缀索引一般是针对字符串。</p>
</blockquote>
<h5 id="MySQL前缀索引和索引选择性"><a href="#MySQL前缀索引和索引选择性" class="headerlink" title="MySQL前缀索引和索引选择性"></a>MySQL前缀索引和索引选择性</h5><p>有时候需要索引很长的字符列，这会让索引变得大且慢。通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但这样也会降低<strong>索引的选择性</strong>。<strong>索引的选择性是指不重复的索引值（也称为基数，cardinality)和数据表的记录总数的比值，范围从1/#T到1之间。</strong>索引的选择性越高则查询效率越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的行。唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p>
<p>一般情况下某个前缀的选择性也是足够高的，足以满足查询性能。对于BLOB，TEXT，或者很长的VARCHAR类型的列，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度。</p>
<p>诀窍在于要选择足够长的前缀以保证较高的选择性，同时又不能太长（以便节约空间）。前缀应该足够长，以使得前缀索引的选择性接近于索引的整个列。换句话说，前缀的”基数“应该接近于完整的列的”基数“。</p>
<p>前缀索引是一种能使索引更小，更快的有效办法，但另一方面也有其缺点：</p>
<p><strong>mysql无法使用其前缀索引做ORDER BY和GROUP BY，也无法使用前缀索引做覆盖扫描。</strong></p>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>MySQL提供了一个<code>EXPLAIN</code>命令，它可以对SELECT语句的执行计划进行分析，并输出SELECT执行的详细信息，以供开发人员针对性优化。</p>
<p>使用explain这个命令来查看一个这些SQL语句的执行计划，查看该SQL语句有没有使用上了索引，有没有做全表扫描，这都可以通过explain命令来查看。</p>
<p>可以通过explain命令深入了解MySQL的基于开销的优化器，还可以获得很多可能被优化器考虑到的访问策略的细节，以及当运行SQL语句时哪种策略预计会被优化器采用。</p>
<p>EXPLAIN命令用法十分简单，在SELECT语句前加上explain就可以了，例如:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><p>EXPLAIN命令的输出内容大致如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from user where id = 2\G</span><br><span class="line">******************** 1. row ************************</span><br><span class="line">id: 1</span><br><span class="line">select_type: SIMPLE</span><br><span class="line">table: user_info</span><br><span class="line">partitions: NULL</span><br><span class="line">type: const</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">key: PRIMARY</span><br><span class="line">key_len: 8</span><br><span class="line">ref: const</span><br><span class="line">row: 1</span><br><span class="line">filtered: 100.00</span><br><span class="line">Extra: NULL</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>各列含义</p>
<ul>
<li>id: SELECT查询的标识符．每个SELECT都会自动分配一个唯一的标识符.</li>
<li>select_type: SELECT查询的类型.</li>
<li>table: 查询的是哪个表</li>
<li>partitions: 匹配的分区</li>
<li>type: join类型</li>
<li>possible_keys: 此次查询中可能选用的索引</li>
<li>key: 此次查询中确切使用到的索引.</li>
<li>ref: 哪个字段或常数与key一起被使用</li>
<li>rows: 显示此查询一共扫描了多少行．这个是一个估计值.</li>
<li>filtered: 表示此查询条件所过滤的数据的百分比</li>
<li>extra: 额外的信息</li>
</ul>
<h5 id="type"><a href="#type" class="headerlink" title="type"></a>type</h5><p>显示的是单位查询的连接类型或者理解为访问类型，访问性能依次从好到差：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">system</span><br><span class="line">const</span><br><span class="line">eq_ref</span><br><span class="line">ref</span><br><span class="line">fulltext</span><br><span class="line">ref_or_null</span><br><span class="line">unique_subquery</span><br><span class="line">index_subquery</span><br><span class="line">range</span><br><span class="line">index_merge</span><br><span class="line">index</span><br><span class="line">ALL</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<blockquote>
<p>除了<code>All</code>之外，其他的<code>type</code>都可以用到索引<br>除了<code>index_merge</code>之外，其他的<code>type</code>只能用到一个索引<br>最少要使用到<code>range</code>级别</p>
</blockquote>
<h6 id="system"><a href="#system" class="headerlink" title="system"></a>system</h6><blockquote>
<p>只有一行数据，或者是空表时</p>
</blockquote>
<h6 id="const-重要"><a href="#const-重要" class="headerlink" title="const(重要)"></a>const(重要)</h6><blockquote>
<p>使用唯一索引或者主键，返回记录一定是1行记录的等值where条件时，通常type是const。其他数据库也叫做唯一索引扫描。</p>
</blockquote>
<h6 id="eq-ref-重要"><a href="#eq-ref-重要" class="headerlink" title="eq_ref(重要)"></a>eq_ref(重要)</h6><blockquote>
<p>此类型通常出现在多表的join查询，表示对于前表的每一个结果，都只能匹配到后表的一行结果．并且查询的比较操作通常是<code>=</code>，查询效率较高。</p>
<p>和<code>ref</code>相比，<code>eq_ref</code>主要针对唯一索引。</p>
</blockquote>
<h6 id="ref-重要"><a href="#ref-重要" class="headerlink" title="ref(重要)"></a>ref(重要)</h6><blockquote>
<p>针对非唯一性索引或者组合索引；使用等值( <code>=</code>)查询。或者是使用了最左前缀规则索引的查询。</p>
</blockquote>
<h6 id="fulltext"><a href="#fulltext" class="headerlink" title="fulltext"></a>fulltext</h6><blockquote>
<p>全文索引检索，要注意，全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql不管代价，优先选择使用全文索引</p>
</blockquote>
<h6 id="ref-or-null"><a href="#ref-or-null" class="headerlink" title="ref_or_null"></a>ref_or_null</h6><blockquote>
<p>与ref方法类似，只是增加了null值的比较。实际用的不多。</p>
</blockquote>
<h6 id="unique-subquery"><a href="#unique-subquery" class="headerlink" title="unique_subquery"></a>unique_subquery</h6><blockquote>
<p>用于where中的in形式子查论查询返回不重复值唯一值</p>
</blockquote>
<h6 id="index-subquery"><a href="#index-subquery" class="headerlink" title="index_subquery"></a>index_subquery</h6><blockquote>
<p>用于in形式子查询使用到了辅助索引或者in常数列表，子查询可能返回重复值，可以使用索引将子查询去重,</p>
</blockquote>
<h6 id="range-重要"><a href="#range-重要" class="headerlink" title="range(重要)"></a>range(重要)</h6><blockquote>
<p>索引范围扫描，常见于使用&gt;,&lt;,is null, between ,in ,like等运算符的查询中。</p>
</blockquote>
<h6 id="index-merge"><a href="#index-merge" class="headerlink" title="index_merge"></a>index_merge</h6><blockquote>
<p>表示查询使用了两个以上的索引，最后取交集或者并集，常见and , or的条件使用了不同的索引，官方排序这个在ref_or_null之后，但是实际上由于要读取所个索引，性能可能大部分时间都不如range</p>
</blockquote>
<h6 id="index-重要"><a href="#index-重要" class="headerlink" title="index(重要)"></a>index(重要)</h6><blockquote>
<p>select结果列中使用到了索引，type会显示为index。即查询的结果列就是索引列，可以直接从索引树上获得，而不用再回表查询。</p>
<p>索引扫描，把索引从头到尾扫一遍，常见于使用索引列就可以处理不需要读取数据文件的查询、可以使用索引排序或者分组的查询。</p>
</blockquote>
<h6 id="all-重要）"><a href="#all-重要）" class="headerlink" title="all(重要）"></a>all(重要）</h6><blockquote>
<p>这个就是全表扫描数据文件，然后再在server层进行过滤返回符合要求的记录。</p>
</blockquote>
<h5 id="extra-重要"><a href="#extra-重要" class="headerlink" title="extra(重要)"></a>extra(重要)</h5><p>这个列包含不适合在其他列中显示但十分重要的额外的信息，这个列可以显示的信息非常多，有几十种。</p>
<h6 id="using-index-重要）"><a href="#using-index-重要）" class="headerlink" title="using index(重要）"></a>using index(重要）</h6><blockquote>
<p>查询时不需要回表查询，直接通过索引就可以获取查询的结果数据。</p>
<ul>
<li>表示相应的SELECT查询中使用到了<strong>覆盖索引(Covering Index)</strong>，避免访问表的数据行，效率不错!（这也是为何大多公司要求尽量不使用<code>select *</code>的原因，因为无法做到索引覆盖，会导致回表查询）</li>
<li>如果同时出现<code>Using Where</code>，说明索引被用来执行查找素引键值</li>
<li>如果没有同时出现<code>Using Where</code>，表明索引用来读取教据而非执行查找动作。</li>
</ul>
</blockquote>
<h6 id="using-where-重要"><a href="#using-where-重要" class="headerlink" title="using where(重要)"></a>using where(重要)</h6><blockquote>
<p>表示Mysql将对storage engine提取的结果进行过滤，过滤条件字段无索引;</p>
<p>如下图，对于该查询语句，使用到了主键索引，所以在innodb存储引擎中会进行第一步过滤，然后对于<code>name = &#39;lisi&#39;</code>则是在MySQL server层进行的第二次过滤，如果在server层进行了第二次过滤，则会显示——<code>using where</code>。</p>
<p>也可以将这两层分别对应数据库的逻辑分页和物理分页进行理解。</p>
</blockquote>
<blockquote>
<p>同时在5.6版本之后，推出了ICP索引下推，即如果下图中<code>name</code>也有索引，则会将其过滤也放在底层进行过滤，进而增大效率。</p>
</blockquote>
<p><img src="https://i.loli.net/2021/02/05/6zs9MQZ4KPrLpFc.png" alt="image.png"></p>
<h6 id="using-index-condition-重要"><a href="#using-index-condition-重要" class="headerlink" title="using index condition(重要)"></a>using index condition(重要)</h6><blockquote>
<p>Using index condition 会先条件过滤索引，过滤完索引后找到所有符合索引条件的数据行，随后用WHERE 子句中的其他条件去过滤这些数据行;</p>
<p>因为MySQL的架构原因，分成了server层和引擎层，才有所谓的“下推”的说法。所以ICP ( Index ConditionPushdown，索引下推）其实就是实现了index filter技术，将原来的在server层进行的table filter中可以进行index filter的部分，在引擎层面使用index filter进行处理，不再需要回表进行table filter。</p>
<p>查询条件中分为限制条件和检查条件，5.6之前，存储引擎只能根据限制条件扫描数据并返回，然后server层根据检查条件进行过滤再返回真正符合查询的数据。5.6.x之后支持<strong>ICP</strong>特性，可以把检查条件也下推到存储引擎层，不符合检查条件和限制条件的数据，直接不读取，这样就大大减少了存储引擎扫描的记录数星。</p>
</blockquote>
<h6 id="using-filesort-重要"><a href="#using-filesort-重要" class="headerlink" title="using filesort(重要)"></a>using filesort(重要)</h6><blockquote>
<ul>
<li>排序时无法使用到索引时，就会出现这个。常见于order by和group by语句中。</li>
<li>说明MySQL会使用一个外部的索引排序，而不是按照索引顺序进行读取。</li>
<li>MySQL中无法利用索引完成的排序操作称为“文件排序”。</li>
</ul>
</blockquote>
<h6 id="using-temporary"><a href="#using-temporary" class="headerlink" title="using temporary"></a>using temporary</h6><blockquote>
<ul>
<li>表示使用了临时表存储中问结果。</li>
<li>MySQL在对查询结果order by和group by时使用临时表</li>
<li>临时表可以是内存临时表和磁盘临时表，执行计划中看不出来，需要查看status变量，used_tmp_table，used_tmp_disk_table才能看出来。</li>
</ul>
</blockquote>
<h6 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h6><blockquote>
<p>在select部分使用了distinct关键字</p>
</blockquote>
<h6 id="no-tables-used"><a href="#no-tables-used" class="headerlink" title="no tables used"></a>no tables used</h6><blockquote>
<p>不带from字句的查询或者From dual查询</p>
</blockquote>
<h3 id="索引失效分析"><a href="#索引失效分析" class="headerlink" title="索引失效分析"></a>索引失效分析</h3><h4 id="案例环境"><a href="#案例环境" class="headerlink" title="案例环境"></a>案例环境</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">staffs员工表 三条记录</span><br><span class="line">+----+------+-----+---------+---------------------+</span><br><span class="line">| id | name | age | pos     | add_time            |</span><br><span class="line">+----+------+-----+---------+---------------------+</span><br><span class="line">| 1  | z3   | 22  | manager | 2016-12-09 09:31:34 |</span><br><span class="line">| 2  | July | 23  | dev     | 2016-12-09 09:31:34 |</span><br><span class="line">| 3  | 2000 | 23  | dev     | 2016-12-09 09:31:34 |</span><br><span class="line">+----+------+-----+---------+---------------------+</span><br><span class="line"></span><br><span class="line">索引:</span><br><span class="line">主键索引(id)和联合索引(name, age, pos)</span><br></pre></td></tr></table></figure>

<h4 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h4><blockquote>
<p>1、全值匹配我最爱(等值匹配且为全值)<br>2、最佳左前缀法则<br>3、不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描<br>4、存储引擎不能使用索引中范围条件右边的列，即在<code>where</code>语句中范围条件右边的列，无法使用索引。<br>5、尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致))，减少<code>select *</code><br>6、mysql在使用不等于(<code>!=</code>或者<code>&lt;&gt;</code>)的时候无法使用索引会导致全表扫描|<br>7、<code>is null ,is not null</code>也无法使用索引<br>8、<code>like</code>以通配符开头(<code>&#39;%abc...&#39;</code>)Mysql索引失效会变成全表扫描的操作<br>9、字符串不加单引号索引失效<br>10、少用<code>or</code>，用它来连接时会索引失效</p>
</blockquote>
<h3 id="MySQL性能优化"><a href="#MySQL性能优化" class="headerlink" title="MySQL性能优化"></a>MySQL性能优化</h3><h4 id="服务器层面优化"><a href="#服务器层面优化" class="headerlink" title="服务器层面优化"></a>服务器层面优化</h4><p>将数据保存在内存中，保证从内存读取数据。</p>
<ul>
<li><p>设置足够大的<code>innodb_buffer_pool_size</code>，将数据读到内存中(建议设置为总内存的3/4或者4/5)</p>
</li>
<li><pre><code>可通过下面命令查看
show global status like &apos;innodb_buffer_pool_pages_%&apos;
若innodb_buffer_pool_pages_free为0则表示buffer pool已被用光
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### 内存预热</span><br><span class="line">将磁盘数据在MysQL Server启动的时候，读取到内存中。</span><br><span class="line"></span><br><span class="line">##### 降低磁盘写入次数</span><br><span class="line"></span><br><span class="line">* 对于生产环境来说，很多日志是不需要开启的，比如∶通用查询日志、慢查询日志、错误日志</span><br><span class="line"></span><br><span class="line">* 使用足够大的写入缓存**innodb_log_file_size**</span><br></pre></td></tr></table></figure>
推荐 innodb_log_file_size设置为0.25 * innodb_buffer_pool_size
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 设置合适的**innodb_flush_log_at_trx_commit**，和日志落盘有关系。</span><br><span class="line"></span><br><span class="line">##### 提高磁盘读写</span><br><span class="line"></span><br><span class="line">* 可以考虑使用SSD硬盘，不过得考虑成本是否合适。</span><br><span class="line"></span><br><span class="line">#### SQL设计层面优化</span><br><span class="line"></span><br><span class="line">具体优化方案如下:</span><br><span class="line"></span><br><span class="line">* 设计中间表，一般针对于统计分析功能，或者实时性不高的需求( OLTP、OLAP )</span><br><span class="line">* 为减少关联查询，创建合理的冗余字段(考虑数据库的三范式和查询性能的取舍，创建冗余字段还需要注意数据—致性问题)</span><br><span class="line">* 对于字段太多的大表，考虑垂直拆表(比如一个表有100多个字段)</span><br><span class="line">* 对于表中经常不被使用的字段或者存储数据比较多的字段，考虑拆表（比如商品表中会存储商品介绍，此时可以将商品介绍字段单独拆解到另一个表中，使用商品ID关联)</span><br><span class="line">* 每张表建议都要有一个主键(主键索引），而且主键类型最好是int类型，建议自增主键(不考虑分布式系统的情况下)。</span><br><span class="line"></span><br><span class="line">#### SQL语句优化(开发人员)</span><br><span class="line"></span><br><span class="line">##### 索引优化</span><br><span class="line"></span><br><span class="line">* 为搜索字段(where中的条件)、排序字段、 select查询列，创建合适的索引，不过要考虑数据的业务场景∶查询多还是增删多?</span><br><span class="line">* 尽量建立组合索引并注意组合索引的创建顺序，按照顺序组织查询条件、尽量将筛选粒度大的查询条件放到最左边。</span><br><span class="line">* 尽量使用覆盖索引，SELECT语句中尽量不要使用\*。</span><br><span class="line">* order by、group by语句要尽量使用到索引</span><br><span class="line"></span><br><span class="line">##### 其他优化</span><br><span class="line"></span><br><span class="line">* 尽量不使用count(\*)、尽量使用count(主键)</span><br></pre></td></tr></table></figure>
COUNT(*): 查询行数，是会遍历所有的行、所有的列。
</code></pre></li>
</ul>
<p>COUNT(列): 查询指定列不为null的行数(过滤null)，如果列可以为空，则COUNT (<em>)不等于COUNT(列)，除非指定的列是非空的列才会让COUNT (</em>)等于COUNT(列)</p>
<p>COUNT(伪列): 比如COUNT (1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* JOIN两张表的关联字段建立索引，而且最好字段类型是一样的。</span><br></pre></td></tr></table></figure>
<p>SELECT * FROM orders o LEFT OIN user u on o.user_id = u.id</p>
<p>orders表中的user_id和user表中的id，类型要一致</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* WHERE条件中尽量不要使用1=1、not in语句（建议使用not exists ) .</span><br><span class="line">* 不用MySQL内置的函数，因为内置函数不会建立查询缓存。</span><br></pre></td></tr></table></figure>
<p>SQL查询语句和查询结果都会在第一次查询只会存储到MySQL的查询缓存中，如果需要获取到查询缓存中的查询结果，查询的SQL语句必须和第一次的查询SQL语句一致。</p>
<p>SELECT * FROM user where birthday = now()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 分布式事务</span><br><span class="line"></span><br><span class="line">两个基本场景</span><br><span class="line"></span><br><span class="line">&gt; 多数据源：多个数据库之间的一个事务操作。跨库事务指的是，一个应用某个功能需要操作多个库，不同的库中存储不同</span><br><span class="line">&gt; 的业务数据。在真实应用场景下，一个业务操作多个库也是比较常见的，那么多个数据库是之间是互相不可见的，如何保证数据库的一致性呢?此时就必须使用分布式事务的解决方案。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 多服务：多台服务器之间的事务操作。事务分布在不同服务器上，要求不同服务器事务要么都成功要么都失败，称为分布式事务。</span><br><span class="line"></span><br><span class="line">分布式事务就是为了保证不同资源服务器的数据一致性。</span><br><span class="line"></span><br><span class="line">### 分布式事务事务模型——DTP模型</span><br><span class="line"></span><br><span class="line">1)应用程序(Application Program : AP): 定义事务边界(事务开始，结束)</span><br><span class="line"></span><br><span class="line">2)资源管理器(Resource Manager: RM): 任何用来存储数据的服务。</span><br><span class="line"></span><br><span class="line">3)事务管理器(Transaction Manager : TM ): 监控事务进度，负责事务提交，回滚。</span><br><span class="line"></span><br><span class="line">4)通信资源管理(Communcation Resource Manager : CRM )</span><br><span class="line"></span><br><span class="line">5)通信协议(负责事务模型之间的通信协议)</span><br><span class="line"></span><br><span class="line">当一个DTP模型中，存在多个模型实例时，会形成一种树形调用关系，叫做**全局事务树形结构(GlobalTransaction Tree Structure)**。</span><br><span class="line"></span><br><span class="line">### 分布式事务事务模型-XA规范</span><br><span class="line">XA规范的最主要的作用是，就是定义了RM-TM的交互接口</span><br><span class="line"></span><br><span class="line">XA∶定义了TM和RM交互接口的规范。（事务注册，开始，回滚，事务结束...)</span><br><span class="line"></span><br><span class="line">XA标准∶存储数据的服务都开发了支持分布式事务接口规范:XA(MySQL，RocketMQ)</span><br><span class="line"></span><br><span class="line">TM事务管理器也必须按照XA规范来进行调用事务控制接口。</span><br><span class="line"></span><br><span class="line">### 分布式事务事务模型-2PC(2阶段提交)</span><br><span class="line"></span><br><span class="line">两阶段提交协议(Two Phase Commit )，XA规范对其进行了优化。而从字面意思来理解，TwoPhase Commit，就是将提交(commit)过程划分为2个阶段(Phase):</span><br><span class="line"></span><br><span class="line">[![https://img.rruu.net/image/601e3519d55f7](https://img.rruu.net/image/601e3519d55f7)](https://img.rruu.net/image/601e3519d55f7)</span><br><span class="line"></span><br><span class="line">### 分布式事务事务模型-3PC(3阶段提交)</span><br><span class="line"></span><br><span class="line">三阶段提交（3PC)[Three-phase commit]，是二阶段提交（2PC)的改进版本。与两阶段提交不同的是，三阶段提交有两个改动点</span><br><span class="line"></span><br><span class="line">* 引入超时机制。同时在协调者和参与者中都引入超时机制。</span><br><span class="line">* 在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。也就是说，除了引入超时机制之外，3PC把2PC的准备阶段再次一分为二，这样三阶段提交就有CanCommit、PreCommit、DoCommit三个阶段</span><br><span class="line"></span><br><span class="line">### 分布式事务解决方案-JTA</span><br><span class="line"></span><br><span class="line">Java事务APl ( JTA : Java Transaction APl ）和它的同胞Java事务服务（JTS : Java Transaction Service )，为J2EE平台提供了分布式事务服务(distributed transaction)的能力。某种程度上，可以认为JTA规范是XA规范的Java版，其把XA规范中规定的DTP模型交互接口抽象成Java接口中的方法，并规定每个方法要实现什么样的功能。</span><br></pre></td></tr></table></figure>
<p>Java事务JTA分布式事务控制规范:<br>JTA是XA接口规范的Java版本。控制分布式事务。<br>1、AP<br>2、Application Server (Jboss,weblogic,websphere等等)<br>3、TM<br>4、RM</p>
<p>Java分布式事务:Application Server 实现XA接口的规范，在服务内部自己根据XA规范，开发了一套分布式事务控逻辑TM,把TM集成到jboss,weblogic</p>
<p>问题:TOMCAT服务器没有实现XA接口规范，不能自己控制分布式事务?<br>    第三方框架: atomikos —- xa</p>
<p>Atomiko主要用来控制多数据源这样的分布式事务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 分布式事务解决方案-LCN</span><br><span class="line"></span><br><span class="line">TX-LCN由两大模块组成，TxClient、TxManager，TxClient作为模块的依赖框架，提供TX-LCN的标准支持，TxManager作为分布式事务的控制器.</span><br><span class="line"></span><br><span class="line">事务发起方或者参与都由TxClient端来控制</span><br><span class="line"></span><br><span class="line">原理:</span><br><span class="line"></span><br><span class="line">&gt; LCN模式是通过代理Connection的方式实现对本地事务的操作，然后在由TxManager统一协调控制事务。当本地事务提交回滚或者关闭连接时将会执行假操作，该代理的连接将由LCN连接池管理。</span><br><span class="line"></span><br><span class="line">特点:</span><br><span class="line"></span><br><span class="line">&gt; 该模式对代码的嵌入性为低。</span><br><span class="line">&gt; 该模式仅限于本地存在连接对象且可通过连接对象控制事务的模块。</span><br><span class="line">&gt; 该模式下的事务提交与回滚是由本地事务方控制，对于数据一致性上有较高的保障。该模式缺陷在于代理的连接需要随事务发起方一起释放连接，增加了连接占用的时间。</span><br><span class="line"></span><br><span class="line">### 分布式事务解决方案-TCC</span><br><span class="line"></span><br><span class="line">TCC——事务补偿机制，控制分布式事务的实现。</span><br><span class="line"></span><br><span class="line">TCC事务机制相对于传统事务机制(X/Open XA Two-Phase-Commit)，其特征在于它不依赖资源管理器(RM)对XA的支持，而是通过对(由业务系统提供的）业务逻辑的调度来实现分布式事务。</span><br><span class="line"></span><br><span class="line">主要由三步操作∶</span><br><span class="line"></span><br><span class="line">&gt; Try:尝试执行业务</span><br><span class="line">&gt; Confirm:确认执行业务</span><br><span class="line">&gt; Cancel:取消执行业务。</span><br><span class="line"></span><br><span class="line">特点:</span><br><span class="line"></span><br><span class="line">&gt; 该模式对代码的嵌入性高，要求每个业务需要写三种步骤的操作。该模式对有无本地事务控制都可以支持使用面广。</span><br><span class="line">&gt; 数据一致性控制几乎完全由开发者控制，对业务开发难度要求高。</span><br><span class="line"></span><br><span class="line">### 分布式事务解决方案-RocketMQ</span><br><span class="line">实际系统的开发过程中，可能服务间的调用是异步的(MQ消息中间件异步通知)、那么如何保证这种异步的各个服务间的分布式事务呢?</span><br><span class="line"></span><br><span class="line">### 分布式事务解决方案-尽最大可能通知</span><br><span class="line"></span><br><span class="line">最大努力通知型(Best-effort delivery)是最简单的一种柔性事务，适用于一些最终一致性时间敏感度低的业务，且被动方处理结果不影响主动方的处理结果。典型的使用场景∶如银行通知、商户通知等。最大努力通知型的实现方案，一般符合以下特点:</span><br><span class="line"></span><br><span class="line">&gt; 不可靠消息∶业务活动主动方，在完成业务处理之后，向业务活动的被动方发送消息，直到通知N次后不再通知，允许消息丢失(不可靠消息)。</span><br><span class="line">&gt; 定期校对∶业务活动的被动方，根据定时策略，向业务活动主动方查询(主动方提供查询接口)，恢复丢失的业务消息。</span><br><span class="line"></span><br><span class="line">### CAP</span><br><span class="line"></span><br><span class="line">C和A无法同时存在。</span><br><span class="line"></span><br><span class="line">因为在保证强一致性的时候，主节点会将从节点锁定并进行同步来保证一致性，此时用户请求则无法立刻得到结果，违反可用性。</span><br><span class="line"></span><br><span class="line">因此存在的组合只有CP和AP模型。因此选型也就只有强一致性(2PC)和最终一致性(MQ、TCC)两种选择。</span><br><span class="line"></span><br><span class="line">### BASE理论</span><br><span class="line">BASE是Basically Available (基本可用)、Soft state(软状态）和Eventually consistent (最终一致性)三个短语的缩写。</span><br><span class="line"></span><br><span class="line">* 基本可用(Basically Available )：指分布式系统在出现不可预知故障的时候，允许损失部分可用性。</span><br><span class="line">* 软状态( Soft State )：指允许系统中的数据存在中间状态，并认该中间状态的存在不会影响系统的整体可用性。</span><br><span class="line">* 最终一致(Eventual Consistency )：强调的是所有的数据更新操作，在经过一段时间的同步之后，最终都能够达到一个一致的状态</span><br><span class="line"></span><br><span class="line">### 柔性事务</span><br><span class="line"></span><br><span class="line">&gt; 最大努力通知（非可靠消息、定期校对)</span><br><span class="line">&gt;</span><br><span class="line">&gt; 可靠消息最终一致性（异步确保型)</span><br><span class="line">&gt;</span><br><span class="line">&gt; TCC(两阶段型、补偿型)</span><br><span class="line"></span><br><span class="line">## IO多路复用</span><br><span class="line"></span><br><span class="line">### select</span><br><span class="line"></span><br><span class="line">非多线程，是单线程，多线程存在上下文切换的开销。</span><br><span class="line"></span><br><span class="line">简单思路：死循环中遍历所有fd文件描述符，获得其中有数据的部分进行读取和处理。</span><br><span class="line"></span><br><span class="line">具体实现：</span><br><span class="line"></span><br><span class="line">&gt; ①首先获得所有的fd</span><br><span class="line">&gt; ②在一个死循环中，将所有fd拷入一个rset中(rset是一个位图bitmap)，将fd对应的编号置为1</span><br><span class="line">&gt; ③调用select函数，从用户态拷贝rset到内核态，并进行阻塞等待，监听所有fd，直到有对应的有数据到来</span><br><span class="line">&gt; ④将有数据到来的fd(可能会有多个)进行置位，是在rset中置位，fd本身没有变化</span><br><span class="line">&gt; ⑤再次遍历rset，读取其中被置位的fd的数据，并进行相应处理。再次进入死循环</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line"></span><br><span class="line">&gt; 位图的大小是有限的，默认1024位</span><br><span class="line">&gt;</span><br><span class="line">&gt; rset不能重用，内核态对其进行了改变，导致每次需要重置rset并重新拷贝fd</span><br><span class="line">&gt;</span><br><span class="line">&gt; 用户态到内核态的转换和拷贝开销较大</span><br><span class="line">&gt;</span><br><span class="line">&gt; 在内核态监听完成并置位rset后，还需要再次遍历rset，时间开销较大</span><br><span class="line"></span><br><span class="line">### poll</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">struct pullfd &#123;</span><br><span class="line">	int fd;</span><br><span class="line">	short events; // 初始化为需要监听的事件 如 PULLIN</span><br><span class="line">	short revents; // 用于置位使用 </span><br><span class="line">&#125;</span><br><span class="line">// 不再使用bitmap，而是采用自定义结构体</span><br></pre></td></tr></table></figure>

<p>具体实现和select类似，相同点和区别在于：</p>
<blockquote>
<p>相同点：①都是需要从用户态拷贝到内核态并由内核进行监听处理，开销较大②都需要对存储fd的数据结构进行二次遍历③也是阻塞调用</p>
<p>①未使用bitmap进行存储，而是采用pullfd[]数组进行存储<br>②内核监听到数据时，不再对pullfd[]整体置位，只对revents成员置位，这样使得pullfd[]可以重用。<br>③内核监听完成后，对pullfd进行遍历时，如果revents被置位，则进行数据读取和处理，同时将revents重新赋值为0。<br>④存储的数量远大于bitmap的限制1024位。</p>
</blockquote>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p><img src="https://i.loli.net/2021/03/04/Y3mdEcJ64DyvZe2.png" alt="image.png"></p>
<p>同样存在一个结构体epoll_event，包含fd和event数据，但不包含revents</p>
<p>具体实现：</p>
<blockquote>
<p>①准备数据，通过epoll_ctl将fd和events拷贝进入一个由epoll_create创建的白板中，同时还会在内核创建一个红黑树和一个链表<br>②同样通过死循环，然后调用epoll_wait方法，同时上文提到的白板是并不是用户态和内核态共享的<strong>(b站视频有误)</strong><br>③通过epoll_wait方法，内核通过监听，将fd进行”置位”，这里的置位是指重排序，将有数据的fd放到链表前面，然后返回有数据的fd数量<br>④通过返回值再进行遍历，省去了之前O(n)复杂度的再次遍历，然后对数据进行读取和处理</p>
</blockquote>
<p>两种工作模式</p>
<blockquote>
<p>LT模式</p>
<p>fd可读之后，如果服务程序读走一部分就结束此次读取，LT模式下该文件描述符仍然可读<br>fd可写之后，如果服务程序写了一部分就结束此次写入，LT模式下该文件描述符也仍然可写</p>
<p>ET模式</p>
<p>fd可读之后，如果服务程序读走一部分就结束此次读取，ET模式下该文件描述符是不可读，需要等到下次有数据到达时才可变为可读，所有我们要保证循环读取数据，以确保把所有数据读出<br>fd可写之后，如果服务程序写了一部分就结束此次写入，ET模式下该文件描述符是不可写的，我们要保证写入数据，确保把数据写满</p>
</blockquote>
<p>redis和nginx、java的nio在linux下都是通过epoll实现。</p>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="JVM常识"><a href="#JVM常识" class="headerlink" title="JVM常识"></a>JVM常识</h3><h4 id="程序的执行方式"><a href="#程序的执行方式" class="headerlink" title="程序的执行方式"></a>程序的执行方式</h4><blockquote>
<p>静态编译、动态编译和动态解释执行。</p>
<p>注意：此处的编译是指编译成OS能直接运行的机器码。</p>
</blockquote>
<h4 id="JVM的运行模式"><a href="#JVM的运行模式" class="headerlink" title="JVM的运行模式"></a>JVM的运行模式</h4><p>JVM有两种运行模式: Server模式与Client棒式。</p>
<p>两种模式的区别在于:</p>
<ul>
<li>Client模式启动速度较快，Server模式启动较慢;</li>
<li>但是启动进入稳定期长期运行之后Server模式的程序运行速度比Client要快很多。</li>
<li>因为Server模式启动的JVM采用的是重量级的虚拟机，对程序采用了更多的优化;而Client模式启动的VM采用的是轻量级的虚拟机。所以Server启动慢，但稳定后速度比Client远远要快。</li>
</ul>
<h3 id="JVM架构理解"><a href="#JVM架构理解" class="headerlink" title="JVM架构理解"></a>JVM架构理解</h3><p><img src="https://img.rruu.net/image/601e6713dd864" alt></p>
<h3 id="JVM-程序执行流程"><a href="#JVM-程序执行流程" class="headerlink" title="JVM 程序执行流程"></a>JVM 程序执行流程</h3><p>java编译成字节码、动态编译和解释为机器码的过程分析</p>
<p><img src="https://img.rruu.net/image/601e6e43cd20a" alt></p>
<p>编译器和解释器的协调工作流程：</p>
<p><img src="https://img.rruu.net/image/601e6ec3e78e5" alt></p>
<p>在部分商用虚拟机中(如HotSpot),Java程序最初是通过解释器(Interpreter)进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为”热点代码”。为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器(Just In Time Compiler，下文统称IT编译器)。</p>
<p>由于Java虚拟机规范并没有具体的约束规则去限制即使编译器应该如何实现，所以这部分功能完全是与虚拟机具体实现相关的内容，如无特殊说明，我们提到的编译器、即时编译器都是指Hotspot虚拟机内的即时编译器，虚拟机也是特指HotSpot虚拟机。</p>
<p>我们的JIT是属于动态编译方式的，动态编译（dynamic compilation)指的是”在运行时进行编译”;与之相对的是事前编译(ahead-of-time compilation，简称AOT)，也叫静态编译(static compilation)。</p>
<p>JIT编译(just-in-time compilation)狭义来说是当某段代码即将第一次被执打时进行编译，因而叫”即时编译”。JIT编译是动态编译的一种特例。]JIT编译一词后来被泛化，时常与动态编译等价;但要注意广义与狭义的JIT编译所指的区别。</p>
<h3 id="JIT的使用"><a href="#JIT的使用" class="headerlink" title="JIT的使用"></a>JIT的使用</h3><ul>
<li>为何HotSpot需要使用解释器和编译器并存的架构?</li>
<li>JVM为什么要实现两个不同的即时编译器?</li>
<li>程序何时会使用解释器执行?何时会使用编译器执行?</li>
<li>哪些程序代码会被编译成为本地代码?如何编译?</li>
<li>JAVA代码的执行效率就一定比C,C++静态执行的执行差?JAVA代码解析执行有何优势?</li>
</ul>
<h4 id="为什么要使用解释器与编译器并存的架构"><a href="#为什么要使用解释器与编译器并存的架构" class="headerlink" title="为什么要使用解释器与编译器并存的架构"></a>为什么要使用解释器与编译器并存的架构</h4><p>尽管并不是所有的Java虚拟机都采用解释器与编译器并存的架构，但许多主流的商用虚拟机(如HotSpot)，都同时包含解释器和编译器。</p>
<p><strong>解释器与编译器特点</strong></p>
<ul>
<li>当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取更高的执行效率</li>
<li>当程序运行环境中内存资源限制较大(如部分嵌入式系统中)，可以使用解释器执行节约内存，反之可以使用编译执行来提升效率。</li>
</ul>
<p><strong>编译的时间开销</strong></p>
<p>解释器的执行，抽象的看是这样的:<br><strong><em>输入的代码-&gt;[解释器解释执行]-&gt;执行结果</em></strong></p>
<p>而要JIT编译然后再执行的话，抽象的看则是:<br><strong><em>输入的代码→&gt;[编译器编译]-&gt;编译后的代码→&gt;[执行]-&gt;执行结果</em></strong></p>
<p>说JIT比解释快，其实说的是”执行编译、代码”比”解释器解释执行”要快，并不是说”编译”这个动作比”解释”这个动作快。JIT编译再怎么快，至少也比解释执行一次略慢一些，而要得到最后的执行结果还得再经过一个”执行编译后的代码”的过程。所以，对“只执行一次””的代码而言，解释执行其实总是比JIT编译执行要快。</p>
<p>怎么算是”只执行一次的代码”呢?粗略说，下面两个条件同时满足时就是严格的“只执行一次”<br>1、只被调用一次，例如类的构造器(class initializer，<clinit>())<br>2、没有循环<br>对只执行一次的代码做JIT编译再执行，可以说是得不偿失。<br>对只执行少量次数的代码，JIT编译带来的执行速度的提升也未必能抵消掉最初编译带来的开销。</clinit></p>
<p><strong><em>只有对频繁执行的代码，JIT编译才能保证有正面的收益。</em></strong></p>
<p><strong>编译的空间开销</strong></p>
<p>对一般的Java方法而言，编译后代码的大小相对于字节码的大小，膨胀比达到10x是很正常的。同上面说的时间开销一样，这里的空间开销也是，只有对执行频繁的代码才值得编译，如果把所有代码都编译则会显著增加代码所占空间，导致”代码爆炸”。</p>
<p><strong><em>这也就解释了为什么有些VM会选择不总是做JIT编译，而是选择用解释器 + JIT编译器的混合执行引擎。</em></strong></p>
<h4 id="为何要实现两个不同的即时编译器"><a href="#为何要实现两个不同的即时编译器" class="headerlink" title="为何要实现两个不同的即时编译器"></a>为何要实现两个不同的即时编译器</h4><p><font color="red">HotSpot虚拟机中内置了两个即时编译器:Client Complier和Server Complier0，简称为C1、C2编译器，分别用在客户端和服务端。</font></p>
<p>目前主流的HotSpot虚拟机中默认是采用解释器与其中一个编译器直接配合的方式工作。程序使用哪个编译器，取决于<strong>虚拟机运行的模式</strong>。HotSpot虚拟机会根据自身版本与宿主机器的硬件性能自动选择运行模式，用户也可以使用”-client”或”-server”参数去强制指定虚拟机运行在Client模式或Server模式。</p>
<p>用Client Complier获取更高的<strong>编译速度</strong>，用Server Complier来获取更好的<strong>编译质量</strong>。为什么提供多个即时编译器与为什么提供多个垃圾收集器类似，都是为了适应不同的应用场景。</p>
<h4 id="哪些程序代码会被即时编译"><a href="#哪些程序代码会被即时编译" class="headerlink" title="哪些程序代码会被即时编译"></a>哪些程序代码会被即时编译</h4><p>程序中的代码只有是热点代码时，才会编译为本地代码，那么什么是<strong>热点代码</strong>呢?</p>
<p>运行过程中会被即时编译器编译的“热点代码”有两类:</p>
<ol>
<li>被多次调用的方法。</li>
<li>被多次执行的循环体。</li>
</ol>
<p>两种情况，编译器都是以<strong>整个方法</strong>作为编译对象。这种编译方法因为编译发生在方法执行过程之中，因此形象的称之为栈上替换(On Stack Replacement，oSR)，即方法栈帧还在栈上，方法就被替换了。</p>
<h4 id="如何判断热点代码呢"><a href="#如何判断热点代码呢" class="headerlink" title="如何判断热点代码呢"></a>如何判断热点代码呢</h4><p>要知道方法或一段代码是不是热点代码，是不是需要触发即时编译，需要进行Hot Spot Detection(热点探测)。</p>
<p>目前主要的热点探测方式有以下两种:</p>
<ul>
<li>基于采样的热点探测<br><strong>采用这种方法的虚拟机会周期性地检查各个线程的栈顶，如果发现某些方法经常出现在栈顶，那这个方法就是”热点方法”。</strong>这种探测方法的好处是实现简单高效，还可以很容易地获取方法调用关系（将调用堆栈展开即可)，缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测。</li>
<li>基于计数器的热点探测<br><strong>采用这种方法的虚拟机会为每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的阀值，就认为它是”热点方法”</strong>，这种统计方法实现复杂一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系L它的统计结果相对更加精确严谨。</li>
</ul>
<h4 id="热点检测方式"><a href="#热点检测方式" class="headerlink" title="热点检测方式"></a>热点检测方式</h4><p>在HotSpot虚拟机中使用的是第二种―—基于计数器的热点探测方法，因此它为每个方法准备了两个计数器︰方法调用计数器和回边计数器。在确定虚拟机运行参数的前提下，这两个计数器都有一个确定的阈值，当计数器超过阈值溢出了，就会触发JIT编译。</p>
<p><strong>方法调用计数器</strong></p>
<p>顾名思义，这个计数器用于统计方法被调用的次数。</p>
<p><strong>回边计数器</strong></p>
<p>它的作用就是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为”回边”。</p>
<h3 id="JIT优化"><a href="#JIT优化" class="headerlink" title="JIT优化"></a>JIT优化</h3><h4 id="公共子表达式的消除"><a href="#公共子表达式的消除" class="headerlink" title="公共子表达式的消除"></a>公共子表达式的消除</h4><p>javac编译器不会对公共子表达式进行消除。进入即时编译器后，JIT会对公共子表达式进行消除，且还有可能进行代数替换，即将可以计算出的结果直接计算得到，进行优化。</p>
<h4 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h4><p>指的是：在JIT即时编译时，将方法调用直接使用方法体内的代码进行替换，从而减少方法调用过程中的压栈和入栈的开销。</p>
<p>当JVM检测到一些小方法频繁调用时，会使用方法内联进行优化。</p>
<h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h4><p>逃逸分析(Escape Analysis)是目前Java虚拟机中比较前沿的优化技术。这是一种可以有效减少]ava程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析. Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p>
<blockquote>
<p>个人理解：如果对象逃逸了，则无法对其进行优化，只能分配到堆上，如果没有逃逸，则可以将其分配到栈上。</p>
</blockquote>
<p><strong>逃逸分析的基本行为就是分析对象动态作用域:当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸。</strong></p>
<p>逃逸分析包括:</p>
<ul>
<li>全局变量赋值逃逸</li>
<li>方法返回值逃逸</li>
<li>实例引用发生逃逸</li>
<li>线程逃逸:赋值给类变量或可以在其他线程中访问的实例变量</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object object;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">globalVariableEscape</span><span class="params">()</span> </span>&#123;<span class="comment">//全局变量赋值逃逸</span></span><br><span class="line">	object =<span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">methodEscape</span><span class="params">()</span> </span>&#123; <span class="comment">//方法返回值逃逸</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">instancePassEscape</span><span class="params">()</span> </span>&#123;<span class="comment">//实例引用发生逃逸</span></span><br><span class="line">	<span class="keyword">this</span>.speak(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">(EscapeAna1ysis escapeAna1ysis)</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"Escape He11o"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法逃逸案例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title">createStringBuffer</span><span class="params">(String s1，String s2)</span> </span>&#123;</span><br><span class="line">	StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">	sb.append(s1);</span><br><span class="line">	sb.append(s2);</span><br><span class="line">	<span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>StringBuffer sb是一个方法内部变量，上述代码中直接将sb返回，这样这个StringBuffer有可能被其他方法所改变，这样它的作用域就不只是在方法内部，虽然它是一个局部变量，称其逃逸到了方法外部。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。</p>
</blockquote>
<p>上述代码如果想要StringBuffer sb不逃出方法，可以这样写:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createStringBuffer</span><span class="params">(String s1，String s2)</span> </span>&#123;</span><br><span class="line">	StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">	sb.append(s1);</span><br><span class="line">	sb.append(s2);</span><br><span class="line">	<span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不直接返回StringBuffer，那么StringBuffer将不会逃逸出方法。</p>
<p>使用逃逸分析，编译器可以对代码做如下优化:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一、同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</span><br><span class="line"></span><br><span class="line">二、将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分</span><br><span class="line">配的候选，而不是堆分配。</span><br><span class="line"></span><br><span class="line">三、分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分(或全</span><br><span class="line">部）可以不存储在内存，而是存储在CPU寄存器中。</span><br></pre></td></tr></table></figure>

<p>在Java代码运行时，通过JVM参数可指定是否开启逃逸分析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+DoEscapeAnalysis: open</span><br><span class="line">-XX:-DoEscapeAnalysis: close</span><br></pre></td></tr></table></figure>

<p>从jdk1.7开始默认开启逃逸分析。</p>
<h4 id="对象上的栈分配"><a href="#对象上的栈分配" class="headerlink" title="对象上的栈分配"></a>对象上的栈分配</h4><p>我们知道，在一般情况下，对象和数组元素的内存分配是在堆内存上进行的。但是随着JIT编译器的日渐成熟，很多优化使这种分配策略并不绝对。<strong>JIT编译器就可以在编译期间根据逃谗分析的结果，来决定是否可以将对象的内存分配从堆转化为栈。</strong></p>
<h4 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h4><p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存在类A</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 存在一方法使用类里的a和b</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getAB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	A x = <span class="keyword">new</span> A();</span><br><span class="line">	x.a;</span><br><span class="line">	x.b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译时JVM会直接编译成这样</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getAB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	a = <span class="number">1</span>;</span><br><span class="line">	b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这就是标量替换 */</span></span><br></pre></td></tr></table></figure>

<h4 id="同步锁消除"><a href="#同步锁消除" class="headerlink" title="同步锁消除"></a>同步锁消除</h4><p>同样基于逃逸分析，当加锁的变量不会发生逃逸，是线程私有的完全没有必要加锁。在JIT编译时期就可以将同步锁去掉，以减少加锁与解锁造成的资源开销。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLockEliminate</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">(String s1，String s2)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        sb.append(s1);</span><br><span class="line">        sb.append(s2);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> tsStart = System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">			getString( <span class="string">""</span>TestLockE1iminate <span class="string">"， "</span>suffix<span class="string">""</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"一共耗费: "</span>+ (System.currentTimeMillis() - tsStart) + <span class="string">"ms"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>getString()方法中的StringBuffer数以函数内部的局部变量，进作用于方法内部，不可能逃逸出该方法，因此他就不可能被多个线程同时访问，也就没有资源的竞争，但是StringBuffer的append操作却需要执行同步操作，代码如下:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">       toStringCache = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">super</span>.append(str);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>逃逸分析和锁消除分别可以使用参数-xX:+DOEscapeAnalysis和-XX:+EliminateLocks(锁消除必须在-server模式下)开启。</p>
<h3 id="带你认识一下class文件"><a href="#带你认识一下class文件" class="headerlink" title="带你认识一下class文件"></a>带你认识一下class文件</h3><h4 id="class文件概述"><a href="#class文件概述" class="headerlink" title="class文件概述"></a>class文件概述</h4><p>内容为16进制。开头为<code>CAFEBABE</code>魔数</p>
<p><img src="https://img.rruu.net/image/6021434267a6b" alt></p>
<h5 id="常量池数据区"><a href="#常量池数据区" class="headerlink" title="常量池数据区"></a>常量池数据区</h5><p><img src="https://img.rruu.net/image/6021439fcabec" alt></p>
<p>双亲委派：当类加载器碰到一个类时，需要交给其父类加载器加载，只有当其父类加载器无法加载时，自己才去尝试加载。</p>
<p>破坏双亲委派</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag"># 学习</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/12/07/antlr/" rel="prev" title="ANTLR4 解析语法树 以及IDEA相关插件使用">
      <i class="fa fa-chevron-left"></i> ANTLR4 解析语法树 以及IDEA相关插件使用
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/03/05/jvm/" rel="next" title="JVM">
      JVM <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java面试准备"><span class="nav-number">1.</span> <span class="nav-text">Java面试准备</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java基础"><span class="nav-number">1.1.</span> <span class="nav-text">Java基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#String、StringBuilder、StringBuffer"><span class="nav-number">1.1.1.</span> <span class="nav-text">String、StringBuilder、StringBuffer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#包装类"><span class="nav-number">1.1.2.</span> <span class="nav-text">包装类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#equals-和hashCode-方法"><span class="nav-number">1.1.3.</span> <span class="nav-text">equals()和hashCode()方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java值传递"><span class="nav-number">1.1.4.</span> <span class="nav-text">Java值传递</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#final关键字"><span class="nav-number">1.1.5.</span> <span class="nav-text">final关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O流"><span class="nav-number">1.1.6.</span> <span class="nav-text">I/O流</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java集合"><span class="nav-number">1.2.</span> <span class="nav-text">Java集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#List"><span class="nav-number">1.2.1.</span> <span class="nav-text">List</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map"><span class="nav-number">1.2.2.</span> <span class="nav-text">Map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">1.2.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java多线程"><span class="nav-number">1.3.</span> <span class="nav-text">Java多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Synchronized"><span class="nav-number">1.3.1.</span> <span class="nav-text">Synchronized</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MESI缓存一致性协议"><span class="nav-number">1.3.2.</span> <span class="nav-text">MESI缓存一致性协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile"><span class="nav-number">1.3.3.</span> <span class="nav-text">volatile</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CAS-compare-and-swap"><span class="nav-number">1.3.4.</span> <span class="nav-text">CAS(compare and swap)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ABA问题"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">ABA问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#阻塞队列"><span class="nav-number">1.3.5.</span> <span class="nav-text">阻塞队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL调优"><span class="nav-number">1.4.</span> <span class="nav-text">MySQL调优</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL存储引擎"><span class="nav-number">1.4.1.</span> <span class="nav-text">MySQL存储引擎</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL性能分析"><span class="nav-number">1.4.2.</span> <span class="nav-text">MySQL性能分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL索引优化"><span class="nav-number">1.4.3.</span> <span class="nav-text">MySQL索引优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#聚集索引-IOT索引组织表-——InnoDB"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">聚集索引(IOT索引组织表)——InnoDB</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#非聚集索引-堆组织表-——MyISAM"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">非聚集索引(堆组织表)——MyISAM</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#组合索引的使用"><span class="nav-number">1.4.4.</span> <span class="nav-text">组合索引的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#为何使用组合索引"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">为何使用组合索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何创建组合索引"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">如何创建组合索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最左前缀原则"><span class="nav-number">1.4.4.3.</span> <span class="nav-text">最左前缀原则</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何使用索引"><span class="nav-number">1.4.5.</span> <span class="nav-text">如何使用索引</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#哪些情况需要创建索引"><span class="nav-number">1.4.5.1.</span> <span class="nav-text">哪些情况需要创建索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#哪些情况不需要创建索引"><span class="nav-number">1.4.5.2.</span> <span class="nav-text">哪些情况不需要创建索引</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查看执行计划"><span class="nav-number">1.4.6.</span> <span class="nav-text">查看执行计划</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#建表语句"><span class="nav-number">1.4.6.1.</span> <span class="nav-text">建表语句</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#MySQL前缀索引和索引选择性"><span class="nav-number">1.4.6.1.1.</span> <span class="nav-text">MySQL前缀索引和索引选择性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#介绍"><span class="nav-number">1.4.6.2.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#参数说明"><span class="nav-number">1.4.6.3.</span> <span class="nav-text">参数说明</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#type"><span class="nav-number">1.4.6.3.1.</span> <span class="nav-text">type</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#system"><span class="nav-number">1.4.6.3.1.1.</span> <span class="nav-text">system</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#const-重要"><span class="nav-number">1.4.6.3.1.2.</span> <span class="nav-text">const(重要)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#eq-ref-重要"><span class="nav-number">1.4.6.3.1.3.</span> <span class="nav-text">eq_ref(重要)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#ref-重要"><span class="nav-number">1.4.6.3.1.4.</span> <span class="nav-text">ref(重要)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#fulltext"><span class="nav-number">1.4.6.3.1.5.</span> <span class="nav-text">fulltext</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#ref-or-null"><span class="nav-number">1.4.6.3.1.6.</span> <span class="nav-text">ref_or_null</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#unique-subquery"><span class="nav-number">1.4.6.3.1.7.</span> <span class="nav-text">unique_subquery</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#index-subquery"><span class="nav-number">1.4.6.3.1.8.</span> <span class="nav-text">index_subquery</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#range-重要"><span class="nav-number">1.4.6.3.1.9.</span> <span class="nav-text">range(重要)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#index-merge"><span class="nav-number">1.4.6.3.1.10.</span> <span class="nav-text">index_merge</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#index-重要"><span class="nav-number">1.4.6.3.1.11.</span> <span class="nav-text">index(重要)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#all-重要）"><span class="nav-number">1.4.6.3.1.12.</span> <span class="nav-text">all(重要）</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#extra-重要"><span class="nav-number">1.4.6.3.2.</span> <span class="nav-text">extra(重要)</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#using-index-重要）"><span class="nav-number">1.4.6.3.2.1.</span> <span class="nav-text">using index(重要）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#using-where-重要"><span class="nav-number">1.4.6.3.2.2.</span> <span class="nav-text">using where(重要)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#using-index-condition-重要"><span class="nav-number">1.4.6.3.2.3.</span> <span class="nav-text">using index condition(重要)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#using-filesort-重要"><span class="nav-number">1.4.6.3.2.4.</span> <span class="nav-text">using filesort(重要)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#using-temporary"><span class="nav-number">1.4.6.3.2.5.</span> <span class="nav-text">using temporary</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#distinct"><span class="nav-number">1.4.6.3.2.6.</span> <span class="nav-text">distinct</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#no-tables-used"><span class="nav-number">1.4.6.3.2.7.</span> <span class="nav-text">no tables used</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引失效分析"><span class="nav-number">1.4.7.</span> <span class="nav-text">索引失效分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#案例环境"><span class="nav-number">1.4.7.1.</span> <span class="nav-text">案例环境</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#案例演示"><span class="nav-number">1.4.7.2.</span> <span class="nav-text">案例演示</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL性能优化"><span class="nav-number">1.4.8.</span> <span class="nav-text">MySQL性能优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#服务器层面优化"><span class="nav-number">1.4.8.1.</span> <span class="nav-text">服务器层面优化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll"><span class="nav-number">1.4.9.</span> <span class="nav-text">epoll</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM"><span class="nav-number">1.5.</span> <span class="nav-text">JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM常识"><span class="nav-number">1.5.1.</span> <span class="nav-text">JVM常识</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#程序的执行方式"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">程序的执行方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JVM的运行模式"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">JVM的运行模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM架构理解"><span class="nav-number">1.5.2.</span> <span class="nav-text">JVM架构理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM-程序执行流程"><span class="nav-number">1.5.3.</span> <span class="nav-text">JVM 程序执行流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JIT的使用"><span class="nav-number">1.5.4.</span> <span class="nav-text">JIT的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么要使用解释器与编译器并存的架构"><span class="nav-number">1.5.4.1.</span> <span class="nav-text">为什么要使用解释器与编译器并存的架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为何要实现两个不同的即时编译器"><span class="nav-number">1.5.4.2.</span> <span class="nav-text">为何要实现两个不同的即时编译器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#哪些程序代码会被即时编译"><span class="nav-number">1.5.4.3.</span> <span class="nav-text">哪些程序代码会被即时编译</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何判断热点代码呢"><span class="nav-number">1.5.4.4.</span> <span class="nav-text">如何判断热点代码呢</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#热点检测方式"><span class="nav-number">1.5.4.5.</span> <span class="nav-text">热点检测方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JIT优化"><span class="nav-number">1.5.5.</span> <span class="nav-text">JIT优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#公共子表达式的消除"><span class="nav-number">1.5.5.1.</span> <span class="nav-text">公共子表达式的消除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法内联"><span class="nav-number">1.5.5.2.</span> <span class="nav-text">方法内联</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#逃逸分析"><span class="nav-number">1.5.5.3.</span> <span class="nav-text">逃逸分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象上的栈分配"><span class="nav-number">1.5.5.4.</span> <span class="nav-text">对象上的栈分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#标量替换"><span class="nav-number">1.5.5.5.</span> <span class="nav-text">标量替换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#同步锁消除"><span class="nav-number">1.5.5.6.</span> <span class="nav-text">同步锁消除</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#带你认识一下class文件"><span class="nav-number">1.5.6.</span> <span class="nav-text">带你认识一下class文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#class文件概述"><span class="nav-number">1.5.6.1.</span> <span class="nav-text">class文件概述</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#常量池数据区"><span class="nav-number">1.5.6.1.1.</span> <span class="nav-text">常量池数据区</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Bcutty Kmy</p>
  <div class="site-description" itemprop="description">NO DEPENDENCE ONLY PRIDE</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bcutty Kmy</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              leancloudSelector(url).innerText = 'Counter not initialized! More info at console err msg.';
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"2z9X7Dx6RjzhCEydcpBXNAF5-gzGzoHsz","app_key":"d4qtySNKtCjyy1f975pQrdgB","server_url":null,"security":true};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : '2z9X7Dx6RjzhCEydcpBXNAF5-gzGzoHsz',
      appKey     : 'd4qtySNKtCjyy1f975pQrdgB',
      placeholder: "Please leave your comments here.",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
