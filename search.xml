<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux上Java相关环境变量配置</title>
      <link href="/2021/04/22/Java%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/"/>
      <url>/2021/04/22/Java%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux上Java相关环境配置"><a href="#Linux上Java相关环境配置" class="headerlink" title="Linux上Java相关环境配置"></a>Linux上Java相关环境配置</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>主要是记录一下Linux上Java相关的环境配置过程，希望能够帮助到大家，同时也防止自己忘记。</p><p>主要包括：JDK的配置、Maven的配置、Zookeeper的配置</p><p>主要步骤都相同：下载——解压——配置环境变量——source</p><p>linux版本：ubuntu18.04 or ubuntu20.04</p><a id="more"></a><h2 id="JDK配置"><a href="#JDK配置" class="headerlink" title="JDK配置"></a>JDK配置</h2><p><em>注意：本人未使用openjdk，也未通过包管理器进行下载，而是通过在oracle官网下载的方式</em></p><p>①下载对应版本jdk。进入Oracle官网，选择对应的jdk版本，需要登录，然后下载对应linux的安装包，tar.gz结尾，如<code>jdk-8u291-linux-x64.tar.gz</code></p><p>②在虚拟机新建一个目录（放置这些文件），我个人比较喜欢放在<code>/usr/bin/java</code>下，所以在<code>/usr/bin</code>目录下<code>sudo mkdir java</code>即可。</p><p>③上传压缩包。将该压缩包上传到服务器对应目录中<code>/usr/bin/java</code></p><blockquote><p>如果是本地虚拟机，则可以通过sftp的方式</p><p>如果是使用WSL2，则可以通过<code>/mnt</code>目录找到下载的压缩包</p><p>如果使用的是云服务器，也可以通过sftp或者云服务提供商相关来上传文件</p><p><em>最不是办法的办法：上传到github或者其他服务器能够拉取的地方进行拉取</em></p></blockquote><p>④解压压缩包，然后删除压缩包（也可以不删）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo tar xvf jdk-8u291-linux-x64.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash"> sudo rm jdk-8u291-linux-x64.tar.gz 删除压缩包</span></span><br></pre></td></tr></table></figure><p>⑤配置jdk环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/profile</span><br></pre></td></tr></table></figure><p>在文件最后添加以下文字</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/bin/java/jdk1.8.0_291# 根据自己的java目录进行设置</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br></pre></td></tr></table></figure><p>最后<code>:wq</code>进行保存即可</p><p>刷新，保证配置生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p>⑥检查是否配置成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><h2 id="Maven配置"><a href="#Maven配置" class="headerlink" title="Maven配置"></a>Maven配置</h2><p>①同理在maven官网选择自己需要的版本进行下载，然后上传到服务器上对应位置并进行解压</p><p>②配置jdk环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/profile</span><br></pre></td></tr></table></figure><p>在文件最后添加以下文字</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/bin/java/jdk1.8.0_291# 确保java存在</span><br><span class="line">export MAVEN_HOME=/usr/bin/java/apache-maven-3.6.3# 自己放置maven的目录</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin:$PATH:$MAVEN_HOME/bin# 增加一个$MAVEN_HOME/bin</span><br><span class="line"><span class="meta">#</span><span class="bash"> CLASSPATH不变</span></span><br></pre></td></tr></table></figure><p>最后<code>:wq</code>进行保存即可</p><p>刷新，保证配置生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p>③检查是否配置成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn -V</span><br></pre></td></tr></table></figure><h2 id="Zookeeper配置"><a href="#Zookeeper配置" class="headerlink" title="Zookeeper配置"></a>Zookeeper配置</h2><p>①同理在Zookeeper官网选择自己需要的版本进行下载，然后上传到服务器上对应位置并进行解压</p><p>②配置jdk环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/profile</span><br></pre></td></tr></table></figure><p>在文件最后添加以下文字</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> zookeeper 确保java已经安装</span></span><br><span class="line">export ZOOKEEPER_HOME=/usr/bin/java/apache-zookeeper-3.6.3-bin</span><br><span class="line">export PATH=$PATH:$ZOOKEEPER_HOME/bin</span><br></pre></td></tr></table></figure><p>最后<code>:wq</code>进行保存即可</p><p>刷新，保证配置生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p>③检查是否配置成功</p><p>进入zookeeper对应bin目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/bin/java/apache-zookeeper-3.6.3-bin/bin</span><br></pre></td></tr></table></figure><p>执行启动命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./zkServer.sh start</span><br></pre></td></tr></table></figure><p>注意：可能会提示你JAVA_HOME不存在</p><p>则</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim zkEnv.sh</span><br></pre></td></tr></table></figure><p>然后在大概77行增加这样一行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME="/usr/bin/java/jdk1.8.0_291" # 根据自己的java目录来</span><br></pre></td></tr></table></figure><p><img src="https://ae01.alicdn.com/kf/Udddfcc0ffe674b5ea4f1cc6b8fe01d79O.jpg" alt></p><p>然后再次尝试即可。</p>]]></content>
      
      
      <categories>
          
          <category> 部署篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习</title>
      <link href="/2021/04/01/python%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/04/01/python%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Python学习"><a href="#Python学习" class="headerlink" title="Python学习"></a>Python学习</h1><p><em>学习自廖雪峰的博客网站python篇</em></p><h3 id="Pycharm内容"><a href="#Pycharm内容" class="headerlink" title="Pycharm内容"></a>Pycharm内容</h3><a id="more"></a><p><code>ctrl+d</code>复制当前行，<code>ctrl+y</code>删除当前行，<code>shift+enter</code>换行(当前行任意位置均可换行)，<code>ctrl+/</code>批量注释或批量取消注释，<code>Tab</code>键和<code>shift+Tab</code>键完成批量缩进和取消缩进，<code>ctrl+f</code>查找，<code>ctrl+r</code>替换，<code>ctrl+&#39;+&#39;/&#39;-&#39;</code>折叠或者展开代码或<code>ctrl+shift+&#39;+&#39;/&#39;-&#39;</code>全部折叠或展开代码。设置-&gt;KeyMap设置快捷键。#TODO 记录要做的事情。</p><h3 id="小Tips"><a href="#小Tips" class="headerlink" title="小Tips"></a>小Tips</h3><p>转义字符——除了用<code>\</code>外，还可以用<code>r&#39; &#39;</code>代表单引号内的内容不转义，特殊的<code>%%</code>表示<code>%</code>。<br>多行写代码——用<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>的格式表示多行字符，并且还能在前面加上<code>r</code>一起使用表示内部内容不转义。<br>python除法——<code>/</code>默认是结果为浮点数，而<code>//</code>则默认会去掉小数部分保留整数。<br>字符编码——ASCII码(单字节)-&gt;Unicode码(通常双字节)-&gt;utf-8编码(可变长编码)，计算机中编码：内存统一使用Unicode编码，需要保存到硬盘或者需要传输时则转为utf-8，用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件，浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器。<br>格式化输出——利用<code>%</code>来实现，和c语言类似。例如<code>print(&#39;hello %s %d&#39; % (&#39;world&#39;,4))</code>就会输出<code>hello world 4</code>如果只有一个格式化输出，则不用添加括号。在<code>%d</code>前面添加数字代表空格数或者<code>%f</code>前加<code>.</code>和数字控制小数位数，若不确定要格式化输出的内容可以用<code>%s</code>代替，会将所有内容转换为字符串输出。还有一种格式化方法是使用<code>format()</code>方法，它会用传入的参数依次替换字符串内的占位符<code>{0}</code>、<code>{1}</code>……，不过这种方式写起来比%要麻烦得多，如<code>&#39;Hello, {0}, 成绩提升了 {1:.1f}%&#39;.format(&#39;小明&#39;, 17.125)</code>，输出<code>Hello, 小明, 成绩提升了 17.1%</code>。<br>条件判断——可用<code>elif</code>表示<code>else if</code>，同时如果<code>if</code>后面只有一个变量就和C语言类似。<br>IO——<code>input()</code>的返回类型为<code>str</code>，可用<code>int()</code>转换为整数型，<code>float()</code>转换为浮点数类型。<br>不可变对象——对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。</p><p>全局变量——在函数中想要修改全局遍历，如果是可变类型，则可以直接进行修改，如果是不可变类型，则需要使用global声明才可修改。</p><h3 id="Python基础"><a href="#Python基础" class="headerlink" title="Python基础"></a>Python基础</h3><h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>python3以unicode编码，即支持多种语言的字符串。<br>对于单个字符(英文或中文)，可用<code>ord()</code>和<code>chr()</code>函数分别读取字符的整数表示和把编码转换为字符。还可以用十六进制表示其他语言如：<code>&#39;\u4e2d\u6587&#39;</code>等价于<code>中文</code>。<br>对于<code>bytes</code>类型的数据用带<code>b</code>前缀的单引号或双引号表示，如<code>x = b&#39;ABC&#39;</code>,<code>bytes</code>类型的数据每个字符占用一个字节。用unicode编码的字符串可以通过<code>encode()</code>函数编码为指定的<code>bytes</code>,内部参数为<code>ascii或者utf-8</code>等其他编码方式,反过来就是使用<code>decode()</code>函数，如果<code>bytes</code>中只有一小部分无效的字节，可以传入<code>errors=&#39;ignore&#39;</code>。纯英文的<code>str</code>可以用<code>ASCII</code>编码为<code>bytes</code>，内容是一样的，含有中文的<code>str</code>可以用<code>UTF-8</code>编码为<code>bytes</code>。<br>对于<code>str</code>字符串可用<code>len()</code>函数计算字符数，如果换为<code>bytes</code>类型，则计算字节数。为了避免乱码问题，我们应该坚持使用<code>utf-8</code>来对<code>str</code>和<code>bytes</code>进行转换。</p><h5 id="list"><a href="#list" class="headerlink" title="list"></a>list</h5><p>Python内置的数据类型——列表list，用<code>[]</code>表示。有序的集合，<code>len()</code>获取长度，可用下标访问元素(从0开始的)，也可以使用<code>-1</code>作为下标来直接访问最后一个元素，以此类推用<code>-2</code>,<code>-3</code>等来获取倒数第几个元素。可使用<code>append()方法</code>在列表最后添加元素，或者使用<code>insert(int index, Object obj)方法</code>来添加元素到指定位置；使用<code>pop()方法</code>删除列表末尾的元素或者添加参数<code>index</code>来指定下标；如果需要替换可以直接通过<code>str[i]=&quot;...&quot;</code>来实现，并且<code>list</code>内部的各个元素的数据类型也是可以不相同的，比如可以就是<code>list</code>类型。</p><h5 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h5><p>Python内置的另一种有序列表类型——元组，用<code>()</code>表示。和<code>list</code>不同，<code>tuple</code>一旦初始化就不能更改，也没有append()，insert()这样的方法，但是可以通过下标访问元素，不过不能替换，也更加安全，还有一个需要注意的就是如果定义的时候只有一个元素需要加上一个<code>,</code>来避免歧义，<code>t=(1,)</code>，因为如果不加，<code>t</code>就是一个值为1的整型变量了。不过，如果<code>tuple</code>中存在<code>list</code>类型的元素，这个就<code>list</code>中的元素就可以改变了，从而可以理解为<code>tuple</code>也是”可变“的。</p><h5 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h5><p>首先是<code>for..in</code>循环，依次把<code>list</code>,<code>tuple</code>中的元素打印出来，例如<code>for x in [1,2,3,4,5]:</code>；或者使用<code>range(x)</code>表示从0开始到小于x的整数序列<code>for x in range(5):</code>，还可以使用<code>list()</code>将<code>range()</code>转换为list类型。</p><h5 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h5><p>Python内置的字典类，其他语言也叫<code>map</code>，采用键值对存储方式存储。可通过<code>d[&#39;key&#39;]</code>查询对应的值，还可通过该方法放入键值对。一个<code>key</code>对应一个<code>value</code>，若对一个关键字放入多个值，则后面放入的会把前面放入的冲掉。如果<code>key</code>值不存在，字典会报错，为了避免，可使用<code>&#39;key&#39; in d</code>来查看key是否存在于字典中，若不存在则返回<code>False</code>；或者使用<code>get()方法</code>，如果不存在会返回<code>None</code>，或者返回自己指定的<code>value</code>，还可以使用<code>pop(&#39;key&#39;)方法</code>删除键值对。最重要的是<code>key</code>对象必须是不可变对象。</p><h5 id="set"><a href="#set" class="headerlink" title="set"></a>set</h5><p>和dict类似，也是一组key的集合，只是不存储value值，也同样不能重复。通过<code>add()</code>和<code>remove()</code>方法实现添加或者删除key，set可以看作数学上的集合，可以进行∩、∪等操作。并且要创建一个set，需要提供一个list作为输入集合，<code>s = set([1, 2, 3])</code></p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h5 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h5><p><code>max()</code>——可以从传入任意个参数，返回最大的那个。<br><code>str()</code>,<code>int()</code>,<code>bool()</code>等——数据类型转换函数。<br><code>hex()</code>函数——把一个整数转换成十六进制表示的字符串。</p><p>函数名实际是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”。即<code>a = abs</code>，然后可以用<code>a()</code>来实现<code>abs()</code>的功能。<br>如果想要保证传入函数的参数类型是正确的，可用<code>isinstance()方法</code>判断是否参数类型满足你所定义的参数类型。<br>函数是可以返回多个值的，可以用多个变量来接收，也可以用一个，因为返回的实际上是一个<code>tuple</code></p><h5 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h5><p><code>def f(x,n=2)</code>这里就给n设置了一个默认参数，如果调用函数<code>f()</code>时只传入了一个参数x，则会默认传入一个等于2的n进函数，这样就比较方便，例如<code>f(5)</code>实际上就是<code>f(5,2)</code>。不过设置默认参数的时候也有几个需要注意的地方：第一是必选参数在前，默认参数在后，第二是默认参数必须指向不变对象。如果指向一个list，则每次调用时都会改变list里的元素从而导致函数无法发挥作用。可见，默认参数降低了函数调用的难度，而一旦需要更复杂的调用时，又可以传递更多的参数来实现。无论是简单调用还是复杂调用，函数只需要定义一个。</p><p>在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个<code>*</code>号。在函数内部，参数<code>numbers</code>接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数：<code>def calc(numbers)</code>，<code>def calc(*numbers)</code>前者调用需要传入list或tuple，<code>calc([1,2,3])</code>而后者则不需要，<code>calc(1,2,3)</code>。同时可变参数还可传入一个list或tuple进函数，不过需要添加<code>*</code>号，例如<code>nums = [1,2,3]</code>，<code>calc(*nums)</code>即可，<code>*nums</code>表示把<code>nums</code>这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见。</p><h5 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h5><p>关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, **kw)</span>:</span></span><br><span class="line">    print(<span class="string">'name:'</span>, name, <span class="string">'age:'</span>, age, <span class="string">'other:'</span>, kw)</span><br><span class="line"><span class="comment"># 不传入关键字参数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Michael'</span>, <span class="number">30</span>)</span><br><span class="line">name: Michael age: <span class="number">30</span> other: &#123;&#125;</span><br><span class="line"><span class="comment"># 传入任意个数的关键字参数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Bob'</span>, <span class="number">35</span>, city=<span class="string">'Beijing'</span>)</span><br><span class="line">name: Bob age: <span class="number">35</span> other: &#123;<span class="string">'city'</span>: <span class="string">'Beijing'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Adam'</span>, <span class="number">45</span>, gender=<span class="string">'M'</span>, job=<span class="string">'Engineer'</span>)</span><br><span class="line">name: Adam age: <span class="number">45</span> other: &#123;<span class="string">'gender'</span>: <span class="string">'M'</span>, <span class="string">'job'</span>: <span class="string">'Engineer'</span>&#125;</span><br><span class="line"><span class="comment"># 和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>extra = &#123;<span class="string">'city'</span>: <span class="string">'Beijing'</span>, <span class="string">'job'</span>: <span class="string">'Engineer'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Jack'</span>, <span class="number">24</span>, **extra)</span><br><span class="line">name: Jack age: <span class="number">24</span> other: &#123;<span class="string">'city'</span>: <span class="string">'Beijing'</span>, <span class="string">'job'</span>: <span class="string">'Engineer'</span>&#125;</span><br></pre></td></tr></table></figure><p><code>**extra</code>表示把<code>extra</code>这个dict的所有key-value用关键字参数传入到函数的<code>**kw</code>参数，<code>kw</code>将获得一个dict，注意<code>kw</code>获得的dict是<code>extra</code>的一份拷贝，对<code>kw</code>的改动不会影响到函数外的<code>extra</code>。</p><h5 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果要限制关键字参数的名字，就可以用命名关键字参数</span></span><br><span class="line"><span class="comment"># 例如，只接收city和job作为关键字参数。这种方式定义的函数如下：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, *, city, job)</span>:</span></span><br><span class="line">    print(name, age, city, job)</span><br><span class="line"><span class="comment"># 如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, *args, city, job)</span>:</span></span><br><span class="line">    print(name, age, args, city, job)</span><br><span class="line"><span class="comment"># 命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错，即需要写上city='..',job='..'</span></span><br><span class="line"><span class="comment"># 由于调用时缺少参数名city和job，Python解释器把这4个参数均视为位置参数，但person()函数仅接受2个位置参数。</span></span><br><span class="line"><span class="comment"># 命名关键字参数可以有缺省值，从而简化调用：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, *, city=<span class="string">'Beijing'</span>, job)</span>:</span></span><br><span class="line">    print(name, age, city, job)</span><br></pre></td></tr></table></figure><h5 id="参数组合"><a href="#参数组合" class="headerlink" title="参数组合"></a>参数组合</h5><p>在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。比如定义一个函数，包含上述若干种参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(a, b, c=<span class="number">0</span>, *args, **kw)</span>:</span></span><br><span class="line">    print(<span class="string">'a ='</span>, a, <span class="string">'b ='</span>, b, <span class="string">'c ='</span>, c, <span class="string">'args ='</span>, args, <span class="string">'kw ='</span>, kw)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(a, b, c=<span class="number">0</span>, *, d, **kw)</span>:</span></span><br><span class="line">    print(<span class="string">'a ='</span>, a, <span class="string">'b ='</span>, b, <span class="string">'c ='</span>, c, <span class="string">'d ='</span>, d, <span class="string">'kw ='</span>, kw)</span><br></pre></td></tr></table></figure><p>在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">0</span> args = () kw = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>, <span class="number">2</span>, c=<span class="number">3</span>)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = () kw = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="string">'b'</span>)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = (<span class="string">'a'</span>, <span class="string">'b'</span>) kw = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, x=<span class="number">99</span>)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = (<span class="string">'a'</span>, <span class="string">'b'</span>) kw = &#123;<span class="string">'x'</span>: <span class="number">99</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f2(<span class="number">1</span>, <span class="number">2</span>, d=<span class="number">99</span>, ext=<span class="literal">None</span>)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">0</span> d = <span class="number">99</span> kw = &#123;<span class="string">'ext'</span>: <span class="literal">None</span>&#125;</span><br></pre></td></tr></table></figure><p>最神奇的是通过一个tuple和dict，你也可以调用上述函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>args = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kw = &#123;<span class="string">'d'</span>: <span class="number">99</span>, <span class="string">'x'</span>: <span class="string">'#'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1(*args, **kw)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = (<span class="number">4</span>,) kw = &#123;<span class="string">'d'</span>: <span class="number">99</span>, <span class="string">'x'</span>: <span class="string">'#'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>args = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kw = &#123;<span class="string">'d'</span>: <span class="number">88</span>, <span class="string">'x'</span>: <span class="string">'#'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f2(*args, **kw)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> d = <span class="number">88</span> kw = &#123;<span class="string">'x'</span>: <span class="string">'#'</span>&#125;</span><br></pre></td></tr></table></figure><p>所以，对于任意函数，都可以通过类似<code>func(*args, **kw)</code>的形式调用它，无论它的参数是如何定义的。</p><h5 id="参数小结"><a href="#参数小结" class="headerlink" title="参数小结"></a>参数小结</h5><p>Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。<br>默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！<br>要注意定义可变参数和关键字参数的语法：<br><code>*args</code>是可变参数，args接收的是一个tuple；<br><code>**kw</code>是关键字参数，kw接收的是一个dict。<br>以及调用函数时如何传入可变参数和关键字参数的语法：<br>可变参数既可以直接传入：<code>func(1, 2, 3)</code>，又可以先组装list或tuple，再通过<code>*args</code>传入：<code>func(*(1, 2, 3))</code>；<br>关键字参数既可以直接传入：<code>func(a=1, b=2)</code>，又可以先组装dict，再通过<code>**kw</code>传入：<code>func(**{&#39;a&#39;: 1, &#39;b&#39;: 2})</code>。<br>使用<code>*args</code>和<code>**kw</code>是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。<br>命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。<br>定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符<code>*</code>，否则定义的将是位置参数。</p><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><p>尾递归优化——尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。python未提供该优化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 上面的fact(n)函数由于return n * fact(n - 1)引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> fact_iter(n, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact_iter</span><span class="params">(num, product)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> product</span><br><span class="line">    <span class="keyword">return</span> fact_iter(num - <span class="number">1</span>, num * product)</span><br><span class="line"><span class="comment"># 可以看到，return fact_iter(num - 1, num * product)仅返回递归函数本身，`num - 1`和`num * product`在函数调用前就会被计算，不影响函数调用。</span></span><br></pre></td></tr></table></figure><h3 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h3><h5 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h5><p>正向切片——<code>L[0:3]</code>，从索引0开始取到索引3为止且不包含索引为3的元素，如果第一个索引为0，还可以省略，即<code>L[:3]</code>。<br>倒数切片——<code>L[-10:-1]</code>，即取从倒数第十到倒数第一的元素且不包含最后一个元素，如果想取最后一个元素，则<code>L[-10:]</code>即可。<br>设置间隔——<code>L[0:10:2]</code>，即取前十个数且每两个数取一个，或者<code>L[::5]</code>，取所有，每5个取一个。如果只写<code>:</code>则复制原有的<code>list</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试</span></span><br><span class="line"><span class="comment"># 利用切片操作，实现一个trim()函数，去除字符串首尾的空格，注意不要调用str的strip()方法：</span></span><br><span class="line"><span class="comment"># 自己写的</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trim</span><span class="params">(s)</span>:</span></span><br><span class="line">    l = len(s)</span><br><span class="line">    end = <span class="number">0</span></span><br><span class="line">    front = l</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(l):</span><br><span class="line">        <span class="keyword">if</span> s[i] != <span class="string">' '</span>:</span><br><span class="line">            front = i</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(l - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> s[i] != <span class="string">' '</span>:</span><br><span class="line">            end = i</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> front &gt; end:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    <span class="keyword">return</span> s[front:end+<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 网上的一些</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trim</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="number">0</span>==len(s):</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">while</span> <span class="string">' '</span>==s[<span class="number">0</span>]:</span><br><span class="line">        s=s[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span>==len(s):</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">while</span> <span class="string">' '</span>==s[<span class="number">-1</span>]:</span><br><span class="line">        s=s[:<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span>==len(s):</span><br><span class="line">            <span class="keyword">return</span> s         </span><br><span class="line">    <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><h5 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h5><p>只要是可迭代对象，就可以通过<code>for</code>进行迭代，用<code>dict</code>举例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> d:</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> d.values():</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> d.items():</span><br><span class="line"><span class="comment"># 如何判断是否可以迭代呢</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line">isinstance(<span class="string">'abc'</span>, Iterable) <span class="comment"># 判断是否可迭代</span></span><br></pre></td></tr></table></figure><h5 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h5><p>用来生成<code>list</code>，例<code>list(range(1,11))</code>，并且可以和<code>if,for</code>配合使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>)]  <span class="comment"># [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span></span><br><span class="line">[x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]  <span class="comment"># [4, 16, 36, 64, 100]</span></span><br><span class="line">[m + n <span class="keyword">for</span> m <span class="keyword">in</span> <span class="string">'ABC'</span> <span class="keyword">for</span> n <span class="keyword">in</span> <span class="string">'XYZ'</span>]  <span class="comment"># ['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']</span></span><br><span class="line">d = &#123;<span class="string">'x'</span>: <span class="string">'A'</span>, <span class="string">'y'</span>: <span class="string">'B'</span>, <span class="string">'z'</span>: <span class="string">'C'</span> &#125;</span><br><span class="line">[k + <span class="string">'='</span> + v <span class="keyword">for</span> k, v <span class="keyword">in</span> d.items()]  <span class="comment"># ['y=B', 'x=A', 'z=C']</span></span><br><span class="line">L = [<span class="string">'Hello'</span>, <span class="string">'World'</span>, <span class="string">'IBM'</span>, <span class="string">'Apple'</span>]</span><br><span class="line">[s.lower() <span class="keyword">for</span> s <span class="keyword">in</span> L]  <span class="comment"># ['hello', 'world', 'ibm', 'apple']</span></span><br></pre></td></tr></table></figure><p>可见，在一个列表生成式中，<code>for</code>前面的<code>if ... else</code>是表达式，而<code>for</code>后面的<code>if</code>是过滤条件，不能带<code>else</code>。</p><h5 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h5><p><code>generator</code>一边循环，一边计算，可以把列表生成式的<code>[]</code>改为<code>()</code>即可，可以用<code>next(g)</code>来打印生成器的下一个值，在没有元素时会抛出异常。也可以通过<code>for</code>来迭代从而避免异常。定义generator的另一种方法，如果一个函数定义中包含<code>yield</code>关键字，那么这个函数就不再是一个普通函数，而是一个generator。</p><p>生成器每次停止是在遇到<code>yield</code>关键字停止，下一次开始也同样从这里开始。调用generator时，需要先生成一个generator对象，<code>o=odd() # odd是一个generator</code>，同样使用for来迭代：<code>for n in odd()</code>，但是使用for语句会拿不到generator<code>return</code>语句的值，需要使用错误捕获来获得。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">triangles</span><span class="params">()</span>:</span></span><br><span class="line">    list  = [<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> list[:]</span><br><span class="line">        list.append(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> index,value <span class="keyword">in</span> enumerate(list[:<span class="number">-1</span>]):</span><br><span class="line">            list[index+<span class="number">1</span>] += value</span><br></pre></td></tr></table></figure><h5 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h5><p><code>isinstance([], Iterable)</code>判断是否是Iterable对象。可以被<code>next()</code>函数调用并不断返回下一个值的对象称为迭代器：<code>Iterator</code>。生成器都是<code>Iterator</code>对象，但<code>list</code>、<code>dict</code>、<code>str</code>虽然是<code>Iterable</code>，却不是<code>Iterator</code>。把<code>list</code>、<code>dict</code>、<code>str</code>等<code>Iterable</code>变成<code>Iterator</code>可以使用<code>iter()</code>函数。<code>Iterator</code>的计算是惰性的，只有在需要返回下一个数据时它才会计算。所以list等就不是<code>Iterator</code>。</p><h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><h5 id="map-reduce"><a href="#map-reduce" class="headerlink" title="map/reduce"></a>map/reduce</h5><p><code>map()</code>函数接受两个参数，一个是函数，一个<code>Iterable</code>，<code>map</code>将传入的函数依次作用到序列的每个元素，并把结果作为新的<code>Iterator</code>返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">     <span class="keyword">return</span> x * x</span><br><span class="line"></span><br><span class="line">r = map(f, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"><span class="comment"># map()传入的第一个参数是f，即函数对象本身。由于结果r是一个Iterator，Iterator是惰性序列</span></span><br><span class="line"><span class="comment"># 因此通过list()函数让它把整个序列都计算出来并返回一个list。</span></span><br><span class="line">list(r) <span class="comment"># [1, 4, 9, 16, 25, 36, 49, 64, 81]</span></span><br></pre></td></tr></table></figure><p><code>reduce()</code>也接受两个参数，一个是函数，一个<code>Iterable</code>，<code>reduce</code>把一个函数作用在一个序列<code>[x1, x2, x3, ...]</code>上，这个函数必须接收两个参数，<code>reduce</code>把结果继续和序列的下一个元素做累积计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">reduce(add, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]) <span class="comment"># 25</span></span><br><span class="line"><span class="comment"># 利用map()函数，把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。</span></span><br><span class="line"><span class="comment"># 输入：['adam', 'LISA', 'barT']，输出：['Adam', 'Lisa', 'Bart']：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">normalize</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> name[:<span class="number">1</span>].upper() + name[<span class="number">1</span>:].lower()</span><br><span class="line"><span class="comment"># str2float</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">str2float</span><span class="params">(s)</span>:</span></span><br><span class="line">    DIGITS = &#123;<span class="string">'0'</span>: <span class="number">0</span>, <span class="string">'1'</span>: <span class="number">1</span>, <span class="string">'2'</span>: <span class="number">2</span>, <span class="string">'3'</span>: <span class="number">3</span>, <span class="string">'4'</span>: <span class="number">4</span>, <span class="string">'5'</span>: <span class="number">5</span>, <span class="string">'6'</span>: <span class="number">6</span>, <span class="string">'7'</span>: <span class="number">7</span>, <span class="string">'8'</span>: <span class="number">8</span>, <span class="string">'9'</span>: <span class="number">9</span>, <span class="string">'.'</span>: <span class="number">-1</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> DIGITS[x]</span><br><span class="line">    L = list(map(f, s))</span><br><span class="line">    index = L.index(<span class="number">-1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">r</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x *<span class="number">10</span> + y</span><br><span class="line">    x1 = reduce(r, L[:index])</span><br><span class="line">    x2 = reduce(r, L[index+<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> float(str(x1)+<span class="string">'.'</span>+str(x2))</span><br></pre></td></tr></table></figure><h5 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h5><p><code>filter()</code>函数用于过滤序列。和<code>map()</code>类似，<code>filter()</code>也接收一个函数和一个序列。和<code>map()</code>不同的是，<code>filter()</code>把传入的函数依次作用于每个元素，然后根据返回值是<code>True</code>还是<code>False</code>决定保留还是丢弃该元素。且<code>filter()</code>返回的是<code>Iterator</code>，惰性序列，需要使用<code>list()</code>来生成。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用于生成素数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成器-从3开始的奇数序列</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_odd_iter</span><span class="params">()</span>:</span></span><br><span class="line">    n = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n = n + <span class="number">2</span></span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line"><span class="comment"># 筛选函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_not_divisible</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x: x % n &gt; <span class="number">0</span>  </span><br><span class="line"><span class="comment"># 生成素数序列的生成器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">primes</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    it = _odd_iter() <span class="comment"># 初始序列</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n = next(it) <span class="comment"># 返回序列的第一个数</span></span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line">        it = filter(_not_divisible(n), it) <span class="comment"># 构造新序列</span></span><br><span class="line"><span class="comment"># 打印1000以内的素数:</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> primes():</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">1000</span>:</span><br><span class="line">        print(n)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h5 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h5><p>Python内置的<code>sorted()</code>函数就可以直接对list进行排序(默认从小到大)，此外，<code>sorted()</code>函数也是一个高阶函数，它还可以接收一个<code>key</code>函数来实现自定义的排序。<code>key</code>指定的函数将作用于<code>list</code>的每一个元素上，并根据<code>key</code>函数返回的结果进行排序。要进行反向排序，不必改动key函数，可以传入第三个参数<code>reverse=True</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sorted([<span class="string">'bob'</span>, <span class="string">'about'</span>, <span class="string">'Zoo'</span>, <span class="string">'Credit'</span>], key=str.lower, reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># ['Zoo', 'Credit', 'bob', 'about']</span></span><br></pre></td></tr></table></figure><h5 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lazy_sum</span><span class="params">(*args)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">()</span>:</span></span><br><span class="line">        ax = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> args:</span><br><span class="line">            ax = ax + n</span><br><span class="line">        <span class="keyword">return</span> ax</span><br><span class="line">    <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure><p>返回的是一个函数，并且是在调用返回的函数<code>f</code>时，才会真正开始计算。且每次调用<code>lazy_sum()</code>返回的都是不同的函数，即使函数相同。</p><p>闭包——我们在函数<code>lazy_sum</code>中又定义了函数<code>sum</code>，并且，内部函数<code>sum</code>可以引用外部函数<code>lazy_sum</code>的参数和局部变量，当<code>lazy_sum</code>返回函数<code>sum</code>时，相关参数和变量都保存在返回的函数中的程序结构，就称为闭包。需要注意，返回的函数不是立即执行，而是在函数调用时才会执行。所以返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每次返回递增整数的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_counter</span>:</span></span><br><span class="line">    l = [<span class="number">0</span>] <span class="comment"># 这里使用int类型会报错 如果使用l = 0，后面l += 1，则会报错</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">counter</span>:</span></span><br><span class="line">    l[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> l[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> counter</span><br><span class="line"><span class="comment"># 原因：不可变类型所指向的地址随值的变化而变化，即l=0指向一个地址，而l+=1，l=1后，指向其他地址</span></span><br><span class="line"><span class="comment"># 而对于可变对象，则其指向的地址不会随值变化而变化，l[0]对应的地址一直不会变，只是该地址对应的值在变</span></span><br></pre></td></tr></table></figure><h5 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h5><p><code>lambda</code>关键字表示匿名函数，匿名函数有个限制，就是只能有一个表达式，不用写<code>return</code>，返回值就是该表达式的结果。用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> x: x * x <span class="comment"># def f(x): return x * x </span></span><br><span class="line"><span class="comment"># 也可以没有参数，即和函数没有参数一样的道理，例子:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x, y)</span></span></span><br><span class="line"><span class="function"><span class="title">return</span> <span class="title">lambda</span>:</span> x + y</span><br></pre></td></tr></table></figure><h5 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h5><p>函数有一个<code>_name_</code>属性，可以通过该属性拿到函数的名字。在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。即不改变函数定义，增加功能。装饰器接受函数作为参数，且使用装饰器时，要借助Python的@语法，把decorator置于函数的定义处。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 装饰器</span></span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        print(<span class="string">'call %s():'</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@log</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'2015-3-25'</span>)</span><br><span class="line"><span class="comment"># 即表示now = log(now)</span></span><br><span class="line"><span class="comment"># 且now._name_ = wrapper</span></span><br></pre></td></tr></table></figure><p>如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数，写出来会更复杂。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(text)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">        @functools.wraps(func)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">            print(<span class="string">'%s %s():'</span> % (text, func.__name__))</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@log('execute')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'2015-3-25'</span>)</span><br><span class="line"><span class="comment"># 即now = log('execute')(now)</span></span><br></pre></td></tr></table></figure><p>在oop设计模式中还有一些应用。</p><h5 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h5><p><code>functools.partial</code>帮助我们创建一个偏函数，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。但是创建完后，也仍然可以传递参数来改变功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line">int2 = functools.partial(int, base=<span class="number">2</span>)</span><br><span class="line">int2(<span class="string">'1000000'</span>) <span class="comment"># 64</span></span><br><span class="line">int2(<span class="string">'1000000'</span>, base=<span class="number">10</span>) <span class="comment"># 1000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际上固定了int()函数的关键字参数base，也就是：</span></span><br><span class="line">int2(<span class="string">'10010'</span>)</span><br><span class="line"><span class="comment"># 相当于</span></span><br><span class="line">kw = &#123; <span class="string">'base'</span>: <span class="number">2</span> &#125;</span><br><span class="line">int(<span class="string">'10010'</span>, **kw)</span><br><span class="line"></span><br><span class="line">max2 = functools.partial(max, <span class="number">10</span>)</span><br><span class="line">max2(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line"><span class="comment"># 相当于</span></span><br><span class="line">args = (<span class="number">10</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line">max(*args)</span><br></pre></td></tr></table></figure><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><h5 id="使用模块"><a href="#使用模块" class="headerlink" title="使用模块"></a>使用模块</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">' a test module '</span></span><br><span class="line"></span><br><span class="line">__author__ = <span class="string">'Michael Liao'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"><span class="comment"># xxxxxx</span></span><br></pre></td></tr></table></figure><p>第1行和第2行是标准注释，第1行注释可以让这个<code>hello.py</code>文件直接在Unix/Linux/Mac上运行，第2行注释表示.py文件本身使用标准UTF-8编码。第4行是一个字符串，表示模块的文档注释，任何模块代码的第一个字符串都被视为模块的文档注释。第6行使用<code>__author__</code>变量把作者写进去。</p><p><code>sys</code>模块中的<code>agrv</code>变量，即命令行参数，第一个参数是该<code>.py</code>文件的名称，<code>argv</code>是一个<code>list</code>。</p><p>当我们在命令行运行模块文件时，Python解释器把一个特殊变量<code>__name__</code>置为<code>__main__</code>，而如果在其他地方导入该模块时，<code>if</code>判断将失败，因此，这种<code>if</code>测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。</p><p>模块的作用域——在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用。在Python中，是通过<code>_</code>前缀来实现的。类似<code>_xxx</code>和<code>__xxx</code>这样的函数或变量就是非公开的（private），不应该被直接引用，比如<code>_abc</code>，<code>__abc</code>等；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># example</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_private_1</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello, %s'</span> % name</span><br></pre></td></tr></table></figure><h5 id="模块搜索路径"><a href="#模块搜索路径" class="headerlink" title="模块搜索路径"></a>模块搜索路径</h5><p>当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错。默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在<code>sys</code>模块的<code>path</code>变量中，如果我们要添加自己的搜索目录，有两种方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一是直接修改sys.path，添加要搜索的目录：</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">'/Users/michael/my_py_scripts'</span>)</span><br><span class="line"><span class="comment"># 这种方法是在运行时修改，运行结束后失效。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种方法是设置环境变量PYTHONPATH，该环境变量的内容会被自动添加到模块搜索路径中。</span></span><br><span class="line"><span class="comment"># 设置方式与设置Path环境变量类似。注意只需要添加你自己的搜索路径，Python自己本身的搜索路径不受影响。</span></span><br></pre></td></tr></table></figure><h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><h5 id="类和实例"><a href="#类和实例" class="headerlink" title="类和实例"></a>类和实例</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Object)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, age, score)</span>:</span></span><br><span class="line">        self.age = age</span><br><span class="line">        self.score = score</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_grade</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.score &gt;= <span class="number">90</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'A'</span></span><br><span class="line">        <span class="keyword">elif</span> self.score &gt;= <span class="number">60</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'B'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'C'</span></span><br><span class="line">        </span><br><span class="line">Jack = Student() <span class="comment"># 实例</span></span><br><span class="line">Jack.name = jack <span class="comment"># 添加属性</span></span><br></pre></td></tr></table></figure><p>定义类，用<code>class</code>关键字，<code>Object</code>即该类的父类。创建实例即类名+<code>()</code>，还可以自由地给一个实例变量绑定属性，比如，给实例<code>Jack</code>绑定一个<code>name</code>属性。<code>__init__方法</code>可以理解为构造方法，可以绑定需要的属性。且<code>__init__方法</code>的第一个参数永远为<code>self</code>，表示创建的实例本身。和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量<code>self</code>，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。</p><h5 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h5><p>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线<code>__</code>，在Python中，实例的变量名如果以<code>__</code>开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Object)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, age, score)</span>:</span></span><br><span class="line">        self.__age = age</span><br><span class="line">        self.__score = score</span><br><span class="line"><span class="comment"># 无法从外部访问实例变量.__age和实例变量.__score</span></span><br></pre></td></tr></table></figure><p>如果想要访问相应的私有变量，可以通过<code>getter</code>和<code>setter</code>方法来获得和修改私有变量。还有需要注意的是，在Python中，变量名类似<code>__xxx__</code>的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用<code>__name__</code>、<code>__score__</code>这样的变量名。</p><p>有些时候，你会看到以一个下划线开头的实例变量名，比如<code>_name</code>，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。</p><p>双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问<code>__name</code>是因为Python解释器对外把<code>__name</code>变量改成了<code>_Student__name</code>，所以，仍然可以通过<code>_Student__name</code>来访问<code>__name</code>变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Jack._Student__name <span class="comment"># jack</span></span><br></pre></td></tr></table></figure><p>最后注意下面的这种<strong>错误写法</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bart = Student(<span class="string">'Bart Simpson'</span>, <span class="number">59</span>)</span><br><span class="line">bart.get_name()</span><br><span class="line"><span class="comment"># 'Bart Simpson'</span></span><br><span class="line">bart.__name = <span class="string">'New Name'</span> <span class="comment"># 设置__name变量！</span></span><br><span class="line">bart.__name</span><br><span class="line"><span class="comment"># 'New Name'</span></span><br><span class="line">bart.get_name() <span class="comment"># get_name()内部返回self.__name</span></span><br><span class="line"><span class="comment"># 'Bart Simpson'</span></span><br></pre></td></tr></table></figure><p>表面上看，外部代码“成功”地设置了<code>__name</code>变量，但实际上这个<code>__name</code>变量和class内部的<code>__name</code>变量<em>不是</em>一个变量！内部的<code>__name</code>变量已经被Python解释器自动改成了<code>_Student__name</code>，而外部代码给<code>bart</code>新增了一个<code>__name</code>变量。</p><h5 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Animal is running...'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Dog is running...'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Cat is running...'</span>)</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_twice</span><span class="params">(animal)</span>:</span></span><br><span class="line">    animal.run()</span><br><span class="line">    animal.run()</span><br></pre></td></tr></table></figure><p>在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。但是，反过来就不行。</p><p>多态的开闭原则：1）对扩展开放：允许新增<code>Animal</code>子类    2）对修改封闭：不需要修改依赖<code>Animal</code>类型的<code>run_twice()</code>等函数。</p><p><strong>静态语言和动态语言</strong>——对于静态语言（例如Java）来说，如果需要传入<code>Animal</code>类型，则传入的对象必须是<code>Animal</code>类型或者它的子类，否则，将无法调用<code>run()</code>方法。对于Python这样的动态语言来说，则不一定需要传入<code>Animal</code>类型。我们只需要保证传入的对象有一个<code>run()</code>方法就可以了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Timer</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Start...'</span>)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 这里没有继承于Animal 但是还是可以当作Animal类型的类传入，因为其具有run()方法</span></span><br></pre></td></tr></table></figure><p>这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</p><p>Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个<code>read()</code>方法，返回其内容。但是，许多对象，只要有<code>read()</code>方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了<code>read()</code>方法的对象。</p><h5 id="获取对象信息"><a href="#获取对象信息" class="headerlink" title="获取对象信息"></a>获取对象信息</h5><p>判断对象类型，使用<code>type()</code>函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type(<span class="number">123</span>) <span class="comment"># &lt;class 'int'&gt;</span></span><br><span class="line">type(<span class="string">'str'</span>) <span class="comment"># &lt;class 'str'&gt;</span></span><br><span class="line">type(<span class="literal">None</span>) <span class="comment"># &lt;type(None) 'NoneType'&gt;</span></span><br><span class="line">type(abs) <span class="comment"># &lt;class 'builtin_function_or_method'&gt;</span></span><br><span class="line">type(a) <span class="comment"># &lt;class '__main__.Animal'&gt;</span></span><br></pre></td></tr></table></figure><p>可以在<code>if</code>语句中判断两个变量的类型是否相等</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">type(<span class="number">123</span>)==type(<span class="number">456</span>) <span class="comment"># True</span></span><br><span class="line">type(<span class="number">123</span>)==int <span class="comment"># True</span></span><br><span class="line">type(<span class="string">'abc'</span>)==type(<span class="string">'123'</span>) <span class="comment"># True</span></span><br><span class="line">type(<span class="string">'abc'</span>)==str <span class="comment"># True</span></span><br><span class="line">type(<span class="string">'abc'</span>)==type(<span class="number">123</span>)<span class="comment"># False</span></span><br><span class="line"><span class="comment"># 还可以使用types模块中来判断函数、生成器、对象等等</span></span><br><span class="line"><span class="keyword">import</span> types</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">type(fn)==types.FunctionType <span class="comment"># True</span></span><br><span class="line">type(abs)==types.BuiltinFunctionType <span class="comment"># True</span></span><br><span class="line">type(<span class="keyword">lambda</span> x: x)==types.LambdaType <span class="comment"># True</span></span><br><span class="line">type((x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)))==types.GeneratorType <span class="comment"># True</span></span><br></pre></td></tr></table></figure><p>还可以使用<code>isinstance()</code>来判断类的继承等关系，而不建议使用<code>type()</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># object -&gt; Animal -&gt; Dog -&gt; Husky</span></span><br><span class="line">a = Animal()</span><br><span class="line">d = Dog()</span><br><span class="line">h = Husky()</span><br><span class="line">isinstance(h, Husky) <span class="comment"># True</span></span><br><span class="line">isinstance(h, Dog) <span class="comment"># True</span></span><br><span class="line">isinstance(h, Animal) <span class="comment"># True</span></span><br><span class="line"><span class="comment"># isinstance()判断的是一个对象是否是该类型本身，或者位于该类型的父继承链上。</span></span><br><span class="line">isinstance(d, Husky) <span class="comment"># False</span></span><br><span class="line"><span class="comment"># 能用type()判断的基本类型也可以用isinstance()判断：</span></span><br><span class="line">isinstance(<span class="string">'a'</span>, str) <span class="comment"># True</span></span><br><span class="line"><span class="comment"># 并且还可以判断一个变量是否是某些类型中的一种，比如下面的代码就可以判断是否是list或者tuple：</span></span><br><span class="line">isinstance([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (list, tuple)) <span class="comment"># True</span></span><br><span class="line">isinstance((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (list, tuple)) <span class="comment"># True</span></span><br></pre></td></tr></table></figure><p>如果要获得一个对象的所有属性和方法，可以使用<code>dir()</code>函数，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dir(<span class="string">'ABC'</span>)</span><br><span class="line"><span class="comment"># ['__add__', '__class__',..., '__subclasshook__', 'capitalize', 'casefold',..., 'zfill']</span></span><br></pre></td></tr></table></figure><p>类似<code>__xxx__</code>的属性和方法在Python中都是有特殊用途的，比如<code>__len__</code>方法返回长度。在Python中，如果你调用<code>len()</code>函数试图获取一个对象的长度，实际上，在<code>len()</code>函数内部，它自动去调用该对象的<code>__len__()</code>方法，所以，下面的代码是等价的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">len(<span class="string">'ABC'</span>) <span class="comment"># 3</span></span><br><span class="line"><span class="string">'ABC'</span>.__len__() <span class="comment"># 3</span></span><br><span class="line"><span class="string">'ABC'</span>.lower() <span class="comment"># abc</span></span><br></pre></td></tr></table></figure><p>同样如果是我们自己写的类，如果也想用<code>len(myObj)</code>的话，也可以自己写一个<code>__len__()</code>方法。还有就是<code>lower()</code>普通方法。</p><p>仅仅把属性和方法列出来是不够的，配合<code>getattr()</code>、<code>setattr()</code>以及<code>hasattr()</code>，我们可以直接操作一个对象的状态：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.x = <span class="number">9</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">power</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.x * self.x</span><br><span class="line"></span><br><span class="line">obj = MyObject()</span><br></pre></td></tr></table></figure><p>紧接着，可以测试该对象的属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hasattr(obj, <span class="string">'x'</span>) <span class="comment"># 有属性'x'吗？ True</span></span><br><span class="line">obj.x <span class="comment"># 9</span></span><br><span class="line">hasattr(obj, <span class="string">'y'</span>) <span class="comment"># 有属性'y'吗？ False</span></span><br><span class="line">setattr(obj, <span class="string">'y'</span>, <span class="number">19</span>) <span class="comment"># 设置一个属性'y'</span></span><br><span class="line">hasattr(obj, <span class="string">'y'</span>) <span class="comment"># 有属性'y'吗？ True</span></span><br><span class="line">getattr(obj, <span class="string">'y'</span>) <span class="comment"># 获取属性'y' 19</span></span><br><span class="line">obj.y <span class="comment"># 获取属性'y' 19</span></span><br></pre></td></tr></table></figure><p>如果试图获取不存在的属性，会抛出AttributeError的错误：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getattr(obj, <span class="string">'z'</span>) <span class="comment"># 获取属性'z'</span></span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment"># File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span></span><br><span class="line"><span class="comment"># AttributeError: 'MyObject' object has no attribute 'z'</span></span><br></pre></td></tr></table></figure><p>还可以传入一个default参数，如果属性不存在，就返回默认值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getattr(obj, <span class="string">'z'</span>, <span class="number">404</span>) <span class="comment"># 获取属性'z'，如果不存在，返回默认值404</span></span><br><span class="line"><span class="comment"># 404</span></span><br></pre></td></tr></table></figure><p>也可以获得对象的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hasattr(obj, <span class="string">'power'</span>) <span class="comment"># 有属性'power'吗？ True</span></span><br><span class="line">getattr(obj, <span class="string">'power'</span>) <span class="comment"># 获取属性'power'</span></span><br><span class="line"><span class="comment"># &lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;</span></span><br><span class="line">fn = getattr(obj, <span class="string">'power'</span>) <span class="comment"># 获取属性'power'并赋值到变量fn</span></span><br><span class="line">fn <span class="comment"># fn指向obj.power</span></span><br><span class="line"><span class="comment"># &lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;</span></span><br><span class="line">fn() <span class="comment"># 调用fn()与调用obj.power()是一样的 81</span></span><br></pre></td></tr></table></figure><p>通过内置的一系列函数，我们可以对任意一个Python对象进行剖析，拿到其内部的数据。要注意的是，只有在不知道对象信息的时候，我们才会去获取对象信息。如果可以直接使用类名.属性的形式来进行。</p><p>一个正确的用法的例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readImage</span><span class="params">(fp)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> hasattr(fp, <span class="string">'read'</span>):</span><br><span class="line">        <span class="keyword">return</span> readData(fp)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h5 id="实例属性和类属性"><a href="#实例属性和类属性" class="headerlink" title="实例属性和类属性"></a>实例属性和类属性</h5><p>实例属性归属于类本身，但是类的实例也可以像访问属性一样访问，同时还可以通过类名.类属性名来访问。</p><p>需要注意的是，千万不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。</p>]]></content>
      
      
      <categories>
          
          <category> 学习篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript学习</title>
      <link href="/2021/04/01/JavaScript%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/04/01/JavaScript%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript学习"><a href="#JavaScript学习" class="headerlink" title="JavaScript学习"></a>JavaScript学习</h2><p><em>time:2020/04/10</em></p><h4 id="Javascript基础"><a href="#Javascript基础" class="headerlink" title="Javascript基础"></a>Javascript基础</h4><a id="more"></a><p>数据类型和变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Number类型，不区分整数和浮点数统一为Number类型。</span></span><br><span class="line"><span class="comment">//NaN和Infinity是特殊的Number类型</span></span><br><span class="line"><span class="comment">//一个表示无法表示的数，另一个则是在JavaScript中超过最大能表示的范围，就为Infinity</span></span><br><span class="line"><span class="comment">//%取模运算在JavaScript中可以对浮点数使用</span></span><br><span class="line"><span class="number">10.5</span>%<span class="number">3</span>==<span class="number">1.5</span>;</span><br><span class="line"><span class="number">0</span>/<span class="number">0</span>==<span class="literal">NaN</span>;</span><br><span class="line"><span class="number">2</span>/<span class="number">0</span>==<span class="literal">Infinity</span>;</span><br><span class="line"><span class="comment">//==和===运算符，前者会自动转换类型再比较，所以应坚持使用后者进行比较</span></span><br><span class="line"><span class="comment">//NaN和所有值都不同，包括其自身，需使用isNaN()来判断</span></span><br><span class="line"><span class="comment">//浮点数的比较也需要注意,eg.1/3!=1-2/3</span></span><br></pre></td></tr></table></figure><p>字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可用`...`来表示多行字符串</span></span><br><span class="line"><span class="string">`这是一个</span></span><br><span class="line"><span class="string">多行</span></span><br><span class="line"><span class="string">字符串`</span>;</span><br><span class="line"><span class="comment">//除了用'+'连接字符串，还可以使用$&#123;&#125;来实现</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'小明'</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">`你好, <span class="subst">$&#123;name&#125;</span>, 你今年<span class="subst">$&#123;age&#125;</span>岁了!`</span>;</span><br><span class="line"><span class="comment">//var message = '你好, ' + name + ', 你今年' + age + '岁了!';</span></span><br><span class="line"><span class="comment">//字符串可以使用下标访问特定位置的字符。</span></span><br><span class="line"><span class="comment">//字符串是不变的，所以对某位置的字符进行改变，全字符串是不变的</span></span><br></pre></td></tr></table></figure><p><em>time:2020/04/16</em></p><p>数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以直接给Array的length赋值，并且会改变Array的大小</span></span><br><span class="line"><span class="comment">//可以给Array超过范围的索引赋值，同样会改变Array</span></span><br><span class="line"><span class="comment">//indexOf()方法，可以返回一个索引或者返回索引对应的元素，即参数可以是索引也可以是元素</span></span><br><span class="line"><span class="comment">//slice()方法，就是和string的substring方法是同样的效果，且参数是参数包含开始索引不包含结束索引,不传递参数，则代表剪切整个字符串，可以这样复制数组</span></span><br><span class="line"><span class="comment">//push()和pop()方法，字符串末尾添加或者删除元素</span></span><br><span class="line"><span class="comment">//unshift()和shift()方法，字符串开头添加或者删除元素(unshift添加)</span></span><br><span class="line"><span class="comment">//sort()方法，排序;reverse()方法，调转数组。</span></span><br><span class="line"><span class="keyword">var</span> arr=&#123;<span class="string">'A'</span>,<span class="string">'b'</span>&#125;;</span><br><span class="line">arr.sort();</span><br><span class="line"><span class="comment">//splice()方法,第一个参数指定索引，第二个参数指定从该索引开始删除的元素个数，然后后面可以跟一些字符串表示从该索引开始添加的元素，也可以不添加，即只有两个参数。并且该方法会返回删除的元素形成的数组</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">'Microsoft'</span>, <span class="string">'Apple'</span>, <span class="string">'Yahoo'</span>, <span class="string">'AOL'</span>, <span class="string">'Excite'</span>, <span class="string">'Oracle'</span>];</span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">3</span>, <span class="string">'Google'</span>, <span class="string">'Facebook'</span>); <span class="comment">// 返回删除的元素 ['Yahoo', 'AOL', 'Excite']</span></span><br><span class="line">arr; <span class="comment">// ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// ['Google', 'Facebook']</span></span><br><span class="line">arr; <span class="comment">// ['Microsoft', 'Apple', 'Oracle']</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="string">'Google'</span>, <span class="string">'Facebook'</span>); <span class="comment">// 返回[],因为没有删除任何元素</span></span><br><span class="line">arr; <span class="comment">// ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']</span></span><br><span class="line"><span class="comment">//concat方法，连接两个数组并返回新数组</span></span><br><span class="line"><span class="keyword">var</span> c=a.concat(b);</span><br><span class="line"><span class="comment">//join方法，把数组中的元素用特定的字符串连接起来，返回字符串</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.join(<span class="string">'-'</span>); <span class="comment">// 'A-B-C-1-2-3'，可以是字符串 不一定只有一个字符</span></span><br></pre></td></tr></table></figure><p>对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stu = &#123;</span><br><span class="line">    name:<span class="string">'小小'</span></span><br><span class="line">&#125;;</span><br><span class="line">stu.name;</span><br><span class="line">stu[<span class="string">'name'</span>]; <span class="comment">//这两种访问都是可以的</span></span><br><span class="line">stu.number = <span class="string">'153'</span>; <span class="comment">//可以动态添加属性</span></span><br><span class="line"><span class="keyword">delete</span> stu.number; <span class="comment">//删除属性</span></span><br><span class="line"><span class="string">'name'</span> <span class="keyword">in</span> stu; <span class="comment">//检查对象是否拥有某属性,或者其是否继承某属性 布尔型</span></span><br><span class="line">stu.hasOwnProperty(<span class="string">'name'</span>); <span class="comment">//检查自身是否拥有某一属性 布尔型</span></span><br></pre></td></tr></table></figure><p>循环</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//条件判断语句if else与常规语言没有什么区别</span></span><br><span class="line"><span class="comment">//for循环的基本使用也都一样</span></span><br><span class="line"><span class="comment">//for...in...，可以将一个对象的所有属性都循环一遍</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    name: <span class="string">'Jack'</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    city: <span class="string">'Beijing'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> o) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key); <span class="comment">// 'name', 'age', 'city'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//要过滤掉对象继承的属性，用hasOwnProperty()来实现</span></span><br><span class="line"><span class="comment">//Array也是对象，也可以使用for..in..循环，循环得到的是索引</span></span><br><span class="line"><span class="comment">//需要注意，得到的索引是String而不是Number</span></span><br></pre></td></tr></table></figure><p>Map和Set</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Map</span></span><br><span class="line"><span class="comment">//初始化map需要一个二维数组，或者可以初始化为空</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'Michael'</span>, <span class="number">95</span>], [<span class="string">'Bob'</span>, <span class="number">75</span>], [<span class="string">'Tracy'</span>, <span class="number">85</span>]]);</span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>(); <span class="comment">// 空Map</span></span><br><span class="line">m.set(<span class="string">'Adam'</span>, <span class="number">67</span>);<span class="comment">//通过set方法添加键值对</span></span><br><span class="line">m.get(<span class="string">'Adam'</span>);<span class="comment">//通过get方法取得键对应的值</span></span><br><span class="line">m.has(<span class="string">'Adam'</span>); <span class="comment">//通过has方法检查是否存在键 布尔型</span></span><br><span class="line">m.delete(<span class="string">'Adam'</span>); <span class="comment">//通过delete方法删除键值对</span></span><br><span class="line"><span class="comment">//由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉</span></span><br><span class="line"><span class="comment">//Set</span></span><br><span class="line"><span class="comment">//要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set</span></span><br><span class="line"><span class="comment">//重复元素在Set中自动被过滤</span></span><br><span class="line"><span class="comment">//通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果；通过delete(key)方法可以删除元素</span></span><br></pre></td></tr></table></figure><p><em>time:2020/04/18</em></p><p>iterable</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//for..of..迭代器循环</span></span><br><span class="line"><span class="comment">//可用来遍历array的所有元素</span></span><br><span class="line"><span class="comment">//forEach()方法</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]);</span><br><span class="line">s.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">element, sameElement, set</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(element);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">'x'</span>], [<span class="number">2</span>, <span class="string">'y'</span>], [<span class="number">3</span>, <span class="string">'z'</span>]]);</span><br><span class="line">m.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">value, key, map</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//需要提供回调函数function，对每个元素都执行一遍function</span></span><br></pre></td></tr></table></figure><p>函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//javascrpit中函数也可以看作对象，函数名可以认为是指向该函数的变量</span></span><br><span class="line"><span class="keyword">var</span> abs = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//允许传入多个参数，没有定义的参数传入也不会改变什么，传入的参数少也是可以的</span></span><br><span class="line"><span class="comment">//没有参数传入，函数内部的参数接收到的就是undefined，可以在函数内部进行检查以避免</span></span><br><span class="line"><span class="comment">//javascript函数中存在默认参数arguments，里面存放了所有参数，为Array类型</span></span><br><span class="line"><span class="comment">//而且就算函数不定义参数，如果传入了参数，也可以通过arguments拿到参数值</span></span><br><span class="line"><span class="comment">//还可以利用arguments拿到传入参数的个数</span></span><br><span class="line"><span class="comment">//rest参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b, ...rest</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a = '</span> + a);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'b = '</span> + b);</span><br><span class="line">    <span class="built_in">console</span>.log(rest);</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 结果:</span></span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 2</span></span><br><span class="line"><span class="comment">// Array [ 3, 4, 5 ]</span></span><br><span class="line"><span class="comment">//如果没有多余的参数，rest就会接受一个空数组</span></span><br></pre></td></tr></table></figure><p>变量作用域与解构赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//变量提升</span></span><br><span class="line"><span class="comment">//javascript的函数中会自动把变量的声明提到函数顶部，但不会把赋值提前进行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="string">'Hello, '</span> + y;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">    <span class="keyword">var</span> y = <span class="string">'Bob'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不会报错，但是打印的y是undefined</span></span><br><span class="line"><span class="comment">//由于JavaScript的这一怪异的“特性”，我们在函数内部定义变量时，请严格遵守“在函数内部首先申明所有变量”这一规则。</span></span><br><span class="line"><span class="comment">//最常见的做法是用一个var申明函数内部用到的所有变量</span></span><br><span class="line"><span class="comment">//不在任何函数内定义的变量就具有全局作用域。</span></span><br><span class="line"><span class="comment">//实际上，JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性</span></span><br><span class="line"><span class="comment">//可以通过window.变量进行访问该变量</span></span><br><span class="line"><span class="comment">//某些函数也同样是全局的，可通过window进行访问</span></span><br><span class="line"><span class="comment">//局部作用域</span></span><br><span class="line"><span class="comment">//由于JavaScript的变量作用域实际上是函数内部，我们在for循环等语句块中是无法定义具有局部作用域的变量的</span></span><br><span class="line"><span class="comment">//为了解决块级作用域，ES6引入了新的关键字let，用let替代var可以申明一个块级作用域的变量</span></span><br><span class="line"><span class="comment">//ES6标准引入了新的关键字const来定义常量，const与let都具有块级作用域</span></span><br><span class="line"><span class="keyword">const</span> PI = <span class="number">3.14</span>;</span><br><span class="line"><span class="comment">//解构赋值</span></span><br><span class="line"><span class="comment">//从ES6开始，JavaScript引入了解构赋值，可以同时对一组变量进行赋值。</span></span><br><span class="line"><span class="keyword">var</span> [x, y, z] = [<span class="string">'hello'</span>, <span class="string">'JavaScript'</span>, <span class="string">'ES6'</span>];</span><br><span class="line"><span class="comment">//注意，对数组元素进行解构赋值时，多个变量要用[...]括起来。</span></span><br><span class="line"><span class="comment">//如果数组本身还有嵌套，也可以通过下面的形式进行解构赋值，注意嵌套层次和位置要保持一致：</span></span><br><span class="line"><span class="keyword">let</span> [x, [y, z]] = [<span class="string">'hello'</span>, [<span class="string">'JavaScript'</span>, <span class="string">'ES6'</span>]];</span><br><span class="line"><span class="comment">//解构赋值还可以忽略某些元素：</span></span><br><span class="line"><span class="keyword">let</span> [, , z] = [<span class="string">'hello'</span>, <span class="string">'JavaScript'</span>, <span class="string">'ES6'</span>]；</span><br><span class="line"><span class="comment">//如果需要从一个对象中取出若干属性，也可以使用解构赋值，便于快速获取对象的指定属性：</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    gender: <span class="string">'male'</span>,</span><br><span class="line">    passport: <span class="string">'G-12345678'</span>,</span><br><span class="line">    school: <span class="string">'No.4 middle school'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> &#123;name, age, passport&#125; = person;</span><br><span class="line"><span class="comment">//使用解构赋值对对象属性进行赋值时，如果对应的属性不存在，变量将被赋值为undefined</span></span><br><span class="line"><span class="comment">//如果要使用的变量名和属性名不一致，可以用下面的语法获取：</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    gender: <span class="string">'male'</span>,</span><br><span class="line">    passport: <span class="string">'G-12345678'</span>,</span><br><span class="line">    school: <span class="string">'No.4 middle school'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把passport属性赋值给变量id:</span></span><br><span class="line"><span class="keyword">let</span> &#123;name, <span class="attr">passport</span>:id&#125; = person</span><br><span class="line"><span class="comment">//解构赋值还可以使用默认值，这样就避免了不存在的属性返回undefined的问题：</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    gender: <span class="string">'male'</span>,</span><br><span class="line">    passport: <span class="string">'G-12345678'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果person对象没有single属性，默认赋值为true:</span></span><br><span class="line"><span class="keyword">var</span> &#123;name, single=<span class="literal">true</span>&#125; = person;</span><br><span class="line">name; <span class="comment">// '小明'</span></span><br><span class="line">single; <span class="comment">// true</span></span><br><span class="line"><span class="comment">//有些时候，如果变量已经被声明了，再次赋值的时候，正确的写法也会报语法错误：</span></span><br><span class="line"><span class="keyword">var</span> x, y;</span><br><span class="line"><span class="comment">// 解构赋值:</span></span><br><span class="line">&#123;x, y&#125; = &#123; <span class="attr">name</span>: <span class="string">'小明'</span>, <span class="attr">x</span>: <span class="number">100</span>, <span class="attr">y</span>: <span class="number">200</span>&#125;;</span><br><span class="line"><span class="comment">// 语法错误: Uncaught SyntaxError: Unexpected token =</span></span><br><span class="line"><span class="comment">//这是因为JavaScript引擎把&#123;开头的语句当作了块处理，于是=不再合法。解决方法是用小括号括起来：</span></span><br><span class="line">(&#123;x, y&#125; = &#123; <span class="attr">name</span>: <span class="string">'小明'</span>, <span class="attr">x</span>: <span class="number">100</span>, <span class="attr">y</span>: <span class="number">200</span>&#125;);</span><br><span class="line"><span class="comment">//解构赋值在很多时候可以大大简化代码。例如，交换两个变量x和y的值，可以这么写，不再需要临时变量：</span></span><br><span class="line"><span class="keyword">var</span> x=<span class="number">1</span>, y=<span class="number">2</span>;</span><br><span class="line">[x, y] = [y, x]</span><br><span class="line"><span class="comment">//如果一个函数接收一个对象作为参数，那么，可以使用解构直接把对象的属性绑定到变量中。例如，下面的函数可以快速创建一个Date对象：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildDate</span>(<span class="params">&#123;year, month, day, hour=<span class="number">0</span>, minute=<span class="number">0</span>, second=<span class="number">0</span>&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(year + <span class="string">'-'</span> + month + <span class="string">'-'</span> + day + <span class="string">' '</span> + hour + <span class="string">':'</span> + minute + <span class="string">':'</span> + second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//它的方便之处在于传入的对象只需要year、month和day这三个属性：</span></span><br><span class="line">buildDate(&#123; <span class="attr">year</span>:<span class="number">2017</span>, <span class="attr">month</span>:<span class="number">1</span>, <span class="attr">day</span>:<span class="number">1</span> &#125;);</span><br></pre></td></tr></table></figure><p>方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JavaScript的函数内部如果调用了this，那么这个this到底指向谁？</span></span><br><span class="line"><span class="comment">//如果是通过对象的形式进行调用，那么this指向的是调用的对象，是符合情理的</span></span><br><span class="line"><span class="comment">//如果单独调用函数，比如getAge()，此时，该函数的this指向全局对象，也就是window。</span></span><br><span class="line"><span class="comment">//要保证this指向正确，必须用obj.xxx()的形式调用！</span></span><br><span class="line"><span class="comment">//也可以先使用that捕获this，然后再使用</span></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    age: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>; <span class="comment">// 在方法内部一开始就捕获this</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getAgeFromBirth</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">            <span class="keyword">return</span> y - that.birth; <span class="comment">// 用that而不是this</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getAgeFromBirth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//这样就能避免出错了</span></span><br><span class="line"><span class="comment">//apply</span></span><br><span class="line"><span class="comment">//指定函数的this指向哪个对象，可以用函数本身的apply方法</span></span><br><span class="line"><span class="comment">//它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。</span></span><br><span class="line"><span class="comment">//使用apply来避免this的出错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">    <span class="keyword">return</span> y - <span class="keyword">this</span>.birth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    age: getAge</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.age(); <span class="comment">// 25</span></span><br><span class="line">getAge.apply(xiaoming, []); <span class="comment">// 25, this指向xiaoming, 参数为空</span></span><br><span class="line"><span class="comment">//另一个与apply()类似的方法是call()，唯一区别是：</span></span><br><span class="line"><span class="comment">//apply()把参数打包成Array再传入；</span></span><br><span class="line"><span class="comment">//call()把参数按顺序传入。</span></span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>]); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">Math</span>.max.call(<span class="literal">null</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>); <span class="comment">// 5</span></span><br><span class="line"><span class="comment">//对普通函数调用，我们通常把this绑定为null</span></span><br><span class="line"><span class="comment">//装饰器</span></span><br><span class="line"><span class="comment">//利用apply()，我们还可以动态改变函数的行为。</span></span><br><span class="line"><span class="comment">//现在假定我们想统计一下代码一共调用了多少次parseInt()，</span></span><br><span class="line"><span class="comment">//可以把所有的调用都找出来，然后手动加上count += 1，</span></span><br><span class="line"><span class="comment">//不过这样做太傻了。最佳方案是用我们自己的函数替换掉默认的parseInt()</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> oldParseInt = <span class="built_in">parseInt</span>; <span class="comment">// 保存原函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.parseInt = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> oldParseInt.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>); <span class="comment">// 调用原函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 闭包</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Array的map()方法</span></span><br><span class="line"><span class="comment">//传入参数为函数对象，作用为将此函数作用于数组的所有元素</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">var</span> results = arr.map(pow); <span class="comment">// [1, 4, 9, 16, 25, 36, 49, 64, 81]</span></span><br><span class="line"><span class="comment">//reduce()方法</span></span><br><span class="line"><span class="comment">//Array的reduce()把一个函数作用在这个Array的[x1, x2, x3...]上</span></span><br><span class="line"><span class="comment">//这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算，其效果就是：</span></span><br><span class="line">[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4);</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>];</span><br><span class="line">arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">10</span> + y;</span><br><span class="line">&#125;); <span class="comment">// 13579,reduce的一些好用的地方</span></span><br><span class="line"><span class="comment">//可以省略function，进而变成arr.map(x=&gt;10*x)或者arr.reduce((x,y)=&gt;10*x+y)</span></span><br></pre></td></tr></table></figure><p>箭头函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用箭头函数来省略function</span></span><br><span class="line">x=&gt;x*x;</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;<span class="keyword">return</span> x*x;&#125;;<span class="comment">//两者等价</span></span><br><span class="line"><span class="comment">//箭头函数相当于匿名函数</span></span><br><span class="line"><span class="comment">//如果函数只用return一个表达式，则可以全部省略</span></span><br><span class="line"><span class="comment">//如果函数体里包含了一些其他结构，则不能省略return</span></span><br><span class="line">x =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>) <span class="keyword">return</span> x * x;</span><br><span class="line">    <span class="keyword">else</span>  <span class="keyword">return</span> - x * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果存在多个参数需要用括号括起来</span></span><br><span class="line">(x, y) =&gt; x * x + y * y</span><br><span class="line">() =&gt; <span class="number">3.14</span></span><br><span class="line"><span class="comment">// 可变参数:</span></span><br><span class="line">(x, y, ...rest) =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> i, sum = x + y;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;rest.length; i++) &#123;</span><br><span class="line">        sum += rest[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在返回对象的时候需要用小括号括起来，因为&#123;&#125;会导致歧义</span></span><br><span class="line">x=&gt;(&#123;<span class="attr">foo</span> : x&#125;);</span><br><span class="line"><span class="comment">//使用箭头函数也不用担心this的错用，箭头函数会保证this指向外部作用域</span></span><br><span class="line"><span class="comment">//this在箭头函数中已经词法绑定了</span></span><br><span class="line"><span class="comment">//用call()或者apply()调用箭头函数时，无法对this进行绑定，即传入的第一个参数被忽略</span></span><br><span class="line">arr.sort(<span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x-y;</span><br><span class="line">&#125;);<span class="comment">//简化sort写法</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 10, 20]</span></span><br></pre></td></tr></table></figure><p>generator</p>]]></content>
      
      
      <categories>
          
          <category> 学习篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML学习</title>
      <link href="/2021/04/01/HTML%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/04/01/HTML%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>时隔几个月，终于又开始写博客了，原因呢，大学太颓废，还是得找点事给自己干，所以从现在开始学习前端开发，最开始，当然，从HTML开始，虽然之前也学过一些，但是总结的东西都不多，所以这次就当是正式开始系统的学习前端知识了，我的一个思路呢就是HTML-&gt;CSS-&gt;JS，先把这三大基础整透，再说后面的内容。写博客的目的呢，一是监督自己学习，二呢就是方便自己在学习的时候做好相关的笔记记录，这样也能给予自己前进的动力了，好了废话就说这么多，开始这一系列第一篇博客的更新了。</p><p><em>time：2020/04/07</em></p><a id="more"></a><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p>在开始这篇博客前已经完成了一些准备工作如下：</p><p>vscode安装、webstorm安装、sublime安装，虽然这三个IDE都比较推荐，但我还是全都安装下来了，在使用过程中再来取舍。</p><h4 id="HTML基础"><a href="#HTML基础" class="headerlink" title="HTML基础"></a>HTML基础</h4><p>用 style 属性代替旧的一些标签以及属性，如<code>&lt;font&gt;,&lt;basefont&gt;,&lt;s&gt;,&lt;u&gt;,alion,color,bgcolor</code>等等。将其变成以下样式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span> = <span class="string">"background-color:red"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span> = <span class="string">"color:red"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span> = <span class="string">"font-family:verdana"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"text-align:center"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>文本格式化标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--粗体--&gt;</span> <span class="tag">&lt;<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--着重文字--&gt;</span> <span class="tag">&lt;<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--斜体--&gt;</span> <span class="tag">&lt;<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--加重语气,和加粗差不多--&gt;</span> <span class="tag">&lt;<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--插入字,即下划线--&gt;</span> <span class="tag">&lt;<span class="name">ins</span>&gt;</span><span class="tag">&lt;/<span class="name">ins</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--删除字--&gt;</span> <span class="tag">&lt;<span class="name">del</span>&gt;</span><span class="tag">&lt;/<span class="name">del</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--大号和小号--&gt;</span> <span class="tag">&lt;<span class="name">big</span>&gt;</span><span class="tag">&lt;/<span class="name">big</span>&gt;</span> <span class="tag">&lt;<span class="name">small</span>&gt;</span><span class="tag">&lt;/<span class="name">small</span>&gt;</span></span><br></pre></td></tr></table></figure><p>计算机输出标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--代码--&gt;</span> <span class="tag">&lt;<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">code</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--键盘码--&gt;</span> <span class="tag">&lt;<span class="name">kbd</span>&gt;</span><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--计算机代码样本--&gt;</span> <span class="tag">&lt;<span class="name">sample</span>&gt;</span><span class="tag">&lt;/<span class="name">sample</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--打印机代码--&gt;</span> <span class="tag">&lt;<span class="name">tt</span>&gt;</span><span class="tag">&lt;/<span class="name">tt</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--变量，用于定义--&gt;</span> <span class="tag">&lt;<span class="name">var</span>&gt;</span><span class="tag">&lt;/<span class="name">var</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--预格式文本,在code内包围代码可实现保留空格回车--&gt;</span> <span class="tag">&lt;<span class="name">pre</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure><p>引用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--短的引用--&gt;</span> <span class="tag">&lt;<span class="name">q</span>&gt;</span><span class="tag">&lt;/<span class="name">q</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--长引用，并会进行缩进处理--&gt;</span> <span class="tag">&lt;<span class="name">blockquote</span>&gt;</span><span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--定义缩写，为浏览器提供帮助--&gt;</span> <span class="tag">&lt;<span class="name">abbr</span>&gt;</span><span class="tag">&lt;/<span class="name">abbr</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--定义缩写的意义，鼠标放置即可查看--&gt;</span> <span class="tag">&lt;<span class="name">dfn</span>&gt;</span><span class="tag">&lt;/<span class="name">dfn</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--定义文档或者文章的联系信息--&gt;</span> <span class="tag">&lt;<span class="name">address</span>&gt;</span><span class="tag">&lt;/<span class="name">address</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--定义著作的标题--&gt;</span> <span class="tag">&lt;<span class="name">cite</span>&gt;</span><span class="tag">&lt;/<span class="name">cite</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--双向书写，可以从左边开始--&gt;</span> <span class="tag">&lt;<span class="name">bdo</span>&gt;</span><span class="tag">&lt;/<span class="name">bdo</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><p><em>time：2020/04/08</em></p><p>外部样式表</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"mystyle.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>内部样式表</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-tag">body</span> &#123;<span class="attribute">background-color</span>: red&#125;</span></span><br><span class="line"><span class="css"><span class="selector-tag">p</span> &#123;<span class="attribute">margin-left</span>: <span class="number">20px</span>&#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>内联样式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color: red; margin-left: 20px"</span>&gt;</span></span><br><span class="line">This is a paragraph</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><p>链接</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"url"</span>&gt;</span>Link text<span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="comment">&lt;!--链接不一定是网页，也可以是图片等等--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"url"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="comment">&lt;!--使链接在新窗口打开--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">"xxx"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="comment">&lt;!--定义锚点--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#xxx"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="comment">&lt;!--本文档其他位置可以创建访问锚点的链接,适用于pdf--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://....#xxx"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="comment">&lt;!--其他界面创建访问该锚点的链接--&gt;</span></span><br></pre></td></tr></table></figure><p>图片</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--alt在图片未加载的时候显示，无闭合标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">alt</span>=<span class="string">"loading..."</span> <span class="attr">alion</span>=<span class="string">"left"</span> <span class="attr">width</span>=<span class="string">""</span> <span class="attr">height</span>=<span class="string">""</span>/&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--还可用&lt;a&gt;包裹图片制作图片链接--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--还可利用&lt;map&gt;,&lt;area&gt;来定义图像地图--&gt;</span></span><br></pre></td></tr></table></figure><p><em>time：2020/04/09</em></p><p>表格</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span> <span class="attr">cellpadding</span>=<span class="string">"10"</span> <span class="attr">cellspacing</span>=<span class="string">"10"</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--border表示表格边框的厚度 cellpadding表示边界与单元内容之间的距离 cellspacing规定单元格之间的距离--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">caption</span>&gt;</span>我的标题<span class="tag">&lt;/<span class="name">caption</span>&gt;</span> <span class="comment">&lt;!--表格标题--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span> <span class="attr">rowspan</span>=<span class="string">"2"</span>&gt;</span>Heading<span class="tag">&lt;/<span class="name">th</span>&gt;</span> <span class="comment">&lt;!--表头 加粗居中 横跨两行--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span> <span class="attr">colspan</span>=<span class="string">"2"</span>&gt;</span>Another Heading<span class="tag">&lt;/<span class="name">th</span>&gt;</span> <span class="comment">&lt;!--横跨两列--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>row 1, cell 1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>row 1, cell 2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>&amp;nbsp;<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="comment">&lt;!--避免空单元格，会使边框无法显示，使用空格占位--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>row 2, cell 2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--表格中每个单元格都可设置颜色、背景、对齐方式、frame属性等等--&gt;</span></span><br></pre></td></tr></table></figure><p>列表</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--无序列表 type代表小圆点的类型--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">type</span>=<span class="string">"disc"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>咖啡<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>茶<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>牛奶<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--有序列表 start设置开始序号 type代表序号的类型--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">start</span>=<span class="string">"50"</span> <span class="attr">type</span>=<span class="string">"I"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>咖啡<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>牛奶<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>茶<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--列表都可以嵌套使用--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--自定义列表 dt标题 dd内容--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dt</span>&gt;</span>计算机<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dd</span>&gt;</span>用来计算的仪器 ... ...<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dt</span>&gt;</span>显示器<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dd</span>&gt;</span>以视觉方式显示信息的装置 ... ...<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><p>块</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--块元素和内联元素区别就是 块元素会以新行来开始 而内联元素则不会--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--块级：&lt;h1&gt;, &lt;p&gt;, &lt;ul&gt;, &lt;table&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--内联级：&lt;b&gt;, &lt;td&gt;, &lt;a&gt;, &lt;img&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;div&gt;块级元素 和CSS一起使用对大块地方进行样式设计--&gt;</span> <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;span&gt;内联级元素 和CSS一起使用对文本进行样式设计--&gt;</span> <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>类</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--对 HTML 进行分类（设置类），使我们能够为元素的类定义 CSS 样式。</span></span><br><span class="line"><span class="comment">为相同的类设置相同的样式，或者为不同的类设置不同的样式。--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.cities</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background-color</span><span class="selector-pseudo">:black</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">color</span><span class="selector-pseudo">:white</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">margin</span><span class="selector-pseudo">:20px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">padding</span><span class="selector-pseudo">:20px</span>;</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"cities"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>London<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">London is the capital city of England. </span><br><span class="line">It is the most populous city in the United Kingdom, </span><br><span class="line">with a metropolitan area of over 13 million inhabitants.</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>布局</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--&lt;div&gt; 元素常用作布局工具，因为能够轻松地通过 CSS 对其进行定位。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--DIV的ID属性和CLASS属性的区别--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--id对应css是用样式选择符“#”（井号）class对应css是用样式选择符“.”(英文半角输入句号)--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--id属性，只能被一个元素调用（以“#”选择符命名CSS样式在一个页面只能使用调用一次）</span></span><br><span class="line"><span class="comment">class类标记，可以用于被多个元素调用(以“.”选择符命名样式可以一个页面使用多次)--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--一个代表身份证，一个代表衣服,下方是实例--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-id">#header</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background-color</span><span class="selector-pseudo">:black</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">color</span><span class="selector-pseudo">:white</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">text-align</span><span class="selector-pseudo">:center</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">padding</span><span class="selector-pseudo">:5px</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-id">#nav</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">line-height</span><span class="selector-pseudo">:30px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background-color</span>:<span class="selector-id">#eeeeee</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">height</span><span class="selector-pseudo">:300px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">width</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">float</span><span class="selector-pseudo">:left</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">padding</span><span class="selector-pseudo">:5px</span>;      </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-id">#section</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">width</span><span class="selector-pseudo">:350px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">float</span><span class="selector-pseudo">:left</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">padding</span><span class="selector-pseudo">:10px</span>;  </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-id">#footer</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background-color</span><span class="selector-pseudo">:black</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">color</span><span class="selector-pseudo">:white</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">clear</span><span class="selector-pseudo">:both</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">text-align</span><span class="selector-pseudo">:center</span>;</span></span><br><span class="line"><span class="css">   <span class="selector-tag">padding</span><span class="selector-pseudo">:5px</span>;  </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"header"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>City Gallery<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"nav"</span>&gt;</span></span><br><span class="line">London<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">Paris<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">Tokyo<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"section"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>London<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">London is the capital city of England. It is the most populous city in the United Kingdom,</span><br><span class="line">with a metropolitan area of over 13 million inhabitants.</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">Standing on the River Thames, London has been a major settlement for two millennia,</span><br><span class="line">its history going back to its founding by the Romans, who named it Londinium.</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"footer"</span>&gt;</span></span><br><span class="line">Copyright ? W3Schools.com</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><em>time:2020/04/10</em></p><p>框架</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--框架结构标签&lt;frameset&gt;,rows和cols的值规定了每个框架所占的面积--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--框架标签&lt;frame&gt;,每个frame中设置一个html文档--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--假如一个框架有可见边框，用户可以拖动边框来改变它的大小。为了避免这种情况发生，可以在 &lt;frame&gt; 标签中加入：noresize="noresize"。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--重要提示：不能将 &lt;body&gt;&lt;/body&gt; 标签与 &lt;frameset&gt;&lt;/frameset&gt; 标签同时使用！不过，假如你添加包含一段文本的 &lt;noframes&gt; 标签，就必须将这段文字嵌套于 &lt;body&gt;&lt;/body&gt; 标签内。（在下面的第一个实例中，可以查看它是如何实现的。）--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--这里都是简要介绍，具体的应用现在还无法完全掌握--&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面经整理</title>
      <link href="/2021/03/31/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"/>
      <url>/2021/03/31/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Java面经整理"><a href="#Java面经整理" class="headerlink" title="Java面经整理"></a>Java面经整理</h1><a id="more"></a><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>几种常见的数据结构</p><blockquote><p>树、图、链表、优先队列(堆)、跳表(链表+多级索引)</p><p>跳表(redis的zset使用跳表)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;跳表的查询的时间复杂度为 O(logn)，因为找到位置之后插入和删除的时间复杂度很低，为 O(1)，所以最终插入和删除的时间复杂度也为 O(logn)</span><br><span class="line">&gt;删除操作:</span><br><span class="line">* 如果这个结点在索引中也有出现，我们除了要删除原始链表中的结点，还要删除索引中的。</span><br><span class="line">* 同时我们删除节点时需要获得前驱节点(双向链表除外)</span><br><span class="line">&gt;插入操作</span><br><span class="line">* 插入元素过多，可能导致两个索引间节点过多，效率降低。我们需要维护索引与原始链表的大小平衡。。</span><br><span class="line">* 跳表是通过一个随机函数来维护这个平衡的，当我们向跳表中插入数据时，我们可以选择同时把这个数据插入到索引里，那我们插入到哪一级的索引呢，这就需要随机函数，来决定我们插入到哪一级的索引中。这样可以很有效的防止跳表退化，而造成效率变低。</span><br></pre></td></tr></table></figure><p>优先队列实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 清楚大顶堆、小顶堆定义</span></span><br><span class="line">&gt;<span class="comment">// Java PriorityQueue 通过数组实现</span></span><br><span class="line">&gt;<span class="comment">// 插入元素 从末尾开始找</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123; <span class="comment">// k代表当前元素个数、x为需要插入的元素</span></span><br><span class="line">  Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;) x;</span><br><span class="line">  <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 找到父节点下标</span></span><br><span class="line">      <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">      Object e = queue[parent];</span><br><span class="line">      <span class="comment">// 如果是小顶堆 则判断 x &gt;= queue[parent] 如果符合说明找到了需要插入的位置 break</span></span><br><span class="line">      <span class="comment">// 进行插入该节点，并将该parent节点放入index为k的位置</span></span><br><span class="line">      <span class="keyword">if</span> (key.compareTo((E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// 否则 将该节点下降 并令k为parent继续循环</span></span><br><span class="line">      queue[k] = e;</span><br><span class="line">      k = parent;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 插入到找到的位置</span></span><br><span class="line">  queue[k] = key;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// poll方法 移除最小元素</span></span><br><span class="line">&gt;<span class="comment">// 传入index为size的元素 此时根节点为空 k从0开始</span></span><br><span class="line">&gt;<span class="comment">// 即index为k的元素被取走后，拿出数组最后的元素x 不断寻找位置进行插入 如果不满足 会将空节点的子节点放入空节点 然后对其子节点进行继续操作直到找到能插入的位置或者循环结束</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123; <span class="comment">// x为堆中最后的元素</span></span><br><span class="line">  Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;)x;</span><br><span class="line">  <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;        <span class="comment">// loop while a non-leaf</span></span><br><span class="line">  <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">      <span class="comment">// x 从根节点开始 每次和 index为2k+1和2k+2中更小的元素进行比较</span></span><br><span class="line">      <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// assume left child is least</span></span><br><span class="line">      Object c = queue[child];</span><br><span class="line">      <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">          ((Comparable&lt;? <span class="keyword">super</span> E&gt;) c).compareTo((E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">          <span class="comment">// 小顶堆：c为2k+1和2k+2中较小的一个 也就是k对应节点的左右节点中小的那个</span></span><br><span class="line">          c = queue[child = right];</span><br><span class="line">      <span class="comment">// 小顶堆：如果x比较c大，我们就和c交换位置 否则我们的数就应该在k位置上，k从0开始。</span></span><br><span class="line">      <span class="keyword">if</span> (key.compareTo((E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// 交换位置</span></span><br><span class="line">      queue[k] = c;</span><br><span class="line">      k = child;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 找到了位置</span></span><br><span class="line">  queue[k] = key;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// remove方法 移除指定元素</span></span><br><span class="line">&gt;<span class="function">E <span class="title">removeAt</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="comment">// i为指定元素的index 是通过循环遍历得到的</span></span><br><span class="line">  <span class="comment">// assert i &gt;= 0 &amp;&amp; i &lt; size;</span></span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="keyword">int</span> s = --size; <span class="comment">// s为最后一个元素的下标</span></span><br><span class="line">  <span class="keyword">if</span> (s == i) <span class="comment">// removed last element</span></span><br><span class="line">      queue[i] = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 将s对应的节点也就是最后一个节点拿到 需要进行树的修复</span></span><br><span class="line">      E moved = (E) queue[s];</span><br><span class="line">      <span class="comment">// 将其置为null</span></span><br><span class="line">      queue[s] = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// 以queue[i]为根节点的树(堆) 进行树的修复</span></span><br><span class="line">      <span class="comment">// 小顶堆：将moved元素作为上文的x元素 和上文的poll方法类似 </span></span><br><span class="line">      <span class="comment">// 只是此处不是k=0开始，而是k=i开始 因为移除的是index=i的元素</span></span><br><span class="line">      siftDown(i, moved);</span><br><span class="line">      <span class="comment">// 此时以queue[i]为根节点的树(堆)已经修复完成了</span></span><br><span class="line">      <span class="keyword">if</span> (queue[i] == moved) &#123;</span><br><span class="line">          <span class="comment">// 如果moved在i位置上 说明moved元素较小 还可以继续向上调整</span></span><br><span class="line">          siftUp(i, moved); <span class="comment">// 向上调整 ？？？？</span></span><br><span class="line">          <span class="keyword">if</span> (queue[i] != moved)</span><br><span class="line">              <span class="keyword">return</span> moved;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><p>判断链表是否存在环</p><blockquote><p>快慢指针判断是否重合（如果需要找到入环点，在第一次相遇后一指针指向头部，然都保持慢指针速度继续前进，再次相遇的地方即为入环点）</p></blockquote><p>二叉搜索树、平衡二叉树、红黑树</p><blockquote><p>搜索二叉树：左节点 &lt; 根节点 &lt; 右节点，且左子树所有节点 &lt; 根节点 &lt; 右子树所有节点</p><p>平衡二叉树：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。对于插入节点和删除节点，如果破坏了平衡，那么都需要进行旋转以重新平衡。AVL树的查找、插入、删除操作在平均和最坏的情况下都是O（logn），代码可参考下方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 只会存在4种旋转方式：左旋、右旋、先左再右、先右再左。</span></span><br><span class="line">&gt;<span class="comment">// 递归进行判断即可</span></span><br><span class="line">&gt;<span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">&gt;<span class="keyword">int</span> val;</span><br><span class="line">&gt;Node left, right;</span><br><span class="line"><span class="comment">// 构造方法...</span></span><br><span class="line">&gt;<span class="comment">/* 左旋，右旋省略 */</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Node newNode = <span class="keyword">new</span> Node(<span class="keyword">this</span>.val);</span><br><span class="line">  newNode.left = <span class="keyword">this</span>.left;</span><br><span class="line">  newNode.right = <span class="keyword">this</span>.right.left;</span><br><span class="line">  <span class="keyword">this</span>.val = <span class="keyword">this</span>.right.val;</span><br><span class="line">  <span class="keyword">this</span>.left = newNode;</span><br><span class="line">  <span class="keyword">this</span>.right = <span class="keyword">this</span>.right.right;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">/* 添加节点 */</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 首先进行节点添加</span></span><br><span class="line">  <span class="keyword">if</span> (node.val &lt; <span class="keyword">this</span>.lval) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) <span class="keyword">this</span>.left = node;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">this</span>.left.add(node);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.val &gt; <span class="keyword">this</span>.lval) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) <span class="keyword">this</span>.right = node;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">this</span>.right.add(node);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// 判断是否需要旋转</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.getLeftHeight() - <span class="keyword">this</span>.getRightHeight() &gt; <span class="number">1</span>) &#123; <span class="comment">// 获得子树高度的get方法 略</span></span><br><span class="line">      <span class="comment">// 需要右旋 但需要先判断左子树是否需要先左旋</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.getLeftHeight() &lt; <span class="keyword">this</span>.left.getRightHeight()) &#123;</span><br><span class="line">          <span class="keyword">this</span>.left.leftRotate();</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">this</span>.rightRotate();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 左旋同理...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 删除节点</span></span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">  1、查找到对应节点</span></span><br><span class="line"><span class="comment">  2、判断该节点是否为叶节点，如果为叶节点，则直接删除</span></span><br><span class="line"><span class="comment">  如果不是叶节点，则判断该节点是否存在左右子树</span></span><br><span class="line"><span class="comment">  如果只有左子树 则获得左子树的最大值leftMax 并将需要删除的节点的值置为leftMax 然后递归删除左子树中的该节点</span></span><br><span class="line"><span class="comment">  如果只有右子树 则获得右子树的最小值rigthMin 并将需要删除的节点的值置为rigthMin 然后递归删除右子树中的该节点</span></span><br><span class="line"><span class="comment">  如果左右子树均存在，也一样获得右子树的最小值rigthMin 并将需要删除的节点的值置为rigthMin 然后递归删除右子树中的该节点</span></span><br><span class="line"><span class="comment">  3、删除完成后 判断是否平衡 即和上面add方法的后半部分类似 然后进行旋转平衡接即可</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>==红黑树==：</p><ol><li><strong>任何一个节点都有颜色，黑色或者红色</strong></li><li><strong>根节点是黑色的</strong></li><li><strong>空节点被认为是黑色的</strong>(即NIL结点)</li><li><strong>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</strong></li><li><strong>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</strong>(这也叫做完美黑色平衡，与2-3树的完美平衡有些不同)</li></ol><p><strong>只有黑色节点的红黑树其实就是平衡二叉树</strong>。我们将<strong>红色点想成是填充节点</strong>。即每次插入都以红色插入，且将<strong>黑色想成主要节点</strong>。红色节点做填充。红色节点的作用就是使得树的高度更加灵活，不至于像平衡二叉树那样每次插入都需要 做平衡操作（减少了需要平衡的概率）。<strong>（红色节点的子节点是黑色节点）</strong>条件就使得高度受到限制，极限情况就是一个红色一个黑色串联。最多的查找次数 不会超过2倍的 最少的查找数。</p><p>红黑树其实就是 二叉查找树和平衡二叉树 两者优缺点的一种折中。可以防止出现二叉查找树那种极差的情况，也可以减少插入时平衡的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 旋转操作和平衡树保持一致</span></span><br><span class="line">&gt;<span class="comment">/* </span></span><br><span class="line"><span class="comment">&gt;插入操作有三种情况是不会破坏性质的 且插入的节点一定是红色</span></span><br><span class="line"><span class="comment">  1、插入节点作为根节点</span></span><br><span class="line"><span class="comment">  2、插入节点作为根节点的子节点</span></span><br><span class="line"><span class="comment">  3、插入节点的父结点是黑色的</span></span><br><span class="line"><span class="comment">&gt;如果会破坏性质 则说明不满足以上情况 也就是说明 新节点必定存在祖父节点、新节点父节点为红色</span></span><br><span class="line"><span class="comment">1、叔节点为红色——重绘，父节点和叔节点绘制为黑色，祖父节点绘制为红色</span></span><br><span class="line"><span class="comment">2、叔节点为黑色，祖-父-子节点在同侧——将父绘黑，祖绘红，然后以祖为枢纽进行向相反侧的方向旋转</span></span><br><span class="line"><span class="comment">3、叔节点为黑色，祖-父-子节点不在同侧——先根据子父所在的那一侧的方向，以父为枢向相反方向旋转，这样就实现了将子父祖异侧转换为了父子祖同侧，第二步是发现它符合上一种情况了，那就将现在的父(原来的子)绘黑，祖(原来的祖)绘红，然后再次旋转。</span></span><br><span class="line"><span class="comment">&gt;注意：需要修复时，还需要递归进行，即在一次修复后将指针指向此次操作的祖父节点 然后继续判断是否需要修复</span></span><br><span class="line"><span class="comment">&gt;最后仍然需要将根节点绘制为红色。</span></span><br><span class="line"><span class="comment">&gt;*/</span></span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2021/03/10/O3Kf8HcTyFd69kz.png" alt="红黑树remove.png" style="zoom: 33%;"></blockquote><p>线段树、树状数组</p><blockquote><p>树状数组是一种特殊的线段树</p></blockquote><p>B树、B+树</p><blockquote><p>每个节点不止一个数据</p><p>B树：每个节点上都存了key-data</p><p>B+树：只有叶子节点存了data，其他节点可存更多key，且所有叶子节点之间存在顺序指针关系。</p></blockquote><h2 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h2><p>开机过程</p><blockquote><p>BIOS自检-&gt;加载bootloader到内存-&gt;bootloader加载OS到内存-&gt;从OS起始位置开始执行指令</p><p>BIOS位于RAM；bootstrap位于磁盘第一个主引导扇区；OS位于磁盘</p><p>以x86为例，bootloader一般会被加载到于内存0x7c00处</p></blockquote><p>内存管理</p><blockquote><p>段页式存储、虚拟内存、系统抖动。</p></blockquote><p>进程和线程区别，什么是协程</p><blockquote><p>进程是资源分配的基本单位。线程是CPU调度的基本单位。一个进程中可包含多个线程。</p><p>协程是轻量级的用户线程，一个线程可包含多个协程，只在用户态运行，开销小。</p></blockquote><p>进程调度的方式(CFS?)</p><blockquote><p><em>Linux*的调度器类主要实现两类进程调度算法：实时调度算法和完全公平调度算法</em>(CFS)*，实时调度算法SCHED_FIFO和SCHED_RR，按优先级执行，一般不会被抢占。直到实时进程执行完，才会执行普通进程。而大多数的普通进程，用的就是CFS算法。</p><p>CFS 调度程序并不采用严格规则来为一个优先级分配某个长度的时间片，而是为每个任务分配一定比例的 CPU 处理时间。每个任务分配的具体比例是根据友好值来计算的。友好值的范围从 -20 到 +19，数值较低的友好值表示较高的相对优先级。具有较低友好值的任务，与具有较高友好值的任务相比，会得到更高比例的处理器处理时间。默认友好值为 0。</p><blockquote><p>友好一词源自如下想法：当一个任务增加了它的友好值，如从 0 至 +10，该任务通过降低优先级，进而对其他任务更加友好。</p></blockquote><p>CFS 没有使用离散的时间片，而是采用目标延迟，这是每个可运行任务应当运行一次的时间间隔。根据目标延迟，按比例分配 CPU 时间。除了默认值和最小值外，随着系统内的活动任务数量超过了一定阈值，目标延迟可以增加。</p><p>CFS 调度程序没有直接分配优先级。相反，它通过每个任务的变量 vruntime 以便维护虚拟运行时间，进而记录每个任务运行多久。虚拟运行时间与基于任务优先级的衰减因子有关，更低优先级的任务比更高优先级的任务具有更高衰减速率。对于正常优先级的任务（友好值为 0），虚拟运行时间与实际物理运行时间是相同的。</p><p>因此，如果一个默认优先级的任务运行 200ms，则它的虚拟运行时间也为 200ms。然而，如果一个较低优先级的任务运行 200ms，则它的虚拟运行时间将大于 200ms。同样，如果一个更高优先级的任务运行 200ms，则它的虚拟运行时间将小于 200ms。当决定下步运行哪个任务时，调度程序只需选择具有最小虚拟运行时间的任务。此外，一个更高优先级的任务如成为可运行，就会抢占低优先级任务。</p><p>下面分析一下 CFS 调度程序是如何工作的。假设有两个任务，它们具有相同的友好值。一个任务是 I/O 密集型而另一个为 CPU 密集型。通常，I/O 密集型任务在运行很短时间后就会阻塞以便等待更多的 I/O；而 CPU 密集型任务只要有在处理器上运行的机会，就会用完它的时间片。</p><p>因此，I/O 密集型任务的虚拟运行时间最终将会小于 CPU 密集型任务的，从而使得 I/O 密集型任务具有更高的优先级。这时，如果 CPU 密集型任务在运行，而 I/O 密集型任务变得有资格可以运行（如该任务所等待的 I/O 已成为可用)，那么 I/O 密集型任务就会抢占 CPU 密集型任务。</p></blockquote><p>死锁</p><blockquote><p>两个线程互相持有对方所需要的资源，互相等待，谁也无法继续执行下去。</p><p>条件：互斥、持有并等待、不可抢占、循环等待</p><p>处理方法：死锁预防(破坏四个条件中的一个)、死锁避免(银行家)、死锁检测与消除</p></blockquote><p>进程、线程、协程的区别（详细）</p><blockquote><p>进程、线程，都是有内核进行调度，有 CPU 时间片的概念，进行 抢占式调度。</p><p>协程(用户级线程)完全由用户自己的程序进行调度（协作式调度），需要协程自己主动把控制权转让出去之后，其他协程才能被执行到。</p><p>协程，是在应用层模拟的线程，他避免了上下文切换的额外耗费，兼顾了多线程的优点。简化了高并发程序的复杂度。协程还是通过共享内存通讯.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;目前的协程框架一般都是设计成 1:N 模式。</span><br><span class="line">&gt;所谓 1:N 就是一个线程作为一个容器里面放置多个协程。</span><br><span class="line">&gt;那么谁来适时的切换这些协程？答案是有协程自己主动让出CPU，</span><br><span class="line">&gt;也就是每个协程池里面有一个调度器，这个调度器是被动调度的。</span><br><span class="line">&gt;意思就是他不会主动调度。</span><br><span class="line">&gt;而且当一个协程发现自己执行不下去了(比如异步等待网络的数据回来，但是当前还没有数据到)，</span><br><span class="line">&gt;这个时候就可以由这个协程通知调度器，</span><br><span class="line">&gt;这个时候执行到调度器的代码，调度器根据事先设计好的调度算法找到当前最需要CPU的协程。</span><br><span class="line">&gt;切换这个协程的CPU上下文把CPU的运行权交个这个协程，直到这个协程出现执行不下去需要等等的情况，</span><br><span class="line">&gt;或者它调用主动让出CPU的API之类，触发下一次调度。对的没错就是类似于 领导人模式那么这个实现有没有问题？</span><br><span class="line">&gt;其实是有问题的，假设这个线程中有一个协程是CPU密集型的他没有IO操作，也就是自己不会主动触发调度器调度的过程，</span><br><span class="line">&gt;那么就会出现其他协程得不到执行的情况，所以这种情况下需要程序员自己避免。</span><br></pre></td></tr></table></figure></blockquote><p>深拷贝、浅拷贝（java）</p><blockquote><p>浅拷贝：只是增加了一个指针指向原内存。</p><p>深拷贝：深拷贝是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存。</p></blockquote><p>写时复制</p><blockquote><p>系统调用 fork() 创建了父进程的一个复制，以作为子进程。传统上，fork() 为子进程创建一个父进程地址空间的副本，复制属于父进程的页面。然而，考虑到许多子进程在创建之后立即调用系统调用 exec()，父进程地址空间的复制可能没有必要。</p><p>因此，可以采用一种称为写时复制的技术，它通过允许父进程和子进程最初共享相同的页面来工作。这些共享页面标记为写时复制，这意味着如果任何一个进程写入共享页面，那么就创建共享页面的副本。</p><p>当使用写时复制技术时，仅复制任何一进程修改的页面，所有未修改的页面可以由父进程和子进程共享。</p><p>注意：采用 vfork()，父进程被挂起，子进程使用父进程的地址空间。因为 vfork() 不采用写时复制，如果子进程修改父地址空间的任何页面，那么这些修改过的页面对于恢复的父进程是可见的。因此，应谨慎使用 vfork()，以确保子进程不会修改父进程的地址空间。</p></blockquote><p>mmap内存映射</p><blockquote><p>内存映射，简而言之就是将用户空间的一段内存区域映射到内核空间，映射成功后，用户对这段内存区域的修改可以直接反映到内核空间，同样，内核空间对这段区域的修改也直接反映用户空间。那么对于内核空间&lt;—-&gt;用户空间两者之间需要大量数据传输等操作的话效率是非常高的。</p></blockquote><p>缓冲区溢出</p><blockquote><p>例如栈溢出导致返回值或者方法返回地址被修改，进而导致被攻击。</p></blockquote><p>为何需要用户态、内核态</p><blockquote><p>应用程序不能直接访问外设，需要内核在其中充当被信任的第三方，只有内核才能执行特权指令。同时也是方便应用程 序通过内核提供的接口来更方便编写操作外设的程序。即不用关注和外设具体打交道的细节，其应该由操作系统来完成。</p></blockquote><p>read ahead文件预读</p><blockquote><p>所谓预读，是指文件系统为应用程序一次读出比预期更多的文件内容并缓存在page cache中，这样下一次读请求到来时部分页面直接从page cache读取即可。当然，这个细节对应用程序透明，应用程序可能的感觉就是下次读的速度会更快</p></blockquote><p>x86是大端还是小端，为什么</p><blockquote><p>小端</p></blockquote><p>select、poll、epoll</p><blockquote><p>select：bitmap、遍历bitmap获取数据、bitmap不可重用</p><p>poll：结构体数组(三个字段存在状态位)、遍历判断状态位获取数据、结构体数组可重用</p><p>epoll：类似poll结构体(两个字段 不存在状态位)、由内核对其进行排序并返回数量，直接遍历数量即可获得socket</p></blockquote><p>管道底层实现</p><blockquote><p>无名管道：内存中实现(内核中的缓存)，如<kbd>|</kbd>，有名管道：磁盘实现，如<kbd>mkfifo</kbd>。只有父子进程之间可以通过匿名管道。</p><p>管道采用半双工通信，使用一个管道一般的规则是<strong>读管道数据的进程关闭管道写入端,而写管道进程关<br>闭其读出端</strong>。</p><p>管道传输的数据是无格式的且大小受限。</p><p>父子进程之间的匿名管道，因为子进程复制父进程创建的文件描述符，所以各自拥有两个fd[0]、fd[1]，这样就实现了进程间通信。</p></blockquote><p>系统调用的具体过程，如何实现</p><blockquote><p>应用程序主动向操作系统发起服务请求，应用程序请求操作系统提供服务，切换到内核态，内核态响应服务然后完成后返回。</p></blockquote><p>select、poll、epoll机制</p><blockquote><p>select采用轮询机制，耗时较大，且监听的socket有限(可以改变)</p><p>select和poll只支持LT工作模式，epoll的默认的工作模式是LT模式，还支持ET（边缘触发）模式。</p><p>水平触发：①对于读操作，只要缓冲内容不为空，LT模式返回读就绪。②对于写操作，只要缓冲区还不满，LT模式会返回写就绪。</p><p>边缘触发：在ET模式下， 缓冲区从不可读变成可读，会唤醒应用进程，缓冲区数据变少的情况，则不会再唤醒应用进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">举例1：</span><br><span class="line">读缓冲区刚开始是空的</span><br><span class="line">读缓冲区写入2KB数据</span><br><span class="line">水平触发和边缘触发模式此时都会发出可读信号</span><br><span class="line">收到信号通知后，读取了1KB的数据，读缓冲区还剩余1KB数据</span><br><span class="line">水平触发会再次进行通知，而边缘触发不会再进行通知</span><br><span class="line">举例2：（以脉冲的高低电平为例）</span><br><span class="line">水平触发：0为无数据，1为有数据。缓冲区有数据则一直为1，则一直触发。</span><br><span class="line">边缘触发发：0为无数据，1为有数据，只要在0变到1的上升沿才触发。</span><br></pre></td></tr></table></figure></blockquote><p>epoll红黑树</p><blockquote><p>epoll和poll的一个很大的区别在于，poll每次调用时都会存在一个将pollfd结构体数组中的每个结构体元素从用户态向内核态中的一个链表节点拷贝的过程，而内核中的这个链表并不会一直保存，当poll运行一次就会重新执行一次上述的拷贝过程，这说明一个问题：poll并不会在内核中为要监听的文件描述符长久的维护一个数据结构来存放他们，而epoll内核中维护了一个内核事件表，它是将所有的文件描述符全部都存放在内核中，系统去检测有事件发生的时候触发回调，当你要添加新的文件描述符的时候也是调用epoll_ctl函数使用EPOLL_CTL_ADD宏来插入，epoll_wait也不是每次调用时都会重新拷贝一遍所有的文件描述符到内核态。当我现在要在内核中长久的维护一个数据结构来存放文件描述符，并且时常会有插入，查找和删除的操作发生，这对内核的效率会产生不小的影响，因此需要一种插入，查找和删除效率都不错的数据结构来存放这些文件描述符，那么红黑树当然是不二的人选。</p></blockquote><p>epoll与select、poll的对比</p><blockquote><p><strong>1. 用户态将文件描述符传入内核的方式</strong></p><p>select：创建3个文件描述符集并拷贝到内核中，分别监听读、写、异常动作。这里受到单个进程可以打开的fd数量限制，默认是1024。poll：将传入的struct pollfd结构体数组拷贝到内核中进行监听。epoll：执行epoll_create会在内核的高速cache区中建立一颗红黑树以及就绪链表(该链表存储已经就绪的文件描述符)。接着用户执行的epoll_ctl函数添加文件描述符会在红黑树上增加相应的结点。</p><p><strong>2. 内核态检测文件描述符读写状态的方式</strong></p><p>select：采用轮询方式，遍历所有fd，最后返回一个描述符读写操作是否就绪的mask掩码，根据这个掩码给fd_set赋值。poll：同样采用轮询方式，查询每个fd的状态，如果就绪则在等待队列中加入一项并继续遍历。epoll：采用回调机制。在执行epoll_ctl的add操作时，不仅将文件描述符放到红黑树上，而且也注册了回调函数，内核在检测到某文件描述符可读/可写时会调用回调函数，该回调函数将文件描述符放在就绪链表中。</p><p><strong>3. 找到就绪的文件描述符并传递给用户态的方式</strong></p><p>select：将之前传入的fd_set拷贝传出到用户态并返回就绪的文件描述符总数。用户态并不知道是哪些文件描述符处于就绪态，需要遍历来判断。poll：将之前传入的fd数组拷贝传出用户态并返回就绪的文件描述符总数。用户态并不知道是哪些文件描述符处于就绪态，需要遍历来判断。epoll：epoll_wait只用观察就绪链表中有无数据即可，最后将链表的数据返回给数组并返回就绪的数量。内核将就绪的文件描述符放在传入的数组中，所以只用遍历依次处理即可。这里返回的文件描述符是通过mmap让内核和用户空间共享同一块内存实现传递的，减少了不必要的拷贝。</p><p><strong>4. 重复监听的处理方式</strong></p><p>select：将新的监听文件描述符集合拷贝传入内核中，继续以上步骤。poll：将新的struct pollfd结构体数组拷贝传入内核中，继续以上步骤。epoll：无需重新构建红黑树，直接沿用已存在的即可。</p><p><strong>epoll更高效的原因</strong></p><p>select和poll的动作基本一致，只是poll采用链表来进行文件描述符的存储，而select采用fd标注位来存放，所以select会受到最大连接数的限制，而poll不会。select、poll、epoll虽然都会返回就绪的文件描述符数量。但是select和poll并不会明确指出是哪些文件描述符就绪，而epoll会。造成的区别就是，系统调用返回后，调用select和poll的程序需要遍历监听的整个文件描述符找到是谁处于就绪，而epoll则直接处理即可。select、poll都需要将有关文件描述符的数据结构拷贝进内核，最后再拷贝出来。而epoll创建的有关文件描述符的数据结构本身就存于内核态中，系统调用返回时利用mmap()文件映射内存加速与内核空间的消息传递：即epoll使用mmap减少复制开销。select、poll采用轮询的方式来检查文件描述符是否处于就绪态，而epoll采用回调机制。造成的结果就是，随着fd的增加，select和poll的效率会线性降低，而epoll不会受到太大影响，除非活跃的socket很多。epoll的边缘触发模式效率高，系统不会充斥大量不关心的就绪文件描述符虽然epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</p></blockquote><h2 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h2><p>TCP</p><blockquote><p>特点：可靠、面向连接、点对点通信、全双工通信、拥塞控制、流量控制。（ARQ）</p><p>close_wait：防止被动关闭方仍然存在数据没有发送完。</p><p>time_wait为何等待两个MSL：①保证自己发送的ACK能够到达被动方，2MSL保证能够超时重传；②保证本次连接中产生的所有报文都已经在网络中消失，不会影响下一个连接。</p><p>time_wait太多：调整内核参数。即：①重用处于time_wait的socket；②快速回收处于time_wait的socket；③降低socket处于time_wait的时间④降低系统默认设置的time_wait的socket最大数量；⑤扩大可用于socket的端口范围</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_syncookies = 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭； --用于防御半连接攻击</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME_WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；</span><br><span class="line">net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME_WAIT sockets的快速回收，默认为0，表示关闭。</span><br><span class="line">net.ipv4.tcp_fin_timeout 修改系统默认的 TIMEOUT 时间</span><br></pre></td></tr></table></figure><p>流量控制：发送窗口不能大于接收窗口。</p><p>拥塞控制：慢开始(小于门限，指数增长)、拥塞避免(大于门限、线性增长)、快重传(收到三个重复确认时，直接重传丢失报文而非等待超时)、快恢复(门限值减半，拥塞窗口减半，直接开始拥塞避免)。对于超时的情况，门限减半，拥塞窗口直接从0开始执行慢开始算法。</p></blockquote><p>拥塞控制为何是3个ACK才快重传</p><blockquote><p>TCP segment乱序有2/5= 40%的概率会造成A收到三次duplicated ACK(N)；而如果N丢了，则会100%概率A会收到三次duplicated ACK(N);</p></blockquote><p>UDP</p><blockquote><p>不可靠、无连接、RIP协议使用、实现可靠传输需要上层应用层帮助(RUDPS、RTP、UDT模仿TCP)。不对数据包做任何操作，直接将其发送，也不考虑接收方。</p></blockquote><p>丢包问题一般发生在哪一层</p><blockquote></blockquote><p>ICMP协议作用</p><blockquote><p>类型：目标不可到达、源抑制和超时报文</p><p>是ip报文的组成部分。</p></blockquote><p>电脑联网失败，发生在哪一层</p><blockquote></blockquote><p>TCP和UDP的报头长度</p><blockquote><p>udp8字节，tcp20字节</p></blockquote><p>SCTP了解过吗, 介绍一下</p><blockquote><p>流控制传输协议（SCTP，Stream Control Transmission Protocol）是一种在网络连接两端之间同时传输多个数据流的协议。</p><p>SCTP是面向消息的（message-oriented）。它提供各个记录的按序递送服务。与UDP一样，由发送端写入的每一条记录的长度随数据一道传递给接收端应用。</p><p>SCTP能给在所连接的端点之间提供多个流，每个流各自可靠地按序递送消息。一个流上某个消息的丢失不会阻塞同一关联其他流上消息的投递。这种做法与TCP正好相反，就TCP而言，在单一字节流中任何位置的字节丢失都将在阻塞该连接上其后所有数据的递送，直到该丢失被修复为止。</p></blockquote><p>TELNET</p><blockquote><p>Telnet协议是TCP/IP协议家族中的一员，是Internet远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用telnet程序，用它连接到服务器。终端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制服务器。要开始一个telnet会话，必须输入用户名和密码来登录服务器。Telnet是常用的远程控制Web服务器的方法。</p><p>需要连接的机器开启telnet服务。</p></blockquote><p>半连接攻击（SYN_FLOOD）</p><blockquote><p>半连接就是通过不断地构造客户端的SYN连接数据包发向服务端，等到服务端的半连接队列满的时候，后续的正常用户的连接请求将会被丢弃，从而无法连接到服务端。此为半连接攻击方式。</p><p>可通过开启SYN Cookies来解决，即通过发送方的信息(端口、ip)和接收方的信息计算出一个cookie，并将其作为序列号进行回复，然后cookie对应一个时间范围，在时间范围内的ack都是合法的，不进入半连接队列，直接完成三次握手。</p></blockquote><p>全连接攻击</p><blockquote><p>全连接攻击：是通过消费服务端进程数和连接数，只连接而不进行发送数据的一种攻击方式。当客户端连接到服务端，仅仅只是连接，此时服务端会为每一个连接创建一个进程来处理客户端发送的数据。但是客户端只是连接而不发送数据，此时服务端会一直阻塞在recv或者read的状态，如此一来，多个连接，服务端的每个连接都是出于阻塞状态从而导致服务端的崩溃。</p><p>可通过设置超时时间来解决。</p></blockquote><p>为何需要三次握手而不是两次？四次挥手而不是三次？</p><blockquote><p>个人理解：三次握手分别保证客户端发送数据的能力、服务端发送数据和接收数据的能力以及客户端接收数据的能力。如果没有第三次握手，就无法保证客户端有接收数据的能力。同时三次握手保证了序列号的一致性以及双方连接建立的完整性(两次握手可能存在服务端的ack延迟到达客户端，此时客户端已经放弃连接了而服务端却以为建立好了连接)。而四次挥手则是因为被动关闭方可能还存在数据未发送完全，需要等待被动方发送完数据并主动发出FIN才能保证数据发送完毕。</p></blockquote><p>http：</p><blockquote><p>状态码：1xx信息、2xx成功、3xx重定向、4xx客户端错误、5xx服务端错误</p><p>100——继续、200——成功、301永久重定向、302临时重定向、400 Bad Request、404找不到页面、401未授权、403拒绝请求、500服务器内部错误。</p><p>301 302区别：301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），<strong>搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址</strong>；302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，<strong>搜索引擎会抓取新的内容而保存旧的网址。</strong></p><p>400——1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。2、请求参数有误。</p><p>403——服务器理解了请求但是拒绝执行</p></blockquote><p>http头部</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">通用头部：</span><br><span class="line">cache-control：请求和响应遵循的缓存机制</span><br><span class="line">pragma：Pragma头域用来包含实现特定的指令，最常用的是Pragma:no-cache</span><br><span class="line">connection：是否保持长连接 keep-alive等等</span><br><span class="line">date：时间</span><br><span class="line">请求头：</span><br><span class="line">accept：接收什么类型 text/html等等</span><br><span class="line">accept-encoding、accept-language</span><br><span class="line">referer：从何而来 如何跳转过来的</span><br><span class="line">user-agent：浏览器表明自己身份</span><br><span class="line">响应头：</span><br><span class="line">age：当代理服务器用自己缓存的实体去响应请求时，用该头部表明该实体从产生到现在经过多长时间了。</span><br><span class="line">server：表明自身是什么软件 Server：Apache/2.0.61 (Unix)</span><br><span class="line">Accept-Ranges：bytes表示接受、none表示不接受</span><br><span class="line">实体头：</span><br><span class="line">allow：支持哪些方法</span><br><span class="line">content-length：响应对象长度</span><br><span class="line">content-type：响应对象的类型</span><br><span class="line">last-modified：对象的最后修改时间</span><br></pre></td></tr></table></figure></blockquote><p>http各版本</p><blockquote><p><strong>1）HTTP 1.0：</strong></p><ul><li>请求与响应支持 HTTP 头，响应含状态行，增加了状态码，</li><li>支持 HEAD，POST 方法</li><li>支持传输 HTML 文件以外其他类型的内容</li></ul><p>HTTP1.0 使用的是非持久连接，主要缺点是客户端必须为每一个待请求的对象建立并维护一个新的连接，即每请求一个文档就要有两倍RTT的开销。因为同一个页面可能存在多个对象，所以非持久连接可能使一个页面的下载变得十分缓慢，而且这种短连接增加了网络传输的负担。（RTT(Round Trip Time)：一个连接的往返时间，即数据发送时刻到接收到确认的时刻的差值）</p><p><strong>2）HTTP 1.1：</strong></p><ul><li>支持长连接。</li><li>在HTTP1.0的基础上引入了更多的缓存控制策略。</li><li>引入了请求范围设置，优化了带宽。</li><li>在错误通知管理中新增了错误状态响应码。</li><li>增加了Host头处理，可以传递主机名（hostname）。</li></ul><p><strong>缺点：</strong>传输内容是明文，不够安全</p><p><strong>3）HTTPS</strong></p><ul><li>HTTPS运行在安全套接字协议(Secure Sockets Layer，SSL )或传输层安全协议（Transport Layer Security，TLS）之上，所有在TCP中传输的内容都需要经过加密。</li><li>连接方式不同，HTTP的端口是80，HTTPS的端口是443。</li><li>HTTPS可以有效防止运营商劫持。</li></ul><p>注：SSL运行在TCP之上</p><p><strong>4）HTTP 1.x优化（SPDY）</strong><br>SPDY 并不是新的一种协议，而是在 HTTP 之前做了一层会话层。为了达到减少页面加载时间的目标，SPDY 引入了一个新的二进制分帧数据层，以实现优先次序、最小化及消除不必要的网络延迟，目的是更有效地利用底层 TCP 连接。</p><ul><li>多路复用，为多路复用设立了请求优先级。</li><li>对header部分进行了压缩。</li><li>引入了HTTPS加密传输。</li><li>客户端可以在缓存中取到之前请求的内容。</li></ul><p><strong>5）HTTP2.0（SPDY的升级版）：</strong></p><ul><li>HTTP2.0支持明文传输，而HTTP 1.X强制使用SSL/TLS加密传输。</li><li>和HTTP 1.x使用的header压缩方法不同。</li><li>HTTP2.0 基于二进制格式进行解析，而HTTP 1.x基于文本格式进行解析。</li><li>多路复用，HTTP1.1是多个请求串行化单线程处理，HTTP 2.0是并行执行，一个请求超时并不会影响其他请求。</li></ul><p>HTTP2.0的多路复用提升了网页性能：</p><ul><li>在 HTTP1 中浏览器限制了同一个域名下的请求数量（Chrome下一般是六个），当在请求很多资源的时候，由于队头阻塞，当浏览器达到最大请求数量时，剩余的资源需等待当前的六个请求完成后才能发起请求。</li><li>HTTP2 中引入了多路复用的技术，这个技术可以只通过一个TCP连接就可以传输所有的请求数据。多路复用可以绕过浏览器限制同一个域名下的请求数量的问题，进而提高了网页的性能。</li></ul><p><strong>注意：</strong></p><ul><li>主流浏览器只支持基于TLS部署的HTTP 2.0协议，所以要将网站升级为HTTP 2.0，就需要先升级为HTTPS。</li><li>HTTP 2.0完全兼容HTTP 1.x,所以对于部署了HTTP 2.0的网站可以自动向下兼容HTTP 1.X。</li></ul><p><strong>6） HTTP 3.0 (QUIC)：</strong></p><p>QUIC (Quick UDP Internet Connections)，快速 UDP 互联网连接。QUIC是基于UDP协议的。</p><p>两个主要特性：</p><p>（1）线头阻塞(HOL)问题的解决更为彻底：</p><p>基于TCP的HTTP/2，尽管从逻辑上来说，不同的流之间相互独立，不会相互影响，但在实际传输方面，数据还是要一帧一帧的发送和接收，一旦某一个流的数据有丢包，则同样会阻塞在它之后传输的流数据传输。而基于UDP的QUIC协议则可以更为彻底地解决这样的问题，让不同的流之间真正的实现相互独立传输，互不干扰。</p><p>（2）切换网络时的连接保持：</p><p>当前移动端的应用环境，用户的网络可能会经常切换，比如从办公室或家里出门，WiFi断开，网络切换为3G或4G。基于TCP的协议，由于切换网络之后，IP会改变，因而之前的连接不可能继续保持。而基于UDP的QUIC协议，则可以内建与TCP中不同的连接标识方法，从而在网络完成切换之后，恢复之前与服务器的连接。</p></blockquote><p>线头阻塞(HOL)</p><blockquote><p>TCP协议中，序号为1、3的数据包接收到后，不能直接传递给上层，需要等待到序号为2的数据包到达，这种等待的情况称为线头阻塞。</p></blockquote><p>https身份认证</p><blockquote><p>身份认证（CA数字证书）：</p><p>https协议中身份认证的部分是由数字证书来完成的，证书由<strong>公钥、证书主题、数字签名</strong>等内容组成，在客户端发起SSL请求后，服务端会将数字证书发给客户端，客户端对证书进行验证，并获取用于秘钥交换的非对称秘钥</p><p>数字证书作用：</p><ul><li>身份授权 确保浏览器访问的网站是经过CA验证的可信任网站</li><li>分发公钥 每个数字证书都包含了注册者生成的公钥。在SSL握手时通过certificate消息传输给客户端</li></ul><p>数字证书验证：</p><p>申请者拿到CA的证书并部署在网站服务器端，浏览器发起握手接收到证书后，如何确认这个证书就是CA签发的呢？怎样避免第三方伪造这个证书？答案就是数字签名（digital signature）。数字签名是证书的防伪标签，目前使用最广泛的是SHA-RSA（SHA用于哈希算法，RSA用于非对称加密算法）数字签名</p></blockquote><p>浏览器如何验证CA证书</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">首先，浏览器通过URL网址去请求服务端，服务端接收到请求后，就会给浏览器发送一个自己的CA数字证书</span><br><span class="line">然后，浏览器接收到证书以后，开始验证。首先从证书中得知证书的颁发机构，然后从浏览器系统中去寻找此颁发机构的根证书(世界上权威CA机构的根证书都是预先嵌入到浏览器中的)，如果在浏览器系中没有找到对应的根证书，就代表此机构不是受信任的，那么就会警告无法确认证书的真假，比如以前打开12360网站就会提示。</span><br><span class="line">之后，如果找到了证书颁发机构的根证书，那么就从根证书中取得那个根公钥，用根公钥去解密此证书的数字签名，成功解密的话就得到证书的指纹和指纹算法，指纹是证书内容通过指纹算法计算得到的一个hash值，这里我们称之为h1，h1代表证书的原始内容；然后用指纹算法对当前接收到的证书内容再进行一次hash计算得到另一个值h2，h2则代表当前证书的内容，如果此时h1和h2是相等的，就代表证书没有被修改过。如果证书被篡改过，h2和h1是不可能相同的。</span><br><span class="line"></span><br><span class="line">假如证书上的指纹是不法分子伪造的，伪造是没有用的，因为你伪造的指纹不可能用CA机构的根私钥去加密（根私钥是CA机构绝对保密的），伪造者只能拿自己的秘钥去加密这个伪造的指纹，但当我们拿机构的根公钥去解密伪造指纹的时候是不可能成功的（加密内容只能由一对公钥私钥解密）</span><br><span class="line"></span><br><span class="line">在证书没有被修改过的基础上，再检查证书上的使用者的URL（比如csdn.net）和我们请求的URL是否相等，如果相等，那么就可以证明当前浏览器链接的网址也是正确的，而不是一些钓鱼网之类的。</span><br><span class="line"></span><br><span class="line">但如果浏览器的连接被某个中间人截取了，中间人也可以发一个由权威的CA机构颁发的证书给浏览器，然后也可以通过证书没有被篡改的验证，但是在证书没有被篡改的前提下，通过对比证书上的URL和我们请求的URL是否相同，我们还是可以判断当前证书是不是服务器发的证书。可以这么理解，因为URL具有唯一性，所以中间人的证书的上的URL和我们的证书的URL是不可能相同的，如果中间人修改了自己证书上的URL，那么就通过不了证书没有被篡改的验证，所以中间人的证书也是欺骗不了我们的。</span><br><span class="line">然后生成对称密钥即可。</span><br></pre></td></tr></table></figure></blockquote><p>https密钥协商机制</p><blockquote><p>1）非对称加密：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">客户端发送 ClientHello（包含支持的协议版本、加密算法和 随机数A (Client random)）到服务端</span><br><span class="line">服务端返回 ServerHello、公钥、证书、随机数B (Server random) 到客户端</span><br><span class="line">客户端使用CA证书验证返回证书无误后。生成 随机数C (Premaster secret)，用公钥对其加密，发送到服务端</span><br><span class="line">服务端用 私钥 解密得到 随机数C (Premaster secret)，随后根据已经得到的 随机数ABC生成对称密钥（hello的时候确定的加密算法），并对需要发送的数据进行对称加密发送</span><br><span class="line">客户端使用对称密钥（客户端也用随机数ABC生成对称密钥）对数据进行解密。</span><br><span class="line">双方手持对称密钥 使用对称加密算法通讯</span><br></pre></td></tr></table></figure><p>2）DH密钥协商：可以做到——“通讯双方在完全没有对方任何预先信息的条件下通过不安全信道创建起一个密钥”</p><p>但无法防止中间人篡改。需要和RSA配合签名机制使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 客户端先连上服务端</span><br><span class="line">2. 服务端生成一个随机数 s 作为自己的私钥，然后根据算法参数计算出公钥 S（算法参数通常是固定的）</span><br><span class="line">3. 服务端使用某种签名算法把“算法参数（模数p，基数g）和服务端公钥S”作为一个整体进行签名</span><br><span class="line">4. 服务端把“算法参数（模数p，基数g）、服务端公钥S、签名”发送给客户端</span><br><span class="line">5. 客户端收到后验证签名是否有效</span><br><span class="line">6. 客户端生成一个随机数 c 作为自己的私钥，然后根据算法参数计算出公钥 C</span><br><span class="line">7. 客户端把 C 发送给服务端</span><br><span class="line">8. 客户端和服务端（根据上述 DH 算法）各自计算出 k 作为会话密钥</span><br></pre></td></tr></table></figure><p>如何防范偷窥（嗅探）:</p><p>嗅探者可以通过监视网络传输，得到算法参数（模数p，基数g）以及双方的公钥，但是【无法】推算出双方的私钥，也【无法】推算出会话密钥（这是由 DH 算法在数学上保证的）</p><p>如何防范篡改（假冒身份）</p><p>攻击方式1：攻击者可以第4步篡改数据（修改算法参数或服务端公钥）。但因为这些信息已经进行过数字签名。篡改之后会被客户端发现。</p><p>攻击方式2：攻击者可以在第7步篡改客户端公钥。这步没有签名，服务端收到数据后不会发现被篡改。但是，攻击者篡改之后会导致“服务端与客户端生成的会话密钥【不一致】”。在后续的通讯步骤中会发现这点，并导致通讯终止。</p></blockquote><p>TLS</p><blockquote><p>整个TLS传输的过程如下：<br>(1）TCP三次握手<br>(2）SSL的ClientHello和ServerHello和对应的秘钥交换KeyExchange<br>(3）Client和Server互相ChangeCipherSpec通知进入加密模式，此时可以进入数据传输状态<br>(4）应用数据传输过程<br>(5）应用数据传输完成，TCP两次挥手<br>抛开TCP连接和数据包文传输的部分，TLS握手部分将使用2个RTT。</p></blockquote><p>前向安全性</p><blockquote><p>指的是长期使用的主密钥泄漏不会导致过去的会话密钥泄漏</p></blockquote><p>http一些参数</p><blockquote><p>Content-Length：指明响应体的数据大小</p><p>content-type：数据格式。</p><ul><li>application/json:JSON数据格式</li><li>text/html:HTML格式</li><li>text/xml:XML格式</li></ul><p>Connection: keep-alive：保持长连接</p></blockquote><p>http——chunk</p><blockquote><p>当客户端向服务器请求一个静态页面或者一张图片时，服务器可以很清楚的知道内容大小，然后通过Content-Length消息首部字段告诉客户端需要接收多少数据。但是如果是动态页面等时，服务器是不可能预先知道内容大小，这时就可以使用Transfer-Encoding：chunk模式来传输数据了。即如果要一边产生数据，一边发给客户端，服务器就需要使用”Transfer-Encoding: chunked”这样的方式来代替Content-Length。</p><p>在进行chunked编码传输时，在回复消息的头部有Transfer-Encoding: chunked</p><p>编码使用若干个chunk组成，由一个标明长度为0的chunk结束。每个chunk有两部分组成，第一部分是该chunk的长度，第二部分就是指定长度的内容，每个部分用CRLF隔开。在最后一个长度为0的chunk中的内容是称为footer的内容，是一些没有写的头部内容。</p><blockquote><p>chunk编码格式如下：</p><p>[chunk size][\r\n][chunk data][\r\n][chunk size][\r\n][chunk data][\r\n][chunk size = 0][\r\n][\r\n]</p><p>chunk size是以十六进制的ASCII码表示，比如：头部是3134这两个字节，表示的是1和4这两个ascii字符，被http协议解释为十六进制数14，也就是十进制的20，后面紧跟[\r\n](0d 0a)，再接着是连续的20个字节的chunk正文。chunk数据以0长度的chunk块结束，也就是（30 0d 0a 0d 0a）。</p></blockquote><p>原理</p><p>HTTP 1.1引入分块传输编码提供了以下几点好处：</p><p>HTTP分块传输编码允许服务器为动态生成的内容维持HTTP持久链接。通常，持久链接需要服务器在开始发送消息体前发送Content-Length消息头字段，但是对于动态生成的内容来说，在内容创建完之前是不可知的。</p><p>分块传输编码允许服务器在最后发送消息头字段。对于那些头字段值在内容被生成之前无法知道的情形非常重要，例如消息的内容要使用散列进行签名，散列的结果通过HTTP消息头字段进行传输。没有分块传输编码时，服务器必须缓冲内容直到完成后计算头字段的值并在发送内容前发送这些头字段的值。</p></blockquote><p>DNS</p><blockquote><p>浏览器输入一个地址，发生了什么？</p><p>根据域名查找ip地址(浏览器缓存——本机host缓存——DNS系统调用——本地DNS服务器缓存——递归查询直到获得ip地址——可能因为负载均衡每次获得不同的ip地址)，然后向该ip发送http请求，服务器响应回复html文档，浏览器解析html并根据content-type判断如何处理(显示、下载等等)，浏览器获取html文档内嵌的图片、音频、js等等，最后浏览器还可以发送ajax异步请求。</p><p>DNS区域传输的时候使用TCP协议：辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。</p><p>域名解析时使用UDP协议</p></blockquote><p>DNS over TLS / HTTPS</p><blockquote><p>加密的DNS协议。但是延时也很高，需要耗费4 RTT来保证安全。</p></blockquote><p>cookie和session、token</p><blockquote><p>cookie：客户端会话技术，存储数据在客户端浏览器，默认浏览器关闭后清除，能存放的数据有限且安全性较低。存放sessionID，之后的请求默认携带。</p><p>session：服务端会话技术，存储在服务端，用来保存状态，依赖于cookie，存放的数据无限制且安全性高，但需要单独存储，耗费空间。</p><p>token：无状态的令牌。采用签名的方式来验证(私钥签名、公钥验证)，每次传输过来的数据再次进行签名以对比。再次请求需要手动添加token。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当用户首次与Web服务器建立连接的时候，服务器会给用户分发一个 SessionID作为标识。SessionID是一个由24个字符组成的随机字符串。用户每次提交页面，浏览器都会把这个SessionID包含在 HTTP头中提交给Web服务器，这样Web服务器就能区分当前请求页面的是哪一个客户端。这个SessionID就是保存在客户端的，属于客户端Session。</span><br><span class="line">其实客户端Session默认是以cookie的形式来存储的，所以当用户禁用了cookie的话，服务器端就得不到SessionID。</span><br></pre></td></tr></table></figure></blockquote><p>http和rpc区别</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RPC:可以基于TCP协议，也可以基于HTTP协议</span><br><span class="line">HTTP:基于HTTP协议</span><br><span class="line"></span><br><span class="line">RPC:可以基于thrift实现高效的二进制传输</span><br><span class="line">HTTP:大部分是通过json来实现的，字节大小和序列化耗时都比thrift要更消耗性能</span><br><span class="line"></span><br><span class="line">RPC：基本都自带了负载均衡策略</span><br><span class="line">HTTP：需要配置Nginx，HAProxy来实现</span><br><span class="line"></span><br><span class="line">RPC主要用于公司内部的服务调用，性能消耗低，传输效率高，服务治理方便。</span><br><span class="line">HTTP主要用于对外的异构环境，浏览器接口调用，APP接口调用，第三方接口调用等。</span><br></pre></td></tr></table></figure></blockquote><p>nginx</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">工作流程：</span><br><span class="line">1、用户通过域名发出访问Web服务器的请求，该域名被DNS服务器解析为反向代理服务器的IP地址；</span><br><span class="line">2、反向代理服务器接受用户的请求；</span><br><span class="line">3、反向代理服务器在本地缓存中查找请求的内容，找到后直接把内容发送给用户；</span><br><span class="line">4、如果本地缓存里没有用户所请求的信息内容，反向代理服务器会代替用户向源服务器请求同样的信息内容，并把信息内容发给用户，如果信息内容是非缓存的还会把它保存到缓存中。</span><br><span class="line">--------</span><br><span class="line">Nginx模块：</span><br><span class="line">Nginx有五大优点：模块化、事件驱动、异步、非阻塞、多进程单线程。由内核和模块组成的，其中内核完成的工作比较简单，仅仅通过查找配置文件将客户端请求映射到一个location block，然后又将这个location block中所配置的每个指令将会启动不同的模块去完成相应的工作。</span><br><span class="line">--------</span><br><span class="line">作用：</span><br><span class="line">* 保护了真实的web服务器，保证了web服务器的资源安全</span><br><span class="line">* 节约了有限的IP地址资源</span><br><span class="line">* 减少WEB服务器压力，提高响应速度</span><br><span class="line"> - 反向代理就是通常所说的web服务器加速，它是一种通过在繁忙的web服务器和外部网络之间增加一个高速的web缓冲服务器来降低实际的web服务器的负载的一种技术。反向代理是针对web服务器提高加速功能，作为代理缓存，它并不是针对浏览器用户，而针对一台或多台特定的web服务器，它可以代理外部网络对内部网络的访问请求。</span><br><span class="line">- 反向代理服务器会强制将外部网络对要代理的服务器的访问经过它，这样反向代理服务器负责接收客户端的请求，然后到源服务器上获取内容，把内容返回给用户，并把内容保存到本地，以便日后再收到同样的信息请求时，它会把本地缓存里的内容直接发给用户，以减少后端web服务器的压力，提高响应速度。因此Nginx还具有缓存功能。</span><br><span class="line">* 请求的统一控制，包括设置权限、过滤规则等；</span><br><span class="line">* 区分动态和静态可缓存内容；</span><br><span class="line">* 实现负载均衡，内部可以采用多台服务器来组成服务器集群，外部还是可以采用一个地址访问；</span><br><span class="line">* 解决Ajax跨域问题；</span><br><span class="line">* 作为真实服务器的缓冲，解决瞬间负载量大的问题；</span><br></pre></td></tr></table></figure></blockquote><p>接口幂等性</p><blockquote><p>接口幂等用于表示任意多次请求执行的结果均与一次请求执行的结果相同</p><p>实现幂等性的关键步骤分为以下三个：</p><p>（1）每个请求操作必须有唯一的 ID，而这个 ID 就是用来表示此业务是否被执行过的关键凭证，例如，订单支付业务的请求，就要使用订单的 ID 作为幂等性验证的 Key；</p><p>（2）每次执行业务之前必须要先判断此业务是否已经被处理过；</p><p>（3）第一次业务处理完成之后，要把此业务处理的状态进行保存，比如存储到 Redis 中或者是数据库中，这样才能防止业务被重复处理</p><p>get请求为幂等、post则不是</p></blockquote><p>理解restful(Representational State Transfer)</p><blockquote><p>（1）每一个URI代表一种资源；</p><p>（2）客户端和服务器之间，传递这种资源的某种表现层；</p><p>（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RESTful 架构的核心规范与约束：统一接口</span><br><span class="line">分为四个子约束：</span><br><span class="line">1.每个资源都拥有一个资源标识，每个资源的资源标识可以用来唯一地标明该资源</span><br><span class="line">2.消息的自描述性</span><br><span class="line">3.资源的自描述性。</span><br><span class="line">4.HATEOAS Hypermedia As The Engine Of Application State(超媒体作为应用状态引擎)</span><br><span class="line">即客户只可以通过服务端所返回各结果中所包含的信息来得到下一步操作所需要的信息，如到底是向哪个URL发送请求等。也就是说，一个典型的REST服务不需要额外的文档标示通过哪些URL访问特定类型的资源，而是通过服务端返回的响应来标示到底能在该资源上执行什么样的操作</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/03/12/T5aPvYtkK9zIefD.png" alt="image.png"></p><p>使用标准的状态码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">GET</span><br><span class="line">安全且幂等、获取表示、变更时获取表示（缓存）</span><br><span class="line">200（OK） - 表示已在响应中发出</span><br><span class="line">204（无内容） - 资源有空表示</span><br><span class="line">301（Moved Permanently） - 资源的URI已被更新</span><br><span class="line">303（See Other） - 其他（如，负载均衡）</span><br><span class="line">304（not modified）- 资源未更改（缓存）</span><br><span class="line">400 （bad request）- 指代坏请求（如，参数错误）</span><br><span class="line">404 （not found）- 资源不存在</span><br><span class="line">406 （not acceptable）- 服务端不支持所需表示</span><br><span class="line">500 （internal server error）- 通用错误响应</span><br><span class="line">503 （Service Unavailable）- 服务端当前无法处理请求</span><br><span class="line"></span><br><span class="line">POST</span><br><span class="line">不安全且不幂等</span><br><span class="line">使用服务端管理的（自动产生）的实例号创建资源</span><br><span class="line">创建子资源</span><br><span class="line">部分更新资源</span><br><span class="line">如果没有被修改，则不过更新资源（乐观锁）</span><br><span class="line">200（OK）- 如果现有资源已被更改</span><br><span class="line">201（created）- 如果新资源被创建</span><br><span class="line">202（accepted）- 已接受处理请求但尚未完成（异步处理）</span><br><span class="line">301（Moved Permanently）- 资源的URI被更新</span><br><span class="line">303（See Other）- 其他（如，负载均衡）</span><br><span class="line">400（bad request）- 指代坏请求</span><br><span class="line">404 （not found）- 资源不存在</span><br><span class="line">406 （not acceptable）- 服务端不支持所需表示</span><br><span class="line">409 （conflict）- 通用冲突</span><br><span class="line">412 （Precondition Failed）- 前置条件失败（如执行条件更新时的冲突）</span><br><span class="line">415 （unsupported media type）- 接受到的表示不受支持</span><br><span class="line">500 （internal server error）- 通用错误响应</span><br><span class="line">503 （Service Unavailable）- 服务当前无法处理请求</span><br><span class="line"></span><br><span class="line">PUT</span><br><span class="line">不安全但幂等</span><br><span class="line">用客户端管理的实例号创建一个资源</span><br><span class="line">通过替换的方式更新资源</span><br><span class="line">如果未被修改，则更新资源（乐观锁）</span><br><span class="line">200 （OK）- 如果已存在资源被更改</span><br><span class="line">201 （created）- 如果新资源被创建</span><br><span class="line">301（Moved Permanently）- 资源的URI已更改</span><br><span class="line">303 （See Other）- 其他（如，负载均衡）</span><br><span class="line">400 （bad request）- 指代坏请求</span><br><span class="line">404 （not found）- 资源不存在</span><br><span class="line">406 （not acceptable）- 服务端不支持所需表示</span><br><span class="line">409 （conflict）- 通用冲突</span><br><span class="line">412 （Precondition Failed）- 前置条件失败（如执行条件更新时的冲突）</span><br><span class="line">415 （unsupported media type）- 接受到的表示不受支持</span><br><span class="line">500 （internal server error）- 通用错误响应</span><br><span class="line">503 （Service Unavailable）- 服务当前无法处理请求</span><br><span class="line"></span><br><span class="line">DELETE</span><br><span class="line">不安全但幂等</span><br><span class="line">删除资源</span><br><span class="line">200 （OK）- 资源已被删除</span><br><span class="line">301 （Moved Permanently）- 资源的URI已更改</span><br><span class="line">303 （See Other）- 其他，如负载均衡</span><br><span class="line">400 （bad request）- 指代坏请求</span><br><span class="line">404 （not found）- 资源不存在</span><br><span class="line">409 （conflict）- 通用冲突</span><br><span class="line">500 （internal server error）- 通用错误响应</span><br><span class="line">503 （Service Unavailable）- 服务端当前无法处理请求</span><br></pre></td></tr></table></figure></blockquote><p>路由器和交换机具体实现了什么功能，路由选择如何实现</p><blockquote><p>路由器属于网络层，使用ip地址通信，连接局域网和外网。</p><p>交换机属于数据链路层，使用mac地址通信，工作在局域网内部。 </p></blockquote><p>介绍下IPV6</p><blockquote><p>128位，16字节，16进制</p></blockquote><p>jwt(JSON Web Token)</p><blockquote><p>JSON Web Token由三部分组成，它们之间用圆点(.)连接。这三部分分别是：</p><ul><li>Header、Payload、Signature</li></ul><p><strong>header</strong>典型的由两部分组成：token的类型（“JWT”）和算法名称（比如：HMAC SHA256或者RSA等等）。例如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    'alg': "HS256",</span><br><span class="line">    'typ': "JWT"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用Base64对这个JSON编码就得到JWT的第一部分</p><p><strong>payload</strong>，它包含声明（要求）。声明是关于实体(通常是用户)和其他数据的声明。声明有三种类型: registered, public 和 private。</p><p>Registered claims : 这里有一组预定义的声明，它们不是强制的，但是推荐。比如：iss (issuer), exp (expiration time), sub (subject), aud (audience)等。</p><p>Public claims : 可以随意定义。</p><p>Private claims : 用于在同意使用它们的各方之间共享信息，并且不是注册的或公开的声明。 下面是一个例子：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"sub"</span>: '<span class="number">1234567890</span>',</span><br><span class="line">    <span class="attr">"name"</span>: 'john',</span><br><span class="line">    <span class="attr">"admin"</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对payload进行Base64编码就得到JWT的第二部分</p><p>注意，不要在JWT的payload或header中放置敏感信息，除非它们是加密的。</p><p><strong>Signature</strong></p><p>为了得到签名部分，你必须有编码过的header、编码过的payload、一个秘钥，签名算法是header中指定的那个，然对它们签名即可。例如：</p><blockquote><p>HMACSHA256(base64UrlEncode(header) + “.” + base64UrlEncode(payload), secret)</p></blockquote><p>签名是用于验证消息在传递过程中有没有被更改，并且，对于使用私钥签名的token，它还可以验证JWT的发送方是否为它所称的发送方。</p></blockquote><p>CSRF跨站点请求伪造(Cross—Site Request Forgery)</p><blockquote><p>攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 </p></blockquote><p>反爬策略</p><blockquote><ol><li>限制IP地址单位时间的访问次数</li><li>用户登录才能访问网站内容, 若识别为爬虫账号,封禁IP</li><li>header, User-Agent检查用户所用客户端的种类和版本, 在请求头中加入CSRF_token识别用户请求(参考form表单验证)</li><li>Referer, 检查请求由哪里来，通常可以做图片的盗链判断</li><li>Cookies,检测Cookie中session_id 的使⽤用次数，如果超过限制，就触发反爬策略略</li><li>动态加载,网站使用ajax动态加载内容</li><li>对前端请求的API的参数进行加密</li><li>对网站JS进行混淆加密(适用于对API参数加密的情况,对用于加密的JS进行混淆)</li><li>在用户登录时,进行验证码验证(图片验证码或滑动验证码或短信验证码等)</li><li>对网页数据展示的总页数进行限制,比如用户只能浏览200页</li></ol></blockquote><h2 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h2><p>包装类自动拆箱、自动装箱</p><blockquote><p>c == a + b    c.equals(a + b)</p></blockquote><p>注解</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">* 作用分类</span><br><span class="line">* 编写文档：生成文档【doc文档】</span><br><span class="line">    * 代码分析：通过注解对代码进行分析【使用反射】</span><br><span class="line">    * 编译检查：让编辑器能实现基本的编译检查【@Override】</span><br><span class="line"></span><br><span class="line">* JDK中预定义的一些注解</span><br><span class="line">* @Override：检测被该注解标注的方法是否是继承自父类(接口)的</span><br><span class="line">    * @Deprecated：将该注解标注的内容，表示已过时</span><br><span class="line">    * @SuppressWarnings：压制警告</span><br><span class="line">    * 一般传递参数all@SuppressWarnings(&quot;all&quot;)</span><br><span class="line">  </span><br><span class="line">* 自定义注解</span><br><span class="line">* 格式：</span><br><span class="line">* 元注解</span><br><span class="line">        * public @interface 注解名称() &#123;</span><br><span class="line">        属性列表;</span><br><span class="line">        &#125;</span><br><span class="line">* 本质：注解本质上就是一个接口，该接口默认继承Annotation</span><br><span class="line">* public interface 注解名称 extends java.lang.annotation.Annotation &#123;&#125;</span><br><span class="line">* 属性：接口中的抽象方法</span><br><span class="line">* 要求：</span><br><span class="line">1. 属性的返回值类型有下列取值：</span><br><span class="line">* 基本数据类型</span><br><span class="line">* String</span><br><span class="line">                * 枚举</span><br><span class="line">                * 注解</span><br><span class="line">                * 以上类型的数组</span><br><span class="line">2. 定义了属性，在使用时需要给属性赋值</span><br><span class="line">1. 如果定义属性时，使用default关键字给属性默认初始值，则使用注解时可以不进行属性的赋值</span><br><span class="line">                2. 如果只有一个属性需要赋值，并且属性的名称为value，则value可以省略，直接定义值即可【@SuppressWarnings】</span><br><span class="line">                3. 数组赋值时，值使用&#123;&#125;包裹，如果数组中只有一个值，则&#123;&#125;可以省略</span><br><span class="line"></span><br><span class="line">* 元注解：用于描述注解的注解</span><br><span class="line">* @Target：描述注解能够作用的位置</span><br><span class="line">        * ElementType取值：</span><br><span class="line">        * TYPE：可以作用于类上</span><br><span class="line">        * METHOD：可以作用于方法上</span><br><span class="line">        * FIELD：可以作用于成员变量上</span><br><span class="line">* @Retention：描述注解被保留的一个阶段</span><br><span class="line">* @Rentention(RententionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到</span><br><span class="line">* @Documented：描述注解是否被抽取到api文档中</span><br><span class="line">* @Inherited：描述注解是否被子类继承</span><br><span class="line">  </span><br><span class="line">* 在程序中使用(解析)注解：获取注解中定义的属性值</span><br><span class="line">1. 获取注解定义的位置的对象【Class，Method，Field】</span><br><span class="line">2. 获取指定的注解</span><br><span class="line">* getAnnotation(Class)</span><br><span class="line">* public class ProImpl implements Pro&#123;</span><br><span class="line">              public String className()&#123;</span><br><span class="line">                  return &quot;day01.annotation.Demo1&quot;;</span><br><span class="line">              &#125;</span><br><span class="line">              public String methodName()&#123;</span><br><span class="line">                  return &quot;show&quot;;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">3. 调用注解中的抽象方法，获取配置的属性值</span><br></pre></td></tr></table></figure></blockquote><ul><li>RPC（Remote Procedure Call）远程过程调用，简单的理解是一个节点请求另一个节点提供的服务</li></ul><p>继承和多态</p><blockquote><p>继承：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。</p><p>多态：允许将子类类型的指针赋值给父类类型的指针。</p></blockquote><p>重写和重载</p><blockquote><p>重写：子类重写父类方法，返回值和形参都不能改变</p><p>重载：方法名字相同，而参数不同。返回类型可以相同也可以不同。每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</p></blockquote><p>TCP UDP对应的socket编程的API</p><blockquote><p>socket()：创建socket<br>bind()：绑定socket到本地地址和端口，通常由服务端调用<br>listen()：TCP专用，开启监听模式<br>accept()：TCP专用，服务器等待客户端连接，一般是阻塞态<br>connect()：TCP专用，客户端主动连接服务器<br>send()：TCP专用，发送数据<br>recv()：TCP专用，接收数据<br>sendto()：UDP专用，发送数据到指定的IP地址和端口<br>recvfrom()：UDP专用，接收数据，返回数据远端的IP地址和端口<br>closesocket()：关闭socket</p></blockquote><p>函数式编程</p><blockquote><p>示例：<code>Function&lt;Integer, Integer&gt; f = x -&gt; x + 1;</code></p><p>和匿名内部类的区别：</p><p>①this指向不同，lambda指向当前类，匿名内部类指向其本身<br>②lambda表达式并没有生成.class文件，匿名内部类则生成了</p></blockquote><p>RBAC模型</p><blockquote><p>权限控制？</p></blockquote><p>transient</p><blockquote><p>不进行序列化</p></blockquote><p>NIO</p><blockquote><p>BytebBuffer——HeapByteBuffer：在堆中创建的缓冲区。MappedByteBuffer：直接缓冲区。</p><p>allocate方法创建的直接缓冲区是创建的DirectByteBuffer实例。</p></blockquote><h2 id="java集合"><a href="#java集合" class="headerlink" title="java集合"></a>java集合</h2><p>HashMap源码、实现原理、转红黑树的时机(为何是7)、多线程优化、多线程失败的场景</p><blockquote><p>jdk7，数组加链表，hash冲突插入首部；jdk8，数组+链表+红黑树。hash冲突插入尾部，在链表长度大于7且数组长度大于64时转换为红黑树，否则先扩容。为何是7呢，因为链表中节点数是8的概率已经接近千分之一，而且此时链表的性能已经很差了。所以在这种比较罕见和极端的情况下，才会把链表转变为红黑树。而同时树节点的占用空间约为链表的两倍，占用空间较大。且在红黑树节点数为6时退化为链表。</p><p>容量：默认容量16，可自定义容量，如果不是2的幂次系统会默认设置为2的幂次，如果容量超过initial * loadFactor(默认0.75)会进行扩容(两倍)。(hash &amp; (len - 1) —— 10101001  00001111)</p><p>为何线程不安全：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">jdk7中由于头插法，会存在resize后链表中形成环的情况。</span><br><span class="line">    线程1阻塞前链表情况：a-&gt;b-&gt;null</span><br><span class="line">    线程2此时执行，会采用头插法将该链表放入新的table，放入后变成b-&gt;a-&gt;null</span><br><span class="line">    线程1此时返回，同样采用头插法插入该线程自己的新的table中，两次循环后变为b-&gt;a，但是由于线程2执行时的后果会导致b的next不是null而是a，所以循环多执行一次，e此时变为a会导致a.next = newTable[i](也就是b)然后发生循环。</span><br><span class="line"></span><br><span class="line">jdk8中采用尾插法会导致数据的覆盖。</span><br><span class="line">假设两个线程A、B都在进行put操作，并且hash函数计算出的插入下标是相同的，当线程A执行完第13行代码后(hash碰撞判断，此时判断是没有碰撞的但还没有进行插入)由于时间片耗尽导致被挂起，而线程B得到时间片后在该下标处插入了元素，完成了正常的插入，然后线程A获得时间片，由于之前已经进行了hash碰撞的判断，所有此时不会再进行判断，而是直接进行插入，这就导致了线程B插入的数据被线程A覆盖了，从而线程不安全。</span><br><span class="line">除此之外还存在一个++size的线程安全问题。</span><br><span class="line"></span><br><span class="line">jdk8解决成环问题：</span><br><span class="line">采用两组指针loHead、loTail、hiHead、hiTail</span><br><span class="line">这两组指针将链表分成了两部分，高位指针指向哪些扩容后下标变为(旧下标+扩容大小)，低位指针指向哪些扩容后下标还保持不变的节点。分成两条链表今次那个迁移，迁移后节点的前后顺序保持不变，不会出现环的情况。(扩容后链表节点的情况只有两种下标不变 or 旧下标+扩容的大小)</span><br><span class="line">红黑树的拆分和链表的逻辑基本一致，不同的地方在于，重新映射后，会将红黑树拆分成两条链表，根据链表的长度，判断需不需要把链表重新进行树化。</span><br></pre></td></tr></table></figure><p>多线程优化：和读写锁配合。</p></blockquote><p>ConcurrentHashMap原理</p><blockquote><p>jdk7，Segment数组 + HashEntry数组 + ReentrantLock(对每个Segment上锁)；jdk8，Node数组 + CAS + Synchronized(只对每个node上锁)</p><p>具体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jdk7：保证segment数组为2的幂次、会再散列来获取下标</span><br><span class="line">初始化有三个参数：</span><br><span class="line">initialCapacity：初始容量大小 ，默认16。</span><br><span class="line">loadFactor, 扩容因子，默认0.75，当一个Segment存储的元素数量大于initialCapacity* loadFactor时，该Segment会进行一次扩容。</span><br><span class="line">concurrencyLevel：并发度，默认16。Segment[]的数组长度。如果并发度设置的过小，会带来严重的锁竞争问题；如果并发度设置的过大，原本位于同一个Segment内的访问会扩散到不同的Segment中，CPU cache命中率会下降，从而引起程序性能下降。</span><br><span class="line">segment不扩容，扩容的是hashentry数组</span><br><span class="line"></span><br><span class="line">扩容时的get操作访问的是旧链表，对于put以及其他更新操作会阻塞直到扩容完成。</span><br></pre></td></tr></table></figure><p>get不需要加锁，除非读到的是null，原理是get方法中的变量都使用volatile关键字修饰。且对volatile字段的写入操作先于读取操作，所以即使两个线程同时修改和获取volatile变量，get操作也能保证拿到最新的值。</p></blockquote><p>ArrayList和LinkedList插入效率比较</p><blockquote><p>插入到最后，效率相当。插入到中间，LinkedList效率高。数据量过大，ArrayList动态扩容，LinkedList效率更高。</p></blockquote><p>ArrayList</p><blockquote><p>懒加载(但在jdk7及以前会直接初始化一个容量为10的数组)，需要扩容时，会首先扩容置原容量的1.5倍左右(<code>new = old + old &gt;&gt; 1</code>)，然后如果new满足需求，则会直接用new作为新容量，否则会将当前所需容量作为新容量。</p></blockquote><p>Java最顶层集合有哪些</p><blockquote><p>Collection、Map</p></blockquote><p>抽象类和接口的区别：</p><blockquote><p>抽象类更多是对事物的抽象，如人，是一种模板的设计；而接口则是对行为的抽象，如：运动，是一种行为的规范。</p><p>抽象类可以有静态方法、成员变量可以为任意类型。</p></blockquote><h2 id="java并发"><a href="#java并发" class="headerlink" title="java并发"></a>java并发</h2><p>synchronized和lock区别以及底层原理</p><blockquote><p>区别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;1.首先synchronized是java内置关键字，在jvm层面，Lock是个java类；</span><br><span class="line">&gt;2.synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；</span><br><span class="line">&gt;3.synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；</span><br><span class="line">&gt;4.用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；</span><br><span class="line">&gt;5.synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可中断、可公平（两者皆可）</span><br><span class="line">&gt;6.Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。</span><br></pre></td></tr></table></figure><p>底层原理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt;synchronized:</span><br><span class="line">&gt;原子性：保证语句块内是原子的</span><br><span class="line">&gt;可见性：通过在unlock前需要将变量同步回主存，其他线程需要重新获取</span><br><span class="line">&gt;有序性：一个变量在同一时刻只允许一条线程对其操作</span><br><span class="line">&gt;方法级的同步是通过方法调用和返回中实现的，方法常量池的ACC_SYNCHRONIZED标志是否为同步方法，如果方法是同步方法，则执行线程需要先持有monitor然后执行方法，返回后释放。</span><br><span class="line">&gt;代码块的同步是通过monitorenter和monitorexit实现的。遇到monitorenter试图获取monitor对象，如果未加锁或者已经被自己持有，则锁计数器+1，执行，遇到monitorexit则锁计数-1.计数器为0代表锁释放。如果获取monitor对象失败会进入阻塞。且是可重入的。</span><br><span class="line">&gt;1.6前慢的原因：对象内部的监视器锁是通过底层OS的Mutex实现的，存在用户态到内核态的切换，成本极高</span><br><span class="line">&gt;1.6后的优化：四种锁状态 无锁——偏向锁——轻量级锁——重量级锁。(不可降级)</span><br><span class="line">&gt;--</span><br><span class="line">&gt;偏向锁：无实际竞争，且将来只有第一个申请锁的线程会使用锁。只有一次CAS</span><br><span class="line">&gt;锁对象第一次被获取时，jvm将对象头锁标志位设为01偏向模式，然后通过CAS将线程id记录到对象的markword中。如果成功，该线程在以后每次进入该同步块时，jvm不进行任何操作。如果不是第一次获取锁，则判断偏向线程id是否为当前线程，是的话就进入同步块。否则则根据当前偏向的线程是否存活，未存活则取消锁到无锁状态，存活则升级为轻量级锁。</span><br><span class="line">&gt;--</span><br><span class="line">&gt;轻量级锁：无实际竞争，多个线程交替使用锁；允许短时间的锁竞争。申请和释放需要CAS</span><br><span class="line">&gt;轻量级锁是相对于重量级锁而言的。使用轻量级锁时，不需要申请互斥量，而是在当前线程栈帧中开辟空间Lock Record用来记录当前对象markword的拷贝。然后将Mark Word中的部分字节CAS更新指向线程栈中的Lock Record，如果更新成功，则轻量级锁获取成功，记录锁状态为00轻量级锁；否则，说明已经有线程获得了轻量级锁，如果指向的是当前线程的栈帧，则重入代码块，否则出现了竞争，会尝试几次CAS，如果不行，升级为重量级锁，标志位11，markword中指针指向重量级锁。</span><br><span class="line">&gt;--</span><br><span class="line">&gt;重量级锁：有实际竞争，且锁竞争时间长。monitor实现。</span><br><span class="line">&gt;Lock: 有三个实现类，ReentrantLock, ReentrantReadWriteLock类中的两个静态内部类ReadLock和WriteLock。</span><br><span class="line">&gt;底层实现为AQS。</span><br><span class="line">&gt;AQS：CLH锁队列(双向链表)+state状态变量，线程通过CAS去改变状态，成功则获取锁成功，失败则进入等待队列，等待被唤醒。</span><br><span class="line">&gt;lock的存储结构：一个int类型状态值（用于锁的状态变更），一个双向链表（用于存储等待中的线程）</span><br><span class="line">&gt;lock获取锁的过程：本质上是通过 CAS 来获取状态值修改，如果当场没获取到，会将该线程放在线程等待链表中。</span><br><span class="line">&gt;lock释放锁的过程：修改状态值，调整等待链表。</span><br><span class="line">&gt;lock()-acquire()-tryAcquire()-未成功获取锁-addwaiter()-acquireQueued()</span><br><span class="line">&gt;acquireQueued的主要作用是把已经追加到队列的线程节点进行阻塞，但阻塞前又通过tryAccquire重试是否能获得锁，如果重试成功能则无需阻塞，直接返回。</span><br></pre></td></tr></table></figure></blockquote><img src="https://i.loli.net/2021/03/10/qU1w9tpoERWl45b.png" alt="image.png" style="zoom:200%;"><p>ReebtrantLock</p><blockquote><p>可重入的互斥锁。可公平可非公平(公平锁会判断当前线程前是否有其他等待线程，有的话就进入等待队列，没有的话才会尝试获取锁，而非公平锁则是直接尝试获取锁)</p></blockquote><p>ReebtrantReadWriteLock</p><blockquote><p>支持公平和非公平、可重入、锁降级(获得写锁—获得读锁—释放写锁)，不支持锁升级。</p><p>状态变量：高16位标识读，低16位表示写。通过位运算来获得读写的状态。</p></blockquote><p>BlockingQueue原理</p><blockquote><p>ArrayBlockingxxx, LinkedBlockingxxx, PriorityBlockingxxx, Delayxxx(延时获取元素), Synchronousxxx(不存储元素), LinkedTransferxxx(无界), LinkedBlockingDeque</p><p>处理方式：抛出异常(add)、返回特殊值(offer)、一直阻塞(put、超时退出(offer(e, time, unit))</p><p>使用Condition + LockSupport实现。</p></blockquote><p>线程池</p><blockquote><p>Executors的几个静态方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">newFixedThreadPool() 阻塞队列无限，会OOM</span><br><span class="line">newSingleThreadExecutor() 阻塞队列无限，会OOM</span><br><span class="line">newCachedThreadPool() 最大线程数为Integer.MAX 也会OOM</span><br></pre></td></tr></table></figure><p>自定义线程池参数的设置(cpu密集 or io密集)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cpu使用率较高（也就是一些复杂运算，逻辑处理），所以线程数一般只需要cpu核数的线程就可以了，减少上下文切换</span><br><span class="line">cpu使用率较低，程序中会存在大量I/O操作占据时间，导致线程空余时间出来，所以通常就需要开cpu核数的两倍的线程， 当线程进行I/O操作cpu空暇时启用其他线程继续使用cpu，提高cpu使用率 </span><br></pre></td></tr></table></figure><p>核心线程数、最大线程数、存活时间、时间单位、阻塞队列、创建线程的工厂、拒绝策略</p><p>拒绝策略：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AbortPolicy：默认的策略，直接抛出 RejectedExecutionException 异常，阻⽌系统正常运⾏。</span><br><span class="line">CallerRunsPolicy：既不会抛出异常，也不会终⽌任务，⽽是将任务返回给调⽤者，从⽽降低新任务的流量。</span><br><span class="line">DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加⼊队列中尝试再次提交任务。</span><br><span class="line">DiscardPolicy：该策略默默地丢弃⽆法处理的任务，不予任何处理也不抛出异常。如果允许任务丢失，这是最好的⼀种策略。</span><br></pre></td></tr></table></figure></blockquote><p>读写锁的实现类</p><blockquote><p>ReentrantReadWriteLock、ReadWriteLockView in StampedLock</p></blockquote><p>公平锁和非公平锁</p><blockquote><p>公平锁保证了FIFO原则但是耗费大量资源在上下文切换，而非公平锁则保证了极大的吞吐量和效率，但可能造成饥饿。</p></blockquote><p>CAS</p><blockquote><p>compareAndSet，自旋保证原子操作，和volatile关键字配合使用。</p></blockquote><p>重排序</p><blockquote><p>volatile，内存屏障。final</p></blockquote><p>AQS</p><blockquote><p>acquire方法中：tryAcquire()—失败—addWaiter()加入等待队列—addQueued()再尝试一次失败就阻塞。</p><p>只有前节点唤醒或者中断才会继续执行。</p></blockquote><p>volatile</p><blockquote><p>内存屏障保证有序性，总线嗅探机制保证可见性。</p><p>伪共享：volatile修饰变量需要更新时，其他和volatile修饰变量在同一缓存行的变量也需要重新获取，性能降低。通过添加一些long的变量来填充缓存行。</p></blockquote><p>创建线程的方式</p><blockquote><p>①继承自Thread重写run方法②实现Runnable接口并实现run方法③实现Callerable接口，实现call方法，可有返回值</p></blockquote><p>TLAB</p><blockquote><p>缺省情况下仅占有整个Eden空间的1%</p></blockquote><p>LockSupport</p><blockquote><p>park()、unpark(Thread t)、parkNaos、parkUtil</p></blockquote><p>Condition接口</p><blockquote><p>await方法原理：将当前获得锁的线程从同步队列移到等待队列最后，并且释放同步状态。</p><p>signal：将当前condition对应的等待队列的首节点放入到同步队列最后，然后通过unpark唤醒线程，进而线程通过acquireQueued方法尝试获取同步状态。</p></blockquote><p>乐观锁、悲观锁：</p><blockquote><p>容易发生冲突且冲突量大时使用悲观锁，否则乐观锁(多读少写)。</p><p>数据库等适合悲观锁。</p></blockquote><p>concurrent包下有哪些：</p><blockquote><p>java.util.concurrent包下包含：tools、locks、collections、executor、atomic</p><p>其中tools包含CountDownLatch、Semaphore、Executors、Exchanger等等</p><p>locks则是包含了Lock、Condition、LockSupport、ReadWriteLock</p><p>collections则是一些支持并发的集合：阻塞队列、ConcurrentHashMap、ConcurrentSkipList等等</p><p>executors则是线程池，atomic为原子类。</p></blockquote><p>Java线程的通信方式</p><blockquote><p>volatile</p><p>等待/通知机制</p><p>join方式</p><p>threadLocal</p></blockquote><p>ThreadLoacl 类、内存泄漏（key是弱引用 ，value是强引用） 每次使用后remove。</p><blockquote><p>由于Thread中包含变量ThreadLocalMap，因此ThreadLocalMap与Thread的生命周期是一样长，如果都没有手动删除对应key，都会导致内存泄漏。</p><p>但是使用<strong>弱引用</strong>可以多一层保障：弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用set(),get(),remove()【源码保证】的时候会被清除。</p><p>因此，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。</p><p>解决方案：</p><ul><li>每次使用完ThreadLocal都调用它的remove()方法清除数据</li><li>将ThreadLocal变量定义成private static，这样就一直存在ThreadLocal的强引用，也就能保证任何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进而清除掉 。</li></ul></blockquote><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>JVM内存结构</p><blockquote><p>class文件——类加载子系统——运行时数据区(方法区、堆、虚拟机栈、本地方法栈、PC寄存器)——执行引擎——本地方法库</p></blockquote><p>垃圾回收算法</p><blockquote><p>标记-清除、标记-整理、复制算法</p><p>垃圾回收器：CMS、G1、ParNew、Serial Old、Parellel Old</p></blockquote><p>类加载过程</p><blockquote><p>加载(已经存在Class对象)——链接(验证、准备、解析，准备阶段对类变量赋默认值)——初始化(clinit方法)</p></blockquote><p>类加载机制</p><blockquote><ul><li>隐式加载 new 创建类的实例,</li><li>显式加载：loaderClass,forName等</li><li>访问类的静态变量，或者为静态变量赋值</li><li>调用类的静态方法</li><li>使用反射方式创建某个类或者接口对象的Class对象。</li><li>初始化某个类的子类</li><li>直接使用<code>java.exe</code>命令来运行某个主类</li></ul></blockquote><p>双亲委派模型</p><blockquote><p>1) 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类豳加载器去执行;<br>2) 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器<br>3) 如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。 </p></blockquote><p>破坏双亲委派机制</p><blockquote><p>在Java应用中存在着很多服务提供者接口（Service Provider Interface，SPI），这些接口允许第三方为它们提供实现，如常见的 SPI 有 JDBC、JNDI等，这些 SPI 的接口属于 Java 核心库，一般存在rt.jar包中，由Bootstrap类加载器加载，而 SPI 的第三方实现代码则是作为Java应用所依赖的 jar 包被存放在classpath路径下，由于SPI接口中的代码经常需要加载具体的第三方实现类并调用其相关方法，但SPI的核心接口类是由引导类加载器来加载的，而Bootstrap类加载器无法直接加载SPI的实现类，同时由于双亲委派模式的存在，Bootstrap类加载器也无法反向委托AppClassLoader加载器SPI的实现类。在这种情况下，我们就需要一种特殊的类加载器来加载第三方的类库，而线程上下文类加载器就是很好的选择。</p><p>线程上下文类加载器（contextClassLoader）是从 JDK 1.2 开始引入的，我们可以通过java.lang.Thread类中的getContextClassLoader()和 setContextClassLoader(ClassLoader cl)方法来获取和设置线程的上下文类加载器。如果没有手动设置上下文类加载器，线程将继承其父线程的上下文类加载器，初始线程的上下文类加载器是系统类加载器（AppClassLoader）,在线程中运行的代码可以通过此类加载器来加载类和资源</p></blockquote><p>沙箱安全机制</p><blockquote><p>假如自定义java.lang.String类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件(rt.jar包中java\lang\String.class)，报错信息说没有main方法，就是因为加载的是rt.jar包中的String类。这样可以保证对java核心源代码的保护，这就是<strong>沙箱安全机制</strong>。</p></blockquote><p>ClassLoader的方法</p><blockquote><p>getParent()获取父加载器、loadClass(String name)加载指定name的类并返回Class对象、findClass(String name)查找指定name的类并返回Class对象、 findLoadedClass(String name)查找已经加载的类并返回、defineClass(String name, byte[] b, int off, int len)将字节数组中的内容转换为一个类、resolveClass(Class&lt;?&gt; c)链接指定的一个类。</p><p>遵循双亲委派——重写findClass方法即可、打破双亲委派——重写loadClass方法</p></blockquote><p>OOM如何分析，一些分析工具，常用命令</p><blockquote><p>jvisualVM、jprofiler</p><p>jmap、jflag、jinfo、jstate</p></blockquote><p>堆和栈的区别</p><blockquote><p>堆中存在OOM和GC，栈中只存在OOM。堆是存储的单位，栈是运行时的单位。</p></blockquote><p>对象头</p><blockquote><p>MarkWord(hashcode、锁标志位、分代年龄、是否偏向锁、偏向线程id等等)</p><p>元数据指针(指向方法区的类型数据信息)</p><p>数组长度(如果是数组的话)</p></blockquote><p>对象实例化过程</p><blockquote><p>①查看对应的类信息是否加载②计算所需内存并分配空间③并发问题(CAS)分配TLAB④默认初始化⑤设置对象头⑥显示初始化</p></blockquote><p>NIO</p><blockquote><p>直接内存，DirectByteBuffer操作本地内存，没有中间状态。IO多路复用</p></blockquote><p>String不可变原理：</p><blockquote><p>final修饰char数组(jdk9后采用byte数组)。</p><p>原因：①字符串常量池②String缓存了自身的hashcode，如果可变但hash没变，散列会存在问题③String会作为参数</p><p>StringBuffer线程安全，synchronized修饰，StringBuilder性能更高。</p></blockquote><p>String str1=”a”；String str2=”a”+”bc”;</p><blockquote><p>都在字符串常量池中创建一个对象。</p><p>String a = new String(“11”)+new String(“22”);创建了几个对象？</p><p>new String(“xx”)都会创建两个对象，然后如果+两边存在变量，那么都会存在一个StringBuilder对象，StirngBuilder还会通过toString方法再创建一个对象。</p></blockquote><p>ClassNotFoundException场景</p><blockquote><p>1、调用class的forName方法时，找不到指定的类<br>2、ClassLoader 中的 findSystemClass() 方法时，找不到指定的类<br>3、ClassLoader 中的 loadClass() 方法时，找不到指定的类</p></blockquote><p>GC ROOTS</p><blockquote><p>在Java语言中，GC Roots包括以下几类元素：</p><p>①虚拟机栈中引用的对象。比如：各个线程被调用的方法中使用到的参数、局部变量等。<br>②本地方法栈内JNI(通常说的本地方法)引用的对象<br>③方法区中类静态属性引用的对象。比如: Java类的引用类型静态变量<br>④方法区中常量引用的对象。比如:字符串常量池（string Table）里的引用<br>⑤所有被同步锁synchronized持有的对象<br>⑥Java虚拟机内部的引用。基本数据类型对应的class对象，一些常驻的异常对象（如:NullPointerException、OutOfMemoryError）、系统类加载器<br>⑦反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。<br>⑧在某些特殊情况下，还可能存在一些对象临时加入到Root中的情况。(如：在分代垃圾收集时，如果只回收新生代的对象，那么一些老年代的对象也可以作为Root)</p></blockquote><p>OOM排查</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1、先查看应用进程号pid: ps -ef | grep 应用名</span><br><span class="line">2、查看pid垃圾回收情况: jstat -gc pid 5000（时间间隔）</span><br><span class="line">3、开启OOM快照: </span><br><span class="line">-XX：+HeapDumpOnOutOfMemoryError（开启堆快照）</span><br><span class="line">-XX：HeapDumpPath=C:/m.hprof（保存文件到哪个目录）</span><br><span class="line">4、dump 查看方法栈信息：</span><br><span class="line">jstack -l pid &gt; /home/test/jstack.txt</span><br><span class="line">5、dump 查看JVM内存分配以及使用情况</span><br><span class="line">jmap -heap pid &gt; /home/test/jmapHeap.txt</span><br><span class="line">6、dump jvm二进制的内存详细使用情况 </span><br><span class="line">jmap -dump:format=b,file=/home/test/oom.hprof pid</span><br></pre></td></tr></table></figure></blockquote><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>java连接数据库 jdbc原生</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">conn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">String URL = <span class="string">"jdbc:mysql://127.0.0.1:3306/Supermarket?characterEncoding=utf-8"</span>;</span><br><span class="line">String USER = <span class="string">"root"</span>;</span><br><span class="line">String PASSWORD = <span class="string">"123"</span>;</span><br><span class="line"><span class="comment">// 1.加载驱动程序</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line"><span class="comment">// 2.获得数据库链接</span></span><br><span class="line">Connection conn = DriverManager.getConnection(URL, USER, PASSWORD);</span><br><span class="line"><span class="comment">// 3.通过数据库的连接操作数据库，实现增删改查（使用Statement类）</span></span><br><span class="line">String name=<span class="string">"张三"</span>;</span><br><span class="line"><span class="comment">//预编译</span></span><br><span class="line">String sql=<span class="string">"select * from userinfo where UserName=?"</span>;</span><br><span class="line">PreparedStatement statement = conn.prepareStatement(sql);</span><br><span class="line">statement.setString(<span class="number">1</span>, name);</span><br><span class="line">ResultSet rs = statement.executeQuery();</span><br><span class="line"><span class="comment">//String sql="select * from userinfo where UserName='"+name+"'";</span></span><br><span class="line"><span class="comment">//Statement statement = conn.createStatement();</span></span><br><span class="line"><span class="comment">//ResultSet rs = statement.executeQuery(sql);</span></span><br><span class="line"><span class="comment">// 4.处理数据库的返回结果(使用ResultSet类)</span></span><br><span class="line"><span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">System.out.println(rs.getString(<span class="string">"UserName"</span>) + <span class="string">" "</span> + rs.getString(<span class="string">"Password"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line">conn.close();</span><br><span class="line">rs.close();</span><br><span class="line">statement.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>IOC AOP</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">IOC: Inversion of Control，控制反转</span><br><span class="line">DI: Dependency Injection，依赖注入</span><br><span class="line">关系：IOC是一种面向编程设计思想，DI是IOC思想的实现方式，即：DI实现IOC这一思想</span><br><span class="line">A需要B，A不直接控制B，A给IOC容器需要的信息，然后IOC容器为A创建B。</span><br><span class="line">主动获取反转为被动获取，解耦。</span><br><span class="line"></span><br><span class="line">AOP: jdk or cglib</span><br><span class="line">JDK动态代理主要涉及java.lang.reflect包下边的两个类：Proxy和InvocationHandler。其中，InvocationHandler是一个接口，可以通过实现该接口定义横切逻辑，并通过反射机制调用目标类的代码，动态地将横切逻辑和业务逻辑贬值在一起。</span><br><span class="line">所以使用JDK动态代理的话，他有一个限制，就是它只能为接口创建代理实例，而对于没有通过接口定义业务方法的类，如何创建动态代理实例呢？答案就是CGLib。</span><br><span class="line">CGLib采用底层的字节码技术，全称是：Code Generation Library，CGLib可以为一个类创建一个子类，在子类中采用方法拦截的技术拦截所有父类方法的调用并顺势织入横切逻辑。</span><br><span class="line">在spring中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">JDK的动态代理</span><br><span class="line">final Advice advice = new Advice();   // 获得增强对象</span><br><span class="line">    final Target target = new Target();</span><br><span class="line">    // 返回值就是生成的动态代理对象</span><br><span class="line">    TargetInterface proxy = (TargetInterface) Proxy.newProxyInstance(</span><br><span class="line">            target.getClass().getClassLoader(), // 目标对象的类加载器</span><br><span class="line">            target.getClass().getInterfaces(),  // 目标对象相同的接口字节码对象数组</span><br><span class="line">            new InvocationHandler() &#123;</span><br><span class="line">                // 调用代理对象的任何方法，实质执行的为invoke方法</span><br><span class="line">                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">                    advice.before();// 前置增强</span><br><span class="line">                    method.invoke(target, args);// 执行目标方法</span><br><span class="line">                    advice.after();</span><br><span class="line">                    return null; // 该返回值对于方法本身而言 无意义</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    );</span><br><span class="line">    proxy.save();   // 调用代理对象的方法</span><br><span class="line">cglib的动态代理</span><br><span class="line">final Advice advice = new Advice();   // 获得增强对象</span><br><span class="line">    final Target target = new Target();</span><br><span class="line">    // 返回值就是生成的动态代理对象 基于cglib</span><br><span class="line">    // 1.创建增强器</span><br><span class="line">    Enhancer enhancer = new Enhancer();</span><br><span class="line">    // 2.设置父类 (目标)</span><br><span class="line">    enhancer.setSuperclass(Target.class);</span><br><span class="line">    // 3.设置回调</span><br><span class="line">    enhancer.setCallback(new MethodInterceptor() &#123;</span><br><span class="line">        public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">            advice.before(); // 执行前置</span><br><span class="line">            Object invoke = method.invoke(target, args);</span><br><span class="line">            advice.after(); // 执行后置</span><br><span class="line">            return invoke;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    // 4.生成代理对象</span><br><span class="line">    Target proxy = (Target) enhancer.create();</span><br><span class="line"></span><br><span class="line">    proxy.save();</span><br></pre></td></tr></table></figure></blockquote><p>Spring加载bean的流程</p><blockquote><p>class对象——实例化得到原始bean对象——属性注入——初始化——放入单例池——销毁</p></blockquote><p>三级缓存与循环依赖</p><blockquote><p>class对象——实例化——放入三级缓存——属性注入——需要的属性先查找一级缓存、然后查找二级缓存、然后查找三级缓存，放入二级缓存、删除三级缓存。</p><p>三级缓存内存存的是函数式接口。</p><p>构造器的循环依赖和prototype的循环依赖无法解决。(?)</p></blockquote><p>Spring、MyBatis整合</p><blockquote><p>通过注解对mapper接口进行扫描并获得对应包名和接口，然后进行BD的注册，注册完后根据接口类型等信息对BD进行处理，即改变BD生成bean的方式(通过实现BeanFactory的方式来生成)，通过MapperBeanFactory进行后续的bean的生成。</p></blockquote><p>BeanFactory和FactoryBean</p><blockquote><p>FactoryBean是一个接口，当在IOC容器中的Bean实现了FactoryBean后，通过getBean(String BeanName)获取到的Bean对象并不是FactoryBean的实现类对象，而是这个实现类中的实现的getObject()方法返回的对象，如下图的MapperFactoryBean。而如果要想获取FactoryBean的实现类，就要getBean(&amp;BeanName)，在BeanName之前加上&amp;。</p><p>BeanFactory是一个接口，Spring内部实现了很多类，存放很多东西，如definitionmap、singletonmap等等。BeanFactory是个Factory，也就是IOC容器或对象工厂。在Spring中，所有的Bean都是由BeanFactory(也就是IOC容器)来进行管理的</p></blockquote><p>@Autowired和@Resource区别</p><blockquote><p>@Autowired//默认按type注入<br>@Qualifier(“cusInfoService”)//一般作为@Autowired()的修饰用<br>@Resource(name=”cusInfoService”)//默认按name注入，可以通过name和type属性进行选择性注入</p></blockquote><p>@Inject和@Autowired</p><blockquote><p>@Inject是Java EE 6（JSR-299）中引入的Java CDI（上下文和依赖项注入）标准的一部分</p><p>@Autowired则是Spring框架的一部分。</p><p>前者自动装配的bean范围是singleton，后者则是原型</p><p>前者和@Named一起使用，后者和@Qualifier一起使用。</p></blockquote><p>全局异常处理</p><blockquote><p>继承HandlerExceptionResolver接口，并将实现类作为bean进行注册到Spring，在resolveException中实现处理逻辑。</p></blockquote><p>SpringBoot怎么在服务端接收到HTTP请求后，再转发到控制层？</p><blockquote><p>filter-&gt;dispatchServlet(doService-&gt;doDispath)-&gt;intercepter(prehandle拦截器)-&gt;RequestMappingHandler(查找映射)-&gt;ServletInvocableHandlerMethod: invokeAndHandle(参数处理)-&gt;通过java 反射机制动态调用目标API方法进入相对应具体的controller-&gt;执行 handleReturnValue 方法， 首先会判断是否需要对response entity 进行二次处理（ResponseBodyAdvice: beforeBodyWrite）， 处理完成后， 调用注册进来的MessageConvertor 对返回信息进行转换处理， 比如使用faster Jackson 把对象类型转成 json 字符串，并以application/json 的形式返回 http response -&gt; 拦截器 postHandle 方法， 最后执行拦截器的afterCompletion 方法。</p><p>按照 Servlet 规范，所有请求都会被tomcat容器交到 dispatchServlet 的 doService 方法中去处理。跟到这个方法中去，我们发现其中设置了变量进 request 对象，然后执行了 doDispatch 方法，这个方法才是真正实现请求处理的核心。</p><p>该doDispatch方法中调用 getHandler 找到 url 匹配的 handler 方法（示例代码中的 hello 方法）。然后调用 ha.handle() 来获得处理结果。</p><p>对于getHandler 方法，是通过 HandlerMapping 接口对象的集合对象来操作的。HandlerMapping 接口要求实现类实现从请求到处理对象的映射的方法。以 RequestMappingHandlerMapping 实现为例，它底层注册了一个 url -&gt; handler方法的 map，每当请求过来，就会根据请求的url 去 map 中匹配，匹配到对应的handler 方法。</p></blockquote><p>Spring中的设计模式</p><blockquote><p>简单工厂模式——BeanFactory</p><p>工厂方法模式——FactoryBean</p><p>单例模式——单例池，bean(singleton)</p><p>适配器模式——AOP</p><p>包装器模式——Wrapper、Decorator</p><p>代理模式——AOP动态代理</p><p>观察者模式——</p><p>策略模式——</p></blockquote><h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><p>什么是MVC</p><blockquote><p>Controller（控制器）、Model（业务模型）、View（用户视图）实现代码分离，Controller用于同步Model和View</p></blockquote><p>SpringMVC流程</p><blockquote><p>（1）用户发送请求至前端控制器DispatcherServlet；<br>（2） DispatcherServlet收到请求后，调用HandlerMapping处理器映射器，请求获取Handle；<br>（3）处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet；<br>（4）DispatcherServlet 调用 HandlerAdapter处理器适配器；<br>（5）HandlerAdapter 经过适配调用 具体处理器(Handler，也叫后端控制器)；<br>（6）Handler执行完成返回ModelAndView；<br>（7）HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet；<br>（8）DispatcherServlet将ModelAndView传给ViewResolver视图解析器进行解析；<br>（9）ViewResolver解析后返回具体View；<br>（10）DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）<br>（11）DispatcherServlet响应用户。</p><p><img src="https://i.loli.net/2021/03/22/CAafT92nKwky5jU.png" alt="image.png"></p></blockquote><p>SpringMVC实现返回json</p><blockquote><p>通过一些json框架如(Jackson)，并在方法前加上@ResponseBody即可</p></blockquote><p>解决post、get乱码问题</p><blockquote><p>post：在web.xml中配置一个CharacterEncodingFilter过滤器，设置成utf-8；</p><p>get：①修改tomcat配置文件添加编码与工程编码一致；②对传过来的参数进行重新编码</p></blockquote><p>SpringMVC异常处理</p><blockquote><p>可以将异常抛给Spring框架，由Spring框架来处理；我们只需要配置简单的异常处理器，在异常处理器中添视图页面即可。</p></blockquote><p>SpringMVC控制器</p><blockquote><p>是单例的，多线程存在线程安全问题，不使用同步，会影响性能，在控制器中不写字段来保证线程安全。</p></blockquote><p>SpringMVC常用注解</p><blockquote><p>@RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。<br>@RequestBody：注解实现接收http请求的json数据，将json转换为java对象。<br>@ResponseBody：注解实现将conreoller方法返回对象转化为json对象响应给客户。</p><p>@Controller、@RestController(@Controller + @ResponseBody)</p></blockquote><p>如何在方法中得到session、request对象</p><blockquote><p>直接在方法中声明这个对象，SpringMvc就自动会把属性赋值到这个对象里面。</p></blockquote><p>SpringMvc用什么对象从后台向前台传递数据的？</p><blockquote><p>通过ModelMap对象，可以在这个对象里面调用put方法，把对象加到里面,前台就可以通过el表达式拿到。</p></blockquote><p>怎么样把ModelMap里面的数据放入Session里面？</p><blockquote><p>可以在类上面加上@SessionAttributes注解，里面包含的字符串就是要放入session里面的key。</p></blockquote><p>SpringMvc里面拦截器是怎么写的？</p><blockquote><p>有两种写法，一种是实现HandlerInterceptor接口，另外一种是继承适配器类，接着在接口方法当中，实现处理逻辑；然后在SpringMVC的配置文件中配置拦截器即可</p></blockquote><p>注解原理</p><blockquote><p>注解本质是一个继承了<code>Annotation</code>的特殊接口，其具体实现类是<code>Java</code>运行时生成的动态代理类。我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象。通过代理对象调用自定义注解的方法，会最终调用<code>AnnotationInvocationHandler</code>的<code>invoke</code>方法。该方法会从<code>memberValues</code>这个<code>Map</code>中索引出对应的值。而<code>memberValues</code>的来源是<code>Java</code>常量池。</p></blockquote><p>Controller局部异常处理</p><blockquote><p>①在某个方法上方使用@ExceptionHandler()注解，并给出想要处理的异常类型，然后该方法就会作为该Controller的异常处理方法</p><p>②定义一个异常处理类，并使用@ControllerAdvice()注解修饰，并给出想要处理的Controller，可以传入一个接口class对象，表示实现了该接口的Controller的异常都由该异常类处理，内部的exceptionHandler和方法①一致。</p></blockquote><h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><p>配置文件装载顺序</p><blockquote><p>①application.properties优先级大于application.yml<br>②先去项目根目录找config文件夹下找配置文件件；再去根目录下找配置文件；去resources下找cofnig文件夹下找配置文件；去resources下找配置文件<br>③如果高优先级的配置文件和低优先级的配置文件中属性不冲突，则可以实现互补配置。<br>④外部配置：如cmd命令，或者系统属性System.getProperties()；同样可以形成互补配置</p></blockquote><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>单线程原因：</p><blockquote><ol><li>单线程编程容易并且更容易维护；</li><li>Redis 的性能瓶颈不再 CPU ，主要在内存和网络；</li><li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li></ol></blockquote><p>缓存淘汰策略</p><blockquote><p>lru(最近最少未使用)、ttl(时间)、lfu(使用频率)、不驱逐</p></blockquote><p>布隆过滤器原理</p><blockquote><p>bitmap + 多次hash</p><p>对于hash结果不正确的，一定不存在。反之则不是，可能存在也可能不存在。</p></blockquote><p>一致性hash</p><blockquote><p>hash环(对2^32而不是一个固定值进行hash)，保证即使hash结果数要求发生变化，只用改变hash环上的分割即可。可使用虚拟节点进行hash环分配不均的改良。</p><p>虚拟节点即将单个节点虚拟为多个节点，使得数据能够平均分布在各个节点上。</p></blockquote><p>持久化机制</p><blockquote><p>AOF、RDB</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;RDB其实就是把数据以快照的形式保存在磁盘上。什么是快照呢，你可以理解成把当前时刻的数据拍成一张照片保存下来。Redis调forks。同时拥有父进程和子进程。子进程将数据集写入到一个临时RDB文件中。当子进程完成对新RDB文件的写入时，Redis用新RDB文件替换原来的RDB文件，并删除旧的RDB文件。</span><br><span class="line">&gt;RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。也是默认的持久化方式，这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为dump.rdb。</span><br><span class="line">&gt;三种触发机制save、bgsave、自动化。</span><br><span class="line">save: 阻塞redis，用新的RDB替换旧的并直到过程完成才继续</span><br><span class="line">bgsave: Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。具体操作是Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。基本上 Redis 内部所有的RDB操作都是采用bgsave命令。</span><br><span class="line">自动化：更改配置文件，它在“N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动进行数据集保存操作。</span><br><span class="line">&gt;RDB是一个非常紧凑的文件，方便传输</span><br><span class="line">&gt;快照持久化期间修改的数据不会被保存，可能丢失数据。</span><br><span class="line">&gt;----------------------------------------------------------------------------------------------------</span><br><span class="line">&gt;AOF：redis会将每一个收到的写命令都通过write函数追加到文件中。通俗的理解就是日志记录。每当Redis执行一个改变数据集的命令时（比如 SET）， 这个命令就会被追加到AOF文件的末尾。这样的话， 当Redis重新启时， 程序就可以通过重新执行AOF文件中的命令来达到重建数据集的目的</span><br><span class="line">&gt;为了压缩aof的持久化文件。redis提供了bgrewriteaof命令。将内存中的数据以命令的方式保存到临时文件中，同时会fork出一条新进程来将文件重写。</span><br><span class="line">&gt;每次修改同步always：同步持久化，每次发生数据变更会被立即记录到磁盘，性能较差但数据完整性比较好</span><br><span class="line">&gt;每秒同步everysec：异步操作，每秒记录 如果一秒内宕机，有数据丢失</span><br><span class="line">&gt;不同no：从不 fsync ：将数据交给操作系统来处理，由操作系统来决定什么时候同步数据。更快，也更不安全的选择。</span><br><span class="line">&gt;AOF重写：因为 AOF 的运作方式是不断地将命令追加到文件的末尾， 所以随着写入命令的不断增加， AOF 文件的体积也会变得越来越大。举个例子， 如果你对一个计数器调用了 100 次 INCR ， 那么仅仅是为了保存这个计数器的当前值， AOF 文件就需要使用 100 条记录（entry）。然而在实际上， 只使用一条 SET 命令已经足以保存计数器的当前值了， 其余 99 条记录实际上都是多余的。</span><br><span class="line">&gt;为了处理这种情况， Redis 支持一种有趣的特性： 可以在不打断服务客户端的情况下， 对 AOF 文件进行重建（rebuild）。执行 bgrewriteaof 命令， Redis 将生成一个新的 AOF 文件， 这个文件包含重建当前数据集所需的最少命令。</span><br></pre></td></tr></table></figure><p>Redis 持久化 之 AOF 和 RDB 同时开启，Redis听谁的？</p><blockquote><p>AOF</p></blockquote></blockquote><p>缓存雪崩、缓存击穿、缓存穿透</p><blockquote><p>缓存雪崩是指缓存同一时间大面积的失效（也可能为redis重启），所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p><p>缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。(一般出现于被攻击或者电商中高并发的场景)</p><p>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发<strong>查同一条数据</strong>，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p></blockquote><p>底层数据结构</p><blockquote><p><strong>字符串</strong>：SDS（char数组buf + len + 未使用的空间大小free），可以动态扩容(预分配)，惰性空间释放(改变free的值而非回收内存)。</p><p><strong>链表</strong>：双向链表，表头前置为null，表尾后置为null</p><p><img src="https://i.loli.net/2021/03/22/ycSbiXY1DC9edHO.png" alt="image.png"></p><p><strong>字典</strong>：新增时，先根据键值对的键计算出哈希值，然后根据 sizemask 属性和哈希值，计算索引值——即落入数组中的哪个位置。之后如果有一个位置多个键值对要存入时，组成单向链表即可。</p><p>这里和 HashMap 的不同之处在于，链表添加时总是添加在表头位置。因为 dictEntry 节点组成的链表没有指向链表表尾的指针，为了速度考虑，总是将新节点加在链表的表头位置。（为什么要这样，而不是遍历完整个链表后加在链表尾部，不遍历出现重复键怎么办？）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;rehash:</span><br><span class="line">&gt;rehash 也可以参考 Java 中 HashMap 的原理。</span><br><span class="line">&gt;负载因子 = 哈希表中已保存的节点数量 / 哈希表数组大小。</span><br><span class="line">&gt;当哈希表中存放的键值对不断增多或减少，为了让负载因子在一个合理的范围内，需要对大小进行扩展或者收缩。（这里类似 HashMap 中的重新散列方法）</span><br><span class="line">&gt;1. 字典的 ht[1] 分配空间，空间的大小由 ht[0] 已经使用的键值对数量以及执行的扩张和收缩来决定。</span><br><span class="line">- 扩展操作，那么 ht[1] 分配的空间大小应是比当前 ht[0].used 值的二倍大的第一个 2 的整数幂。（比如当前使用空间 14，那么找 28 的下一个 2 的整数幂，为 32）</span><br><span class="line">- 收缩操作，取 ht[0].used 的第一个大于等于的 2 的整数幂。（比如 14，那么就是 16）</span><br><span class="line">&gt;2. 将 ht[0] 中的所有键值对，rehash 到 ht[1] 上面：根据新的大小来重新计算所有键的哈希和索引，映射到新数组的指定位置上。</span><br><span class="line">&gt;3. ht[0] 的所有键值对都迁移到 ht[1] 之后，释放 ht[0] ，然后将 ht[1] 设置为 ht[0] ，然后在 ht[1] 处新创建空白哈希表，为下一次 rehash 做准备。</span><br><span class="line">&gt;扩展的条件</span><br><span class="line">服务器没有执行 BGSAVE 或者 BGREWRITEAOF 命令，并且哈希表的负载因子大于等于 1 。</span><br><span class="line">服务器正在执行 BGSAVE 或者 BGREWRITEAOP 命令，并且哈希表的负载因子大于等于 5 。</span><br><span class="line">&gt;这两种情况根据是否有后台命令执行来区分，是因为在执行 BGSAVE 或者 BGREWRITEAOF 的过程中，Redis 需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制（copy-on-write）技术来优化子进程的使用效率。所以在子进程存在期间，服务器会提高执行扩展操作所需的负载因子，尽可能避免在子进程存在期间进行哈希表的扩展操作，来避免不必要的内存写入操作，最大限度的节省内存。</span><br><span class="line">&gt;收缩的条件</span><br><span class="line">&gt;当哈希表的负载因子小于 0.1 时，自动开始对哈希表进行收缩操作。</span><br><span class="line">&gt;渐进式rehash:</span><br><span class="line">&gt;如果键值对量巨大时，一次性全部 rehash 必然造成一段时间的停止服务。所以要分多次、渐进式的将键值对从 ht[0] 慢慢的 rehash 到 ht[1] 中。</span><br><span class="line">&gt;具体过程：</span><br><span class="line">&gt;1. 为 ht[1] 分配空间，同时有 ht[0] 和 ht[1] 两个哈希表。</span><br><span class="line">&gt;2. 在字典中维持一个索引计数器变量 rehashindex ，并将其置为 0 ，表示 rehash 正式开始。</span><br><span class="line">&gt;3. 在 rehash 期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作之外，还会顺便将 ht[0] 哈希表在 rehashindex 索引上的所有键值对 rehash 到 ht[1] 上，当 rehash 工作完成之后，程序将 rehashindex 的值加一。</span><br><span class="line">&gt;4. 随着字典操作的不断进行，最终在某个时间点，ht[0] 的所有键值对都被 rehash 到 ht[1] ，这时程序将 rehashindex 的值置为 -1 ，表示 rehash 工作完成。</span><br><span class="line">&gt;渐进式 rehash 的过程中，更新删除查找等都会在两个哈希表上进行，比如查找，先在 ht[0] 中查找，如果没找到，就去 ht[1] 中查找。而新增操作，直接新增在 ht[1] 中，ht[0] 不会进行任何的新增操作。保证 ht[0] 的数量只减不增，最终变为空表。</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/03/22/gAHwEQy36MCmIZ8.png" alt="image.png"></p><p><strong>跳表</strong>：跳跃表是一种有序数据结构，通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。Redis 使用跳跃表作为有序集合键的底层实现之一。<br>跳跃表在 Redis 中，只有两个地方用到：一个是实现有序集合对象，另一个是在集群节点中用作内部数据结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;head：指向跳跃表的表头节点。</span><br><span class="line">&gt;tail：指向跳跃表的表尾节点。</span><br><span class="line">&gt;level：记录当前跳跃表中，层数最高的节点的层数（表头节点的层数不计算）。</span><br><span class="line">&gt;length：记录跳跃表的长度，即包含节点的数量。</span><br><span class="line">&gt;level：每一层都有前进指针和跨度，从头到尾遍历时，访问会沿着层的前进指针进行。</span><br><span class="line">&gt;BW：后退指针，指向前一个节点，从尾到头遍历时使用。</span><br><span class="line">&gt;score：分值，跳跃表中的分值按从小到大排列。</span><br><span class="line">&gt;obj：成员对象，各个节点保存有各个成员对象。</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/03/22/MIchbjWmDHw1S5E.png" alt="image.png"></p><p><strong>整数集合</strong>：整数集合是集合键的底层实现之一。当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis 就会使用整数集合作为集合键的底层实现。<br>整数集合是 Redis 保存整数值的集合的抽象数据结构，可以保存 int16_t ，int32_t ，int64_t 的整数值，并且集合中不会出现重复元素。<br>底层由数组实现，整数集合的每个元素都是数组的一个数组项，各个项在数组中按从小到大排列。length 属性记录了包含的元素数量，即数组的长度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;升级:</span><br><span class="line">&gt;当一个新元素添加到整数集合中时，如果新元素类型比整数集合现有的所有元素的类型都要长时，整数集合要先进行升级，然后才能将新元素添加到整数集合中。</span><br><span class="line">&gt;1. 根据新元素类型，扩展整数集合底层数组的大小，并为新元素分配空间。</span><br><span class="line">&gt;2. 将底层数组现有的所有元素都转换成新元素相同的类型，并将类型转换后的元素放置到正确位置上，而且放置过程中需要维持底层数组的有序。</span><br><span class="line">&gt;3. 将新元素添加到底层数组中。</span><br><span class="line">&gt;因为引发升级的新元素的长度肯定比现有所有元素都大，才会出现升级的情况，所以这个值要么大于所有元素，放置的位置就对应新数组的末尾；要么小于所有元素，放置的位置在数组的开头。</span><br><span class="line">&gt;升级可以提高灵活性，不用担心类型错误，可以随意添加不同类型的元素。另外，可以节约内存，只在有需要的时候进行升级。</span><br><span class="line">&gt;另外，整数集合不支持降级操作。</span><br></pre></td></tr></table></figure><p><strong>压缩列表</strong></p><p>压缩列表（ziplist）是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项并且每个都是小整数值或者长度比较短的字符串时，Redis 就采用压缩列表做底层实现。当一个哈希键只包含少量键值对，并且每个键值对的键和值也是小整数值或者长度比较短的字符串时，Redis 就采用压缩列表做底层实现。</p><p>压缩列表是 Redis 为了节约内存而实现的，是一系列特殊编码的连续内存块组成的顺序型数据结构。<br><img src="https://i.loli.net/2021/03/22/dZbBafAUTePKVno.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;zlbytes ：4 字节。记录整个压缩列表占用的内存字节数，在内存重分配或者计算 zlend 的位置时使用。</span><br><span class="line">&gt;zltail ：4 字节。记录压缩列表表尾节点记录压缩列表的起始地址有多少个字节，可以通过该属性直接确定表尾节点的地址，无需遍历。</span><br><span class="line">&gt;zllen ：2 字节。记录了压缩列表包含的节点数量，由于只有 2 字节大小，那么小于 65535 时，表示节点数量。等于 65535 时，需要遍历得到总数。</span><br><span class="line">&gt;entry ：列表节点，长度不定，由内容决定。</span><br><span class="line">&gt;zlend ：1 字节，特殊值 0xFF ，用于标记压缩列表的结束。</span><br></pre></td></tr></table></figure><p>压缩列表节点保存一个字节数组或者一个整数值。<br>字节数组可以是下列值：</p><ul><li>长度小于等于 2^6-1 字节的字节数组</li><li>长度小于等于 2^14-1 字节的字节数组</li><li>长度小于等于 2^32-1 字节的字节数组</li></ul><p>整数可以是六种长度：</p><ul><li>4 位长，介于 0 到 12 之间的无符号整数</li><li>1 字节长的有符号整数</li><li>3 字节长的有符号整数</li><li>int16_t 类型整数</li><li>int32_t 类型整数</li><li>int64_t 类型整数</li></ul><p>每个压缩列表节点的结构如图：<br><img src="https://i.loli.net/2021/03/22/Q5VpZYUBADC2IfG.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;previous_entry_length 属性以字节为单位，记录了压缩列表中前一个节点的长度。该属性的长度可以是 1 字节或者 5 字节。如果前一个节点的长度小于 254 字节，那么该属性长度为 1 字节，保存小于 254 的值。如果前一节点的长度大于等于 254 字节，那么长度需要为 5 字节，属性的第一字节会被设置为 0xFE (254) 之后的 4 个字节保存其长度。</span><br><span class="line">&gt;压缩列表的从表尾到表头遍历：</span><br><span class="line">&gt;1. 首先，有指向压缩列表表尾节点起始地址的指针 p1 （指向表尾节点的指针可以通过指向压缩列表起始地址的指针加上 zltail 属性的值得出）；</span><br><span class="line">&gt;2. 通过用 p1 减去节点的 previous_entry_length 属性，得到前一个节点的起始地址的指针。</span><br><span class="line">&gt;3. 如此循环，最终从表尾遍历到表头节点。</span><br><span class="line">&gt;encoding 属性记录了节点的 content 属性所保存的数据的类型和长度：</span><br><span class="line">&gt;- 一字节、两字节或五字节长，值的最高位为 00、01 或者 10 的是字节数组编码，字节数组的长度由编码除去最高两位之后的其他位记录；</span><br><span class="line">&gt;- 一字节长，值的最高位以 11 开头的是整数编码，这种编码表示保存是整数值，整数值的类型和长度由其他位记录。</span><br><span class="line">&gt;出现新增或删除节点导致 previous_entry_length 1 字节或者 5 字节的长度变化，是连锁更新的问题，但出现几率比较小，而且数量不多的情况下不会对性能造成影响。</span><br></pre></td></tr></table></figure></blockquote><p>数据结构底层实现</p><blockquote><p>字符串：①整数——int；②长字符串(大于44【64 - 19(头部) - 1(‘/0’)】字节)——raw；③短字符串(小于44字节)——embstr</p><p><img src="https://i.loli.net/2021/03/22/p53zlmPV8FIBZHE.png" alt="image.png"></p><p>列表：①满足列表对象所有字符串元素长度都小于64个字节且元素数量小于512——ziplist；②其他使用双向链表</p><p>hash：①满足元素数量小于512且所有元素长度小于64字节——ziplist；②哈希表</p><p>set：①所有元素都是整数，元素数量小于512——整数列表；②哈希表</p><p>zset：①所有元素都是整数，元素数量小于512——整数列表；②跳表</p></blockquote><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>Docker是一个容器化平台，它以容器的形式将您的应用程序及其所有依赖项打包在一起，以确保您的应用程序在任何环境中无缝运行。</p><p>Docker不是虚拟化方法。docker四种状态：运行、已暂停、重新启动、已退出。</p><p>DockerFile：FROM—指定基础镜像；LABEL—功能是为镜像指定标签；RUN—运行指定的命令；CMD—容器启动时要运行的命令。</p><blockquote><p>虽然ADD并且COPY在功能上类似，但是首选COPY。</p><p>那是因为它比ADD更易懂。COPY仅支持将本地文件复制到容器中，而ADD具有一些功能（如仅限本地的tar提取和远程URL支持），这些功能并不是很明显。因此，ADD的最佳用途是将本地tar文件自动提取到镜像中</p></blockquote><p>Docker镜像是Docker容器的源代码，类和对象实例的关系。</p><p>docker镜像本质：</p><blockquote><p>分层文件系统。</p><p>centos的镜像很小，复用了os的bootfs，只有其他层。tomcat镜像很大，因为依赖于其他的镜像。</p></blockquote><h2 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h2><p>选型</p><blockquote><table><thead><tr><th>MQ</th><th>描述</th></tr></thead><tbody><tr><td>RabbitMQ</td><td>erlang开发，对消息堆积的支持并不好，当大量消息积压的时候，会导致 RabbitMQ 的性能急剧下降。每秒钟可以处理几万到十几万条消息。</td></tr><tr><td>RocketMQ</td><td>java开发，面向互联网集群化功能丰富，对在线业务的响应时延做了很多的优化，大多数情况下可以做到毫秒级的响应，每秒钟大概能处理几十万条消息。</td></tr><tr><td>Kafka</td><td>Scala开发，面向日志功能丰富，性能最高。当你的业务场景中，每秒钟消息数量没有那么多的时候，Kafka 的时延反而会比较高。所以，Kafka 不太适合在线业务场景。</td></tr><tr><td>ActiveMQ</td><td>java开发，简单，稳定，性能不如前面三个。小型系统用也ok，但是不推荐。推荐用互联网主流的。</td></tr></tbody></table></blockquote><p>底层实现</p><blockquote><p>netty</p></blockquote><p>文件上传</p><blockquote><p>断点传输、文件秒传(已经上传过的不再上传)：hash</p></blockquote><p>文件传输粘包问题</p><blockquote><p>为何粘包：</p><p>A. TCP协议为了提高传输效率，发送方往往需要收集定量的数据才会封装给底层并发送，若出现连续send(data)，TCP会把该数据进行整合(直到装满数据缓冲区），这样就造成了粘包数据；<br>B. 接收方接收方的粘包是由于接收用户相关进程不及时接收数据，从而导致粘包问题，这是因为接收方先把接收到的数据放在系统接受缓冲区，用户进程从该缓冲区取定量的数据，但若下一包数据到达前，缓冲区的数据没有及时的被用户进程取走，则下一包数据与前一包部分数据在系统缓冲区，就可能导致用户设定的进程缓冲区从系统缓冲区取走两个包的部分数据，从而导致粘包</p><p>解决方案：</p><p>A 发送方在send()之前，先向接收方发送数据总量大小，并通过双端确认，server端发送数据包，然后接收方通过按数据量大小循环设立缓冲区接收数据;；<br>B: TCP提供了PUSH（强制数据立即传送）操作，但影响性能；</p></blockquote><p>传输文件的方式</p><blockquote><p>ftp、sftp</p></blockquote><p>事务消息：</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">问题：</span><br><span class="line">1、账号服务扣款成功了，通知积分系统也成功了，但是积分增加的时候失败了，数据不一致了。</span><br><span class="line">2、账号服务扣款成功了，但是通知积分系统失败了，所以积分不会增加，数据不一致了。</span><br><span class="line">rocketmq的解决方案：</span><br><span class="line">针对问题1：如果消费失败了，是会自动重试的，如果重试几次后还是消费失败，那么这种情况就需要人工解决了，比如放到死信队列里然后手动查原因进行处理等。</span><br><span class="line">针对问题2：RocketMQ针对第二个问题解决方案是：如果你扣款成功了，但是往mq写消息的时候失败了，那么RocketMQ会进行回滚消息的操作，这时候我们也能回滚我们扣款的操作。（通过半消息实现）</span><br></pre></td></tr></table></figure></blockquote><p>顺序消息：</p><blockquote><p>方案1：发送消息到一个queue中来保证顺序消费(MessageQueueSelector)。<br>方案2：线程数设置为1，且通过消息体判断到哪个queue进行消费。</p></blockquote><p>消息持久化</p><blockquote><p>Broker端拿到消息后先将消息、topic、queue等内容存到ByteBuffer里，然后去持久化到commitlog文件中。commitlog文件大小为1G，超出大小会新创建commitlog文件来存储，采取的nio方式。</p></blockquote><p>如何保证消息不丢失</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">消息消费的流程：</span><br><span class="line">生产阶段：Producer通过网络将消息发送给Broker，这个发送可能会发生丢失，比如网络延迟不可达等。</span><br><span class="line">存储阶段：Broker肯定是先把消息放到内存的，然后根据刷盘策略持久化到硬盘中，刚收到Producer的消息，在内存中了，但是异常宕机了，导致消息丢失。(持久化位置为commitlog)</span><br><span class="line">消费阶段：消费失败了其实也是消息丢失的一种变体吧。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">解决方案：</span><br><span class="line">生产阶段：</span><br><span class="line">1、通过同步发送来保证消息的成功送达。</span><br><span class="line">2、如果发送失败会重试，默认为三次，可通过api调整。producer.setRetryTimesWhenSendFailed(10);</span><br><span class="line">3、如果broker宕机，producer会重试发送到另一台broker</span><br><span class="line">同步发送+自动重试机制+多个Master节点</span><br><span class="line">存储阶段：</span><br><span class="line">1、同步刷盘来保证消息的不丢失，同样会损失一部分性能。（默认为异步）</span><br><span class="line">2、集群部署保证高可用。等Master和Slave都刷完盘后才去通知Producer说消息ok了。brokerRole=SYNC_MASTER</span><br><span class="line">消费阶段：</span><br><span class="line">1、手动ack</span><br><span class="line">2、自动重试15次，进入死信队列</span><br></pre></td></tr></table></figure></blockquote><p>发消息的时候选择queue的算法</p><blockquote><p>random、hash、自定义</p></blockquote><p>为什么同一个消费组设置不同tag会出现奇怪现象</p><blockquote><p>两个相同组的消费者c1,c2相同topic，订阅tag1,tag2。此时往这个topic的两个tag分别发送10条消息。会发现c1没有收到消息，c2只收到了不到10条消息。消息能够正常发送。</p><p>原因：broker的问题。<br>Consumer端发心跳给Broker，Broker收到后存到consumerTable里（就是个Map），key是GroupName，value是ConsumerGroupInfo。<br>ConsumerGroupInfo里面是包含topic等信息的，但是问题就出在上一步骤，key是groupName，你同GroupName的话Broker心跳最后收到的Consumer会覆盖前者的。</p><p>所以c1的tag1被覆盖，无法接收到消息。为何c2没有收到10条消息呢，因为是集群模式消费，所以会有负载均衡，有一部分消息到达了c1但tag为tag2，无法消费，所以c2只收到了几条消息而非10条。如果换为广播模式，则c2能接收到10条消息。</p><p>注意：一个consumer可以订阅多个topic(存在一个map以topic为键)</p></blockquote><p>消费者负载均衡策略</p><blockquote><ul><li>queue个数大于Consumer个数，且queue个数能整除Consumer个数的话， 那么Consumer会平均分配queue。（比如上面表格的<strong>Consumer有2个 可以整除</strong>部分）</li><li>queue个数大于Consumer个数，且queue个数不能整除Consumer个数的话， 那么会有一个Consumer多消费1个queue，其余Consumer平均分配。（比如上面表格的<strong>Consumer有3个 不可整除</strong>部分）</li><li>queue个数小于Consumer个数，那么会有Consumer闲置，就是浪费掉了，其余Consumer平均分配到queue上。（比如上面表格的<strong>Consumer有5个 无法都分配</strong>部分）</li></ul></blockquote><h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><p>单服务器抗压</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1.对socket方面的优化</span><br><span class="line">1）操作系统（linux）的设置：</span><br><span class="line">增大socket的最大连接数</span><br><span class="line">echo 50000 &gt; /proc/sys/net/core/somaxconn   (系统默认的值是128，现在改成50000)</span><br><span class="line">加快系统的tcp回收机制 （系统默认tcp在断开后还会存活一段时间） 方法如下</span><br><span class="line">echo  1 &gt; /proc/sys/net/ipv4/tcp_tw_recycle  (系统默认是0，修改为1)</span><br><span class="line">允许空的tcp回收利用 方法如下</span><br><span class="line">echo 1 &gt;/proc/sys/net/ipv4/tcp_tw_reuse  (系统默认为0，修改为1)</span><br><span class="line">让系统不做洪水抵御保护，（当系统检测到80端口在大量的请求时，会自动给返回信息中增加 cookie ,还验证客户端身份，从而避免受到攻击，但这时只是高并发，并不是攻击，所以要把这个抵御机制给关闭） 方法如下</span><br><span class="line">echo 0 &gt;/proc/sys/net/ipv4/tcp_syncookie (系统默认为1，修改为0) </span><br><span class="line"></span><br><span class="line">2）nginx的设置：</span><br><span class="line">增大子进程打开的连接 ，在event段中   worker_connections 1024;  nginx默认能打开1024个连接</span><br><span class="line">修改worker_connections 10000;  修改为可以打开10000个socket连接</span><br><span class="line"></span><br><span class="line">2.对文件系统方面的优化</span><br><span class="line">1）操作系统方面：</span><br><span class="line">让操作系统允许打开更多的文件 ulimit -n(设置一个比较大的值)</span><br><span class="line">ulimit -n 10240;     (把操作系统允许打开文件的最大值设为10240，原本的默认值是1024)</span><br><span class="line"></span><br><span class="line">2）nginx 配置子进程可以打开的文件个数</span><br><span class="line">在nginx全局的配置中  worker_processes 1;下面加上worker_limit_nofile 10240;</span><br><span class="line">work_limit_nofile 10240  ;  (nginx的子进程可以打开10240个文件)</span><br></pre></td></tr></table></figure></blockquote><p>进程模型</p><blockquote><p>nginx模型有两种进程，master进程和worker进程。master进程主要用来管理worker进程，管理包含：接收来自外界的信号，向各worker进程发送信号，监控worker进程的运行状态，当worker进程退出后(异常情况下)，会自动重新启动新的worker进程。</p><p>而基本的网络事件，则是放在worker进程中来处理了。多个worker进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的。一个请求，只可能在一个worker进程中处理，一个worker进程，不可能处理其它进程的请求。worker进程的个数是可以设置的，一般我们会设置与机器cpu核数一致.</p></blockquote><p>启动方式</p><blockquote><p>Nginx的启动方式有两种：</p><p>单进程启动：此时系统中只有一个进程，这个进程既是master进程，也是worker进程。</p><p>多进程启动：此时系统中有且仅有一个master进程，有多个worker进程，master进程主要是用来管理worker进程的。</p></blockquote><p><img src="https://i.loli.net/2021/03/12/1cXe8UoavICM5Ws.png" alt="image.png"></p><p>如何处理请求</p><blockquote><p>worker进程之间是平等的，每个进程，处理请求的机会也是一样的。</p><p>当我们提供80端口的http服务时，一个连接请求过来，每个进程都有可能处理这个连接。首先，每个worker进程都是从master进程fork过来，在master进程里面，先建立好需要listen的socket之后，然后再fork出多个worker进程，这样每个worker进程都可以去accept这个socket。</p><p>一般来说，当一个连接进来后，所有在accept在这个socket上面的进程，都会收到通知，而只有一个进程可以accept这个连接，其它的则accept失败，这是所谓的惊群现象（<strong>惊群现象（thundering herd）就是当多个进程和线程在同时阻塞等待同一个事件时，如果这个事件发生，会唤醒所有的进程，但最终只可能有一个进程/线程对该事件进行处理，其他进程/线程会在失败后重新休眠，这种性能浪费就是惊群。</strong>）</p><p>当然，nginx也不会视而不见，所以nginx提供了一个accept_mutex这个东西，从名字上，我们可以看这是一个加在accept上的一把共享锁。有了这把锁之后，同一时刻，就只会有一个进程在accpet连接，这样就不会有惊群问题了。accept_mutex是一个可控选项，我们可以显示地关掉，默认是打开的。</p><p>当一个worker进程在accept这个连接之后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才断开连接，这样一个完整的请求就是这样的了。我们可以看到，一个请求，完全由worker进程来处理，而且只在一个worker进程中处理。</p></blockquote><p>通信</p><blockquote><p>linux与nginx之间通过信号进行通信。<br>master进程与worker进程通过sockpair（全双工通信）进行通信（channel）<br>worker进程间则是通过比较快速的共享内存进行通信。（mmap内存映射、通过文件、通过system v）</p></blockquote><h2 id="数据库MySQL"><a href="#数据库MySQL" class="headerlink" title="数据库MySQL"></a>数据库MySQL</h2><p>脏读、不可重复读、幻读</p><blockquote><p>脏读：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个被修改的数据，然后使用了这个数据。事务读取到了其他事务修改并且未提交的数据。</p><p>不可重复读：一个事务多次读取同一数据，该数据记录会改变。(其他事务进行了数据的修改)</p><p>幻读：多次读取，后面读取时数据记录数量发生改变。(其他事务进行了数据的插入、删除操作)</p></blockquote><p>四种隔离级别：</p><blockquote><p>读未提交、读已提交、可重复读、串行化。</p><p>读已提交解决脏读；可重复读解决脏读和不可重复读；串行化解决所有问题</p></blockquote><p>索引、索引类型(Hash、B+、全文索引)</p><blockquote><p>innodb、MyIsam——数据节点存储数据 or 存储数据地址(指针) </p><p>MyISAM索引文件和数据文件分开——非聚集索引、InnoDB则是索引文件和数据文件在一起——聚集索引。</p><p>主键索引、辅助索引。</p><p>最左前缀匹配。</p><p>索引类型：</p><p>1.普通索引；2.唯一索引；3.主键索引；4.组合索引；5.全文索引（innodb不支持）</p></blockquote><p>聚簇索引和非聚簇索引</p><blockquote><p>聚簇索引：索引和数据一起存放(innodb)，非聚簇索引：索引的叶节点是指针指向对应的数据，分开存放(myisam)</p><p>插入数据时，聚簇索引需要排序，非聚簇索引则需要维护索引到数据的指针。非聚集索引会存在索引和数据的两次io，更耗时。</p></blockquote><p>innodb四大特性</p><blockquote><p>插入缓存、两次写、自适应hash、提前读<a href="https://note.youdao.com/ynoteshare1/index.html?id=a6004953a0a7c80073ac74d8e76f1ebd&type=note" target="_blank" rel="noopener">click here</a> or <a href="https://www.jianshu.com/p/dcc0dc450a2c" target="_blank" rel="noopener">there</a></p></blockquote><p>innodb底层详解</p><blockquote><p>InnoDB的内存架构主要分为三大块，<strong>缓冲池</strong>（Buffer Pool）、<strong>重做缓冲池</strong>（Redo Log Buffer）和<strong>额外内存池</strong></p><p>缓冲池采用了<strong>LRU</strong>算法，但可能导致缓冲池污染。</p><p>mysql在写入记录前，会先记录到redo log，用于刷盘。</p><p>插入缓存：等数据达到某个阈值（例如50条）才批量的写入磁盘，降低io。</p><p>两次写：<strong>插入缓冲</strong>提高了MySQL的性能，而<strong>两次写</strong>则在此基础上提高了数据的可靠性。我们知道，当数据还在缓冲池中的时候，当机器宕机了，发生了<strong>写失效</strong>，有Redo Log来进行恢复。但是如果是在从缓冲池中将数据刷回磁盘的时候宕机了呢？这种情况叫做<strong>部分写失效</strong>，此时重做日志就无法解决问题。</p><p>在刷脏页时，并不是直接刷入磁盘，而是copy到内存中的Doublewrite Buffer中，然后再拷贝至磁盘共享表空间（你可以就理解为磁盘）中，每次写入1M，等copy完成后，再将Doublewrite Buffer中的页写入磁盘文件。有了两次写机制，即使在刷脏页时宕机了，在实例恢复的时候也可以从共享表空间中找到Doublewrite Buffer的页副本，直接将其覆盖原来的数据页即可。</p><p>自适应哈希索引：参考jit热点代码，对热点索引进行hash。</p><p>提前读：innodb中将64个页划分为一个extent，当一个extent中的页，被顺序读超过了多少个，比如50个，这个值是可以通过nnodb_read_ahead_threshold设置的，那么就会认为顺序读到下一个extent的可能性很大，会提前将下一个extent中的所有页都加载到buffer pool中，这叫线性预读</p></blockquote><p>间隙锁</p><blockquote><p>Innodb在<strong>可重复读</strong>提交下为了解决<strong>幻读</strong>问题时引入的锁机制。</p><p>针对范围查询，例如查询id为1-9之间的所有数据（前提，数据库中没有id为2 4 6的数据），但是范围锁就会将1-9的所有都锁上，如果此时想要插入一条id为2的数据，是无法插入的，会导致阻塞。</p><p>间隙锁可能导致死锁，间隙锁之间并不是互斥的。</p></blockquote><p>解决mysql读写效率</p><blockquote><p>sql优化、索引、缓存、主从复制+读写分离、垂直拆分（分布式）、水平拆分（解决主键问题）、分区</p></blockquote><p>MVCC原理</p><blockquote><p>多版本并发控制技术。保存数据的历史版本。可以通过比较版本号决定数据是否显示出来。读取数据的时候不需要加锁可以保证事务的隔离效果。</p><p>innodb：更新前建立undo log，根据各种策略读取时非阻塞就是MVCC，undo log中的行就是MVCC中的多版本。即：事务更新某记录时，先用排他锁锁定，然后copy一份记录到undo log然后让roll_ptr指向undo log，然后进行更新并填写事务编号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">解决读写之间阻塞的问题，通过 MVCC 可以让读写互相不阻塞，读不相互阻塞，写不阻塞读，这样可以提升数据并发处理能力。</span><br><span class="line">降低了死锁的概率，这个是因为 MVCC 采用了乐观锁的方式，读取数据时，不需要加锁，写操作，只需要锁定必要的行。</span><br><span class="line">解决了一致性读的问题，当我们朝向某个数据库在时间点的快照是，只能看到这个时间点之前事务提交更新的结果，不能看到时间点之后事务提交的更新结果。</span><br></pre></td></tr></table></figure><p><strong>InnoDB 的 MVCC 是如何实现的？</strong></p><p>InnoDB 是如何存储记录多个版本的？这些数据是 事务版本号，行记录中的隐藏列(row_id, tx_id, roll_ptr)和Undo Log。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">事务查询行记录：</span><br><span class="line">当前事务的 creator_trx_id 想要读取某个行记录，这个行记录ID的trx_id ，这样会有以下的情况：</span><br><span class="line">如果 trx_id &lt; 活跃的最小事务ID（up_limit_id）,也就是说这个行记录在这些活跃的事务创建前就已经提交了，那么这个行记录对当前事务是可见的。</span><br><span class="line">如果trx_id &gt; 活跃的最大事务ID（low_limit_id），这个说明行记录在这些活跃的事务之后才创建，说明这个行记录对当前事务是不可见的。</span><br><span class="line">如果 up_limit_id &lt; trx_id &lt;low_limit_id,说明该记录需要在 trx_ids 集合中，可能还处于活跃状态，因此我们需要在 trx_ids 集合中遍历，如果trx_id 存在于 trx_ids 集合中，证明这个事务 trx_id 还处于活跃状态，不可见，否则 ，trx_id 不存在于 trx_ids 集合中，说明事务trx_id 已经提交了，这行记录是可见的。</span><br><span class="line"></span><br><span class="line">如何查询一条记录</span><br><span class="line">1、获取事务自己的版本号，即事务ID</span><br><span class="line">2、获取 Read View</span><br><span class="line">3、查询得到的数据，然后 Read View 中的事务版本号进行比较。</span><br><span class="line">4、如果不符合 ReadView 规则， 那么就需要 UndoLog 中历史快照；</span><br><span class="line">5、最后返回符合规则的数据</span><br><span class="line">InnoDB 实现多版本控制 （MVCC）是通过 ReadView + UndoLog 实现的，UndoLog 保存了历史快照，ReadView 规则帮助判断当前版本的数据是否可见。</span><br></pre></td></tr></table></figure><p>innodb如何保证崩溃恢复能力</p><blockquote><p>两阶段日志提交</p></blockquote></blockquote><p>MVCC下的一些操作</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">增删查改</span><br><span class="line">在InnoDB中，给每行增加两个隐藏字段来实现MVCC，一个用来记录数据行的创建时间，另一个用来记录行的过期时间（删除时间）。在实际操作中，存储的并不是时间，而是事务的版本号，每开启一个新事务，事务的版本号就会递增。</span><br><span class="line">于是乎，默认的隔离级别（REPEATABLE READ）下，增删查改变成了这样：</span><br><span class="line"></span><br><span class="line">SELECT：读取创建版本小于或等于当前事务版本号，并且删除版本为空或大于当前事务版本号的记录。这样可以保证在读取之前记录是存在的。</span><br><span class="line">INSERT：将当前事务的版本号保存至行的创建版本号</span><br><span class="line">UPDATE：新插入一行，并以当前事务的版本号作为新行的创建版本号，同时将原记录行的删除版本号设置为当前事务版本号</span><br><span class="line">DELETE：将当前事务的版本号保存至行的删除版本号</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">快照读和当前读</span><br><span class="line">快照读：读取的是快照版本，也就是历史版本</span><br><span class="line">当前读：读取的是最新版本</span><br><span class="line">普通的SELECT就是快照读，而UPDATE、DELETE、INSERT、SELECT ...  LOCK IN SHARE MODE、SELECT ... FOR UPDATE是当前读。</span><br></pre></td></tr></table></figure></blockquote><p>read-view(一致性视图)</p><blockquote><p>未提交的事务id数组以及当前已经创建(不论是否提交)的最大事务id。(【未提交事务id】，max_id)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">当执行查询sql时会生成一致性视图read-view，它由执行查询时所有未提交事务id数组(数组里最小的id为min_id)和已创建的最大事务id (max_id)组成，查询的数据结果需要跟read-view做比对从而得到快照结果</span><br><span class="line">版本链比对规则:</span><br><span class="line">1.如果落在绿色部分( trx_id &lt; min_id )，表示这个版本是已提交的事务生成的，这个数据是可见的;</span><br><span class="line">2.如果落在红色部分( trx id &gt; max_id )，表示这个版本是由将来启动的事务生成的，是肯定不可见的;</span><br><span class="line">3.如果落在黄色部分(min_ id &lt;= trx_id &lt;= max_id)，那就包括两种情况</span><br><span class="line">a.若row的trx_id在数组中，表示这个版本是由还没提交的事务生成的，不可见，当前自己的事务是可见的;</span><br><span class="line">b.若row的trx_id不在数组中，表示这个版本是已经提交了的事务生成的，可见。</span><br><span class="line">对于删除的情况可以认为是update的特殊情况，会将版本链上最新的数据复制一份，然后将trx_id修改成删除操作的trx_id，同时在该条记录的头信（record header)里的(deleted_flag)标记位写上true，来表示当前记录已经被删除，在查间时按照上面的规则查到对应的记录如果delete flag标记位为true，意味着记录已被删除，则不返回数据。</span><br></pre></td></tr></table></figure><p>如果是可重复读的隔离级别，则MVCC中每个select记录使用的是之前select的read-view，即进行延用而非重新创建。（当一个session发起第一个查询时，此刻对应的全表的read-view已经确定了，之后的查询都会使用该read-view）</p><p>而如果是读已提交的隔离界别，则MVCC中每个select记录都会重新生成read-view。</p></blockquote><p>行锁和表锁(具体)</p><blockquote><p>行锁：锁定一行或者多行记录，<strong>行锁是基于索引加载的</strong>，可能死锁。<br>表锁：没有触发索引，则会锁表。<strong>表锁响应的是非索引字段，即全表扫描</strong>，不会死锁。</p></blockquote><p>如何实现的隔离级别</p><blockquote><p>读写锁 or MVCC。</p><p>事务看到的是自己查询时候的快照ReadView。</p></blockquote><p>回表查询</p><blockquote><p>第一遍定位主键值，再定位行记录，它的性能较扫一遍索引树更低。</p></blockquote><p>索引覆盖</p><blockquote><p>查询时不需要回表查询，直接通过索引就可以获取查询的结果数据，extra：using index代表索引覆盖</p></blockquote><p>mysql，数据查询慢怎么办</p><blockquote><p>慢查询抓取sql语句，然后用explain执行计划判断，建索引，B+树，为什么可以增快速度。</p></blockquote><p>explain</p><blockquote><p>id、select_type、table、partitions、type、possible_keys、key、key_len、ref、row、filtered、Extra</p></blockquote><p>分库、分表、分区</p><blockquote><p>就搞一个主库，挂多个从库，然后我们就单单只是写主库，然后主库会自动把数据给同步到从库上去。读从库。主从复制，binlog。</p><p>分库：垂直按功能模块切分、水平减少数据库压力、数据隔离、功能切分。</p><p>分表：数据冗余问题、热点数据等等。</p></blockquote><p>mysql主从复制原理</p><blockquote><p>①为何需要主从复制？</p><blockquote><p>并发量大时，需要读写分离，主库负责写，从库负责读，即使需要锁表，对读的性能也没有影响。<br>数据的预热。<br>降低单机IO压力。</p></blockquote><p>②主从复制原理(bin log)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">原理：</span><br><span class="line">1)、在master机器上的操作：</span><br><span class="line">当master上的数据发生变化时，该事件变化会按照顺序写入bin-log中。当slave链接到master的时候，master机器会为slave开启binlog dump线程。当master的binlog发生变化的时候，bin-log dump线程会通知slave，并将相应的binlog内容发送给slave。</span><br><span class="line">2)、在slave机器上操作：</span><br><span class="line">当主从同步开启的时候，slave上会创建两个线程：I\O线程。该线程连接到master机器，master机器上的binlog dump 线程会将binlog的内容发送给该I\O线程。该I/O线程接收到binlog内容后，再将内容写入到本地的relay log；sql线程。该线程读取到I/O线程写入的ralay log。并且根据relay log。并且根据relay log 的内容对slave数据库做相应的操作。</span><br><span class="line"></span><br><span class="line">也就是说：</span><br><span class="line">    - 从库会生成两个线程,一个I/O线程,一个SQL线程;</span><br><span class="line">    - I/O线程会去请求主库的binlog,并将得到的binlog写到本地的relay-log(中继日志)文件中;</span><br><span class="line">    - 主库会生成一个log dump线程,用来给从库I/O线程传binlog;</span><br><span class="line">    - SQL线程,会读取relay log文件中的日志,并解析成sql语句逐一执行;</span><br></pre></td></tr></table></figure><p>③三种主要实现粒度</p><blockquote><p>详细的主从同步主要有三种形式：statement、row、mixed<br>1)、statement: 会将对数据库操作的sql语句写道binlog中<br>2)、row: 会将每一条数据的变化写道binlog中。<br>3)、mixed: statement与row的混合。Mysql决定何时写statement格式的binlog, 何时写row格式的binlog。</p></blockquote><p>④主从复制延迟问题</p><blockquote><p>原因：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1)、MySQL数据库主从同步延迟原理mysql主从同步原理：主库针对写操作，顺序写binlog，从库单线程去主库顺序读”写操作的binlog”，从库取到binlog在本地原样执行（随机写），来保证主从数据逻辑上一致。mysql的主从复制都是单线程的操作，主库对所有DDL和DML产生binlog，binlog是顺序写，所以效率很高，slave的Slave_IO_Running线程到主库取日志，效率比较高，下一步，问题来了，slave的Slave_SQL_Running线程将主库的DDL和DML操作在slave实施。DML和DDL的IO操作是随即的，不是顺序的，成本高很多，还可能可slave上的其他查询产生lock争用，由于Slave_SQL_Running也是单线程的，所以一个DDL卡主了，需要执行10分钟，那么所有之后的DDL会等待这个DDL执行完才会继续执行，这就导致了延时。有朋友会问：“主库上那个相同的DDL也需要执行10分，为什么slave会延时？”，答案是master可以并发，Slave_SQL_Running线程却不可以。</span><br><span class="line"></span><br><span class="line">2)、MySQL数据库主从同步延迟是怎么产生的？当主库的TPS并发较高时，产生的DDL数量超过slave一个sql线程所能承受的范围，那么延时就产生了，当然还有就是可能与slave的大型query语句产生了锁等待。首要原因：数据库在业务上读写压力太大，CPU计算负荷大，网卡负荷大，硬盘随机IO太高次要原因：读写binlog带来的性能影响，网络传输延迟。</span><br></pre></td></tr></table></figure><p>解决方案：</p><p>①硬件方面；②禁用从库binlog；③分担压力等等</p></blockquote></blockquote><p>事务如何实现隔离性</p><blockquote><p>读写锁 or MVCC</p></blockquote><p>三大范式</p><blockquote><p>1NF：字段不可分<br>2NF：属性完全依赖于主键<br>3NF：属性不依赖于其它非主属性   属性直接依赖于主键<br>BCNF：无传递依赖</p></blockquote><p>事务特性</p><blockquote><p>ACID，原子性、一致性、隔离性、持久性</p><p>一致性：数据前后的完整性。</p></blockquote><p>sql很慢优化：</p><blockquote><p>索引、拆分表、大字段、减少函数运算、内存、cpu</p></blockquote><p>自增id用完</p><blockquote><p>id边界值使用后，越过此边界值插入数据会失败。主键冲突、无法插入。使用big int or 自己的主键</p></blockquote><p>mysql和redis数据一致性保证</p><blockquote></blockquote><p>索引下推</p><blockquote><p>即如果下图中<code>name</code>也有索引，则会将其过滤也放在底层进行过滤，进而增大效率。</p><p><img src="https://i.loli.net/2021/02/05/6zs9MQZ4KPrLpFc.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在不使用ICP的情况下，在使用非主键索引（又叫普通索引或者二级索引）进行查询时，存储引擎通过索引检索到数据，然后返回给MySQL服务器，服务器然后判断数据是否符合条件 。</span><br><span class="line">在使用ICP的情况下，如果存在某些被索引的列的判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器 。</span><br><span class="line">索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少MySQL服务器从存储引擎接收数据的次数。</span><br></pre></td></tr></table></figure></blockquote><p>join和union区别</p><blockquote><p>join是通过on上面的条件进行的</p><p>union则是将两个结果集进行合并</p></blockquote><p>窗口函数(用于组内排名)</p><blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本语法</span></span><br><span class="line">&lt;窗口函数&gt; over (partition by &lt;用于分组的列名&gt; order by &lt;用于排序的列名&gt;)</span><br><span class="line"><span class="comment"># rank, dense_rank, row_number</span></span><br><span class="line"><span class="comment"># rank排名会间隔 如 1 2 2 4 5...</span></span><br><span class="line"><span class="comment"># 而dense_rank则不会间隔 如 1 2 2 3 4 5</span></span><br><span class="line"><span class="comment"># row_number则不考虑并列的情况</span></span><br></pre></td></tr></table></figure><p>&lt;窗口函数&gt;的位置，可以放以下两种函数：</p><p>1） 专用窗口函数，包括后面要讲到的rank, dense_rank, row_number等专用窗口函数。</p><p>2） 聚合函数，如sum. avg, count, max, min等</p><p>因为窗口函数是对where或者group by子句处理后的结果进行操作，所以<strong>窗口函数原则上只能写在select子句中</strong>。</p><p><strong>partition by用来对表分组</strong>，<strong>order by子句的功能是对分组后的结果进行排序(默认asc)</strong>。</p><p>partition by不会改变表的行数，而group by则会改变。</p><p>对于聚合函数，则会在分组内，按顺序进行。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select *,</span><br><span class="line">   sum(成绩) over (order by 学号) as current_sum,</span><br><span class="line">   avg(成绩) over (order by 学号) as current_avg,</span><br><span class="line">   count(成绩) over (order by 学号) as current_count,</span><br><span class="line">   max(成绩) over (order by 学号) as current_max,</span><br><span class="line">   min(成绩) over (order by 学号) as current_min</span><br><span class="line">from 班级表</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/03/14/xqXi9wM2LfDs3ok.png" alt="image.png"></p></blockquote><p>数据库分库分表主键处理</p><blockquote><p>①使用自增主键，适用于数据量大并发较小需要分表的情况。<br>②设置数据库 sequence 或者表自增字段步长。比如说，现在有 8 个服务节点，每个服务节点使用一个 sequence 功能来产生 ID，每个 sequence 的起始 ID 不同，并且依次递增，步长都是 8。方案简单，但是如果需要增加服务节点时，就较为麻烦。<br>③UUID，好处就是本地生成，不用基于数据库来了；不好之处就是，UUID 太长了、占用空间大，<strong>作为主键性能太差</strong>了，会导致索引效率低下<br>④snowflake 算法，把一个 64 位的 long 型的 id，1 个 bit 是不用的，用其中的 41 bit 作为毫秒数，用 10 bit 作为工作机器 id，12 bit 作为序列号。</p></blockquote><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>工厂模式、单例模式、原型模式、装饰器模式、代理模式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">工厂：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。</span><br><span class="line">单例：懒汉、饿汉、双重检验锁懒汉</span><br><span class="line"> public static Singleton getSingleton() &#123;  </span><br><span class="line">    if (singleton == null) &#123;  </span><br><span class="line">        synchronized (Singleton.class) &#123;  </span><br><span class="line">            if (singleton == null) &#123;  </span><br><span class="line">                singleton = new Singleton();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return singleton;  </span><br><span class="line">&#125;  </span><br><span class="line">原型模式：创建对象代价太大 采用实现Cloneable接口和重写clone方法</span><br><span class="line">装饰器模式：装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。</span><br><span class="line">代理模式：jdk代理和cglib代理</span><br></pre></td></tr></table></figure><h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>CAP</p><blockquote><ul><li>一致性(<strong>C</strong>onsistency)</li><li>可用性(<strong>A</strong>vailability)</li><li>分区容忍性(<strong>P</strong>artition tolerance)</li></ul></blockquote><p>BASE</p><blockquote><ul><li>Basically Availble –基本可用</li><li>Soft-state –软状态/柔性事务</li></ul><blockquote><p>“Soft state” 可以理解为”无连接”的, 而 “Hard state” 是”面向连接”的</p></blockquote><ul><li>Eventual Consistency –最终一致性</li></ul></blockquote><p>最终一致性（分布式事务）</p><blockquote><p>2PL，两阶段提交。</p><p>消息重试、补偿交易、事务消息、接口支持重入</p></blockquote><p>什么是可重入</p><blockquote></blockquote><h2 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h2><p>wc</p><blockquote><p>wc [-clw] 文件*</p><p>计算文件的行数 单词数 字节数</p><p>-c或–bytes或–chars 只显示Bytes数。-l或–lines 显示行数。-w或–words 只显示字数。</p><p>可以跟多个文件，则会都显示并进行汇总</p></blockquote><p>Linux查看内存, cpu的占有率的命令</p><blockquote><p>top</p></blockquote><p>netstat、find、cat、cp、mv、su、ftp（ftp+ip）</p><blockquote><p>netstat 命令用于显示网络状态。-a显示所有套接字和端口。例子：TCP    192.168.9.52:1299      60.210.8.160:https     CLOSE_WAIT</p><p>find命令格式：find path -xxx expression。将当前目录及其子目录下所有文件后缀为 <strong>.c</strong> 的文件列出来：find . -name “*.c”</p><p>把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：cat -n textfile1 &gt; textfile2 （-b和-n相似只是-b不会把空白行输出）</p></blockquote><p>chmod</p><blockquote><p>chmod [owner group others]<br>RWX——777</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 file</span><br></pre></td></tr></table></figure></blockquote><p>telnet</p><blockquote><p>telnet + ip登陆远程主机</p></blockquote><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>反转链表：递归、迭代</p><p>删除字符串中的空格，时间O(n)，空间O(1)</p><p>写一个程序判断机器是大端法还是小端法（什么是大端、什么是小端）</p><blockquote><p>小端法：低地址存放低位，高地址存放高位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0x11223344</span>;</span><br><span class="line"><span class="keyword">char</span> *c = (<span class="keyword">char</span>*)(&amp;i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%x"</span>, *c); <span class="comment">// 0x44-小端 0x11-大端</span></span><br></pre></td></tr></table></figure></blockquote><p>很长的英文论文，统计出现最高频的k个单词。(hashmap + 堆)</p><p>一组无序的数，找出中位数。(快速选择，O(n))</p><p>熟悉的排序算法(归并、快排、冒泡、插入、选择) 从小到大</p><blockquote><p>插入排序：从第二个数开始，和前面的数进行比较，如果比前面的数小，则交换，直到没有比该数大的数。继续遍历下一个数。</p><p>选择排序：从当前遍历到的数开始遍历到结尾，找到最小的数，和当前数交换，直到遍历完数组。</p><p>冒泡排序：每一趟排序，将相邻的两个数进行比较，小的放在前面。重复len - 1趟，且每一趟都能确定len - 1 - i个数。</p><p>归并排序：分治 + 双指针。</p><p>快速排序：分治 + 选取枢纽。</p><p>稳定：插入、冒泡、归并</p><p>不稳定：选择、快排、堆排序</p></blockquote><p>10亿个数排序后打印，内存有限（拆分成小文件并排好序分别放入小文件，然后每个文件进行读取首数据然后关闭然后读取下一个文件，可以利用堆排序实现大文件的有序）</p><p>从100万个数中找出最大的前100个数（快速选择 or 维护最大堆）</p><p>java操作有500万数据的大表如何操作（多线程？分表？limit分页？）</p><p>两个线程交替打印1-100</p><p>分布锁？</p><p>下层层序序列的完全二叉树 打印前序遍历结果</p><p>找出一个字符串有多少回文字串，输出最大的</p><p>Leetcode 1438</p><p>最长上升子序列(需要输出子序列)</p><p>64匹马 8条赛道 找出跑的最快的4匹 最少需要几场比赛（11）</p><p>lru</p><p>高并发设计：</p><blockquote><p>拆分为服务、缓存、mq、分库分表、读写分离、分布式</p></blockquote><p>如果不用红黑树，怎么把hash后桶上的链表存入到磁盘空间内，要怎么设计 磁盘内的存储方式?</p><blockquote><p>桶上的链表再进行一次hash。<br>——————————<br>——————<br>————<br>———<br>—<br>👆这样划分磁盘的存储空间，使记录hash后的值时先在最大的那块记录，有冲突就往第二大的快记录。使最大的磁盘块能直接返回值，防止hash冲突。</p></blockquote><p>位运算实现加法</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">0 + 0 = 0 不进位</span><br><span class="line">1 + 0 = 1 不进位</span><br><span class="line">0 + 1 = 1 不进位</span><br><span class="line">1 + 1 = 0 进位1</span><br><span class="line">--------------</span><br><span class="line">加法本身：a ^ b</span><br><span class="line">进位：(a &amp; b) &lt;&lt; 1</span><br><span class="line">--------------</span><br><span class="line">结论：设a，b为两个二进制数，则a+b = a^b + (a&amp;b)&lt;&lt;1。</span><br><span class="line">证明：a^b是不考虑进位时加法结果。当二进制位同时为1时，才有进位，因此 (a&amp;b)&lt;&lt;1是进位产生的值，称为进位补偿。将两者相加便是完整加法结果。</span><br><span class="line">后续的加法通过递归即可</span><br><span class="line">public int add(int a, int b) &#123;</span><br><span class="line">    if (b == 0) return a; // 进位为0时退出递归</span><br><span class="line">    return add(a ^ b, (a &amp; b) &lt;&lt; 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>4亿个unsigned int型的数让你保存，然后给你一个数，判断它是否存在已经保存的数中。</p><blockquote><p>bitmap</p></blockquote><p>高考成绩查询高并发</p><blockquote><p>省份、成绩区间分库分表</p><p>redis预热数据</p><p>前端页面提前缓存CDN</p><p>nginx负载均衡</p><p>中间件</p></blockquote><p>三数之和</p><p>lc 678</p><p>lc 316(单调栈 + 贪心)</p><p>场景题：两堆大数，100亿个数和10亿个数，找交集</p><p>场景题：直播房间，一个大V发了一条消息，如何让上千万的粉丝收到这条消息，如果只是纯粹的广播会很耗资源</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/2021/03/05/jvm/"/>
      <url>/2021/03/05/jvm/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h3 id="JVM的架构模型"><a href="#JVM的架构模型" class="headerlink" title="JVM的架构模型"></a>JVM的架构模型</h3><p>Java编译器输入的指令基本是一种<strong>基于栈的指令集架构</strong>，另外一种架构则是基于寄存器的指令集架构。</p><a id="more"></a><blockquote><p>栈：跨平台性、指令集小，但指令较多。执行性能比寄存器架构差一些。<br>寄存器：性能较好、指令少但是和硬件耦合性强，无法实现跨平台。</p></blockquote><h3 id="JVM的生命周期"><a href="#JVM的生命周期" class="headerlink" title="JVM的生命周期"></a>JVM的生命周期</h3><p>启动：通过引导类加载器(bootstrap class loader)创建一个初始类来完成的，该类由虚拟机具体实现指定。</p><p>执行：执行java程序。程序执行的时候就运行，程序结束的时候就停止。执行一个Java程序时，真实在执行的时候是一个进程。</p><p>退出：以下几种情况：①程序正常执行结束；②程序执行过程中出现异常或错误；③OS出现错误导致Java虚拟机进程终止；④某线程调用Runtime类或者System类的exit()方法或者Runtime类的halt()方法，且Java安全管理器也允许此次操作。⑤除此之外，JNI ( Java Native Interface)规范描述了用JNI Invocation API来加载或卸载Java虚拟机时，Java虚拟机的退出情况。</p><h3 id="JVM发展历程"><a href="#JVM发展历程" class="headerlink" title="JVM发展历程"></a>JVM发展历程</h3><p>Sun Classic VM：世界上第一款商用Java虚拟机，JDK 1.4时被完全淘汰。内部只提供解释器而没有JIT。</p><p>Exact VM：准确式内存管理，可以知道内存中某个位置的数据具体是什么类型。也已经能够编译器解释器混合工作和具备热点检测的功能。JDK 1.2时提供该虚拟机。</p><p>HotSpot VM：JDK 1.3时，HotSpot称为默认虚拟机。其名称即热点代码检测技术，通过计数器来找到热点代码触发即时编译或栈上替换。</p><blockquote><p>解释器——保证响应时间，编译器——保证执行性能。</p></blockquote><p>JRockit ：专注于服务器端应用，内部不包含解释器实现，全部靠JIT编译执行。是世界上最快的JVM。</p><p>J9：与HotSpot市场定位相似，在自家产品上性能很好。</p><h2 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h2><h3 id="内存结构概述"><a href="#内存结构概述" class="headerlink" title="内存结构概述"></a>内存结构概述</h3><p>见图</p><h3 id="类加载器和类加载过程"><a href="#类加载器和类加载过程" class="headerlink" title="类加载器和类加载过程"></a>类加载器和类加载过程</h3><ul><li>类加载器子系统负责从文件系统或者网络中加载class文件，class文件在文件开头有特定的文件标识。</li><li>ClassLoader只负责class文件的加载，至于它是否可以运行，则由ExecutionEngine决定。</li><li>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射)</li></ul><p>加载(Loading)：</p><blockquote><p>1．通过一个类的全限定名获取定义此类的二进制字节流<br>2．将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构<br>3．<font color="red">在内存中生成一个代表这个类的java.lang.Class对象</font>，作为方法区这个类的各种数据的访问入口</p><p>笔者理解：加载阶段内存中已经存在Class对象。</p></blockquote><p>补充: 加载.class文件的方式</p><blockquote><ul><li>从本地系统中直接加载</li><li>通过网络获取，典型场景: web Applet</li><li>从zip压缩包中读取，成为日后jar、war格式的基础</li><li>运行时计算生成，使用最多的是:动态代理技术</li><li>由其他文件生成，典型场景：JSP应用</li><li>从专有数据库中提取.class文件，比较少见</li><li>从加密文件中获取，典型的防class文件被反编译的保护措施</li></ul></blockquote><p>链接(Linking)：</p><blockquote><p>验证(Verify):</p><blockquote><ul><li>目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，<br>不会危害虚拟机自身安全。</li><li>主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</li></ul></blockquote><p>准备(Prepare):</p><blockquote><ul><li>为类变量分配内存并且设置该类变量的默认初始值，即零值。</li><li>这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式<br>初始化;</li><li>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。</li></ul><p>笔者理解：将所有类变量初始化为默认值。</p></blockquote><p>解析(Resolve) :</p><blockquote><ul><li>将常量池内的符号引用转换为直接引用的过程。</li><li>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。</li><li>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</li><li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的<br>CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等</li></ul></blockquote></blockquote><p>初始化(initialization)：</p><blockquote><ul><li>初始化阶段就是执行类构造器方法&lt;clinit&gt;()的过程。</li><li>此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。</li><li>构造器方法中指令按语句在源文件中出现的顺序执行。</li><li>&lt;clinit&gt;()不同于类的构造器。(关联：构造器是虚拟机视角下的&lt;init&gt;())若该类具有父类，JVM会保证子类的&lt;clinit&gt;()执行前，父类的&lt;clinit&gt;()己经执行完毕。</li><li>虚拟机必须保证一个类的&lt;clinit&gt;()方法在多线程下被同步加锁。</li></ul><p>笔者理解：clinit方法即赋值类的所有静态变量以及执行静态代码块。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        num = <span class="number">10</span>;</span><br><span class="line">        number = <span class="number">20</span>;</span><br><span class="line">        System.println.out(number); <span class="comment">// 报错 非法前向引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">10</span>; </span><br><span class="line">    <span class="comment">// Linking的prepare阶段：number = 0 --&gt; initial: number = 20 --&gt; number = 10</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.println.out(number); <span class="comment">// 10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h3><p>JVM支持两种类型的类加载器，分别为引导类加载器(BootstrapClassLoader[由c、c++实现])和自定义类加载器(User-Defined classLoader） 。</p><p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。</p><p>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有4类，启动类加载器、扩展类加载器、系统类加载器、用户自定义加载器。且这里的四者之间的关系是包含关系。不是上层下层，也不是子父类的继承关系。</p><p>启动类加载器：</p><blockquote><p>这个类加载使用c/c++语言实现的，嵌套在JVM内部。</p><p>它用来加载Java的核心库（JAVA_HOME/jre/ lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类.</p><p>并不继承自java.lang.ClassLoader，没有父加载器。</p><p>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</p><p>出于安全考虑，Bootstrap启动类加载器只加载包名为java、 javax、sun等开头的类</p></blockquote><p>扩展类加载器（Extension classLoader)</p><blockquote><p>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</p><p>派生于classLoader类</p><p>父类加载器为启动类加载器</p><p>从java.ext.dirs系统属性所指定的目录加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录)下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</p></blockquote><p>应用程序类加载器（系统类加载器，AppclassLoader)</p><blockquote><p>java语言编写由sun.misc.Launcher$AppclassLoader实现</p><p>派生于classLoader类</p><p>父类加载器为扩展类加载器</p><p>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</p><p>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</p><p>通过ClassLoader.getSystemClassLoader()方法可以获取到该类加载器</p></blockquote><p>用户自定义类加载器</p><blockquote><p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。</p><p>为什么要自定义类加载器?</p><blockquote><p>隔离加载类(防止中间件和框架之间的冲突)</p><p>修改类加载的方式</p><p>扩展加载源</p><p>防止源码泄漏</p></blockquote><p>用户自定义类加载器实现步骤:</p><ul><li>开发人员可以通过继承抽象类java.lang.classLoader类的方式，实现自己的类加载器，以满足一些特殊的需求</li><li>在JDK1.2之前，在自定义类加载器时，总会去继承classLoader类并重写loadclass ()方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖loadclass ()方法，而是建议把自定义的类加载逻辑写在findclass()方法中</li><li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写findclass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li></ul></blockquote><h3 id="ClassLoader类"><a href="#ClassLoader类" class="headerlink" title="ClassLoader类"></a>ClassLoader类</h3><p>抽象类，其后所有类加载器都继承于该类(除了启动类加载器)。</p><table><thead><tr><th align="center">方法名称</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">getParent()</td><td align="center">返回该类加载器的超类加载器</td></tr><tr><td align="center">loadClass(String name)</td><td align="center">加载名称为name的类，返回结果为java.lang.Class类的实例</td></tr><tr><td align="center">findClass(String name)</td><td align="center">查找名称为name的类，返回结果为java.lang.Class类的实例</td></tr><tr><td align="center">findLoadedClass(String name)</td><td align="center">查找名称为name的已经被加载过的类，返回结果为java.lang.Class类的实例</td></tr><tr><td align="center">defineClass(String name, byte[] b, int off, int len)</td><td align="center">把字节数组b中的内容转换为一个Java类，返回结果为java.lang.Class类的实例</td></tr><tr><td align="center">resolveClass(Class&lt;?&gt; c)</td><td align="center">连接指定的一个Java类</td></tr></tbody></table><p>获取ClassLoader的途径</p><blockquote><p>获取当前类的类加载器：class.getClassLoader()</p><p>获取当前线程上下文的类加载器：Thread.currentThread().getContextClassLoader()</p><p>获取系统的类加载器：ClassLoader.getSystemClassLoader()</p><p>获取调用者的类加载器：DriverManager.getCallerClassLoader()</p></blockquote><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>Java虚拟机对class文件采用的是<font color="red">按需加载</font>的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是<font color="red">双亲委派模式</font>即把请求交由父类处理,它是一种任务委派模式。</p><p><font color="red">工作原理</font></p><blockquote><p>1)如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类豳加载器去执行;<br>2)如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器<br>3)如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</p></blockquote><p>双亲委派机制的优势</p><blockquote><p>避免类的重复加载</p><p>保护程序安全，防止核心API被随意篡改(java.lang.xxx是不允许自定义的)</p></blockquote><p>沙箱安全机制</p><blockquote><p>自定义java.lang.String类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件(rt.jar包中java\lang\String.class)，报错信息说没有main方法，就是因为加载的是rt.jar包中的String类。这样可以保证对java核心源代码的保护，这就是<strong>沙箱安全机制</strong>。</p></blockquote><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>在JVM中表示两个class对象是否为同一个类存在两个必要条件:</p><blockquote><p>类的完整类名必须一致，包括包名。<br>加载这个类的ClassLoader(指ClassLoader实例对象)必须相同。</p></blockquote><p>换句话说，在JVM中，即使这两个类对象(Class对象)来源同一个class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的。</p><p>对类加载器的引用</p><blockquote><p>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会<strong>将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</strong>。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。</p></blockquote><p>类的主动使用和被动使用</p><blockquote><p>主动使用，分为七种情况:</p><blockquote><p>创建类的实例<br>访问某个类或接口的静态变量，或者对该静态变量赋值<br>调用类的静态方法<br>反射（比如:Class.forName(“com.atguigu.Test”))<br>初始化一个类的子类<br>Java虚拟机启动时被标明为启动类的类<br>JDK 7 开始提供的动态语言支持:<br>java . lang.invoke.MethodHandle实例的解析结果<br>REF_getstatic、REF_putstatic、REF_invokestatic句柄对应的类没有初始化，则初始化</p></blockquote><p>除了以上七种情况，其他使用Java类的方式都被看作是对类的<strong>被动使用</strong>，都<strong>不会导致类的初始化</strong>。</p><p>即主动使用和被动使用的区别即是否会导致类的初始化(执行类构造器方法&lt;clinit&gt;())。</p></blockquote><h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><p>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。<strong>不同的JVM对于内存的划分方式和管理机制存在着部分差异</strong>。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。</p><p>线程私有：PC寄存器、栈、本地栈</p><p>线程间共享：堆、堆外内存(永久代、元空间、代码缓存)</p><p>每个JVM只有一个Runtime实例。即为运行时环境，相当于内存结构的中间的那个框框: 运行时环境。</p><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。</p><p>在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。</p><p>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法。</p><p>如果线程执行过程中发生异常退出，则java线程会直接退出，而本地线程则会根据当前是否全剩下守护线程决定jvm进程是否结束。</p><h3 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h3><p>JVM中的程序计数寄存器（Program counter Register)中，Register 的命名源于CPu的寄存器，寄存器存储指令相关的现场信息。CPu只有把数据装载到寄存器才能够运行。这里，并非是广义上所指的物理寄存器，或许将其翻译为pc计数器（或指令计数器）会更加贴切(也称为程序钩子)，并且也不容易引起一些不必要的误会。<strong>JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。</strong></p><p>作用:</p><blockquote><p>PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。然后由执行引擎读取下一条指令。</p></blockquote><p>它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。</p><p>在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</p><p>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址;或者，如果是在执行native方法，则是未指定值（undefined） 。</p><p>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p><p>它是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p><h4 id="两个常见问题"><a href="#两个常见问题" class="headerlink" title="两个常见问题"></a>两个常见问题</h4><p>使用PC寄存器存储字节码指令地址有什么用呢？为什么使用PC寄存器记录当前线程的执行地址呢？</p><blockquote><p>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继维执行。<br>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p></blockquote><p>PC寄存器为何被设定为线程私有?</p><blockquote><p>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？<strong>为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器</strong>，这样一来各个线程之间便可以进行独立计算，从而不会出现相互千扰的情况。</p><p>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</p><p>这样必然导致经常中断或恢复，如何保证分毫无差呢﹖每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</p></blockquote><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p><font color="red">栈是运行时的单位，而堆是存储的单位。</font></p><blockquote><p>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。<br>堆解决的是数据存储的问题，即数据怎么放、放在哪儿。</p><p>例子–做菜：食材以及做菜的步骤 放在栈中；而具体的过程对菜的各种操作 放在堆中。</p></blockquote><p>Java虚拟机栈（Java virtual Machine stack)，早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧(Stack Frame)，对应着一次次的Java方法调用。<font color="red">是线程私有的</font>，生命周期和线程一致。</p><p>作用：主管Java程序的运行，它保存方法的局部变量(8种基本数据类型、对象的引用地址)、部分结果，并参与方法的调用和返回。</p><p>优点：</p><blockquote><p>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。<br>JVM直接对Java栈的操作只有两个:<br>    每个方法执行，伴随着进栈(入栈、压栈) &amp;&amp; 执行结束后的出栈工作<br>对于栈来说不存在垃圾回收问题</p></blockquote><p>栈中可能出现的异常</p><blockquote><p>Java虚拟机规范允许Java栈的大小是动态的或者是固定不变的。</p><p>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个StackOverflowError异常。</p><p>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法中请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈,那Java虚拟机将会抛出一个OutOfMemoryError异常。</p></blockquote><h4 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h4><ul><li><p>每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame)的格式存在。</p></li><li><p>在这个线程上正在执行的每个方法都各自对应一个栈帧(Stack Frame)。</p></li><li><p>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</p></li></ul><p>栈运行原理:</p><blockquote><p>JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循“先进后出”/“后进先出”原则。</p><p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为<strong>当前栈帧</strong>(current Frame)，与当前栈帧相对应的方法就是<strong>当前方法</strong>（CurrentMethod)，定义这个方法的类就是<strong>当前类</strong>(current class) 。</p><p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</p><p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</p><p>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。</p><p>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</p><p>Java方法有两种返回函数的方式，<strong>一种是正常的函数返回，使用return指令;另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</strong></p></blockquote><h4 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h4><p>每个栈帧中存储着：</p><blockquote><p>局部变量表<br>操作数栈(或表达式栈)<br>动态链接(或指向运行时常量池的方法引用)<br>方法返回地址(或方法正常退出或者异常退出的定义)<br>附加信息</p></blockquote><h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>局部变量表也被称之为局部变量数组或本地变量表</p><p>定义为一个<strong>数字数组</strong>，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型。</p><p>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题。</p><p><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。</p><p>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</p><p>局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后.随着方法栈帧的销毁，局部变量表也会随之销毁。</p><h5 id="关于slot的理解"><a href="#关于slot的理解" class="headerlink" title="关于slot的理解"></a>关于slot的理解</h5><p>参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束。</p><p>局部变量表，最基本的存储单元是slot（变量槽)</p><p>局部变量表中存放编译期可知的各种基本数据类型(8种)，引用类型(reference)，returnAddress类型的变量。</p><p>在局部变量表里，<strong>32位以内的类型只占用一个slot(包括returnAddress类型)，64位的类型(long和double)占用两个slot。</strong></p><blockquote><p>byte、short、char在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true。<br>long和double则占据两个slot。</p></blockquote><p>JVM会为局部变量表中的每一个slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</p><p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个slot上</p><p>如果需要访问局部变量表中一个64bit的局部变量值时，只需要<strong>使用前一个索引</strong>即可。(比如:访问long或double类型变量)</p><p>如果当前帧是由<strong>构造方法</strong>或者<strong>实例方法</strong>创建的，<strong>那么该对象引用this将会存放在index为0的slot处</strong>，其余的参数按照参数表顺序继续排列。</p><p>slot的重复利用</p><blockquote><p>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p></blockquote><p>局部变量和静态变量的对比</p><blockquote><p>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</p><p>我们知道类变量表有两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。</p><p>和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</p></blockquote><p>补充</p><blockquote><p>在栈帧中，方性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</p><p><font color="red">局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</font></p></blockquote><h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p>每一个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出(Last-In-First-Out)的操作数栈，也可以称之为表达式栈(Expression Stack) 。</p><p>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈(push)/出栈(pop) .</p><blockquote><p>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。 </p><p>比如: 执行复制、交换、求和等操作</p></blockquote><p>操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。</p><p>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。</p><p>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为max_stack的值。</p><p>栈中的任何一个元素都是可以任意的Java数据类型。</p><blockquote><p>32bit的类型占用一个栈单位深度<br>64bit的类型占用两个栈单位深度。</p></blockquote><p>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈(push)和出栈(pop)操作来完成一次数据访问。</p><p>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。</p><p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</p><p>另外，我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。</p><h5 id="栈顶缓存技术"><a href="#栈顶缓存技术" class="headerlink" title="栈顶缓存技术"></a>栈顶缓存技术</h5><p>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派(instruction dispatch）次数和内存读/写次数。</p><p>由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，<strong>将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。</strong></p><h4 id="动态链接-指向运行时常量池中的方法引用"><a href="#动态链接-指向运行时常量池中的方法引用" class="headerlink" title="动态链接(指向运行时常量池中的方法引用)"></a>动态链接(指向运行时常量池中的方法引用)</h4><p>帧数据区的概念：方法返回地址、动态链接和一些附加信息称为帧数据区</p><p><strong>每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用</strong>。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接( Dynamic Linking)。比如: invokedynamic指令</p><p>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用(symbolic Reference)保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。</p><h4 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h4><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关。</p><p>静态链接:</p><blockquote><p>当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。</p></blockquote><p>动态链接:</p><blockquote><p>如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。</p></blockquote><p>对应的方法的绑定机制为:早期绑定（Early Binding）和晚期绑定(Late Binding)。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</p><p>早期绑定:</p><blockquote><p>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</p></blockquote><p>晚期绑定:</p><blockquote><p>如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。</p></blockquote><p>随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</p><p>Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</p><p>非虚方法:</p><blockquote><p>如果方法在编译期就确定了具体的调用版本，这个版木在运行时是不可变的。这样的方法称为非虚方法。|</p><ul><li>静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。</li><li>其他方法称为虚方法。</li></ul></blockquote><p>虚拟机中提供了以下几条方法调用指令:</p><ul><li>普通调用指令:</li></ul><blockquote><p>invokestatic: 调用静态方法，解析阶段确定唯一方法版本</p><p>invokespecial: 调用&lt;init&gt;方法、私有及父类方法，解析阶段确定唯一方法版本</p><p>invokeviltual: 调用所有虚方法</p><p>invokeinterface: 调用接口方法</p></blockquote><ul><li>动态调用指令:</li></ul><blockquote><p>invokedynamic: 动态解析出需要调用的方法，然后执行</p></blockquote><p>前四条指令固化在虚拟机内部，方法的调用执行不可人为千预，而invokedynamic指令则支持由用户确定方法版本。<strong>其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。</strong></p><hr><p>JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现<strong>『动态类型语言』</strong>支持而做的一种改进。</p><p>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。</p><p>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。</p><p>动态类型语言和静态类型语言</p><blockquote><p>动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。</p><p>说的再直白一点就是，静态类型语言是判断变量自身的类型信息; 动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。</p></blockquote><p>Java 语言中方法重写的本质:</p><blockquote><p>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作 C。</p><p>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束;如果不通过，则返回java.lang.illegalAccessError异常。</p><p>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</p><p>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</p><p>illegalAccessError介绍:</p><p>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</p></blockquote><p>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，JVM采用在类的方法区建立一个虚方法表(virtual method table）(非虚方法不会出现在表中)来实现。使用索引表来代替查找。</p><p>每个类中都有一个<strong>虚方法表</strong>，表中存放着各个方法的实际入口。如果是重写父类的方法，则该方法入口则为本身，如果使用父类的方法，则方法入口为父类。</p><p>那么虚方法表什么时候被创建?</p><blockquote><p>虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。</p></blockquote><h4 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h4><p>存放调用该方法的pc寄存器的值。</p><p>一个方法的结束，有两种方式:</p><blockquote><p>正常执行完成<br>出现未处理的异常，非正常退出</p></blockquote><p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的PC计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</p><blockquote><p>一个方法在正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定。</p><p>在字节码指令中，返回指令包含ireturn (当返回值是boolean、byte、char、short和int类型时使用）、lreturn、 freturn、dreturn以及areturn，另外还有一个return指令供声明为void的方法、实例初始化方法、类和接口的初始化方法使用。</p></blockquote><p>在方法执行的过程中遇到了异常（Exception)，并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称<strong>异常完成出口</strong>。</p><p>方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码。</p><p><img src="https://i.loli.net/2021/02/17/NuiwLdIh7CYcTxb.png" alt="image.png"></p><p>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、<strong>将返回值压入调用者栈帧的操作数栈</strong>、设置Pc寄存器值等，让调用者方法继续执行下去。</p><p>正常完成出口和异常完成出口的区别在于: <strong>通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</strong></p><h4 id="一些附加信息"><a href="#一些附加信息" class="headerlink" title="一些附加信息"></a>一些附加信息</h4><p>无</p><h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><ul><li>举例栈溢出的情况？(StackOverFlowError)</li></ul><blockquote><p>递归，栈深度大于所分配</p></blockquote><ul><li>调整栈大小，就能保证不出现溢出吗?</li></ul><blockquote><p>不能，可以延迟</p></blockquote><ul><li>分配的栈内存越大越好吗?</li></ul><blockquote><p>不是，总内存是一定的</p></blockquote><ul><li>垃圾回收是否会涉及到虚拟机栈?</li></ul><blockquote><p>不会，但会出现OOM异常</p></blockquote><ul><li>方法中定义的局部变量是否线程安全?</li></ul><blockquote><p>具体问题具体分析。看是否关联到共享资源、是否将局部变量作为返回值进行返回了、是否作为参数。即是否在内部消亡。可判断是否安全。</p></blockquote><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><h4 id="本地方法接口"><a href="#本地方法接口" class="headerlink" title="本地方法接口"></a>本地方法接口</h4><p>简单地讲，一个Native Method就是一个Java调用非Java代码的接口。一个Native Method是这样一个Java方法:该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern “C”告知C++编译器去调用一个c的函数。</p><p>“A native method is a Java method whose implementation is provided by non-java code .”</p><p>在定义一个native method时，并不提供实现体（有些像定义一个Java interface) ，因为其实现体是由非java语言在外面实现的。</p><p>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序</p><p>为什么要使用Native Method ?</p><blockquote><p>Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</p><ul><li>与Java环境外交互:</li></ul><p>有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制:它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</p><ul><li>与操作系统交互:</li></ul><p>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用c写的。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</p><ul><li>sun’s Java</li></ul><p>sun的解释器是用c实现的，这使得它能像一些普通的c一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。例如:类java.lang.Thread的setPriority()方法是用Java实现的，但是它实现调用的是该类里的本地方法setPriority0()。这个本地方法是用c实现的，并被植入JVM内部，在windows 95的平台上，这个本地方法最终将调用win32 setPriority() API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库(external dynamic link library）提供，然后被JVM调用。</p><p>目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用socket通信，也可以使用web service等等，不多做介绍。</p></blockquote><hr><p>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。</p><p>本地方法栈，也是线程私有的。</p><p>允许被实现成固定或者是可动态扩展的内存大小。(在内存溢出方面是相同的)</p><blockquote><p>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个StackOverflowError异常。</p><p>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个OutOfMemoryError异常。</p></blockquote><p>本地方法是使用c语言实现的。</p><p>它的具体做法是Native Method Stack中登记native方法，在Execution Engine执行时加载本地方法库。</p><p>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</p><blockquote><p>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区。</p><p>它甚至可以直接使用本地处理器中的寄存器</p><p>直接从本地内存的堆中分配任意数量的内存。</p></blockquote><p>并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。</p><p>在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。</p><p>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。</p><blockquote><p>堆内存的大小是可以调节的。</p></blockquote><p>《Java虚拟机规范》规定，堆可以处于<strong>物理上不连续</strong>的内存空间中，但在<strong>逻辑上</strong>它应该被视为<strong>连续的</strong>。</p><p> 所有的线程共享Java堆，在这里还可以划分<strong>线程私有的缓冲区</strong>(Thread Local Allocation Buffer，TLAB)。</p><p>《Java虚拟机规范》中对Java堆的描述是: 所有的对象实例以及数组都应当在运行时分配在堆上。(The heap is the run-time data area from which memory for all class instances and arrays is allocated）</p><blockquote><p>我要说的是: “几乎”所有的对象实例都在这里分配内存。—从实际使用角度看的。</p></blockquote><p>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</p><p>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</p><p>堆，是GC (Garbage collection，垃圾收集器）执行垃圾回收的重点区域。</p><hr><p><strong>现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为:</strong></p><p>Java 7及之前堆内存逻辑上分为三部分：新生区+养老区+<strong>永久区</strong></p><blockquote><p>Young Generation Space    新生区    Young/New （又被划分为Eden区和Survivor区）</p><p>Tenure generation Space    养老区    old/Tenure</p><p>Permanent Space    永久区    Perm</p></blockquote><p>Java 8及之后堆内存逻辑上分为三部分：新生区+养老区+<strong>元空间</strong></p><blockquote><p>Young Generation Space    新生区    Young/New（又被划分为Eden区和Survivor区）</p><p>Tenure generation Apace    养老区    old/Tenure</p><p>Meta Space    元空间    Meta</p></blockquote><p>约定：新生区&lt;-&gt;新生代&lt;-&gt;年轻代    养老区&lt;-&gt;老年区&lt;-&gt;老年代    永久区&lt;-&gt;永久代</p><h4 id="设置堆内存大小和OOM"><a href="#设置堆内存大小和OOM" class="headerlink" title="设置堆内存大小和OOM"></a>设置堆内存大小和OOM</h4><p>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”-Xmx”和”-Xms”来进行设置。</p><blockquote><p>“-Xms”用于表示堆区的起始内存，等价于-XX:InitialHeapSize（-X是指jvm的运行参数，ms指memory start）</p><p>“-Xmx”则用于表示堆区的最大内存，等价于-XX:MaxHeapSize</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;查看设置的参数</span><br><span class="line">1、jps / jstat -gc 进程号</span><br><span class="line">2、-XX:+PrintGCDetails (需要程序执行完以后)</span><br></pre></td></tr></table></figure><p>注意：设置的值和实际通过Runtime实例获取的值可能存在差异，因为幸存者区S0和S1区只会有一个工作，所以有一个在计算时不会计算。</p></blockquote><p>一旦堆区中的内存大小超过“-Xmx”所指定的最大内存时，将会抛出OutOfMemoryError异常。</p><p>通常会将-Xms和-Xmx两个参数配置相同的值，其目的是为了能够在<strong>java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小</strong>，从而提高性能。</p><p>默认情况下，初始内存大小：物理电脑内存大小 / 64；最大内存大小：物理电脑内存大小 / 4</p><h4 id="年轻代和老年代"><a href="#年轻代和老年代" class="headerlink" title="年轻代和老年代"></a>年轻代和老年代</h4><p>存储在JVM中的Java对象可以被划分为两类:</p><blockquote><p>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速。</p><p>另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致。</p></blockquote><p>Java堆区进一步细分的话，可以划分为年轻代(YoungGen）和老年代（OldGen)</p><p>其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间(有时也叫做from区、to区）。</p><p>配置新生代与老年代在堆结构的占比：</p><blockquote><p>默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3</p><p>可以修改-XX:NewRatio=4，表示新生代占老年代占4，新生代占整个堆的1/5</p></blockquote><p>在HotSpot中，Eden空间和另外两个Survivor空间缺省所占的比例是8:1:1（但可能默认值并非为8）</p><blockquote><p>当然开发人员可以通过选项”-XX:SurvivorRatio”调整这个空间比例。比如-XX:SurvivorRatio=8</p><p><strong>几乎所有</strong>的Java对象都是在Eden区被new出来的。</p><p>绝大部分的Java对象的销毁都在新生代进行了。（IBM公司的专门研究表明，新生代中80%的对象都是”朝生夕死”的）</p><p>可以使用选项”-Xmn”设置新生代最大内存大小。（这个参数一般使用默认值就可以了，且该参数优先级比XX:NewRatio优先级更高）</p></blockquote><h4 id="对象分配过程"><a href="#对象分配过程" class="headerlink" title="对象分配过程"></a>对象分配过程</h4><p>为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p><p>①new的对象先放伊甸园区。此区有大小限制。<br>②当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收(Minor GC/Young GC)，将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区<br>③然后将伊甸园中的剩余对象移动到幸存者0区。<br>④如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。<br>⑤如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。<br>⑥啥时候能去养老区呢？可以设置次数。默认是15次。</p><blockquote><p>可以设置参数:-XX:MaxTenuringThreshold=&lt;N&gt;进行设置。</p><p>注意：在Eden区满时，YGC不仅会对Eden区进行GC，还会对对应的幸存者区进行GC。同时幸存者区满时，并不会触发YGC，即幸存者区是被动进行垃圾回收的。<br>同时，如果幸存者区中的对象还未达到阈值15就已经装不下了，则其中的一些”老”对象会直接进入老年区。</p></blockquote><p>总结:</p><blockquote><p>针对幸存者s0、s1区的总结：复制之后有交换，谁空谁是to。</p><p>关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不在永久区 / 元空间收集。</p></blockquote><img src="https://i.loli.net/2021/02/18/Pf6Mkxzy1YAluLB.png" alt="对象分配.png" style="zoom:50%;"><h4 id="Minor-GC、Full-GC、Major-GC"><a href="#Minor-GC、Full-GC、Major-GC" class="headerlink" title="Minor GC、Full GC、Major GC"></a>Minor GC、Full GC、Major GC</h4><p>JVM在进行Gc时，并非每次都对上面三个内存(新生代、老年代、方法区)区域一起回收的，大部分时候回收的都是指新生代。</p><p>针对HotSpot VM的实现，它里面的GC按照回收区域又分为两大种类型:一种是部分收集(Partial GC)，一种是整堆收集（Full GC)</p><p>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为:</p><blockquote><p>新生代收集(Minor GC / Young GC)：只是新生代的垃圾收集</p><p>老年代收集(Major GC / Old GC)：只是老年代的垃圾收集。</p><blockquote><p>目前，只有<strong>CMS GC</strong>会有单独收集老年代的行为。<br><font color="red">注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</font></p></blockquote><p>混合收集（Mixed GC)：收集整个新生代以及部分老年代的垃圾收集。</p><blockquote><p>目前，只有<strong>G1 GC</strong>会有这种行为</p></blockquote></blockquote><p>整堆收集(Full GC)：收集整个java堆和<strong>方法区</strong>的垃圾收集。</p><hr><p>年轻代GC(Minor GC)触发机制：</p><blockquote><p>当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden区满，Survivor区满不会引发GC。(每次Minor GC会清理年轻代的内存。)</p><p>因为Java 对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</p><p>Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行。</p></blockquote><p>老年代GC (Major GC/Full GC)触发机制:</p><blockquote><p>指发生在老年代的GC，对象从老年代消失时，我们说“Major GC”或“Full GC”发生了。</p><p>出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。</p><blockquote><p>也就是在老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足，则触发Major GC。</p></blockquote><p>Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。<br>如果Major GC后，内存还不足，就报OOM了。</p></blockquote><p>触发Full GC执行的情况有如下五种:</p><blockquote><p>①调用System.gc()时，系统建议执行Full GC，但是不必然执行<br>②老年代空间不足<br>③方法区空间不足<br>④通过Minor GC后进入老年代的平均大小大于老年代的可用内存<br>⑤由Eden区、Survivor space（From Space）区向Survivor space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</p><p>说明: <font color="red">full gc是开发或调优中尽量要避免的。这样暂时时间会短一些。</font></p></blockquote><h4 id="堆空间分代思想"><a href="#堆空间分代思想" class="headerlink" title="堆空间分代思想"></a>堆空间分代思想</h4><p>为什么需要把Java堆分代?不分代就不能正常工作了吗?</p><blockquote><p>经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。</p><p>新生代: 有Eden、两块大小相同的survivor (又称为from/to，s0/s1)构成，to总为空。<br>老年代: 存放新生代中经历多次Gc仍然存活的对象。</p></blockquote><p>为什么需要把Java堆分代?不分代就不能正常工作了吗?</p><blockquote><p>其实不分代完全可以，分代的唯一理由就是优化<strong>GC</strong>性能。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用,这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收,这样就会腾出很大的空间出来。</p></blockquote><h4 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h4><p>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1 。对象在Survivor区中每熬过一次Minor GC ,年龄就增加岁，当它的年龄增加到一定程度（默认为15 岁，其实每个JVM、每个GC都有所不同)时，就会被晋升到老年代中。</p><p>针对不同年龄段的对象分配原则如下所示:</p><ul><li><p>优先分配到Eden</p></li><li><p>大对象直接分配到老年代</p><blockquote><p>尽量避免程序中出现过多的大对象</p></blockquote></li><li><p>长期存活的对象分配到老年代</p></li><li><p>动态对象年龄判断</p><blockquote><p>如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</p></blockquote></li><li><p>空间分配担保</p><blockquote><p>-xx: HandlePromotionFailure</p></blockquote></li></ul><h4 id="TLAB（Thread-Local-Allocation-Buffer）"><a href="#TLAB（Thread-Local-Allocation-Buffer）" class="headerlink" title="TLAB（Thread Local Allocation Buffer）"></a>TLAB（Thread Local Allocation Buffer）</h4><p>为了避免多个线程访问同一地址。</p><p>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。</p><p>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为<strong>快速分配策略</strong>。</p><p>据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。</p><p>TLAB简单说明：</p><blockquote><p>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是<font color="red">将TLAB作为内存分配的首选</font>。</p><p>在程序中，开发人员可以通过选项“-XX:UseTLAB”设置是否开启TLAB空间。</p><p>默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然我们可以通过选项“-XX:TLABWasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小。</p><p>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过<strong>使用加锁机制</strong>确保数据操作的原子性，从而直接在Eden空间中分配内存。</p></blockquote><h4 id="堆空间常用参数设置"><a href="#堆空间常用参数设置" class="headerlink" title="堆空间常用参数设置"></a>堆空间常用参数设置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintFlagsInitial: 查看所有的参数的默认初始值</span><br><span class="line">-XX:+PrintFlagsFinal: 查看所有的参数的最终值(可能会存在修改，不再是初始值)</span><br><span class="line">具体查看某个参数的指令: jps查看进程号 -&gt; jinfo -flag SurvivalRatio 进程号</span><br><span class="line">-Xms: 初始堆空间内存(默认为物理内存的1/64)</span><br><span class="line">-Xmx: 最大堆空间内存(默认为物理内存的1/4)</span><br><span class="line">-Xmn: 设置新生代的大小。(初始值及最大值)</span><br><span class="line">-Xx:NewRatio: 配置新生代与老年代在堆结构的占比</span><br><span class="line">-Xx:SurvivorRatio: 设置新生代中Eden和s0/s1空间的比例</span><br><span class="line">-XX:MaxTenuringThreshold: 设置新生代垃圾的最大年龄</span><br><span class="line">-XX:+PrintGCDetails: 输出详细的GC处理日志</span><br><span class="line">* 打印gc简要信息:1) -XX:+PrintGC 2)-verbose:gc</span><br><span class="line">-Xx:HandlePromotionFailure: 是否设置空间分配担保</span><br></pre></td></tr></table></figure><p>在发生Minor GC之前，虚拟机会检查老年代最大可用的<strong>连续空间</strong>是否大于新生代所有对象的总空间。</p><blockquote><p>如果大于，则此次Minor GC是安全的</p><p>如果小于，则虚拟机会查看-XX:HandlePromotionFailure设置值是否允许担保失败。如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于<strong>历次晋升到老年代的对象的平均大小</strong>。</p><ul><li>如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的;</li><li>如果小于，则改为进行一次Full Gc。</li></ul><p>如果HandlePromotionFailure=false，则改为进行一次Full GC.</p></blockquote><p>在JDK6 Update24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6 Update24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC.</p><h4 id="堆是对象存储的唯一选择吗？"><a href="#堆是对象存储的唯一选择吗？" class="headerlink" title="堆是对象存储的唯一选择吗？"></a>堆是对象存储的唯一选择吗？</h4><p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过<strong>逃逸分析(Escape Analysis)</strong>后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p><p>此外，前面提到的基于OpenJDK深度定制的TaoBaoVM，其中创新的GCIH (GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</p><p>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</p><p>通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p><p>逃逸分析的基本行为就是分析对象动态作用域:</p><blockquote><p>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。<br>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</p></blockquote><h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><p>使用逃逸分析,编译器可以对代码做如下优化:</p><p>一、栈上分配。将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。</p><blockquote><p>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</p><p>常见的逃逸的场景</p><blockquote><p>在逃逸分析中，已经说明了。分别是给成员变量赋值、方法返回值、实例引用传涕。</p></blockquote></blockquote><p>二、同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</p><blockquote><p>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</p><p>在动态编译同步块的时候，JIT编译器可以<strong>借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问</strong>而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。</p></blockquote><p>三、分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分(或全部）可以不存储在内存，而是存储在CPU寄存器中。</p><blockquote><p>标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</p><p>相对的，那些还可以分解的数据叫做聚合量(Aggregate), Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p><p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是<strong>标量替换</strong>。</p></blockquote><p><font color="red">但是栈上分配只是理论可行，hotspot虚拟机并没有实际应用，而能看到效果的原因是标量替换产生的效果。所以，还是可以认为，对象实例都是分配在堆空间中的。</font></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</p><p>老年代放置长生命周期的对象，通常都是从Survivor区域筛选拷贝过来的Java对象。当然，也有特殊情况，我们知道普通的对象会被分配在TLAB上:如果对象较大，JVM会试图直接分配在Eden其他位置上;如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代</p><p>当Gc只发生在年轻代中，回收年轻代对象的行为被称为Minor GC。当GC发生在老年代时则被称为Major GC或者Full GC。一般的，Minor GC的发生频率要比Major GC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区看作是一块独立于Java堆的内存空间。</p><p><img src="https://i.loli.net/2021/02/22/XkhOpQFZ5VGNyKg.png" alt="image.png"></p><p>且对于栈内存储的对象的referrence，指向堆中的对象实例，而堆中的对象实例中还存在对象类型的指针，而该指针则指向方法区。</p><p>方法区(Method Area)与Java堆一样，是各个线程共享的内存区域。</p><p>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。</p><p>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</p><p>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误: java.lang.outOfMemoryError: <strong>PermGen space</strong>或者java.lang.outofMemoryError: <strong>Metaspace</strong></p><p>关闭JVM就会释放这个区域的内存。</p><h4 id="设置方法区大小"><a href="#设置方法区大小" class="headerlink" title="设置方法区大小"></a>设置方法区大小</h4><p>方法区的大小不必是固定的，jvm可以根据应用的需要动态调整。</p><p>jdk7及以前:</p><blockquote><p>通过-XX:PermSize来设置永久代初始分配空间。默认值是20.75M</p><p>-XX:MaxPermsize来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M</p><p>当JVM加载的类信息容量超过了这个值，会报异常outofMemoryError: PermGen space 。</p></blockquote><p>jdk8及以后:</p><blockquote><p>元数据区大小可以使用参数-XX:MetaspaceSize和-XX:MaxMetaspaceSize指定，替代上述原有的两个参数。</p><p>默认值依赖于平台。windows下，-XX:Metaspacesize是21M，-XX:MaxMetaspacesize的值是-1，即没有限制。</p><p>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError: Metaspace </p><p>-XX:MetaspaceSize:设置初始的元空间大小。对于一个64位的服务器端JVM来说, 其默认的-XX:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类(即这些类对应的类加载器不再存活),然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspacesize时，适当提高该值。如果释放空间过多，则适当降低该值。</p><p>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC，建议将-XC: Metaspacesize设置为一个相对较高的值。</p></blockquote><p>如何解决OOM</p><blockquote><p>1、要解决OOM异常或heap space的异常，一般的手段是首先通过内存映像分析工具(如Eclipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（MemoryLeak）还是内存溢出(Memory Overflow)。</p><p>2、如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置。</p><p>3、如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数(-Xmx与-Xms)，与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</p></blockquote><h4 id="方法区内部结构"><a href="#方法区内部结构" class="headerlink" title="方法区内部结构"></a>方法区内部结构</h4><p>它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</p><p>类型信息：</p><blockquote><p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation)，JVM必须在方法区中存储以下类型信息:<br>①这个类型的完整有效名称(全名=包名.类名)<br>②这个类型直接父类的完整有效名(对于interface或是java.lang.0bject，都没有父类)<br>③这个类型的修饰符(public,abstract, final的某个子集)<br>④这个类型直接接口的一个有序列表</p></blockquote><p>域(Field)信息：</p><blockquote><p>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</p><p>域的相关信息包括：域名称、域类型、域修饰符(public, private,protected,static,final, volatile, transient的某个子集)</p></blockquote><p>方法(Method)信息：</p><blockquote><p>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序:</p><ul><li>方法名称</li><li>方法的返回类型(或void)</li><li>方法参数的数量和类型(按顺序)</li><li>方法的修饰符(public, private,protected,static, final, synchronized, native,abstract的一个子集)</li><li>方法的字节码、bytecodes操作数栈、局部变量表及大小(abstract和native方法除外）</li><li>异常表(abstract和native方法除外)<br>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li></ul></blockquote><p>补充说明:全局常量: <code>static final</code></p><blockquote><p>被声明为final的类变量的处理方法则不同，每个全局常量在<strong>编译</strong>的时候就会被分配了。</p></blockquote><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>方法区包含了<strong>运行时常量池</strong>，而字节码文件又包含了<strong>常量池</strong>。常量池包含了各种字面量和对类型、域、方法的符号引用。</p><p>为什么需要常量池?</p><blockquote><p>一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，需要换另一种方式，也就是可以存到<strong>常量池</strong>。同时字节码文件中也存储了该常量池。在真正进行加载执行的时候，才会进行动态链接，加载真正的引用。</p></blockquote><p>小结:</p><blockquote><p>常量池，可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。</p></blockquote><p>运行时常量池（Runtime constant Poo1）是方法区的一部分。</p><p>常量池表（Constant Pool Table）是class文件的一部分，用于存放编译期生成的各种字面量与符号引用，<strong>这部分内容将在类加载后存放到方法区的运行时常量池中。</strong></p><p>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</p><p>JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。</p><p>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为<strong>真实地址</strong>。</p><blockquote><p>运行时常量池，相对于class文件常量池的另一重要特征是：具备<strong>动态性</strong>。</p><p>比如：一些方法 String.intern()等等</p></blockquote><p>运行时常量池类似于传统编程语言中的符号表(symbol table)，但是它所包含的数据却比符号表要更加丰富一些。</p><p>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛OutOfMemoryError异常。</p><p>注意：(方法区实例演示过程中)</p><blockquote><p>在调用实例方法时，先入栈对象实例，然后入栈参数，然后invoke…..调用方法。</p></blockquote><h4 id="方法区演变细节"><a href="#方法区演变细节" class="headerlink" title="方法区演变细节"></a>方法区演变细节</h4><p>1、首先明确：只有HotSpot才有永久代。BEA、JRockit、IBM9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一。</p><p>2、Hotspot中方法区的变化:</p><table><thead><tr><th align="center">jdk版本</th><th align="center">方法区情况</th></tr></thead><tbody><tr><td align="center">jdk1.6及之前</td><td align="center">有永久代(permanent generation)，<strong>静态变量存放在永久代上</strong></td></tr><tr><td align="center">jdk1.7</td><td align="center">有永久代，但已经逐步“去永久代”，<strong>字符串常量池、静态变量移除，保存在堆中</strong></td></tr><tr><td align="center">jdk1.8及之后</td><td align="center">无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但<strong>字符串常量池、静态变量仍在堆</strong></td></tr></tbody></table><p>改动的原因：</p><p>①为永久代设置多大空间是很难确定（如web工程，需要动态加载的类很多，容易出现OOM）<br>②对永久代进行调优很困难</p><p>有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK 11时期的ZGC收集器就不支持类卸载)。</p><p>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前Sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的Hotspot虚拟机对此区域未完全回收而导致内存泄漏。方法区的垃圾收集主要回收两部分内容: 常量池中废弃的常量和不再使用的类型。</p><blockquote><p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“还再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件:</p><p>①该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。<br>②加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、SP的重加载等，否则通常是很难达成的。<br>③该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p><p>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收,HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class以及-XX:+Traceclass-Loading、-XX:+TraceClassUnLoading查看类加载和卸载信息·在大量使用反射、动态代理、cGLib等字节码框架，动态生成JSP以及osGi这类频繁</p><p>自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</p></blockquote><p>StringTable为什么要调整?</p><blockquote><p>jdk7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在full gc的时候才会触发。而full gc是老年代的空间不足、永久代不足时才会触发。<br>这就导致StringTable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p></blockquote><p>需要注意：</p><blockquote><p>静态引用所对应的<strong>对象实体</strong>始终是存在于堆中，无论是jdk6还是jdk8，只要是对象实例，都在堆中分配。</p></blockquote><h4 id="方法区的垃圾收集"><a href="#方法区的垃圾收集" class="headerlink" title="方法区的垃圾收集"></a>方法区的垃圾收集</h4><p>有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在(如JDK 11时期的zGC收集器就不支持类卸载)。</p><p>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</p><p><strong>方法区的垃圾收集主要回收两部分内容:常量池中废弃的常量和不再使用的类型。</strong></p><p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量:</p><blockquote><p>1、类和接口的全限定名</p><p>2、字段的名称和描述符</p><p>3、方法的名称和描述符</p></blockquote><p>HotSpot虚拟机对常量池的回收策略是很明确的，<strong>只要常量池中的常量没有被任何地方引用，就可以被回收。</strong><br>回收废弃常量与回收Java堆中的对象非常类似。</p><p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件:</p><blockquote><p>①该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。<br>②加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。<br>③该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p></blockquote><p>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收,HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class以及-XX:+TraceClass-Loading、-XX:+TraceClassUnLoading查看类加载和卸载信息</p><p>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><img src="/.com//C:%5CUsers%5C34879%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210225184559735.png" alt="image-20210225184559735"></p><h2 id="对象相关"><a href="#对象相关" class="headerlink" title="对象相关"></a>对象相关</h2><h4 id="对象的实例化"><a href="#对象的实例化" class="headerlink" title="对象的实例化"></a>对象的实例化</h4><p>创建对象的方式：</p><blockquote><p>new：①常用的，直接new对象 ②构造器私有，调用Xxx的静态方法获取 ③XxxBuilder/XxxFactory工厂模式</p><p>Class.newInstance()：反射，只能调用空参构造器，且权限要求public</p><p>Constructor.newInstance(Xxx)：反射，可以调用空参、带参的构造器，对权限无要求</p><p>clone()：不调用任何构造器，当前类需要实现Cloneable接口，重写clone()方法</p><p>反序列化：从文件中、网络中获取一个对象的二进制流</p><p>第三方库Objenesis</p></blockquote><p>创建对象的步骤</p><blockquote><p>①判断对象对应的类是否加载、链接、初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。(即判断类元信息是否存在)。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader+包名+类名为Key进行查找对应的.class文件。如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class类对象</span><br></pre></td></tr></table></figure><p>②为对象分配内存（计算对象占用空间大小，如果实例成员变量是引用类型，只占4个字节）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果内存规整 -&gt; 直接在空闲空间中放入对象，并将指针后移(指针碰撞)</span><br><span class="line">如果不规整 -&gt; 即已经使用的和没有使用的内存的互相交错，虚拟机将采用空闲列表法，即虚拟机维护了一个列表，记录那些内存可用，在分配时从列表中找到一块空间划分给对象，并更新列表。</span><br></pre></td></tr></table></figure><p>③处理并发安全问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">采用CAS配上失败重试保证更新的原子性</span><br><span class="line">为每个线程预先分配一块TLAB</span><br></pre></td></tr></table></figure><p>④初始化分配到的空间（对象属性默认初始化）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所有非静态属性设置默认值，保证对象实例字段在未赋值时可以直接使用。</span><br></pre></td></tr></table></figure><p>⑤设置对象的对象头</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">记录类信息、HashCode、GC信息、锁信息等数据</span><br></pre></td></tr></table></figure><p>⑥执行init方法进行初始化（显式初始化）</p></blockquote><h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><p>对象头</p><blockquote><p>①运行时元数据(Mark Word)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">包含：</span><br><span class="line">哈希值、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳</span><br></pre></td></tr></table></figure><p>②类型指针——指向方法区中的类元数据，确定该对象所属的类型(如obj.getClass()方法)</p><p>③如果是数组，还需记录数组长度</p></blockquote><p>实例数据</p><blockquote><p>是对象真正存储的有效信息，包括字段、以及父类继承的字段等等</p><p>存放规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">相同宽度的字段存放在一起</span><br><span class="line">父类定义的变量会放在子类之前</span><br><span class="line">如果CompactFields参数为true(默认为true)：子类的窄变量可能插入到父类变量的空隙</span><br></pre></td></tr></table></figure></blockquote><p>对齐填充</p><blockquote><p>非必须的，占位符</p></blockquote><h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><p>JVM是如何通过栈帧中的对象引用访问到其内部的对象实例的呢?</p><p>对象访问的方式有两种：①句柄访问    ②直接指针(HotSpot采用)</p><p>句柄访问的好处：reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改。‘</p><p>直接指针的好处：访问效率更高、速度快，也不用在堆空间中开辟一块内存存储句柄。</p><p><img src="https://i.loli.net/2021/02/27/erKuL7W94NUfzDT.png" alt="image.png"></p><p><img src="https://i.loli.net/2021/02/27/N4uhJcVdFqR9BX2.png" alt="image.png"></p><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>来源于NIO，通过DirectByteBuffer操作本地内存。性能优于Java堆。读写效率高。</p><p>也同样可能引起OOM（Direct Buffer Memory），由OS提供的内存大小限制。</p><p>且分配回收的成本较高、不受JVM内存管理。</p><blockquote><p>直接内存大小可以通过MaxDirectMemorysize设置</p><p>如果不指定，默认与堆的最大值-xmx参数值一致</p></blockquote><h2 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h2><p><img src="https://i.loli.net/2021/02/28/9uA7mCrLo1dXHID.png" alt="image.png"></p><p>Java语言是半解释半编译的语言。</p><h3 id="JIT"><a href="#JIT" class="headerlink" title="JIT"></a>JIT</h3><p>将方法编译成机器码后执行。</p><p>首先明确:</p><blockquote><p>当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。<br>而编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。</p></blockquote><p>所以:</p><blockquote><p>尽管JRockit VM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。在此模式下，<strong>当Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。</strong></p><p>同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”。</p></blockquote><p>一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此也被称之为<strong>栈上替换</strong>，或简称为OSR (on StackReplacement）编译。</p><p>一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准?必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠热点探测功能。</p><p>目前HotSpot VM所采用的热点探测方式是<strong>基于计数器的热点探测。</strong></p><p>采用基于计数器的热点探测，HotSpot VM将会为每一个方法都建立2个不同类型的计数器，分别为方法调用计数器（Invocation Counter）和回边计数器(BackEdge Counter) 。</p><blockquote><p>方法调用计数器用于统计方法的调用次数</p><p>回边计数器则用于统计循环体执行的循环次数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当一个方法被调用时，首先会检查该方法是否存在已经被JIT编译好的版本，如果存在则直接使用本地代码；如果不存在则将方法的调用计数器加1，然后判断方法调用计数器和回边计数器之和是否超过阈值。如果超过阈值，则向JIT编译器提交一个该方法的代码编译请求。</span><br></pre></td></tr></table></figure><p><strong>热度衰减</strong></p><blockquote><p>如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个<strong>相对的执行频率</strong>，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的<strong>衰减(Counter Decay)</strong>，而这段时间就称为此方法统计的<strong>半衰周期(counter Half Tife Time)</strong>。</p><p>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数-XX:-UseCounterDecay来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。</p><p>另外，可以使用-XX:CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。</p></blockquote><p><strong>设置HotSpot执行模式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Xint：纯解释器</span><br><span class="line">-Xcomp：纯编译器</span><br><span class="line">-Xmixed：混合模式</span><br></pre></td></tr></table></figure><p>HotSpot中内置两个编译器C1和C2，分别对应Client Compiler和Server Compiler</p><blockquote><p>C1编译器会对字节码进行<strong>简单和可靠的优化</strong>，耗时短。以达到更快的编译速度。</p><p>C2进行<strong>耗时较长的优化，以及激进优化</strong>。但优化的代码执行效率更高。</p></blockquote><hr><p><strong>C1和C2编译器不同的优化策略∶</strong></p><p>在不同的编译器上有不同的优化策略，C1编译器上主要有方法内联，去虚拟化、冗余消除。</p><blockquote><p>方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程</p><p>去虚拟化：对唯一的实现类进行内联</p><p>冗余消除：在运行期间把一些不会执行的代码折叠掉</p></blockquote><p>C2的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在C2上有如下几种优化:</p><blockquote><p>标量替换：用标量值代替聚合对象的属性值</p><p>栈上分配：对于未逃逸的对象分配对象在栈而不是堆</p><p>同步消除：清除同步操作，通常指synchronized</p></blockquote><p>且在Java 7之后，server模式下默认开启分层编译策略，C1和C2协同工作来执行编译任务。</p><hr><p>自JDK10起，HotSpot又加入一个全新的即时编译器:：Graal编译器。编译效果短短几年时间就追评了C2编译器。未来可期。<br>目前，带着“实验状态”标签，需要使用开关参数-XX:+UnlockExperimentalvMoptions -XX:+UseJVMCICompiler去激活，才可以使用。</p><p><strong>AOT编译器(ahead of time)</strong></p><blockquote><p>在jdk9引入</p><p>所谓AOT编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而AOT编译指的则是，<strong>在程序运行之前，便将字节码转换为机器码的过程</strong>。</p></blockquote><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>jdk8及之前使用char数组存储字符串，jdk9及以后采用byte数组存储同时加以字符编码标识进行辅助。</p><blockquote><p>因为大部分String字符串存储的字符用1个字节就能存储，char在Java中占两个字节，会导致很多空间的浪费。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"abc"</span> <span class="comment">// 通过字面量定义的方式，"abc"存放于字符串常量池中</span></span><br><span class="line"><span class="comment">// 注意：字符串常量池中不允许重复字符串</span></span><br></pre></td></tr></table></figure><p>String的不可变性</p><blockquote><p>①对字符串重新赋值，会重写内存区域赋值。<br>②对现有字符串进行连接操作，也需要重新指定内存区域赋值<br>③当调用String的replace()方法修改字符串时，也需要重新指定内存区域赋值。</p></blockquote><p><strong>字符串常量池中不允许重复字符串</strong></p><p>字符串常量池底层也是由一个固定大小的HashTable实现的(jdk6默认长度为1009、jdk7默认大小为60013)。</p><blockquote><p>可使用-XX:StringTableSize进行设置。且从jdk8开始，可设置的最小值为1009。</p></blockquote><p>在Java语言中有8种基本数据类型和一种比较特殊的类型string。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。</p><p>常量池就类似一个Java系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的，String类型的常量池比较特殊。它的主要使用方法有两种。</p><blockquote><p>直接使用双引号声明出来的String对象会直接存储在常量池中。比如:string info = “atguigu .com” ;</p><p>如果不是用双引号声明的String对象，可以使用String提供的intern()方法。这个后面重点谈。</p></blockquote><p>？toString()方法返回的字符串来自哪里？常量池 or 堆</p><h3 id="字符串的拼接操作"><a href="#字符串的拼接操作" class="headerlink" title="字符串的拼接操作"></a>字符串的拼接操作</h3><p>1.常量与常量的拼接结果在常量池，原理是编译期优化<br>2.常量池中不会存在相同内容的常量。<br>3.只要其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder<br>4.如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址。</p><p>字符串拼接(a = a + “xxx”)的底层操作相当于new了一个StringBuilder对象和一个String对象，和StringBuilder的append()方法相比，效率差的非常多，且后者至始至终只创建过一个对象，前者每一次拼接都会创建两个新对象。</p><h3 id="intern-方法"><a href="#intern-方法" class="headerlink" title="intern()方法"></a>intern()方法</h3><p>new String(“aba”)会创建几个对象？</p><blockquote><p>①如果常量池中存在”aba”字符串常量，则会创建一个对象，即new出来的<br>②如果不存在，则会创建两个对象，一个”aba”字符串，一个new的String对象</p></blockquote><p>那对于String str = new String(“a”) + new String(“b”)呢？</p><blockquote><p>对象1：new StringBuilder()<br>对象2：常量池中的”a”<br>对象3：new String(“a”)<br>对象4：常量池中的”b”<br>对象5：new String(“b”)</p><p>StringBuilder的toString()方法<br>对象6：new String(“ab”)</p><p>注意：在字符串常量池中没有生成”ab”</p></blockquote><p>对于上文的str，调用str.intern()方法，发生了什么？</p><blockquote><p>因为此时常量池中没有”ab”，所以应该在常量池中进行生成一个。但是根据jdk版本不同存在差异。</p><p>对于jdk6：字符串常量池处于永久代。所以会在常量池中生成一个”ab”对象，且该对象!=str<br>对于jdk7/8：字符串常量池移到堆中，为了节省空间，不会在常量池中新创建”ab”对象，而是在常量池中创建一个引用指向str，并且返回的也是该地址，因为是str调用的intern方法，所以此时该引用==str。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"a"</span>) + <span class="keyword">new</span> String(<span class="string">"b"</span>)</span><br><span class="line">str.intern();</span><br><span class="line">String s2 = <span class="string">"ab"</span>;</span><br><span class="line">System.out.println(str == s2);<span class="comment">// jdk6: falsejdk7/8: true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"a"</span>) + <span class="keyword">new</span> String(<span class="string">"b"</span>);</span><br><span class="line">String s2 = str.intern();</span><br><span class="line">String s3 = <span class="string">"ab"</span>;</span><br><span class="line">System.out.println(str == s2);<span class="comment">// jdk6: falsejdk7/8: true</span></span><br><span class="line">System.out.println(s3 == s2);<span class="comment">// jdk6: truejdk7/8: true</span></span><br></pre></td></tr></table></figure></blockquote><p>当需要存储大量字符串在内存中时，可以恰当的使用intern()方法，节省空间，促进GC。</p><p><strong>G1的String去重操作</strong></p><blockquote><p>当垃圾收集器工作的时候，会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的String对象。</p><p>如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的String对象。</p><p>使用一个hashtable来记录所有的被String对象使用的不重复的char数组。当去重的时候，会查这个hashtable，来看堆上是否已经存在一个一模一样的char数组。</p><p>如果存在，String对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。<br>如果查找失败，char数组会被插入到hashtable，这样以后的时候就可以共享这个数组了。</p><p>UseStringDeduplication (bool):开启String去重，默认是不开启的，需要手动开启。</p></blockquote><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="垃圾回收算法-标记阶段"><a href="#垃圾回收算法-标记阶段" class="headerlink" title="垃圾回收算法-标记阶段"></a>垃圾回收算法-标记阶段</h3><p>首先需在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为<strong>垃圾标记阶段</strong>。</p><p>那么在JVM中究竟是如何标记一个死亡对象呢?简单来说，当一个对象已经<strong>不再被任何的存活对象继续引用时</strong>，就可以宣判为已经死亡。</p><p>判断对象存活一般有两种方式：<strong>引用计数算法</strong>和<strong>可达性分析算法</strong>。</p><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>引用计数算法(Reference Counting)比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。</p><p>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</p><blockquote><p>优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</p><p>缺点：①它需要单独的字段存储计数器，这样的做法增加了存储空间的开销。②每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。③引用计数器有一个严重的问题，即无法处理<strong>循环引用</strong>的情况。这是一条致命缺陷,导致在Java的垃圾回收器中没有使用这类算法。</p></blockquote><h4 id="可达性分析算法-根搜索算法、追踪性垃圾收集"><a href="#可达性分析算法-根搜索算法、追踪性垃圾收集" class="headerlink" title="可达性分析算法(根搜索算法、追踪性垃圾收集)"></a>可达性分析算法(根搜索算法、追踪性垃圾收集)</h4><p>所谓”GC Roots”根集合就是一组必须活跃的引用。</p><p>基本思路：可达性分析算法是以根对象集合(GC Roots)为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。</p><blockquote><p>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为<strong>引用链(Reference Chain)</strong></p><p>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。</p><p>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</p></blockquote><p>在Java语言中，G Roots包括以下几类元素：</p><p>①虚拟机栈中引用的对象。比如：各个线程被调用的方法中使用到的参数、局部变量等。<br>②本地方法栈内JNI(通常说的本地方法)引用的对象<br>③方法区中类静态属性引用的对象。比如: Java类的引用类型静态变量<br>④方法区中常量引用的对象。比如:字符串常量池（string Table）里的引用<br>⑤所有被同步锁synchronized持有的对象<br>⑥Java虚拟机内部的引用。基本数据类型对应的class对象，一些常驻的异常对象（如:NullPointerException、OutOfMemoryError）、系统类加载器<br>⑦反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。<br>⑧在某些特殊情况下，还可能存在一些对象临时加入到Root中的情况。(如：在分代垃圾收集时，如果只回收新生代的对象，那么一些老年代的对象也可以作为Root)</p><blockquote><p>如果一个指针，它指向堆内存里面的对象，但是其本身又不存放在堆内存里面，那它就是一个Root。</p></blockquote><p>因此采用此方法进行垃圾收集时，需要处于一个一致性的快照环境下。也就是STW的由来。</p><h4 id="对象的finalization机制"><a href="#对象的finalization机制" class="headerlink" title="对象的finalization机制"></a>对象的finalization机制</h4><p>Java语言提供了对象终止(finalization)机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，<strong>总会先调用这个对象的finalize()方法。</strong></p><p>永远不要主动调用某个对象的finalize()方法，应该交给垃圾回收机制调用。理由包括下面三点:</p><p>①在finalize()时可能会导致对象复活。<br>②finalize()方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则finalize()方法将没有执行机会。<br>③一个糟糕的finalize()会严重影响Gc的性能。</p><p>从功能上来说，finalize()方法与C++中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize()方法在本质上不同于C++中的析构函数。</p><p>由于finalize()方法的存在，虚拟机中的对象一般处于三种可能的状态。</p><blockquote><p>可触及的：从根节点开始，可以到达这个对象。<br>可复活的：对象的所有引用都被释放，但是对象有可能在finalize()中复活。且之后也无法再次调用finalize方法<br>不可触及的:对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为finalize ()只会被调用一次。</p><p>以上3种状态中，是由于finalize()方法的存在，进行的区分。只有在对象不可触及时才可以被回收。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">判定一个对象objA是否可回收，至少要经历两次标记过程:</span><br><span class="line">1．如果对象objA到GC Roots没有引用链，则进行第一次标记。</span><br><span class="line">2．进行筛选，判断此对象是否有必要执行finalize()方法</span><br><span class="line">* 如果对象objA没有finalize()方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，obj重写finalize()方法,或者A被判定为不可触及的。</span><br><span class="line">* 如果对象objA重写了finalize()方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize()方法执行。</span><br><span class="line">* finalize()方法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的况。在这个情况下，finalize方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize方法只会被调用一次。</span><br></pre></td></tr></table></figure><h3 id="垃圾回收算法-清除阶段"><a href="#垃圾回收算法-清除阶段" class="headerlink" title="垃圾回收算法-清除阶段"></a>垃圾回收算法-清除阶段</h3><p>当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。</p><p>目前在JVM中比较常见的三种垃圾收集算法是标记一清除算法( Mark-Sweep )、复制算法（ copying )、标记–压缩算法( Mark-Compact )。</p><h4 id="标记-清除方法"><a href="#标记-清除方法" class="headerlink" title="标记-清除方法"></a>标记-清除方法</h4><p>执行过程：当堆中的有效内存空间(available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world)，然后进行两项工作，第一项则是标记，第二项则是清除。</p><blockquote><p>标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。(未标记的为垃圾)<br>清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。</p></blockquote><p>缺点：</p><blockquote><p>①效率不算高<br>②在进行GC的时候，需要停止整个应用程序，导致用户体验差<br>③这种方式清理出来的空闲内存是不连续的，产生内存碎片I需要维护一个空闲列表</p></blockquote><blockquote><p>补充：何为清除，即将需要被清除的对象的地址添加到空闲列表中接口，而没有“置空”之类的说法。</p></blockquote><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</p><blockquote><p>优点：没有标记和清除过程,实现简单，运行高效；复制过去以后保证空间的连续性，不会出现“碎片”问题。</p><p>缺点：此算法的缺点也是很明显的，就是需要两倍的内存空间。对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小。</p><p>特别的：如果系统中的非垃圾对象很多，复制算法不会太理想。因为复制算法需要复制的存活对象数量需要不能太大，或者说非常低才行。（所以可以应用到新生代中）</p></blockquote><h4 id="标记-压缩算法"><a href="#标记-压缩算法" class="headerlink" title="标记-压缩算法"></a>标记-压缩算法</h4><p>执行过程：</p><p>第一阶段和标记-清除算法一样，从根节点开始标记所有被引用对象。第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间。</p><blockquote><p>二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策（引用的修改）。</p><p>可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</p></blockquote><blockquote><p>优点：消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。<br>消除了复制算法当中，内存减半的高额代价。</p><p>缺点：从效率上来说，标记-整理算法要低于复制算法。移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址。_·移动过程中，需要全程暂停用户应用程序。即：STW</p></blockquote><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。</p><p>而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。</p><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>分代收集算法，是基于这样一个事实:不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p><p>目前几乎所有的GC都是采用分代收集(Generational Collecting)算法执行垃圾回收的。</p><p>在Hotspot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。</p><blockquote><p>年轻代(Young Gen)：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</p><p>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</p><p>老年代(Tenured Gen)：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</p><p>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。</p><p>Mark阶段的开销与存活对象的数量成正比。<br>Sweep阶段的开销与所管理区域的大小成正相关。<br>Compact阶段的开销与存活对象的数据成正比。</p></blockquote><p>以Hotspot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于Mark-compact算法的Serial old回收器作为补偿措施:当内存回收不佳（碎片导致的doncurrent Mode Failure时)，将采用Serial old执行Full GC以达到对老年代内存的整理。</p><p>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代。</p><h4 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h4><p>基本思想：如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</p><p>总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。</p><blockquote><p>缺点：使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞叶量的下降。</p></blockquote><h4 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h4><p>一般来说，在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。</p><p>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间region。每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</p><h3 id="垃圾回收的相关概念"><a href="#垃圾回收的相关概念" class="headerlink" title="垃圾回收的相关概念"></a>垃圾回收的相关概念</h3><h4 id="System-gc"><a href="#System-gc" class="headerlink" title="System.gc()"></a>System.gc()</h4><p>在默认情况下，通过System.gc()或者Runtime. getRuntime( ).gc()的调用，会显式触发Full GC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</p><p>然而System.gc()调用附带一个免责声明，无法保证对垃圾收集器的调用。</p><p>JVM实现者可以通过System.gc()调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc()。</p><p>System.runFinalization()方法会强制调用失去引用的对象的finalize()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">&#125;</span><br><span class="line">System.gc(); <span class="comment">// 此时 b数组并不会被回收，虽然作用域已经结束，但是因为局部变量表中仍然存在一个插槽指向该对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">1</span>;</span><br><span class="line">System.gc(); <span class="comment">// 此时 b数组会被回收，因为其之前在局部变量表中的插槽被val变量所占用了，所以属于垃圾对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内存溢出与内存泄漏"><a href="#内存溢出与内存泄漏" class="headerlink" title="内存溢出与内存泄漏"></a>内存溢出与内存泄漏</h4><p>javadoc中对OutOfMemoryError的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。也就是在OOM之前通常会执行垃圾回收(除了分配超大对象时，垃圾收集也无济于事的情况)。</p><p>没有空闲内存的情况：①Java虚拟机的堆内存设置不够；②代码中创建了大量对象，且长时间不能被垃圾收集器收集（存在被引用）</p><hr><p>只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫<strong>内存泄漏</strong>。</p><p>但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致OOM，也可以叫做宽泛意义上的“内存泄漏”。</p><blockquote><p>eg. 当一个对象的引用属于类的静态成员时，该对象的生命周期就很长，随着类的消亡才会消亡。</p></blockquote><p>举例:</p><blockquote><p>1、单例模式<br>单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。</p><p>2、一些提供close的资源未关闭导致内存泄漏<br>数据库连接（dataSourse.getConnection())，网络连接(socket)和io连接必须手动close，否则是不能被回收的。</p></blockquote><h4 id="StopTheWord"><a href="#StopTheWord" class="headerlink" title="StopTheWord"></a>StopTheWord</h4><p>stop-the-world，简称STW，指的是GC事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW。</p><blockquote><p>可达性分析算法中枚举根节点(GC Roots）会导致所有Java执行线程停顿。</p><ul><li>分析工作必须在一个能确保一致性的快照中进行</li><li>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</li><li>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证</li></ul><p>被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少STW的发生。</p></blockquote><p>STW事件和采用哪款GC无关，所有的GC都有这个事件。</p><p>哪怕是G1也不能完全避免stop-the-world 情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。</p><p>STW是JVM在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的工作线程全部停掉。</p><p>开发中不要用System.gc();会导致stop-the-world的发生。</p><h4 id="垃圾回收的并行和并发"><a href="#垃圾回收的并行和并发" class="headerlink" title="垃圾回收的并行和并发"></a>垃圾回收的并行和并发</h4><p>并发：在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，即都在运行中，且这几个程序都是在同一个处理备上运行。</p><p>并行：当系统有一个以上CPU时，当一个CPu执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，我们称之为并行(Parallel)。其实决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以并行。</p><p>并发，指的是多个事情,在同一时间段内同时发生了。并发的多个任务之间是互相抢占资源的。<br>并行，指的是多个事情,在同一时间点上同时发生了。并行的多个任务之间是不互相抢占资源的。</p><hr><p>并行(Parallel)：指<strong>多条垃圾收集线程</strong>并行工作，但此时用户线程仍处于等待状态。如ParNew、Parallel scavenge、Parallel old;</p><p>串行(Serial)：相较于并行的概念,单线程执行。如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。</p><p>并发(Concurrent)：指用户线程与垃圾收集线程同时执行(但不一定是并行的，可能会交替执行)，垃圾回收线程在执行时不会停顿用户程序的运行。</p><blockquote><p>用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上；如：CMS、G1</p></blockquote><h4 id="安全点和安全区域"><a href="#安全点和安全区域" class="headerlink" title="安全点和安全区域"></a>安全点和安全区域</h4><p>程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点(Safe Point) ”。</p><p>Safe Point的选择很重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，通常会根据“是否具有让程序长时间执行的特征”为标准。比如:：选择一些执行时间较长的指令作为Safe Point，如方法调用、循环跳转和异常跳转等。</p><p>如何在GC发生时,检查所有线程都跑到最近的安全点停顿下来呢?</p><blockquote><p>抢先式中断：首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。（目前没有虚拟机采用了)</p><p>主动式中断：设置一个中断标志，各个线程运行到safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。</p></blockquote><p>安全区域</p><blockquote><p>Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safe Point 。但是，程序“不执行”的时候呢?例如线程处于sleep状态或Blocked状态，这时候线程无法响应JVM的中断请求，“走”到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域(Safe Region)来解决。</p><p>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的。我们也可以把Safe Region看做是被扩展了的Safe Point。</p></blockquote><p>实际执行时:<br>1、当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region,如果这段时间内发生GC，JVM会忽略标识为Safe Region状态的线程;</p><p>2、当线程即将离开Safe Region时，会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止。</p><h4 id="java引用"><a href="#java引用" class="headerlink" title="java引用"></a>java引用</h4><p>强引用——软引用——弱引用——虚引用，引用强度逐级递减。</p><p>强引用(Strong Reference)：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj=new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</p><p>软引用(Soft Reference)：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。</p><p>弱引用(Weak Reference)：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。</p><p>虚引用(Phantom Reference)：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。<strong>为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</strong>（对象回收跟踪）</p><h5 id="强引用——不回收"><a href="#强引用——不回收" class="headerlink" title="强引用——不回收"></a>强引用——不回收</h5><blockquote><p>在Java程序中，最常见的引用类型是强引用（普通系统99%以上都是强引用)，也就是我们最常见的普通对象引用，也是默认的引用类型。</p><p>当在]ava语言中使用new操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。</p><p>强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。</p><p>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应(强)引用赋值为null，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。</p><p>相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的（<font color="red">均为可达的</font>），在一定条件下，都是可以被回收的。<strong>所以，强引用是造成Java内存泄漏的主要原因之一</strong>。</p></blockquote><h5 id="软引用——内存不足即回收"><a href="#软引用——内存不足即回收" class="headerlink" title="软引用——内存不足即回收"></a>软引用——内存不足即回收</h5><blockquote><p>软引用是用来描述一些还有用，但非必需的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p><p>软引用通常用来实现内存敏感的缓存。比如：高速缓存就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p><p>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列(Reference Queue)。</p><p>类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。</p></blockquote><h5 id="弱引用——发现即回收"><a href="#弱引用——发现即回收" class="headerlink" title="弱引用——发现即回收"></a>弱引用——发现即回收</h5><blockquote><p>弱引用也是用来描述那些非必需对象，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。</p><p>但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。</p><p>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</p><p>软引用、弱引用都非常适合来保存那些可有可无的缓存数据。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用</p></blockquote><h5 id="虚引用——对象回收跟踪"><a href="#虚引用——对象回收跟踪" class="headerlink" title="虚引用——对象回收跟踪"></a>虚引用——对象回收跟踪</h5><blockquote><p>也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个。</p><p>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</p><p>它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get()方法取得对象时，总是null。</p><p>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。</p><p>虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用就会在回收对象后，<strong>将这个虚引用加入引用队列</strong>，以通知应用程序对象的回收情况，我们可以操作该队列来完成一个通知的机制。</p></blockquote><h5 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h5><blockquote><p>它用以实现对象的finalize()方法，也可以称为终结器引用。</p><p>无需手动编码,其内部配合引用队列使用。</p><p>在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象并调用它的finalize()方法，第二次GC时才能回收被引用对象。</p></blockquote><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><h4 id="GC分类与性能指标"><a href="#GC分类与性能指标" class="headerlink" title="GC分类与性能指标"></a>GC分类与性能指标</h4><p>吞吐量：运行用户代码的时间占总运行时间的比例</p><blockquote><p>（总运行时间：程序的运行时间＋内存回收的时间)</p></blockquote><p>垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。<br>暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间。<br>收集频率：相对于应用程序的执行，收集操作发生的频率。<br>内存占用：Java 堆区所占的内存大小。<br>快速：一个对象从诞生到被回收所经历的时间。</p><p>暂停时间的重要性逐渐凸显。</p><h4 id="垃圾回收器和分代关系"><a href="#垃圾回收器和分代关系" class="headerlink" title="垃圾回收器和分代关系"></a>垃圾回收器和分代关系</h4><p>新生代收集器: Serial、ParNew、Parallel scavenge;<br>老年代收集器: serial old、Parallel old、CMS;<br>整堆收集器:G1;</p><p><img src="https://i.loli.net/2021/03/03/c8nYaLOTkhr3DlH.png" alt="image.png"></p><p>其中虚线为JDK8及以前的搭配。</p><p>且Serrial Old GC是作为CMS GC的后备方案。因为CMS需要在老年代未满时进行并发回收，如果老年代满了，只能通过Serial Old GC来收集。</p><h5 id="Serial-GC（串行回收）"><a href="#Serial-GC（串行回收）" class="headerlink" title="Serial GC（串行回收）"></a>Serial GC（串行回收）</h5><p>单线程。</p><p>新生代复制算法、老年代标记-整理算法。都需要STW。</p><h5 id="ParNew-GC（并行回收）"><a href="#ParNew-GC（并行回收）" class="headerlink" title="ParNew GC（并行回收）"></a>ParNew GC（并行回收）</h5><p>Serial的多线程版本。</p><p>New代表处理的是新生代，采用复制算法。也需要STW。、</p><p>可以和CMS和Serial Old搭配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UserParNewGC 启用ParNew GC</span><br><span class="line">-XX:PareallelGCThreads 限制线程数量 默认和CPU相同</span><br></pre></td></tr></table></figure><h5 id="Parallel-Scavenge回收器（吞吐量优先、并行）"><a href="#Parallel-Scavenge回收器（吞吐量优先、并行）" class="headerlink" title="Parallel Scavenge回收器（吞吐量优先、并行）"></a>Parallel Scavenge回收器（吞吐量优先、并行）</h5><p>同样新生代采用复制算法，需要STW。</p><p>且存在动态自适应调节策略。</p><p>Parallel Old采用标记压缩算法处理老年代，需要STW。</p><p>java8默认收集器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UserParallelGC 启用Parallel GC</span><br><span class="line">-XX:+UserParallelOldGC 且这两个参数互相激活</span><br><span class="line">-XX:PareallelGCThreads 年轻代垃圾收集的线程数</span><br><span class="line">-XX:GCTimeRatio 垃圾收集时间占总时间的比例</span><br><span class="line">-XX:MaxGCPauseMillis 慎用 设置最大暂停时间</span><br><span class="line">-XX:+UseAdaptivesizePolicy 自适应调节策略</span><br></pre></td></tr></table></figure><h5 id="CMS-GC（低延迟）"><a href="#CMS-GC（低延迟）" class="headerlink" title="CMS GC（低延迟）"></a>CMS GC（低延迟）</h5><p>concurrent-mark-sweep 并发-标记-清除 也会STW，为了能在并发清除时不用STW，所以使用mark-sweep</p><p>垃圾收集线程和用户线程同时工作</p><p>只能和Serial、ParNew配合工作。jdk14删除</p><p>CNS整个过程比之前的收集器要复杂,整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段。</p><blockquote><p>初始标记(Initial-Mark)阶段：在这个阶段中，程序中所有的工作线程都将会因为“Stop-the-world”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是标记出GC Roots能<strong>直接关联到的对象</strong>。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。</p><p>并发标记(Concurrent-Mark)阶段：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是<strong>不需要停顿用户线程</strong>，可以与垃圾收集线程一起并发运行。（耗时）</p><p>重新标记(Remark)阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</p><p>并发清除(Concurrent-Sweep)阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。（耗时）</p></blockquote><p><img src="https://i.loli.net/2021/03/03/w6mbDEpgxHdSyo2.png" alt="image.png"></p><p>在并发标记时，需要保证用户线程仍然有足够的内存可以使用。不能在老年代满的时候再收集。否则需要Serial Old GC作为后备方案。</p><p>也会产生内存碎片。需要空闲列表。</p><p>弊端：</p><blockquote><p>1)会产生内存碎片，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发Full GC。<br>2)CMS收集器对cPu资源非常敏感。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。<br>3)CMS收集器无法处理浮动垃圾。可能出现“concurrent Mode Failure”失败而导致另一次 Full cC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在<strong>并发标记阶段如果产生新的垃圾对象</strong>，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行Gc时释放这些之前未被回收的内存空间。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UserConcMarkSweepGC 老年代 默认新生代使用ParNew GC</span><br><span class="line">-XX:CMSInitiatingOccupyFraction 设置堆内存使用率的阈值 %65 jdk6+：%92</span><br><span class="line">还有参数设置多久执行一次内存碎片的整理</span><br></pre></td></tr></table></figure><h5 id="G1-GC（区域化分代式）"><a href="#G1-GC（区域化分代式）" class="headerlink" title="G1 GC（区域化分代式）"></a>G1 GC（区域化分代式）</h5><p>官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望。</p><p>G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1 跟踪各个Region里面的垃圾堆积的价值大小(回收所获得的空间大小以佟以收所需可间的约城值)，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。</p><p>特点</p><blockquote><p>并行与并发：</p><p>并行性: G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW。<br>并发性: G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况。</p><p>分代收集：</p><p>①从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。<br>②将堆空间分为若干个区域(Region)，这些区域中包含了逻辑上的年轻代和老年代。<br>③和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代。</p><p>空间整合：</p><p>CMS：“标记-清除”算法、内存碎片、若干次GC后进行一次碎片整理<br>G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。Region之间是复制算法，但整体上实际可看作是标记-压缩(Mark-Compact)算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。</p><p>可预测的停顿时间模型(即：软实时soft real-time)：</p><p>这是G1 相对于CMS 的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</p><p>①由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。<br>②G1 跟踪各个Region里面的垃圾堆积的价值大小(回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了G1 收集器在有限的时间内可以获取尽可能高的收集效率。<br>③相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseG1GC 手动指定使用G1收集器执行内存回收任务。</span><br><span class="line">-XX:G1HeapRegionSize设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000.</span><br><span class="line">-XX:MaxGCPauseMillis设置期望达到的最大Gc停顿时间指标(JVM会尽力实现，但不保证达到)。默认值是200ms</span><br><span class="line">-XX:Paralle1GCThread 设置STW工作线程数的值。最多设置为8</span><br><span class="line">-XX:ConcGChreads设置并发标记的线程数。将n设置为并行垃圾回收线程数(ParallelGCThreads)的1/4左右。</span><br><span class="line">-XX:InitiatingHeapOccupancyPercent 设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发Gc。默认值是45。</span><br></pre></td></tr></table></figure><p>G1的设计原则就是简化VM性能调优，开发人员只需要简单的三步即可完成调优:</p><p>第一步:开启G1垃圾收集器<br>第二步:设置堆的最大内存<br>第三步:设置最大的停顿时间</p><p>G1中提供了三种垃圾回收模式: YoungGc、Mixed Gc和Full Gc，在不同的条件下被触发。</p><p>设置H的原因:</p><blockquote><p>对于堆中的大对象，默认直接会被分配到老年代,I但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动Full Gc。G1的大多数行为都把H区作为老年代的一部分来看待。</p></blockquote><p>在region内部分配内存采用指针碰撞，还可以分配TLAB。</p><p><strong>垃圾回收细节</strong></p><p>G1垃圾回收主要包含三个环节：</p><p>①年轻代GC(Young GC)<br>②老年代并发标记过程(Concurrent Marking)<br>③混合回收(Mixed Gc)<br>(如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。)</p><p><img src="https://i.loli.net/2021/03/04/Idiyfvm8cHtTwxY.png" alt="image.png"></p><blockquote><p>应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程; G1的年轻代收集阶段是一个并行的独占式收集器。在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。</p><p>当堆内存使用达到一定值(默认45%)时，开始老年代并发标记过程。</p><p>标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了。同时，这个老年代Region是和年轻代一起被回收的。</p><p>举个例子：一个web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</p></blockquote><p><strong>Remebered Set</strong></p><p>一个对象被不同区域引用的问题</p><blockquote><p>一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时,是否需要扫描整个Java堆才能保证准确?</p><p>在其他的分代收集器，也存在这样的问题(而G1更突出)</p><p>回收新生代也不得不同时扫描老年代?</p><p>这样的话会降低Minor GC的效率?</p></blockquote><p>解决方法:</p><blockquote><p>无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描</p><p>每个Region都有一个对应的Remembered set;</p><p>每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作;</p><p>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region(其他收集器:检查老年代对象是否引用了新生代对象);</p><p>如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered set中;</p><p>当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set，就可以保证不进行全局扫描，也不会有遗漏。</p><p>笔者理解：即在回收某一个region时，如果该region中的对象仍然存在其他region的对象引用他们，则这些引用的对象肯定是存在于Remebered Set中的，这样就能够很好的进行标记了，也不会遗漏。</p></blockquote><p><img src="https://i.loli.net/2021/03/04/qxfND297J8VGFip.png" alt="image.png"></p><p><strong>垃圾回收过程</strong></p><p>YGC：</p><blockquote><p>JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。</p><p>年轻代垃圾回收只会回收Eden区和Survivor区。</p><p>YGC时，首先G1停止应用程序的执行(stop-The-world) ，G1创建回收集（collection Set)，回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区<strong>所有</strong>的内存分段。</p></blockquote><p>具体过程</p><blockquote><p>然后开始如下回收过程:</p><p>第一阶段，扫描根。<br>根是指static变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同RSet记录的外部引用作为扫描存活对象的入口。</p><p>第二阶段，更新RSet。<br>处理dirty card queue(见备注)中的card，更新RSet。此阶段完成后，RSet可以准确的反映老年代对所在的内存分段中对象的引用。</p><p>第三阶段，处理RSet。<br>识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。</p><p>第四阶段，复制对象。<br>此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到survivor区中空的内存分段survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到o1d区中空的内存分段。如果survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。</p><p>第五阶段,处理引用。<br>处理Soft，weak，Phantom，Final，JNI weak 等引用。最终Eden空间的数据为空，Gc停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果．减少碎片</p></blockquote><p>并发标记阶段：</p><blockquote><p>1、初始标记阶段：标记从根节点直接可达的对象。这个阶段是STW的，并且会触发一次年轻代GC。<br>2、根区域扫描（Root Region Scanning)：G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在Young GC之前完成。<br>3、并发标记(Concurrent Marking)：在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被Young GC中断。在并发标记阶段，<strong>若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收</strong>。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。<br>4、再次标记(Remark)：由于应用程序持续进行，需要修正上一次的标记结果是STW的。G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。<br>5、独占清理(cleanup,STW)：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。(这个阶段并不会实际上去做垃圾的收集)<br>6、并发清理阶段：识别并清理完全空闲的区域。</p></blockquote><p>混合回收</p><blockquote><p>当越来越多的对象晋升到老年代old region时,为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个old Gc，除了回收整个Young Region,还会回收一部分的old Region。这里需要注意：是一部分老年代，而不是全部老年代。可以选择哪些old Region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed Gc并不是Full Gc。</p></blockquote><p>导致G1Full GC的原因可能有两个:</p><p>①Evacuation的时候没有足够的to-space来存放晋升的对象<br>②并发处理过程完成之前空间耗尽。</p><p>优化建议</p><blockquote><p>年轻代大小：避免使用-Xmn或-XX;NewRatio等相关选项显式设置年轻代大小&gt;固定年轻代的大小会覆盖暂停时间目标<br>暂停时间目标不要太过严苛</p><p>G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间<br>评估G1 Gc的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</p></blockquote><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p><img src="https://i.loli.net/2021/03/04/oFTlgyn5s2i61VQ.png" alt="image.png"></p><p>怎么选择垃圾回收器?</p><blockquote><p>Java垃圾收集器的配置对于VM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一个很大的提升。</p><p>优先调整堆的大小让JVM自适应完成。</p><p>如果内存小于100M，使用串行收集器</p><p>如果是单核、单机程序，并且没有停顿时间的要求，串行收集器</p><p>如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择</p><p>如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用)，使用并发收集器，官方推荐G1，性能高。现在互联网的项目，基本都是使用G1。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面试准备</title>
      <link href="/2021/03/04/Java%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"/>
      <url>/2021/03/04/Java%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<h1 id="Java面试准备"><a href="#Java面试准备" class="headerlink" title="Java面试准备"></a>Java面试准备</h1><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="String、StringBuilder、StringBuffer"><a href="#String、StringBuilder、StringBuffer" class="headerlink" title="String、StringBuilder、StringBuffer"></a>String、StringBuilder、StringBuffer</h3><a id="more"></a><blockquote><p>String 类中使用 final 关键字修饰字符数组来保存字符串，<code>private final char value[]</code>，所以 String 对象是不可变的。补充（来自<a href="https://github.com/Snailclimb/JavaGuide/issues/675" target="_blank" rel="noopener">issue 675</a>）：在 Java 9 之后，String 类的实现改用 byte 数组存储字符串 <code>private final byte[] value</code>。</p><p>而 StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串<code>char[] value</code> 但是没有用 final 关键字修饰，所以这两种对象都是可变的。</p></blockquote><p><strong>线程安全性</strong></p><blockquote><p>String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p></blockquote><p><strong>性能</strong></p><blockquote><p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p></blockquote><p><strong>对于三者使用的总结：</strong></p><blockquote><p>操作少量的数据: 适用 String</p><p>单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder</p><p>多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer</p></blockquote><h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(xxx);</span><br><span class="line">Integer i = xxx;</span><br></pre></td></tr></table></figure><blockquote><p>在通过valueOf方法创建Integer对象的时候，如果数值在[-128,127]之间，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。</p></blockquote><blockquote><p>同时：Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的。而Double、Float的valueOf方法的实现是类似的。而对于Boolean类，则是通过两个静态变量实现的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean TRUE = <span class="keyword">new</span> Boolean(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean FALSE = <span class="keyword">new</span> Boolean(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Integer a = <span class="number">1</span>;</span><br><span class="line">        Integer b = <span class="number">2</span>;</span><br><span class="line">        Integer c = <span class="number">3</span>;</span><br><span class="line">        Integer d = <span class="number">3</span>;</span><br><span class="line">        Integer e = <span class="number">321</span>;</span><br><span class="line">        Integer f = <span class="number">321</span>;</span><br><span class="line">        Long g = <span class="number">3L</span>;</span><br><span class="line">        Long h = <span class="number">2L</span>;</span><br><span class="line">    </span><br><span class="line">        System.out.println(c==d); <span class="comment">// true</span></span><br><span class="line">        System.out.println(e==f); <span class="comment">// false</span></span><br><span class="line">        System.out.println(c==(a+b)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(c.equals(a+b)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(g==(a+b)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(g.equals(a+b)); <span class="comment">// false</span></span><br><span class="line">        System.out.println(g.equals(a+h)); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>第一个和第二个输出结果没有什么疑问。第三句由于 a+b包含了算术运算，因此会触发自动拆箱过程（会调用intValue方法），因此它们比较的是数值是否相等。而对于c.equals(a+b)会先触发自动拆箱过程，再触发自动装箱过程，也就是说a+b，会先各自调用intValue方法，得到了加法运算后的数值之后，便调用Integer.valueOf方法，再进行equals比较。同理对于后面的也是这样，不过要注意倒数第二个和最后一个输出的结果（如果数值是int类型的，装箱过程调用的是Integer.valueOf；如果是long类型的，装箱调用的Long.valueOf方法）。</p></blockquote><h3 id="equals-和hashCode-方法"><a href="#equals-和hashCode-方法" class="headerlink" title="equals()和hashCode()方法"></a>equals()和hashCode()方法</h3><blockquote><p>没重写了equals的类调用equals方法和使用<code>==</code>等价，比较两个对象的地址是否相同<br>重写equals方法时，需要注意满足其原生的一些特点，可参考下面代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(obj == <span class="keyword">null</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果是同一个对象返回true，反之返回false</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span> == obj)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//判断是否类型相同</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.getClass() != obj.getClass())&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 最后制定自己想要的规则进行重写</span></span><br><span class="line">      Person person = (Person)obj;</span><br><span class="line">      <span class="keyword">return</span> name.equals(person.name) &amp;&amp; age == person.age;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>hashCode方法获取对象的一个哈希码，即一个整数值。且<strong>hashCode() 在散列表中才有用，在其它情况下没用。</strong>在散列表中hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。</p></blockquote><blockquote><p>由此可知，若两个元素相等，它们的散列码一定相等；但反过来确不一定。在散列表中，<br>1、如果两个对象相等，那么它们的hashCode()值一定要相同；<br>2、如果两个对象hashCode()相等，它们并不一定相等。<br>注意：这是在散列表中的情况。在非散列表中一定如此！</p></blockquote><p><strong>为什么重写 <code>equals</code> 时必须重写 <code>hashCode</code> 方法？</strong></p><blockquote><p>本质：为了遵守2个对象equals，那么其hashCode一定相同的规则。</p><p>如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等，对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。<strong>因此，equals 方法被覆盖过，则 <code>hashCode</code> 方法也必须被覆盖。</strong></p></blockquote><blockquote><p>且<code>hashCode()</code>的默认行为是对堆上的对象产生独特值。如果没有重写 <code>hashCode()</code>，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p></blockquote><h3 id="Java值传递"><a href="#Java值传递" class="headerlink" title="Java值传递"></a>Java值传递</h3><blockquote><p>Java 程序设计语言对对象采用的不是引用调用，实际上，对象引用也是按值传递的。</p><p>下面再总结一下 Java 中方法参数的使用情况：</p><ul><li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。</li><li>一个方法可以改变一个对象参数的状态。</li><li>一个方法不能让对象参数引用一个新的对象。</li></ul><p>可参考下面的代码理解</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person();</span><br><span class="line">        p1.name = <span class="string">"1"</span>;</span><br><span class="line">        p2.name = <span class="string">"2"</span>;</span><br><span class="line">        change(p1, p2);</span><br><span class="line">        System.out.println(p1.name);</span><br><span class="line">        <span class="comment">// 输出 1</span></span><br><span class="line">        changeName(p1, p2);</span><br><span class="line">        System.out.println(p1.name);</span><br><span class="line">        <span class="comment">// 输出 2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(Person p1, Person p2)</span> </span>&#123;</span><br><span class="line">        p1 = p2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changeName</span><span class="params">(Person p1, Person p2)</span> </span>&#123;</span><br><span class="line">        p1.name = p2.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>final 关键字主要用在三个地方：变量、方法、类。</p><blockquote><p>对于一个 final 变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</p><p>当用 final 修饰一个类时，表明这个类不能被继承。final 类中的所有成员方法都会被隐式地指定为 final 方法。</p><p>使用 final 方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的 Java 实现版本中，会将 final 方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的 Java 版本已经不需要使用 final 方法进行这些优化了）。类中所有的 private 方法都隐式地指定为 final。</p></blockquote><h3 id="I-O流"><a href="#I-O流" class="headerlink" title="I/O流"></a>I/O流</h3><p>流的种类：</p><blockquote><p>按照流的流向分，可以分为输入流和输出流；</p><p>按照操作单元划分，可以划分为字节流和字符流；</p><p>按照流的角色划分为节点流和处理流。</p></blockquote><p>对于所有相关类，都由下方四个抽象基类进行派生</p><blockquote><p>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</p><p>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</p></blockquote><p>BIO、NIO、AIO</p><blockquote><p><strong>BIO (Blocking I/O):</strong> 同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机 1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</p><p><strong>NIO (Non-blocking/New I/O):</strong> NIO 是一种同步非阻塞的 I/O 模型，在 Java 1.4 中引入了 NIO 框架，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 NIO 提供了与传统 BIO 模型中的 <code>Socket</code> 和 <code>ServerSocket</code> 相对应的 <code>SocketChannel</code> 和 <code>ServerSocketChannel</code> 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞 I/O 来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发</p><p><strong>AIO (Asynchronous I/O):</strong> AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步 IO 的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO 操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</p></blockquote><h2 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>ArrayList和LinkedList</p><blockquote><p>均不同步，均不保证线程安全。</p><p>ArrayList：底层由Object数组实现。插入元素到末尾O(1)，插入元素到指定位置O(n-i)。且支持高效的随机访问。</p><p>LinkedList：底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环)，插入元素到末尾O(1)，插入元素到指定位置O(n)，需要移动指针。</p><p>补充：<code>RandomAccess</code> 接口。里面没有任何定义，仅仅作为标识，是否支持快速随机访问。ArrayList实现了该接口而LinkedList没有。</p><p>Vector：List的古老实现类，底层使用Object数组实现，且保证线程安全。</p></blockquote><p>ArrayList扩容机制</p><blockquote><p>对于空参构造时，会初始化一个空数组，直到第一个元素被添加时，才会扩容到10。懒加载(但在jdk7及以前会直接初始化一个容量为10的数组)</p><p>对于需要扩容的过程。则是<code>ensureCapacityInternal()</code> -&gt; <code>ensureExplicitCapacity()</code> -&gt; <code>grow()</code></p><p>对于前两个方法，主要就是处理容量初始化和判断是否需要扩容。</p><p>对于核心<code>grow()</code>方法，需要扩容时，会首先扩容置原容量的1.5倍左右(<code>new = old + old &gt;&gt; 1</code>)，然后如果new满足需求，则会直接用new作为新容量，否则会将当前所需容量作为新容量。如果new已经大于了所给的<code>MAX_ARRAY_SIZE</code>即<code>Integer.MAX_VALUE - 8</code>，则会根据当前所需容量和<code>MAX_ARRAY_SIZE</code>进行比较吗，从而决定取<code>MAX_ARRAY_SIZE</code>或者<code>Integer.MAX_VALUE</code>。</p><p>tips：向 ArrayList 添加大量元素之前最好先使用<code>ensureCapacity</code> 方法，以减少增量重新分配的次数。</p></blockquote><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>HashMap vs HashTable</p><blockquote><p>HashMap: 线程不安全。支持<code>null</code>作为键和值，但只允许存在一个以<code>null</code>为键的键值对，允许多个键值对以<code>null</code>作为值。</p><p>HashTable: 线程安全(现在基本使用ConcurrentHashMap保证线程安全)，HashTable基本已经被淘汰。HashTable不允许<code>null</code>作为键或者值，会抛出<code>NullPointerException</code>异常。</p><p>① 创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证）。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</p></blockquote><p>HashSet</p><blockquote><p>底层由HashMap实现。</p><p>添加元素机制：当你把对象加入<code>HashSet</code>时，<code>HashSet</code> 会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p></blockquote><p>HashMap底层实现</p><blockquote><p>JDK1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。<strong>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</strong></p><p>JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</p></blockquote><p>HashMap长度为2的幂次方</p><blockquote><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648到2147483647，前后加起来大概40亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个40亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ <code>(n - 1) &amp; hash</code>”。（n代表数组长度）。这也就解释了 HashMap 的长度为什么是2的幂次方。</p><p><code>(n - 1) &amp; hash</code>也就是<code>hash % (n - 1)</code>的快速版本。</p></blockquote><p>HashMap多线程情况下死循环的问题</p><blockquote><p>详情请查看：<a href="https://coolshell.cn/articles/9606.html" target="_blank" rel="noopener">https://coolshell.cn/articles/9606.html</a></p></blockquote><p>ConcurrentHashMap 和 Hashtable 的区别]</p><blockquote><p><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别主要体现在实现线程安全的方式上不同。</p><p><strong>底层数据结构：</strong> JDK1.7 的 <code>ConcurrentHashMap</code> 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，数组+链表/红黑二叉树。<code>Hashtable</code> 和 JDK1.8 之前的 <code>HashMap</code> 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</p><p><strong>实现线程安全的方式（重要）：</strong> ① <strong>在 JDK1.7 的时候，<code>ConcurrentHashMap</code>（分段锁）</strong> 对整个桶数组进行了分割分段(<code>Segment</code>)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 <strong>到了 JDK1.8 的时候已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。（JDK1.6 以后 对 <code>synchronized</code> 锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② <strong><code>Hashtable</code>(同一把锁)</strong> :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</p></blockquote><p>ConcurrentHashMap线程安全的具体实现方式/底层具体实现</p><blockquote><p>jdk1.7：首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p><p><strong><code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成</strong>。</p><p>Segment 实现了 <code>ReentrantLock</code>,所以 <code>Segment</code> 是一种可重入锁，扮演锁的角色。<code>HashEntry</code> 用于存储键值对数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个 <code>ConcurrentHashMap</code> 里包含一个 <code>Segment</code> 数组。<code>Segment</code> 的结构和 <code>HashMap</code> 类似，是一种数组和链表结构，一个 <code>Segment</code> 包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 是一个链表结构的元素，每个 <code>Segment</code> 守护着一个 <code>HashEntry</code> 数组里的元素，当对 <code>HashEntry</code> 数组的数据进行修改时，必须首先获得对应的 <code>Segment</code> 的锁。</p></blockquote><blockquote><p>jdk1.8：<code>ConcurrentHashMap</code> 取消了 <code>Segment</code> 分段锁，采用 CAS 和 <code>synchronized</code> 来保证并发安全。数据结构跟 HashMap1.8 的结构类似，数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）。<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>List</p><ul><li><code>Arraylist</code>： <code>Object[]</code>数组</li><li><code>Vector</code>：<code>Object[]</code>数组</li><li><code>LinkedList</code>： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</li></ul><p>Set</p><ul><li><code>HashSet</code>（无序，唯一）: 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素</li><li><code>LinkedHashSet</code>：<code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。有点类似于我们之前说的 <code>LinkedHashMap</code> 其内部是基于 <code>HashMap</code> 实现一样，不过还是有一点点区别的</li><li><code>TreeSet</code>（有序，唯一）： 红黑树(自平衡的排序二叉树)</li></ul><p>再来看看 <code>Map</code> 接口下面的集合。</p><p>Map</p><ul><li><code>HashMap</code>： JDK1.8 之前 <code>HashMap</code> 由数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li><li><code>LinkedHashMap</code>： <code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：<a href="https://www.imooc.com/article/22931" target="_blank" rel="noopener">《LinkedHashMap 源码详细分析（JDK1.8）》</a></li><li><code>Hashtable</code>： 数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的</li><li><code>TreeMap</code>： 红黑树（自平衡的排序二叉树</li></ul><h2 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h2><p>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</p><blockquote><p> new 一个 Thread，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p><p><strong>总结： 调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</strong></p></blockquote><h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><p><strong>synchronized 关键字最主要的三种使用方式：</strong></p><blockquote><p><strong>1.修饰实例方法:</strong> 作用于当前对象实例加锁，进入同步代码前要获得 <strong>当前对象实例的锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.修饰静态方法:</strong> 也就是给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 <strong>当前 class 的锁</strong>。因为静态成员不属于任何一个实例对象，是类成员（ _static 表明这是该类的一个静态资源，不管 new 了多少个对象，只有一份_）。所以，如果一个线程 A 调用一个实例对象的非静态 <code>synchronized</code> 方法，而线程 B 需要调用这个实例对象所属类的静态 <code>synchronized</code> 方法，是允许的，不会发生互斥现象，<strong>因为访问静态 <code>synchronized</code> 方法占用的锁是当前类的锁，而访问非静态 <code>synchronized</code> 方法占用的锁是当前实例对象锁</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> staic <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.修饰代码块</strong> ：指定加锁对象，对给定对象/类加锁。<code>synchronized(this|object)</code> 表示进入同步代码库前要获得<strong>给定对象的锁</strong>。<code>synchronized(类.class)</code> 表示进入同步代码前要获得 <strong>当前 class 的锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">  <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li><code>synchronized</code> 关键字加到 <code>static</code> 静态方法和 <code>synchronized(class)</code> 代码块上都是是给 Class 类上锁。</li><li><code>synchronized</code> 关键字加到实例方法上是给对象实例上锁。</li><li>尽量不要使用 <code>synchronized(String a)</code> 因为 JVM 中，字符串常量池具有缓存功能！</li></ul></blockquote><h3 id="MESI缓存一致性协议"><a href="#MESI缓存一致性协议" class="headerlink" title="MESI缓存一致性协议"></a>MESI缓存一致性协议</h3><p>多个cpu从主内存读取同一个数据到各自的高速缓存，当其中某个cpu修改了缓存里的数据，该数据会马上同步回主内存，其它cpu通过<strong>总线嗅探机制</strong>可以感知到数据的变化从而将自己缓存里的数据失效。从而使得cpu重新到主存中读取已经被更新的数据。</p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><blockquote><p>是一种轻量级的同步机制，保证了可见性和有序性，通过内存屏障能够防止指令重排。</p></blockquote><p>保证可见性的原理：</p><blockquote><p>可见性：总线嗅探机制。</p><p>当volatile修饰的变量发生改变时，线程A会立刻将该变量从工作内存同步到共享内存中且强迫其他拥有该变量副本的线程(线程B)中的该变量失效，使其必须重新从主存中拷贝更新后的变量。</p><p>且有volatile修饰的共享变量进行写操作的时候多出一条带<code>lock</code>前缀的指令，且lock前缀的指令在多核处理器下会引发两件事情：</p><ol><li>将当前处理器缓存行的数据写回到系统内存。</li><li>这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。</li></ol></blockquote><p><strong>内存屏障</strong></p><p>内次屏障分为以下4类</p><table><thead><tr><th align="left">屏障类型</th><th align="left">指令示例</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">LoadLoad Barries</td><td align="left">Load1;LoadLoad;Load2</td><td align="left">确保Load1数据的装载先于Load2以及后续装载指令的装载。</td></tr><tr><td align="left">StoreStore Barries</td><td align="left">Store1;StoreStore;Store2</td><td align="left">确保Store1数据刷新到内存先于Store2以及后续存储指令的存储。</td></tr><tr><td align="left">LoadStore Barries</td><td align="left">Load1;LoadStore;Store2</td><td align="left">确保Load1数据的装载先于Store2数据刷新到内存以及后续存储指令的存储。</td></tr><tr><td align="left">StoreLoad Barries</td><td align="left">Store1;StoreLoad;Load2</td><td align="left">确保Store1数据刷新到内存先于Load2数据的装载以及后续装载指令的装载。</td></tr></tbody></table><p>volatile实现有序性：</p><blockquote><ul><li>在每个volatile写操作的前面插入一个StoreStore屏障。禁止前面的普通写和下面的volatile写重排序。</li><li>在每个volatile写操作的后面插入一个StoreLoad屏障。禁止前面的volatile写和下面可能有的volatile读的重排序。</li><li>在每个volatile读操作的后面插入一个LoadLoad屏障。禁止前面的volatile读和下面的普通读重排序。</li><li>在每个volatile读操作的后面再插入一个LoadStore屏障。禁止前面的volatile读和下面的普通写重排序。</li></ul></blockquote><p>synchronized保证可见性和有序性原理：</p><blockquote><p>可见性：</p><p>JMM关于synchronized的两条规定：</p><p>1）线程解锁前，必须把共享变量的最新值刷新到主内存中</p><p>2）线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新获取最新的值</p><p>（注意：加锁与解锁需要是同一把锁）</p><p>有序性：</p><p>因为synchronized是一种排他锁，所以同一时刻只有一个线程执行，保证加锁的代码是单线程的，遵循as-if-serial语义，因此能够保证有序性。</p></blockquote><p>volatile和synchronized同步使用的原因</p><blockquote><p>关于这个问题有一个很经典的例子，就是单例模式中的双重检查加锁对象初始化可能为null的问题，这个问题就是指令重排引起的。</p><p>具体来说就是synchronized虽然保证了原子性，但却没有保证指令重排序的正确性； </p><p>volatile使共享变量在线程的工作内存中修改后的值能够立即更新到进程主内存，即 volitile 可以保证共享变量值对所有线程的“可见性”，但是它不能保证原子性，</p><p>而且他还有一个很好的附加功能，那就是禁止指令重排。</p><p>将 synchronized 与 volatile 联合使用就可以解决这个问题</p></blockquote><h3 id="CAS-compare-and-swap"><a href="#CAS-compare-and-swap" class="headerlink" title="CAS(compare and swap)"></a>CAS(compare and swap)</h3><p>CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。</p><p>更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。</p><blockquote><p>缺点：会一直循环，开销较大。</p><p>对于一个共享变量执行操作时，可以通过循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS无法保证原子性，需要通过锁来保证原子性。</p></blockquote><h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><p>所谓ABA问题，就是CAS算法实现需要取出内存中某时刻的数据并在当下时刻比较并替换，这里存在一个时间差，使用AtomicStampedReference类可以解决ABA问题。这个类维护了一个“版本号”Stamp，在进行CAS操作的时候，不仅要比较当前值，还要比较版本号。只有两者都相等，才执行更新操作。</p><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><h2 id="MySQL调优"><a href="#MySQL调优" class="headerlink" title="MySQL调优"></a>MySQL调优</h2><p>redo log、undo log、binlog</p><p><img src="https://i.loli.net/2021/03/04/K8chDsaJLgeWFpU.png" alt="image.png"></p><ul><li>redo log是属于innoDB层面，binlog属于MySQL Server层面的，这样在数据库用别的存储引擎时可以达到一致性的要求。</li><li>redo log是物理日志，记录该数据页更新的内容；binlog是逻辑日志，记录的是这个更新语句的原始逻辑</li><li>redo log是循环写，日志空间大小固定；binlog是追加写，是指一份写到一定大小的时候会更换下一个文件，不会覆盖。</li><li>binlog可以作为恢复数据使用，主从复制搭建，redo log作为异常宕机或者介质故障后的数据恢复使用。</li></ul><p>事务特性：ACID。</p><p>事务隔离界别：</p><ol><li>读未提交（READ UNCOMMITTED）</li><li>读提交 （READ COMMITTED）</li><li>可重复读 （REPEATABLE READ）-&gt; 默认</li><li>串行化 （SERIALIZABLE）</li></ol><p>三范式：</p><p>1、不可分割    2、依赖于主键 主键约束    3、外键约束    BF、消除传递依赖</p><h3 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h3><p>存储引擎是针对<strong>表</strong>而言的，而不是针对<strong>整个数据库</strong>。即每个表可拥有不同的存储引擎。</p><p>种类：</p><blockquote><p>MyISAM：高速，在MySQL5.5版本前是作为默认存储引擎，但不支持事务。</p><p>InnoDB：作为MySQL 5.5版本后的默认存储引擎，支持事务和行级锁(行锁才能产生死锁)，比MyISAM稍慢。</p><p>Memory：内存存储引擎，效率很高，但数据容易丢失，用于临时表使用。</p></blockquote><p>顺序IO：追加操作。传输时间</p><p>随机IO：随机操作，可能写在随机的扇区。寻道时间+旋转时间+传输时间</p><p>MyISAM引擎：</p><blockquote><p><code>.frm</code>文件：存储表的结构定义</p><p><code>.MYD</code>文件：存储数据的文件</p><p><code>.MYI</code>文件：存储索引的文件</p><p>支持表锁，不支持行锁。不支持事务。</p><p>计算count：有专门存储count的地方。</p><p>主键索引为非聚集索引(索引文件和数据文件分离)</p></blockquote><p>InnoDB引擎：</p><blockquote><p><code>.frm</code>文件：存储表的结构定义</p><p><code>.ibd</code>文件：数据和索引均存储在该文件</p><p>支持表锁和行锁，也支持事务。</p><p>计算count：需要扫表。</p><p>因为数据文件本身就是按照B+树组织的索引结构文件。</p><p>主键索引为聚集索引。</p></blockquote><p>MyISAM索引B+树中的叶节点存储的data为：该索引对应数据的<strong>磁盘文件指针</strong></p><p>InnoDB索引B+树中的叶节点存储的data为：直接为该索引对应的数据，而不用再多一步指针</p><h3 id="MySQL性能分析"><a href="#MySQL性能分析" class="headerlink" title="MySQL性能分析"></a>MySQL性能分析</h3><ol><li>使用【慢查询功能】，获取查询时间较长的sql语句</li><li>【查看执行计划】，查看有问题的sql的执行计划</li><li>使用【<code>show profiles</code>】查看有问题的sql语句的性能使用情况</li></ol><h3 id="MySQL索引优化"><a href="#MySQL索引优化" class="headerlink" title="MySQL索引优化"></a>MySQL索引优化</h3><p>索引也很大，存储在磁盘上，且索引也就是一种数据结构(B+树)。</p><p>索引优劣</p><blockquote><p>优点：① 提高数据检索效率，降低IO成本；② 通过索引列对数据进行排序，降低排序成本和CPU消耗。(被索引的列会自动排序，对于<code>order by</code>等语句效率也会提高)</p><p>缺点：① 索引会占据磁盘空间；② 能提高查询效率但是会降低更新表的效率。比如每次对表进行增删改，需要对索引结构进行变更。</p></blockquote><p>常用索引：单列索引和组合索引。</p><blockquote><p>单列索引：<br>① 普通索引：MySQL基本索引类型，允许重复值和空值。<br>② 唯一索引：索引列值唯一，可包含空值。<br>③ 主键索引：特殊唯一索引，允许空值。</p><p>组合索引：<br>在表的多个字段组合上创建的一个索引。<br>组合索引的使用需要遵循最左前缀原则(最左匹配原则)。<br>且一般情况建议使用组合索引代替单列索引(主键索引除外)。</p></blockquote><p>MySQL的索引实现</p><blockquote><p><code>HASH</code>：无法进行范围查找，很少的存储引擎支持。Memory存储引擎支持。</p><p><code>B+ tree</code>：几乎都使用该数据结构存储索引。</p></blockquote><h4 id="聚集索引-IOT索引组织表-——InnoDB"><a href="#聚集索引-IOT索引组织表-——InnoDB" class="headerlink" title="聚集索引(IOT索引组织表)——InnoDB"></a>聚集索引(IOT索引组织表)——InnoDB</h4><p><strong>聚集索引即表数据和索引在一起的。</strong></p><p>MySQL在执行查询时，一般情况是通过<strong>优化器</strong>选择<strong>一个</strong>索引来进行使用的。</p><p>主键索引(聚簇索引)的叶子节点存储数据行，辅助索引只会存储主键值(不是地址值)。辅助索引可以有多个，主键索引有且只有一个。</p><p>即如果是非主键查询，需要搜索两次索引树(一次是辅助索引树，一次是主键索引树)，最终取得数据。</p><p>若没有主键：</p><blockquote><p>先寻找一个唯一非空列作为主键索引，如果还是没有。则自动生成一个隐藏列用作主键索引。</p></blockquote><p>InnoDB表为何必须要主键，且推荐使用整型自增主键而非UUID</p><blockquote><p>因为InnoDB需要<code>B+ tree</code>来存储数据，而<code>B+ tree</code>依赖于主键索引。</p><p>① <code>UUID</code>占据空间更大<br>② 查找或者插入时，<code>UUID</code>之间的比较和整型之间的比较相比效率较低<br>③ 当自增主键插入到<code>B+ tree</code>时，可以直接添加在叶子节点最右方，方便快捷分裂的可能也很小，而<code>UUID</code>插入时则可能会导致已经存储满的节点分裂和树的自动平衡，效率低。</p></blockquote><h4 id="非聚集索引-堆组织表-——MyISAM"><a href="#非聚集索引-堆组织表-——MyISAM" class="headerlink" title="非聚集索引(堆组织表)——MyISAM"></a>非聚集索引(堆组织表)——MyISAM</h4><p>由索引得到数据的地址然后从磁盘中进行读取。</p><h3 id="组合索引的使用"><a href="#组合索引的使用" class="headerlink" title="组合索引的使用"></a>组合索引的使用</h3><h4 id="为何使用组合索引"><a href="#为何使用组合索引" class="headerlink" title="为何使用组合索引"></a>为何使用组合索引</h4><p>为了<strong>节省mysql索引存储空间以及提升搜索性能</strong>，可建立组合索引(能使用组合索引就不使用单例索引)</p><p>例如：创建如下的一个组合索引，相当于建立了<code>col1 | col1 col2 | col1 col2 col3</code>三个索引∶</p><p>以下语句会创建—棵<code>B+ Tree</code> ，但是它相当于三棵索引树的功效</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">'table_name'</span> <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_name(<span class="string">'col1'</span>,<span class="string">'col2'</span>,<span class="string">'col3'</span>)</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><blockquote><p><strong>当查询条件为<code>... where col2 = xxx</code>时，是不会走索引的。</strong></p><p><strong>而查询条件为<code>... where col2 = xxx and col1 = xxx and col3 = xxx</code>是会由优化器优化查询条件的顺序从而走<code>col1 col2 col3</code>这个索引的。</strong></p></blockquote><h4 id="如何创建组合索引"><a href="#如何创建组合索引" class="headerlink" title="如何创建组合索引"></a>如何创建组合索引</h4><p>如何选择哪些列用来创建组合索引 ?</p><p>1．常出现在where条件中的列，建议用来创建组合索引，至于组合索引中的顺序，是很重要的。使用到最左前缀原则。但是因为MySQL中存在查询优化器，所以你的书写SQL条件的顺序，不一定是where条件顺序。</p><p>2．常出现在order by和group by语句中的列。最后按照顺序去创建组合索引。</p><p>3．常出现在select语句中的列，也建议按照顺序，创建组合索引。</p><h4 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h4><p>顾名思义，就是最左优先，这个最左是针对于组合索引和前缀索引，理解如下∶</p><ol><li><p>最左前缀匹配原则，非常重要的原则，MySQL会一直向右匹配直到遇到范围查询<code>(&gt;、&lt;、between、like)</code>就停止匹配，比如<code>a = 1 and b = 2 and c &gt; 3 and d = 4</code> 如果建立<code>(a, b, c, d)</code>顺序的索引，<code>d</code>是用不到索引的，如果建立<code>(a, b, d, c)</code>的索引，则都可以用到，<code>a, b, d</code>的顺序可以任意调整。</p></li><li><p><code>=</code>和<code>in</code>可以乱序，比如<code>a = 1 and b = 2 and c = 3</code>建立<code>(a, b, c)</code>索引可以任意顺序，MySQL的查询优化器会帮你优化成索引可以识别的形式</p></li></ol><h3 id="如何使用索引"><a href="#如何使用索引" class="headerlink" title="如何使用索引"></a>如何使用索引</h3><h4 id="哪些情况需要创建索引"><a href="#哪些情况需要创建索引" class="headerlink" title="哪些情况需要创建索引"></a>哪些情况需要创建索引</h4><ol><li>主键自动建立唯一索引</li><li>频繁作为查询条件的字段应该创建索引（业务）</li><li>多表关联查询中，关联字段应该创建索引</li><li>查询中统计或者分组字段，应该创建索引</li><li>查询中排序的字段，应该创建索引</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql创建组合索引的规先会对组合索引的最左边的，也就是第一个name字段的数据进行排序，在第一个字段的排序基础上，然后再对后面第二个的cid字段进行排序。其实就相当于实现了类似 order by name cid这样一种排序规则。</span><br></pre></td></tr></table></figure><h4 id="哪些情况不需要创建索引"><a href="#哪些情况不需要创建索引" class="headerlink" title="哪些情况不需要创建索引"></a>哪些情况不需要创建索引</h4><ol><li>表记录太少</li><li>经常进行增删改操作的表</li><li>更新的字段</li><li>where条件里使用频率不高的字段</li></ol><h3 id="查看执行计划"><a href="#查看执行计划" class="headerlink" title="查看执行计划"></a>查看执行计划</h3><h4 id="建表语句"><a href="#建表语句" class="headerlink" title="建表语句"></a>建表语句</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">create table user(</span><br><span class="line">id int primary key,</span><br><span class="line">name varchar(100),</span><br><span class="line">age int,</span><br><span class="line">sex char(1),</span><br><span class="line">address varchar(100)</span><br><span class="line">);</span><br><span class="line">alter table user add index idx_name_age(name(10), age);</span><br><span class="line">alter table user add index idx_sex(sex);</span><br><span class="line"></span><br><span class="line">insert into user(id, name, age, sex, address) values (1, &apos;zhangsan&apos;, 20, &apos;0&apos;, &apos;致真大厦&apos;);</span><br></pre></td></tr></table></figure><p>特别说明</p><blockquote><p>name列的长度是varchar(100),但是创建索引的时候，指定的长度却是10，这是使用了<strong>前缀索引</strong>这个概念。</p><p>前缀索引一般是针对字符串。</p></blockquote><h5 id="MySQL前缀索引和索引选择性"><a href="#MySQL前缀索引和索引选择性" class="headerlink" title="MySQL前缀索引和索引选择性"></a>MySQL前缀索引和索引选择性</h5><p>有时候需要索引很长的字符列，这会让索引变得大且慢。通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但这样也会降低<strong>索引的选择性</strong>。<strong>索引的选择性是指不重复的索引值（也称为基数，cardinality)和数据表的记录总数的比值，范围从1/#T到1之间。</strong>索引的选择性越高则查询效率越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的行。唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p><p>一般情况下某个前缀的选择性也是足够高的，足以满足查询性能。对于BLOB，TEXT，或者很长的VARCHAR类型的列，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度。</p><p>诀窍在于要选择足够长的前缀以保证较高的选择性，同时又不能太长（以便节约空间）。前缀应该足够长，以使得前缀索引的选择性接近于索引的整个列。换句话说，前缀的”基数“应该接近于完整的列的”基数“。</p><p>前缀索引是一种能使索引更小，更快的有效办法，但另一方面也有其缺点：</p><p><strong>mysql无法使用其前缀索引做ORDER BY和GROUP BY，也无法使用前缀索引做覆盖扫描。</strong></p><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>MySQL提供了一个<code>EXPLAIN</code>命令，它可以对SELECT语句的执行计划进行分析，并输出SELECT执行的详细信息，以供开发人员针对性优化。</p><p>使用explain这个命令来查看一个这些SQL语句的执行计划，查看该SQL语句有没有使用上了索引，有没有做全表扫描，这都可以通过explain命令来查看。</p><p>可以通过explain命令深入了解MySQL的基于开销的优化器，还可以获得很多可能被优化器考虑到的访问策略的细节，以及当运行SQL语句时哪种策略预计会被优化器采用。</p><p>EXPLAIN命令用法十分简单，在SELECT语句前加上explain就可以了，例如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><p>EXPLAIN命令的输出内容大致如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from user where id = 2\G</span><br><span class="line">******************** 1. row ************************</span><br><span class="line">id: 1</span><br><span class="line">select_type: SIMPLE</span><br><span class="line">table: user_info</span><br><span class="line">partitions: NULL</span><br><span class="line">type: const</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">key: PRIMARY</span><br><span class="line">key_len: 8</span><br><span class="line">ref: const</span><br><span class="line">row: 1</span><br><span class="line">filtered: 100.00</span><br><span class="line">Extra: NULL</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>各列含义</p><ul><li>id: SELECT查询的标识符．每个SELECT都会自动分配一个唯一的标识符.</li><li>select_type: SELECT查询的类型.</li><li>table: 查询的是哪个表</li><li>partitions: 匹配的分区</li><li>type: join类型</li><li>possible_keys: 此次查询中可能选用的索引</li><li>key: 此次查询中确切使用到的索引.</li><li>ref: 哪个字段或常数与key一起被使用</li><li>rows: 显示此查询一共扫描了多少行．这个是一个估计值.</li><li>filtered: 表示此查询条件所过滤的数据的百分比</li><li>extra: 额外的信息</li></ul><h5 id="type"><a href="#type" class="headerlink" title="type"></a>type</h5><p>显示的是单位查询的连接类型或者理解为访问类型，访问性能依次从好到差：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">system</span><br><span class="line">const</span><br><span class="line">eq_ref</span><br><span class="line">ref</span><br><span class="line">fulltext</span><br><span class="line">ref_or_null</span><br><span class="line">unique_subquery</span><br><span class="line">index_subquery</span><br><span class="line">range</span><br><span class="line">index_merge</span><br><span class="line">index</span><br><span class="line">ALL</span><br></pre></td></tr></table></figure><p>注意：</p><blockquote><p>除了<code>All</code>之外，其他的<code>type</code>都可以用到索引<br>除了<code>index_merge</code>之外，其他的<code>type</code>只能用到一个索引<br>最少要使用到<code>range</code>级别</p></blockquote><h6 id="system"><a href="#system" class="headerlink" title="system"></a>system</h6><blockquote><p>只有一行数据，或者是空表时</p></blockquote><h6 id="const-重要"><a href="#const-重要" class="headerlink" title="const(重要)"></a>const(重要)</h6><blockquote><p>使用唯一索引或者主键，返回记录一定是1行记录的等值where条件时，通常type是const。其他数据库也叫做唯一索引扫描。</p></blockquote><h6 id="eq-ref-重要"><a href="#eq-ref-重要" class="headerlink" title="eq_ref(重要)"></a>eq_ref(重要)</h6><blockquote><p>此类型通常出现在多表的join查询，表示对于前表的每一个结果，都只能匹配到后表的一行结果．并且查询的比较操作通常是<code>=</code>，查询效率较高。</p><p>和<code>ref</code>相比，<code>eq_ref</code>主要针对唯一索引。</p></blockquote><h6 id="ref-重要"><a href="#ref-重要" class="headerlink" title="ref(重要)"></a>ref(重要)</h6><blockquote><p>针对非唯一性索引或者组合索引；使用等值( <code>=</code>)查询。或者是使用了最左前缀规则索引的查询。</p></blockquote><h6 id="fulltext"><a href="#fulltext" class="headerlink" title="fulltext"></a>fulltext</h6><blockquote><p>全文索引检索，要注意，全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql不管代价，优先选择使用全文索引</p></blockquote><h6 id="ref-or-null"><a href="#ref-or-null" class="headerlink" title="ref_or_null"></a>ref_or_null</h6><blockquote><p>与ref方法类似，只是增加了null值的比较。实际用的不多。</p></blockquote><h6 id="unique-subquery"><a href="#unique-subquery" class="headerlink" title="unique_subquery"></a>unique_subquery</h6><blockquote><p>用于where中的in形式子查论查询返回不重复值唯一值</p></blockquote><h6 id="index-subquery"><a href="#index-subquery" class="headerlink" title="index_subquery"></a>index_subquery</h6><blockquote><p>用于in形式子查询使用到了辅助索引或者in常数列表，子查询可能返回重复值，可以使用索引将子查询去重,</p></blockquote><h6 id="range-重要"><a href="#range-重要" class="headerlink" title="range(重要)"></a>range(重要)</h6><blockquote><p>索引范围扫描，常见于使用&gt;,&lt;,is null, between ,in ,like等运算符的查询中。</p></blockquote><h6 id="index-merge"><a href="#index-merge" class="headerlink" title="index_merge"></a>index_merge</h6><blockquote><p>表示查询使用了两个以上的索引，最后取交集或者并集，常见and , or的条件使用了不同的索引，官方排序这个在ref_or_null之后，但是实际上由于要读取所个索引，性能可能大部分时间都不如range</p></blockquote><h6 id="index-重要"><a href="#index-重要" class="headerlink" title="index(重要)"></a>index(重要)</h6><blockquote><p>select结果列中使用到了索引，type会显示为index。即查询的结果列就是索引列，可以直接从索引树上获得，而不用再回表查询。</p><p>索引扫描，把索引从头到尾扫一遍，常见于使用索引列就可以处理不需要读取数据文件的查询、可以使用索引排序或者分组的查询。</p></blockquote><h6 id="all-重要）"><a href="#all-重要）" class="headerlink" title="all(重要）"></a>all(重要）</h6><blockquote><p>这个就是全表扫描数据文件，然后再在server层进行过滤返回符合要求的记录。</p></blockquote><h5 id="extra-重要"><a href="#extra-重要" class="headerlink" title="extra(重要)"></a>extra(重要)</h5><p>这个列包含不适合在其他列中显示但十分重要的额外的信息，这个列可以显示的信息非常多，有几十种。</p><h6 id="using-index-重要）"><a href="#using-index-重要）" class="headerlink" title="using index(重要）"></a>using index(重要）</h6><blockquote><p>查询时不需要回表查询，直接通过索引就可以获取查询的结果数据。</p><ul><li>表示相应的SELECT查询中使用到了<strong>覆盖索引(Covering Index)</strong>，避免访问表的数据行，效率不错!（这也是为何大多公司要求尽量不使用<code>select *</code>的原因，因为无法做到索引覆盖，会导致回表查询）</li><li>如果同时出现<code>Using Where</code>，说明索引被用来执行查找素引键值</li><li>如果没有同时出现<code>Using Where</code>，表明索引用来读取教据而非执行查找动作。</li></ul></blockquote><h6 id="using-where-重要"><a href="#using-where-重要" class="headerlink" title="using where(重要)"></a>using where(重要)</h6><blockquote><p>表示Mysql将对storage engine提取的结果进行过滤，过滤条件字段无索引;</p><p>如下图，对于该查询语句，使用到了主键索引，所以在innodb存储引擎中会进行第一步过滤，然后对于<code>name = &#39;lisi&#39;</code>则是在MySQL server层进行的第二次过滤，如果在server层进行了第二次过滤，则会显示——<code>using where</code>。</p><p>也可以将这两层分别对应数据库的逻辑分页和物理分页进行理解。</p></blockquote><blockquote><p>同时在5.6版本之后，推出了ICP索引下推，即如果下图中<code>name</code>也有索引，则会将其过滤也放在底层进行过滤，进而增大效率。</p></blockquote><p><img src="https://i.loli.net/2021/02/05/6zs9MQZ4KPrLpFc.png" alt="image.png"></p><h6 id="using-index-condition-重要"><a href="#using-index-condition-重要" class="headerlink" title="using index condition(重要)"></a>using index condition(重要)</h6><blockquote><p>Using index condition 会先条件过滤索引，过滤完索引后找到所有符合索引条件的数据行，随后用WHERE 子句中的其他条件去过滤这些数据行;</p><p>因为MySQL的架构原因，分成了server层和引擎层，才有所谓的“下推”的说法。所以ICP ( Index ConditionPushdown，索引下推）其实就是实现了index filter技术，将原来的在server层进行的table filter中可以进行index filter的部分，在引擎层面使用index filter进行处理，不再需要回表进行table filter。</p><p>查询条件中分为限制条件和检查条件，5.6之前，存储引擎只能根据限制条件扫描数据并返回，然后server层根据检查条件进行过滤再返回真正符合查询的数据。5.6.x之后支持<strong>ICP</strong>特性，可以把检查条件也下推到存储引擎层，不符合检查条件和限制条件的数据，直接不读取，这样就大大减少了存储引擎扫描的记录数星。</p></blockquote><h6 id="using-filesort-重要"><a href="#using-filesort-重要" class="headerlink" title="using filesort(重要)"></a>using filesort(重要)</h6><blockquote><ul><li>排序时无法使用到索引时，就会出现这个。常见于order by和group by语句中。</li><li>说明MySQL会使用一个外部的索引排序，而不是按照索引顺序进行读取。</li><li>MySQL中无法利用索引完成的排序操作称为“文件排序”。</li></ul></blockquote><h6 id="using-temporary"><a href="#using-temporary" class="headerlink" title="using temporary"></a>using temporary</h6><blockquote><ul><li>表示使用了临时表存储中问结果。</li><li>MySQL在对查询结果order by和group by时使用临时表</li><li>临时表可以是内存临时表和磁盘临时表，执行计划中看不出来，需要查看status变量，used_tmp_table，used_tmp_disk_table才能看出来。</li></ul></blockquote><h6 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h6><blockquote><p>在select部分使用了distinct关键字</p></blockquote><h6 id="no-tables-used"><a href="#no-tables-used" class="headerlink" title="no tables used"></a>no tables used</h6><blockquote><p>不带from字句的查询或者From dual查询</p></blockquote><h3 id="索引失效分析"><a href="#索引失效分析" class="headerlink" title="索引失效分析"></a>索引失效分析</h3><h4 id="案例环境"><a href="#案例环境" class="headerlink" title="案例环境"></a>案例环境</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">staffs员工表 三条记录</span><br><span class="line">+----+------+-----+---------+---------------------+</span><br><span class="line">| id | name | age | pos     | add_time            |</span><br><span class="line">+----+------+-----+---------+---------------------+</span><br><span class="line">| 1  | z3   | 22  | manager | 2016-12-09 09:31:34 |</span><br><span class="line">| 2  | July | 23  | dev     | 2016-12-09 09:31:34 |</span><br><span class="line">| 3  | 2000 | 23  | dev     | 2016-12-09 09:31:34 |</span><br><span class="line">+----+------+-----+---------+---------------------+</span><br><span class="line"></span><br><span class="line">索引:</span><br><span class="line">主键索引(id)和联合索引(name, age, pos)</span><br></pre></td></tr></table></figure><h4 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h4><blockquote><p>1、全值匹配我最爱(等值匹配且为全值)<br>2、最佳左前缀法则<br>3、不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描<br>4、存储引擎不能使用索引中范围条件右边的列，即在<code>where</code>语句中范围条件右边的列，无法使用索引。<br>5、尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致))，减少<code>select *</code><br>6、mysql在使用不等于(<code>!=</code>或者<code>&lt;&gt;</code>)的时候无法使用索引会导致全表扫描|<br>7、<code>is null ,is not null</code>也无法使用索引<br>8、<code>like</code>以通配符开头(<code>&#39;%abc...&#39;</code>)Mysql索引失效会变成全表扫描的操作<br>9、字符串不加单引号索引失效<br>10、少用<code>or</code>，用它来连接时会索引失效</p></blockquote><h3 id="MySQL性能优化"><a href="#MySQL性能优化" class="headerlink" title="MySQL性能优化"></a>MySQL性能优化</h3><h4 id="服务器层面优化"><a href="#服务器层面优化" class="headerlink" title="服务器层面优化"></a>服务器层面优化</h4><p>将数据保存在内存中，保证从内存读取数据。</p><ul><li><p>设置足够大的<code>innodb_buffer_pool_size</code>，将数据读到内存中(建议设置为总内存的3/4或者4/5)</p></li><li><pre><code>可通过下面命令查看show global status like &apos;innodb_buffer_pool_pages_%&apos;若innodb_buffer_pool_pages_free为0则表示buffer pool已被用光<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### 内存预热</span><br><span class="line">将磁盘数据在MysQL Server启动的时候，读取到内存中。</span><br><span class="line"></span><br><span class="line">##### 降低磁盘写入次数</span><br><span class="line"></span><br><span class="line">* 对于生产环境来说，很多日志是不需要开启的，比如∶通用查询日志、慢查询日志、错误日志</span><br><span class="line"></span><br><span class="line">* 使用足够大的写入缓存**innodb_log_file_size**</span><br></pre></td></tr></table></figure>推荐 innodb_log_file_size设置为0.25 * innodb_buffer_pool_size<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 设置合适的**innodb_flush_log_at_trx_commit**，和日志落盘有关系。</span><br><span class="line"></span><br><span class="line">##### 提高磁盘读写</span><br><span class="line"></span><br><span class="line">* 可以考虑使用SSD硬盘，不过得考虑成本是否合适。</span><br><span class="line"></span><br><span class="line">#### SQL设计层面优化</span><br><span class="line"></span><br><span class="line">具体优化方案如下:</span><br><span class="line"></span><br><span class="line">* 设计中间表，一般针对于统计分析功能，或者实时性不高的需求( OLTP、OLAP )</span><br><span class="line">* 为减少关联查询，创建合理的冗余字段(考虑数据库的三范式和查询性能的取舍，创建冗余字段还需要注意数据—致性问题)</span><br><span class="line">* 对于字段太多的大表，考虑垂直拆表(比如一个表有100多个字段)</span><br><span class="line">* 对于表中经常不被使用的字段或者存储数据比较多的字段，考虑拆表（比如商品表中会存储商品介绍，此时可以将商品介绍字段单独拆解到另一个表中，使用商品ID关联)</span><br><span class="line">* 每张表建议都要有一个主键(主键索引），而且主键类型最好是int类型，建议自增主键(不考虑分布式系统的情况下)。</span><br><span class="line"></span><br><span class="line">#### SQL语句优化(开发人员)</span><br><span class="line"></span><br><span class="line">##### 索引优化</span><br><span class="line"></span><br><span class="line">* 为搜索字段(where中的条件)、排序字段、 select查询列，创建合适的索引，不过要考虑数据的业务场景∶查询多还是增删多?</span><br><span class="line">* 尽量建立组合索引并注意组合索引的创建顺序，按照顺序组织查询条件、尽量将筛选粒度大的查询条件放到最左边。</span><br><span class="line">* 尽量使用覆盖索引，SELECT语句中尽量不要使用\*。</span><br><span class="line">* order by、group by语句要尽量使用到索引</span><br><span class="line"></span><br><span class="line">##### 其他优化</span><br><span class="line"></span><br><span class="line">* 尽量不使用count(\*)、尽量使用count(主键)</span><br></pre></td></tr></table></figure>COUNT(*): 查询行数，是会遍历所有的行、所有的列。</code></pre></li></ul><p>COUNT(列): 查询指定列不为null的行数(过滤null)，如果列可以为空，则COUNT (<em>)不等于COUNT(列)，除非指定的列是非空的列才会让COUNT (</em>)等于COUNT(列)</p><p>COUNT(伪列): 比如COUNT (1)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* JOIN两张表的关联字段建立索引，而且最好字段类型是一样的。</span><br></pre></td></tr></table></figure><p>SELECT * FROM orders o LEFT OIN user u on o.user_id = u.id</p><p>orders表中的user_id和user表中的id，类型要一致</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* WHERE条件中尽量不要使用1=1、not in语句（建议使用not exists ) .</span><br><span class="line">* 不用MySQL内置的函数，因为内置函数不会建立查询缓存。</span><br></pre></td></tr></table></figure><p>SQL查询语句和查询结果都会在第一次查询只会存储到MySQL的查询缓存中，如果需要获取到查询缓存中的查询结果，查询的SQL语句必须和第一次的查询SQL语句一致。</p><p>SELECT * FROM user where birthday = now()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 分布式事务</span><br><span class="line"></span><br><span class="line">两个基本场景</span><br><span class="line"></span><br><span class="line">&gt; 多数据源：多个数据库之间的一个事务操作。跨库事务指的是，一个应用某个功能需要操作多个库，不同的库中存储不同</span><br><span class="line">&gt; 的业务数据。在真实应用场景下，一个业务操作多个库也是比较常见的，那么多个数据库是之间是互相不可见的，如何保证数据库的一致性呢?此时就必须使用分布式事务的解决方案。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 多服务：多台服务器之间的事务操作。事务分布在不同服务器上，要求不同服务器事务要么都成功要么都失败，称为分布式事务。</span><br><span class="line"></span><br><span class="line">分布式事务就是为了保证不同资源服务器的数据一致性。</span><br><span class="line"></span><br><span class="line">### 分布式事务事务模型——DTP模型</span><br><span class="line"></span><br><span class="line">1)应用程序(Application Program : AP): 定义事务边界(事务开始，结束)</span><br><span class="line"></span><br><span class="line">2)资源管理器(Resource Manager: RM): 任何用来存储数据的服务。</span><br><span class="line"></span><br><span class="line">3)事务管理器(Transaction Manager : TM ): 监控事务进度，负责事务提交，回滚。</span><br><span class="line"></span><br><span class="line">4)通信资源管理(Communcation Resource Manager : CRM )</span><br><span class="line"></span><br><span class="line">5)通信协议(负责事务模型之间的通信协议)</span><br><span class="line"></span><br><span class="line">当一个DTP模型中，存在多个模型实例时，会形成一种树形调用关系，叫做**全局事务树形结构(GlobalTransaction Tree Structure)**。</span><br><span class="line"></span><br><span class="line">### 分布式事务事务模型-XA规范</span><br><span class="line">XA规范的最主要的作用是，就是定义了RM-TM的交互接口</span><br><span class="line"></span><br><span class="line">XA∶定义了TM和RM交互接口的规范。（事务注册，开始，回滚，事务结束...)</span><br><span class="line"></span><br><span class="line">XA标准∶存储数据的服务都开发了支持分布式事务接口规范:XA(MySQL，RocketMQ)</span><br><span class="line"></span><br><span class="line">TM事务管理器也必须按照XA规范来进行调用事务控制接口。</span><br><span class="line"></span><br><span class="line">### 分布式事务事务模型-2PC(2阶段提交)</span><br><span class="line"></span><br><span class="line">两阶段提交协议(Two Phase Commit )，XA规范对其进行了优化。而从字面意思来理解，TwoPhase Commit，就是将提交(commit)过程划分为2个阶段(Phase):</span><br><span class="line"></span><br><span class="line">[![https://img.rruu.net/image/601e3519d55f7](https://img.rruu.net/image/601e3519d55f7)](https://img.rruu.net/image/601e3519d55f7)</span><br><span class="line"></span><br><span class="line">### 分布式事务事务模型-3PC(3阶段提交)</span><br><span class="line"></span><br><span class="line">三阶段提交（3PC)[Three-phase commit]，是二阶段提交（2PC)的改进版本。与两阶段提交不同的是，三阶段提交有两个改动点</span><br><span class="line"></span><br><span class="line">* 引入超时机制。同时在协调者和参与者中都引入超时机制。</span><br><span class="line">* 在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。也就是说，除了引入超时机制之外，3PC把2PC的准备阶段再次一分为二，这样三阶段提交就有CanCommit、PreCommit、DoCommit三个阶段</span><br><span class="line"></span><br><span class="line">### 分布式事务解决方案-JTA</span><br><span class="line"></span><br><span class="line">Java事务APl ( JTA : Java Transaction APl ）和它的同胞Java事务服务（JTS : Java Transaction Service )，为J2EE平台提供了分布式事务服务(distributed transaction)的能力。某种程度上，可以认为JTA规范是XA规范的Java版，其把XA规范中规定的DTP模型交互接口抽象成Java接口中的方法，并规定每个方法要实现什么样的功能。</span><br></pre></td></tr></table></figure><p>Java事务JTA分布式事务控制规范:<br>JTA是XA接口规范的Java版本。控制分布式事务。<br>1、AP<br>2、Application Server (Jboss,weblogic,websphere等等)<br>3、TM<br>4、RM</p><p>Java分布式事务:Application Server 实现XA接口的规范，在服务内部自己根据XA规范，开发了一套分布式事务控逻辑TM,把TM集成到jboss,weblogic</p><p>问题:TOMCAT服务器没有实现XA接口规范，不能自己控制分布式事务?<br>    第三方框架: atomikos —- xa</p><p>Atomiko主要用来控制多数据源这样的分布式事务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 分布式事务解决方案-LCN</span><br><span class="line"></span><br><span class="line">TX-LCN由两大模块组成，TxClient、TxManager，TxClient作为模块的依赖框架，提供TX-LCN的标准支持，TxManager作为分布式事务的控制器.</span><br><span class="line"></span><br><span class="line">事务发起方或者参与都由TxClient端来控制</span><br><span class="line"></span><br><span class="line">原理:</span><br><span class="line"></span><br><span class="line">&gt; LCN模式是通过代理Connection的方式实现对本地事务的操作，然后在由TxManager统一协调控制事务。当本地事务提交回滚或者关闭连接时将会执行假操作，该代理的连接将由LCN连接池管理。</span><br><span class="line"></span><br><span class="line">特点:</span><br><span class="line"></span><br><span class="line">&gt; 该模式对代码的嵌入性为低。</span><br><span class="line">&gt; 该模式仅限于本地存在连接对象且可通过连接对象控制事务的模块。</span><br><span class="line">&gt; 该模式下的事务提交与回滚是由本地事务方控制，对于数据一致性上有较高的保障。该模式缺陷在于代理的连接需要随事务发起方一起释放连接，增加了连接占用的时间。</span><br><span class="line"></span><br><span class="line">### 分布式事务解决方案-TCC</span><br><span class="line"></span><br><span class="line">TCC——事务补偿机制，控制分布式事务的实现。</span><br><span class="line"></span><br><span class="line">TCC事务机制相对于传统事务机制(X/Open XA Two-Phase-Commit)，其特征在于它不依赖资源管理器(RM)对XA的支持，而是通过对(由业务系统提供的）业务逻辑的调度来实现分布式事务。</span><br><span class="line"></span><br><span class="line">主要由三步操作∶</span><br><span class="line"></span><br><span class="line">&gt; Try:尝试执行业务</span><br><span class="line">&gt; Confirm:确认执行业务</span><br><span class="line">&gt; Cancel:取消执行业务。</span><br><span class="line"></span><br><span class="line">特点:</span><br><span class="line"></span><br><span class="line">&gt; 该模式对代码的嵌入性高，要求每个业务需要写三种步骤的操作。该模式对有无本地事务控制都可以支持使用面广。</span><br><span class="line">&gt; 数据一致性控制几乎完全由开发者控制，对业务开发难度要求高。</span><br><span class="line"></span><br><span class="line">### 分布式事务解决方案-RocketMQ</span><br><span class="line">实际系统的开发过程中，可能服务间的调用是异步的(MQ消息中间件异步通知)、那么如何保证这种异步的各个服务间的分布式事务呢?</span><br><span class="line"></span><br><span class="line">### 分布式事务解决方案-尽最大可能通知</span><br><span class="line"></span><br><span class="line">最大努力通知型(Best-effort delivery)是最简单的一种柔性事务，适用于一些最终一致性时间敏感度低的业务，且被动方处理结果不影响主动方的处理结果。典型的使用场景∶如银行通知、商户通知等。最大努力通知型的实现方案，一般符合以下特点:</span><br><span class="line"></span><br><span class="line">&gt; 不可靠消息∶业务活动主动方，在完成业务处理之后，向业务活动的被动方发送消息，直到通知N次后不再通知，允许消息丢失(不可靠消息)。</span><br><span class="line">&gt; 定期校对∶业务活动的被动方，根据定时策略，向业务活动主动方查询(主动方提供查询接口)，恢复丢失的业务消息。</span><br><span class="line"></span><br><span class="line">### CAP</span><br><span class="line"></span><br><span class="line">C和A无法同时存在。</span><br><span class="line"></span><br><span class="line">因为在保证强一致性的时候，主节点会将从节点锁定并进行同步来保证一致性，此时用户请求则无法立刻得到结果，违反可用性。</span><br><span class="line"></span><br><span class="line">因此存在的组合只有CP和AP模型。因此选型也就只有强一致性(2PC)和最终一致性(MQ、TCC)两种选择。</span><br><span class="line"></span><br><span class="line">### BASE理论</span><br><span class="line">BASE是Basically Available (基本可用)、Soft state(软状态）和Eventually consistent (最终一致性)三个短语的缩写。</span><br><span class="line"></span><br><span class="line">* 基本可用(Basically Available )：指分布式系统在出现不可预知故障的时候，允许损失部分可用性。</span><br><span class="line">* 软状态( Soft State )：指允许系统中的数据存在中间状态，并认该中间状态的存在不会影响系统的整体可用性。</span><br><span class="line">* 最终一致(Eventual Consistency )：强调的是所有的数据更新操作，在经过一段时间的同步之后，最终都能够达到一个一致的状态</span><br><span class="line"></span><br><span class="line">### 柔性事务</span><br><span class="line"></span><br><span class="line">&gt; 最大努力通知（非可靠消息、定期校对)</span><br><span class="line">&gt;</span><br><span class="line">&gt; 可靠消息最终一致性（异步确保型)</span><br><span class="line">&gt;</span><br><span class="line">&gt; TCC(两阶段型、补偿型)</span><br><span class="line"></span><br><span class="line">## IO多路复用</span><br><span class="line"></span><br><span class="line">### select</span><br><span class="line"></span><br><span class="line">非多线程，是单线程，多线程存在上下文切换的开销。</span><br><span class="line"></span><br><span class="line">简单思路：死循环中遍历所有fd文件描述符，获得其中有数据的部分进行读取和处理。</span><br><span class="line"></span><br><span class="line">具体实现：</span><br><span class="line"></span><br><span class="line">&gt; ①首先获得所有的fd</span><br><span class="line">&gt; ②在一个死循环中，将所有fd拷入一个rset中(rset是一个位图bitmap)，将fd对应的编号置为1</span><br><span class="line">&gt; ③调用select函数，从用户态拷贝rset到内核态，并进行阻塞等待，监听所有fd，直到有对应的有数据到来</span><br><span class="line">&gt; ④将有数据到来的fd(可能会有多个)进行置位，是在rset中置位，fd本身没有变化</span><br><span class="line">&gt; ⑤再次遍历rset，读取其中被置位的fd的数据，并进行相应处理。再次进入死循环</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line"></span><br><span class="line">&gt; 位图的大小是有限的，默认1024位</span><br><span class="line">&gt;</span><br><span class="line">&gt; rset不能重用，内核态对其进行了改变，导致每次需要重置rset并重新拷贝fd</span><br><span class="line">&gt;</span><br><span class="line">&gt; 用户态到内核态的转换和拷贝开销较大</span><br><span class="line">&gt;</span><br><span class="line">&gt; 在内核态监听完成并置位rset后，还需要再次遍历rset，时间开销较大</span><br><span class="line"></span><br><span class="line">### poll</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">struct pullfd &#123;</span><br><span class="line">int fd;</span><br><span class="line">short events; // 初始化为需要监听的事件 如 PULLIN</span><br><span class="line">short revents; // 用于置位使用 </span><br><span class="line">&#125;</span><br><span class="line">// 不再使用bitmap，而是采用自定义结构体</span><br></pre></td></tr></table></figure><p>具体实现和select类似，相同点和区别在于：</p><blockquote><p>相同点：①都是需要从用户态拷贝到内核态并由内核进行监听处理，开销较大②都需要对存储fd的数据结构进行二次遍历③也是阻塞调用</p><p>①未使用bitmap进行存储，而是采用pullfd[]数组进行存储<br>②内核监听到数据时，不再对pullfd[]整体置位，只对revents成员置位，这样使得pullfd[]可以重用。<br>③内核监听完成后，对pullfd进行遍历时，如果revents被置位，则进行数据读取和处理，同时将revents重新赋值为0。<br>④存储的数量远大于bitmap的限制1024位。</p></blockquote><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p><img src="https://i.loli.net/2021/03/04/Y3mdEcJ64DyvZe2.png" alt="image.png"></p><p>同样存在一个结构体epoll_event，包含fd和event数据，但不包含revents</p><p>具体实现：</p><blockquote><p>①准备数据，通过epoll_ctl将fd和events拷贝进入一个由epoll_create创建的白板中，同时还会在内核创建一个红黑树和一个链表<br>②同样通过死循环，然后调用epoll_wait方法，同时上文提到的白板是并不是用户态和内核态共享的<strong>(b站视频有误)</strong><br>③通过epoll_wait方法，内核通过监听，将fd进行”置位”，这里的置位是指重排序，将有数据的fd放到链表前面，然后返回有数据的fd数量<br>④通过返回值再进行遍历，省去了之前O(n)复杂度的再次遍历，然后对数据进行读取和处理</p></blockquote><p>两种工作模式</p><blockquote><p>LT模式</p><p>fd可读之后，如果服务程序读走一部分就结束此次读取，LT模式下该文件描述符仍然可读<br>fd可写之后，如果服务程序写了一部分就结束此次写入，LT模式下该文件描述符也仍然可写</p><p>ET模式</p><p>fd可读之后，如果服务程序读走一部分就结束此次读取，ET模式下该文件描述符是不可读，需要等到下次有数据到达时才可变为可读，所有我们要保证循环读取数据，以确保把所有数据读出<br>fd可写之后，如果服务程序写了一部分就结束此次写入，ET模式下该文件描述符是不可写的，我们要保证写入数据，确保把数据写满</p></blockquote><p>redis和nginx、java的nio在linux下都是通过epoll实现。</p><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="JVM常识"><a href="#JVM常识" class="headerlink" title="JVM常识"></a>JVM常识</h3><h4 id="程序的执行方式"><a href="#程序的执行方式" class="headerlink" title="程序的执行方式"></a>程序的执行方式</h4><blockquote><p>静态编译、动态编译和动态解释执行。</p><p>注意：此处的编译是指编译成OS能直接运行的机器码。</p></blockquote><h4 id="JVM的运行模式"><a href="#JVM的运行模式" class="headerlink" title="JVM的运行模式"></a>JVM的运行模式</h4><p>JVM有两种运行模式: Server模式与Client棒式。</p><p>两种模式的区别在于:</p><ul><li>Client模式启动速度较快，Server模式启动较慢;</li><li>但是启动进入稳定期长期运行之后Server模式的程序运行速度比Client要快很多。</li><li>因为Server模式启动的JVM采用的是重量级的虚拟机，对程序采用了更多的优化;而Client模式启动的VM采用的是轻量级的虚拟机。所以Server启动慢，但稳定后速度比Client远远要快。</li></ul><h3 id="JVM架构理解"><a href="#JVM架构理解" class="headerlink" title="JVM架构理解"></a>JVM架构理解</h3><p><img src="https://img.rruu.net/image/601e6713dd864" alt></p><h3 id="JVM-程序执行流程"><a href="#JVM-程序执行流程" class="headerlink" title="JVM 程序执行流程"></a>JVM 程序执行流程</h3><p>java编译成字节码、动态编译和解释为机器码的过程分析</p><p><img src="https://img.rruu.net/image/601e6e43cd20a" alt></p><p>编译器和解释器的协调工作流程：</p><p><img src="https://img.rruu.net/image/601e6ec3e78e5" alt></p><p>在部分商用虚拟机中(如HotSpot),Java程序最初是通过解释器(Interpreter)进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为”热点代码”。为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器(Just In Time Compiler，下文统称IT编译器)。</p><p>由于Java虚拟机规范并没有具体的约束规则去限制即使编译器应该如何实现，所以这部分功能完全是与虚拟机具体实现相关的内容，如无特殊说明，我们提到的编译器、即时编译器都是指Hotspot虚拟机内的即时编译器，虚拟机也是特指HotSpot虚拟机。</p><p>我们的JIT是属于动态编译方式的，动态编译（dynamic compilation)指的是”在运行时进行编译”;与之相对的是事前编译(ahead-of-time compilation，简称AOT)，也叫静态编译(static compilation)。</p><p>JIT编译(just-in-time compilation)狭义来说是当某段代码即将第一次被执打时进行编译，因而叫”即时编译”。JIT编译是动态编译的一种特例。]JIT编译一词后来被泛化，时常与动态编译等价;但要注意广义与狭义的JIT编译所指的区别。</p><h3 id="JIT的使用"><a href="#JIT的使用" class="headerlink" title="JIT的使用"></a>JIT的使用</h3><ul><li>为何HotSpot需要使用解释器和编译器并存的架构?</li><li>JVM为什么要实现两个不同的即时编译器?</li><li>程序何时会使用解释器执行?何时会使用编译器执行?</li><li>哪些程序代码会被编译成为本地代码?如何编译?</li><li>JAVA代码的执行效率就一定比C,C++静态执行的执行差?JAVA代码解析执行有何优势?</li></ul><h4 id="为什么要使用解释器与编译器并存的架构"><a href="#为什么要使用解释器与编译器并存的架构" class="headerlink" title="为什么要使用解释器与编译器并存的架构"></a>为什么要使用解释器与编译器并存的架构</h4><p>尽管并不是所有的Java虚拟机都采用解释器与编译器并存的架构，但许多主流的商用虚拟机(如HotSpot)，都同时包含解释器和编译器。</p><p><strong>解释器与编译器特点</strong></p><ul><li>当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取更高的执行效率</li><li>当程序运行环境中内存资源限制较大(如部分嵌入式系统中)，可以使用解释器执行节约内存，反之可以使用编译执行来提升效率。</li></ul><p><strong>编译的时间开销</strong></p><p>解释器的执行，抽象的看是这样的:<br><strong><em>输入的代码-&gt;[解释器解释执行]-&gt;执行结果</em></strong></p><p>而要JIT编译然后再执行的话，抽象的看则是:<br><strong><em>输入的代码→&gt;[编译器编译]-&gt;编译后的代码→&gt;[执行]-&gt;执行结果</em></strong></p><p>说JIT比解释快，其实说的是”执行编译、代码”比”解释器解释执行”要快，并不是说”编译”这个动作比”解释”这个动作快。JIT编译再怎么快，至少也比解释执行一次略慢一些，而要得到最后的执行结果还得再经过一个”执行编译后的代码”的过程。所以，对“只执行一次””的代码而言，解释执行其实总是比JIT编译执行要快。</p><p>怎么算是”只执行一次的代码”呢?粗略说，下面两个条件同时满足时就是严格的“只执行一次”<br>1、只被调用一次，例如类的构造器(class initializer，<clinit>())<br>2、没有循环<br>对只执行一次的代码做JIT编译再执行，可以说是得不偿失。<br>对只执行少量次数的代码，JIT编译带来的执行速度的提升也未必能抵消掉最初编译带来的开销。</clinit></p><p><strong><em>只有对频繁执行的代码，JIT编译才能保证有正面的收益。</em></strong></p><p><strong>编译的空间开销</strong></p><p>对一般的Java方法而言，编译后代码的大小相对于字节码的大小，膨胀比达到10x是很正常的。同上面说的时间开销一样，这里的空间开销也是，只有对执行频繁的代码才值得编译，如果把所有代码都编译则会显著增加代码所占空间，导致”代码爆炸”。</p><p><strong><em>这也就解释了为什么有些VM会选择不总是做JIT编译，而是选择用解释器 + JIT编译器的混合执行引擎。</em></strong></p><h4 id="为何要实现两个不同的即时编译器"><a href="#为何要实现两个不同的即时编译器" class="headerlink" title="为何要实现两个不同的即时编译器"></a>为何要实现两个不同的即时编译器</h4><p><font color="red">HotSpot虚拟机中内置了两个即时编译器:Client Complier和Server Complier0，简称为C1、C2编译器，分别用在客户端和服务端。</font></p><p>目前主流的HotSpot虚拟机中默认是采用解释器与其中一个编译器直接配合的方式工作。程序使用哪个编译器，取决于<strong>虚拟机运行的模式</strong>。HotSpot虚拟机会根据自身版本与宿主机器的硬件性能自动选择运行模式，用户也可以使用”-client”或”-server”参数去强制指定虚拟机运行在Client模式或Server模式。</p><p>用Client Complier获取更高的<strong>编译速度</strong>，用Server Complier来获取更好的<strong>编译质量</strong>。为什么提供多个即时编译器与为什么提供多个垃圾收集器类似，都是为了适应不同的应用场景。</p><h4 id="哪些程序代码会被即时编译"><a href="#哪些程序代码会被即时编译" class="headerlink" title="哪些程序代码会被即时编译"></a>哪些程序代码会被即时编译</h4><p>程序中的代码只有是热点代码时，才会编译为本地代码，那么什么是<strong>热点代码</strong>呢?</p><p>运行过程中会被即时编译器编译的“热点代码”有两类:</p><ol><li>被多次调用的方法。</li><li>被多次执行的循环体。</li></ol><p>两种情况，编译器都是以<strong>整个方法</strong>作为编译对象。这种编译方法因为编译发生在方法执行过程之中，因此形象的称之为栈上替换(On Stack Replacement，oSR)，即方法栈帧还在栈上，方法就被替换了。</p><h4 id="如何判断热点代码呢"><a href="#如何判断热点代码呢" class="headerlink" title="如何判断热点代码呢"></a>如何判断热点代码呢</h4><p>要知道方法或一段代码是不是热点代码，是不是需要触发即时编译，需要进行Hot Spot Detection(热点探测)。</p><p>目前主要的热点探测方式有以下两种:</p><ul><li>基于采样的热点探测<br><strong>采用这种方法的虚拟机会周期性地检查各个线程的栈顶，如果发现某些方法经常出现在栈顶，那这个方法就是”热点方法”。</strong>这种探测方法的好处是实现简单高效，还可以很容易地获取方法调用关系（将调用堆栈展开即可)，缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测。</li><li>基于计数器的热点探测<br><strong>采用这种方法的虚拟机会为每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的阀值，就认为它是”热点方法”</strong>，这种统计方法实现复杂一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系L它的统计结果相对更加精确严谨。</li></ul><h4 id="热点检测方式"><a href="#热点检测方式" class="headerlink" title="热点检测方式"></a>热点检测方式</h4><p>在HotSpot虚拟机中使用的是第二种―—基于计数器的热点探测方法，因此它为每个方法准备了两个计数器︰方法调用计数器和回边计数器。在确定虚拟机运行参数的前提下，这两个计数器都有一个确定的阈值，当计数器超过阈值溢出了，就会触发JIT编译。</p><p><strong>方法调用计数器</strong></p><p>顾名思义，这个计数器用于统计方法被调用的次数。</p><p><strong>回边计数器</strong></p><p>它的作用就是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为”回边”。</p><h3 id="JIT优化"><a href="#JIT优化" class="headerlink" title="JIT优化"></a>JIT优化</h3><h4 id="公共子表达式的消除"><a href="#公共子表达式的消除" class="headerlink" title="公共子表达式的消除"></a>公共子表达式的消除</h4><p>javac编译器不会对公共子表达式进行消除。进入即时编译器后，JIT会对公共子表达式进行消除，且还有可能进行代数替换，即将可以计算出的结果直接计算得到，进行优化。</p><h4 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h4><p>指的是：在JIT即时编译时，将方法调用直接使用方法体内的代码进行替换，从而减少方法调用过程中的压栈和入栈的开销。</p><p>当JVM检测到一些小方法频繁调用时，会使用方法内联进行优化。</p><h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h4><p>逃逸分析(Escape Analysis)是目前Java虚拟机中比较前沿的优化技术。这是一种可以有效减少]ava程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析. Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p><blockquote><p>个人理解：如果对象逃逸了，则无法对其进行优化，只能分配到堆上，如果没有逃逸，则可以将其分配到栈上。</p></blockquote><p><strong>逃逸分析的基本行为就是分析对象动态作用域:当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸。</strong></p><p>逃逸分析包括:</p><ul><li>全局变量赋值逃逸</li><li>方法返回值逃逸</li><li>实例引用发生逃逸</li><li>线程逃逸:赋值给类变量或可以在其他线程中访问的实例变量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object object;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">globalVariableEscape</span><span class="params">()</span> </span>&#123;<span class="comment">//全局变量赋值逃逸</span></span><br><span class="line">object =<span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">methodEscape</span><span class="params">()</span> </span>&#123; <span class="comment">//方法返回值逃逸</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">instancePassEscape</span><span class="params">()</span> </span>&#123;<span class="comment">//实例引用发生逃逸</span></span><br><span class="line"><span class="keyword">this</span>.speak(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">(EscapeAna1ysis escapeAna1ysis)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Escape He11o"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法逃逸案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title">createStringBuffer</span><span class="params">(String s1，String s2)</span> </span>&#123;</span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">sb.append(s1);</span><br><span class="line">sb.append(s2);</span><br><span class="line"><span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>StringBuffer sb是一个方法内部变量，上述代码中直接将sb返回，这样这个StringBuffer有可能被其他方法所改变，这样它的作用域就不只是在方法内部，虽然它是一个局部变量，称其逃逸到了方法外部。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。</p></blockquote><p>上述代码如果想要StringBuffer sb不逃出方法，可以这样写:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createStringBuffer</span><span class="params">(String s1，String s2)</span> </span>&#123;</span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">sb.append(s1);</span><br><span class="line">sb.append(s2);</span><br><span class="line"><span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不直接返回StringBuffer，那么StringBuffer将不会逃逸出方法。</p><p>使用逃逸分析，编译器可以对代码做如下优化:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一、同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</span><br><span class="line"></span><br><span class="line">二、将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分</span><br><span class="line">配的候选，而不是堆分配。</span><br><span class="line"></span><br><span class="line">三、分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分(或全</span><br><span class="line">部）可以不存储在内存，而是存储在CPU寄存器中。</span><br></pre></td></tr></table></figure><p>在Java代码运行时，通过JVM参数可指定是否开启逃逸分析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+DoEscapeAnalysis: open</span><br><span class="line">-XX:-DoEscapeAnalysis: close</span><br></pre></td></tr></table></figure><p>从jdk1.7开始默认开启逃逸分析。</p><h4 id="对象上的栈分配"><a href="#对象上的栈分配" class="headerlink" title="对象上的栈分配"></a>对象上的栈分配</h4><p>我们知道，在一般情况下，对象和数组元素的内存分配是在堆内存上进行的。但是随着JIT编译器的日渐成熟，很多优化使这种分配策略并不绝对。<strong>JIT编译器就可以在编译期间根据逃谗分析的结果，来决定是否可以将对象的内存分配从堆转化为栈。</strong></p><h4 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h4><p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存在类A</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 存在一方法使用类里的a和b</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getAB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">A x = <span class="keyword">new</span> A();</span><br><span class="line">x.a;</span><br><span class="line">x.b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译时JVM会直接编译成这样</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getAB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line">b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这就是标量替换 */</span></span><br></pre></td></tr></table></figure><h4 id="同步锁消除"><a href="#同步锁消除" class="headerlink" title="同步锁消除"></a>同步锁消除</h4><p>同样基于逃逸分析，当加锁的变量不会发生逃逸，是线程私有的完全没有必要加锁。在JIT编译时期就可以将同步锁去掉，以减少加锁与解锁造成的资源开销。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLockEliminate</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">(String s1，String s2)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        sb.append(s1);</span><br><span class="line">        sb.append(s2);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> tsStart = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">getString( <span class="string">""</span>TestLockE1iminate <span class="string">"， "</span>suffix<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"一共耗费: "</span>+ (System.currentTimeMillis() - tsStart) + <span class="string">"ms"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>getString()方法中的StringBuffer数以函数内部的局部变量，进作用于方法内部，不可能逃逸出该方法，因此他就不可能被多个线程同时访问，也就没有资源的竞争，但是StringBuffer的append操作却需要执行同步操作，代码如下:</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">       toStringCache = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">super</span>.append(str);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>逃逸分析和锁消除分别可以使用参数-xX:+DOEscapeAnalysis和-XX:+EliminateLocks(锁消除必须在-server模式下)开启。</p><h3 id="带你认识一下class文件"><a href="#带你认识一下class文件" class="headerlink" title="带你认识一下class文件"></a>带你认识一下class文件</h3><h4 id="class文件概述"><a href="#class文件概述" class="headerlink" title="class文件概述"></a>class文件概述</h4><p>内容为16进制。开头为<code>CAFEBABE</code>魔数</p><p><img src="https://img.rruu.net/image/6021434267a6b" alt></p><h5 id="常量池数据区"><a href="#常量池数据区" class="headerlink" title="常量池数据区"></a>常量池数据区</h5><p><img src="https://img.rruu.net/image/6021439fcabec" alt></p><p>双亲委派：当类加载器碰到一个类时，需要交给其父类加载器加载，只有当其父类加载器无法加载时，自己才去尝试加载。</p><p>破坏双亲委派</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ANTLR4 解析语法树 以及IDEA相关插件使用</title>
      <link href="/2020/12/07/antlr/"/>
      <url>/2020/12/07/antlr/</url>
      
        <content type="html"><![CDATA[<h1 id="ANTLR4-解析语法树-以及IDEA相关插件使用"><a href="#ANTLR4-解析语法树-以及IDEA相关插件使用" class="headerlink" title="ANTLR4 解析语法树 以及IDEA相关插件使用"></a>ANTLR4 解析语法树 以及IDEA相关插件使用</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先，写这篇博文主要是为了记录下我在用antlr+idea开发时遇到的坑点来帮助大家，希望大家不要走我的弯路，同时也是记录自己的一个写编译器历程。</p><a id="more"></a><h2 id="ANTLR简介"><a href="#ANTLR简介" class="headerlink" title="ANTLR简介"></a>ANTLR简介</h2><p>在这就给大家用我自己的话简单介绍一下antlr，就功能需求而言，其就是一个在你给定文法的前提下，能将输入串转换成语法树的工具。</p><p>也就是，你给定一个文法，再给定一个输入串，他能判断该输入串是否符合该文法，如果符合，就能将其生成为一棵语法树供你进一步使用。</p><h2 id="IDEA插件"><a href="#IDEA插件" class="headerlink" title="IDEA插件"></a>IDEA插件</h2><p>在idea的plugins中进行搜索ANTLR4应该就能搜到该插件，进行下载重启即可，如下图所示。</p><p><img src="https://i.loli.net/2020/12/07/ZjAPoifHLBvqDbg.png" alt="antlr.png"></p><p>重启后就能在下方工具栏看到ANTLR Preview和Tool Output两栏，也就是插件提供的功能。如何使用该插件在下文会提到。</p><h2 id="如何使用ANTLR"><a href="#如何使用ANTLR" class="headerlink" title="如何使用ANTLR"></a>如何使用ANTLR</h2><p>如何来使用该工具呢，首先当然是配置环境，因为本人是使用Java语言来进行开发的，所以只能配置一下maven的依赖即可，请一定注意，<strong>版本号应和上文下载的插件对应的最新版本号吻合</strong>，否则可能会有bug</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.antlr<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>antlr4-runtime<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后配置好环境后，下一步就是开始写文法。ANTLR专门的.g4后缀文件，用于写文法，在IDEA中随便找个目录新建一个xxx.g4文件即可，这里推荐大家将xxx的第一个字母大写，因为后面会根据该文件名生成对应的类，所以首字母大写会好一些。</p><p>在创建好.g4文件后，它的图标应该长这样，如下图</p><p><img src="https://i.loli.net/2020/12/07/MbxTp8vC4UH5qlP.png" alt="g4.png"></p><p>当然也有可能它不长那样(比如我自己的)，可能就是IDEA本身的问题了，像这样</p><p><img src="https://i.loli.net/2020/12/07/Hh6bC7vE9mzt8Q4.png" alt="c0.png"></p><p>如果遇到图标无法正常显示，那么插件的功能也就无法正常使用了，因为它没法在该文件中进行相关文法的检验。所以怎么解决呢？</p><p>我本人是通过在项目src/main/java目录里新建一个<strong>Scratch File</strong>，如下图：</p><p><img src="https://i.loli.net/2020/12/07/WQtogHCeP9EnZNA.png" alt="ss.png"></p><p><img src="https://i.loli.net/2020/12/07/NZO8ymUQhvTWpMg.png" alt="sss.png"></p><p>然后里面就应该有这样的画面，然后点击第一个创建，应该就能拿到正常图标显示的文件了，也可以进行相关插件的使用了。</p><p>然后在该文件中进行相关文法的书写，文法的书写规范这里就不再赘述了，大家可以自行找相关博客来学习，在我们成功完成文法的书写后，我们就可以开始生成相应的parser和lexer了。</p><p><strong>但是需要注意的是，ANTLR是不支持直接左递归文法的，需要进行改写。</strong></p><p>我们在g4文件处右键首先进行配置，选择Configure ANTLR</p><p><img src="https://i.loli.net/2020/12/07/D2Ff1sRdVTNa9hj.png" alt="sssss.png"></p><p>就应该会有这个页面</p><p><img src="https://i.loli.net/2020/12/07/MvTyVJp5UxXfZnC.png" alt="2s.png"></p><p>然我们在第一个框里选择想要导出的位置，一般是选择在项目中新建一个包，并选择该包，然后选择OK就行。</p><p>然后我们就可以点击上图的Generate ANTLR Recognizer进行类的生成了。生成成功应该如下图所示：</p><p><img src="https://i.loli.net/2020/12/07/D4RrNLZdokMqAWY.png" alt="cc.png"></p><p>其中Parser是语法分析的类，Lexer是词法分析的类，此时我们就已经可以开始通过输入一些字符串来检查是否符合我们的文法了。</p><p>我们就在一个Main方法中输入以下语句即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, RecognitionException </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">"xxx"</span>); <span class="comment">// 自行选择路径</span></span><br><span class="line">    InputStream in = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">    ANTLRInputStream input = <span class="keyword">new</span> ANTLRInputStream(in);</span><br><span class="line">    C0Lexer lex = <span class="keyword">new</span> C0Lexer(input);</span><br><span class="line">    CommonTokenStream tokens = <span class="keyword">new</span> CommonTokenStream(lex);</span><br><span class="line">    C0Parser parser = <span class="keyword">new</span> C0Parser(tokens);</span><br><span class="line">    C0Parser.ProgramContext tree = parser.program();</span><br><span class="line">    System.out.println(tree.toStringTree(parser));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果输入的字符串符合文法，那么就能正常输出一个生成的语法树了，如果不符合，那么插件也会自动帮你打印出错的位置，并且不会报错。</p><p><strong>如果想要它报错该怎么办呢？</strong>这也是当时困扰我很久的问题，想要其报错，我们就需要为其自己设计一个Listener来自定义错误处理。</p><p>我们就自己新建一个类，并继承BaseErrorListener类，并重载syntaxError方法即可，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyErrorListener</span> <span class="keyword">extends</span> <span class="title">BaseErrorListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syntaxError</span><span class="params">(Recognizer&lt;?, ?&gt; recognizer,</span></span></span><br><span class="line"><span class="function"><span class="params">                            Object offendingSymbol,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> line,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> charPositionInLine,</span></span></span><br><span class="line"><span class="function"><span class="params">                            String msg,</span></span></span><br><span class="line"><span class="function"><span class="params">                            RecognitionException e)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在我们的Parser遇到不符合我们定义的文法时，就能报错并输出了。</p><h2 id="如何测试-g4文件"><a href="#如何测试-g4文件" class="headerlink" title="如何测试.g4文件"></a>如何测试.g4文件</h2><p>即通过插件我们可以测试自己设计的文法中的一个parser，而不用每次都执行main方法，我们只用在g4文件中选择一个parser，并右键选择Test Rule xxx即可，在idea下方就会自动出现一个弹窗用于测试了。</p><h2 id="拿到语法树下一步怎么办"><a href="#拿到语法树下一步怎么办" class="headerlink" title="拿到语法树下一步怎么办"></a>拿到语法树下一步怎么办</h2><p>我们经过一系列努力后，终于成功生成语法树了，那我们应该怎么处理这棵树呢？</p><p>antlr为我们提供了两种遍历语法树的方式，分别为Listener方式和Visitor方式。这两种方式的不同点在于，listener是其已经为你定义好怎么遍历了，而Visitor则需要你自己定义怎么去遍历。且listener的所有返回类型都为void，即不能通过方法返回值传参，而visitor可以自定义一个返回值类型，当然所有方法的返回值类型都是一样的。</p><p>不管要使用listener还是visitor方式，方法都是去继承对应antlr为我们生成的类，有xxxlistener和xxxvisitor，继承就可以了，然后选择自己想要重载的方法进行重载，进而就能实现自己想要的功能了。</p><p>对于listener和visitor，想要用其遍历自己生成的语法树，就通过以下代码即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, RecognitionException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    C0Parser.ProgramContext tree = parser.program();</span><br><span class="line">    <span class="comment">// visitor方式</span></span><br><span class="line">    YourVisitor visitor = <span class="keyword">new</span> YourVisitor();</span><br><span class="line">    visitor.visit(tree);</span><br><span class="line">    <span class="comment">// listener方式</span></span><br><span class="line">    ParseTreeWalker walker = <span class="keyword">new</span> ParseTreeWalker();</span><br><span class="line">    walker.walk(<span class="keyword">new</span> YourListener(), tree);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>如果上文存在谬误请一定不吝指出。</p>]]></content>
      
      
      <categories>
          
          <category> 学习篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 插件使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链普及</title>
      <link href="/2020/09/29/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
      <url>/2020/09/29/%E5%8C%BA%E5%9D%97%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="区块链从零开始完全明白"><a href="#区块链从零开始完全明白" class="headerlink" title="区块链从零开始完全明白"></a>区块链从零开始完全明白</h1><p>写这篇博文是以一个大三学生的角度，以一些通俗一点的语言给大家普及一下什么是区块链，可能文章中很多说法存在错误以及问题，希望能包含并且提出，以便尽快改正。</p><a id="more"></a><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>首先我们要了解什么是区块链以及为何需要区块链这个东西。</p><p>为了方便大家理解，这里先说用途，很简单，就是用来记账，也就是账本。为什么用区块链记账呢，好处是什么呢？好处是这个账本人手一个，且大家都一样并且无法被改变，并且每一笔账都能被找到。无法被改变就是其最厉害的地方。具体怎么实现的呢，我们后面会说到，大家先有个印象，不要将区块链想得太复杂，就是一个无法被改变的且无限大可以溯源的账本而已。</p><p>然后是什么是区块链，顾名思义，由区块组成的链。为什么能够记账呢，就是将交易的记录放在区块里罢了，然后再把区块用链连起来，就形成了区块链。</p><p>区块链还有一些好处，也就是分布式、去中心化。就如同不让一个人保存账本，要是这个人私自改了也没人知道，也就形成了麻烦。使用区块链就能避免这个问题。</p><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>在详细了解区块链的知识之前，我们需要先了解一些加密相关的知识。</p><p>加密分为两类，对称加密和非对称加密。</p><p>什么是对称加密呢，通俗来讲就是一把锁，开锁和解锁是同一把钥匙，这就是对称加密。</p><p>那什么是非对称加密呢，加锁和解锁的钥匙不同，且需要成对使用，这就是非对称加密，同时，非对称加密加锁的钥匙称为公钥而解锁的钥匙称为私钥。公钥可以公开给所有人，但私钥需要自己保存。</p><p>这两种加密方式各有优缺点，对称加密，速度快，但是存在一个密钥如何传输的问题，我这上锁了，我要怎么把密钥安全的给你呢？而对于非对称加密则是安全性非常高但速度很慢。</p><p>所以区块链则将这两种技术结合起来，用非对称加密进行密钥的分发而对称加密用于数据传输。将传输的数据使用对称加密，然后将对称加密的密钥用交易的人提供的非对称加密的公钥加密，然后再传输给交易的人，然后交易的人拿到后通过自己的私钥解密获得密钥后，再解密得到相应的数据。从而结合两者优势，安全也迅速的完成数据的传输。</p><p>还有一个需要说明的地方，非对称加密中公钥和私钥除了用于加锁和解锁外，还有一个功能。即私钥用于签名，公钥用于验证。什么是签名呢，即表明这个东西是你提供的，你签了名，且这个签名被验证成功了，就表示这个东西就是你提供的。比如你要向你的老板给一份数据，但老板不知道这份数据是你给的，因为可能你把数据给你老板的中途被调换之类的，所以你就用你的私钥在这份数据上进行签名(签名不会暴露自己的私钥)，然后将公钥给你的老板，你的老板用公钥来验证这份数据上的签名，验证成功后，就能放心打开数据了。所以在区块链交易中，签名也是必不可少的一部分。</p><p>最后很重要的一部分就是加密的算法，我们这里就介绍哈希加密算法，常见的有MD5和SHA256/512，MD5已经比较过时了，现在用的基本是后者，256和512代表的是加密后的比特位，任何数据经过SHA256/512哈希算法加密后，都会形成256或者512位数据，且无法反推，且任何两个不同的数据会经过hash后得到的肯定是两个不同的256/512位的数据(哈希冲突在该算法中可以认为不存在)。然后这里再提一下签名，签名是将数据的哈希值通过一些算法进行签名，即和数据本身无关，因为签名只用证明发送方即可，和具体的数据无关。</p><h3 id="区块具体实现"><a href="#区块具体实现" class="headerlink" title="区块具体实现"></a>区块具体实现</h3><p>我们这里就开始正题说一下区块到底是什么。一个区块就可以看作一个矩形，分为两个部分，头部和身体部分，前面说到过区块里存交易记录，这个记录就存放在区块的身体部分里，存着一条又一条的记录。如下图</p><p><img src="https://i.loli.net/2020/09/28/NCYDgW7BO2KvAxL.png" alt="1.png"></p><p>那头部存什么东西呢，首先需要存这些所有交易记录的哈希值，即保证如果有一条记录发生任何改变，哈希值肯定发生变化，所以这就保证了交易记录的不可更改。其次需要存一个区块高度，什么是区块高度呢，也就是区块的编号，我们说过区块链是将区块一个个链起来，所以就存在前后顺序，即存在编号，所以还需要存一个编号。然后还需要存一个版本号，这个就不是很重要。同时交易记录的哈希值具体怎么得出的，我们后面还会具体说到和一个merkle tree相关。其次头部里还要存一个值，前面所有区块的总哈希值，即保证如果一个想要改变一个区块的记录，需要将其前面所有区块记录都改变，因为哈希值是唯一的，所以这也保证了所有区块中记录的不可改变且可溯源。最后头部里还要存一个很关键的值，nounce值，一个随机值，具体用来干嘛我们后面会一一道来。</p><p>所以区块链就可以简单看作下图</p><p><img src="https://i.loli.net/2020/09/28/3bc8JyBXvutlaj9.png" alt="2.png"></p><h3 id="比特币"><a href="#比特币" class="headerlink" title="比特币"></a>比特币</h3><p>将区块链肯定离不开比特币这个东西，也正是这个东西推动区块链的发展。</p><p>首先我们从一笔交易开始，假设这样一个场景，A从B处买了一台电脑，3500元，A付给B5000元，B找给A1400元，还剩下100元作为小费。(小费可以这样理解，你这笔交易想要尽快完成即想尽快A拿货B拿钱，就需要付小费，这笔小费是给矿工的)，这就是一次交易，但这样的交易在区块链中形成的交易记录是这样的，如下图</p><p><img src="https://i.loli.net/2020/09/28/B47WtFnpRbPaNcs.png" alt="3.png"></p><p>我们可以看到，其中小费的部分没有在其中体现出来，为什么呢，这就牵扯到下一个重要的点——矿工。</p><p>我们经常听到挖矿挖矿，所以到底什么是挖矿，什么又是矿呢？</p><p>首先我们需要明确，我们的交易，不是立马就完成的，只有当这笔交易记录在区块链上，也就是存在于某一个区块上，这笔交易才算完成。那区块是如何形成的呢，是算出来的，谁来算呢？怎么算呢？</p><p>矿工来算。矿工可以选择一些交易记录来形成区块，形成区块后，小费就归矿工了，所以矿工肯定会选择小费高的交易记录了，这也解释了为何A一定要给一部分小费。</p><p>那怎么形成区块呢，我们前面说过，区块头部里存了该区块所有交易的哈希值，以及前面所有区块的总哈希值，所以这两部分是无法改变的，也是现成的，要形成区块，这两部分是必须的，因为保证了交易的不可改变且可溯源。然后除了这两部分，还有一个东西，就是前面说到的nounce值，这三者结合再哈希得到的值，满足前多少多少位为0，则代表成功，就代表算对了，这个区块就能形成了。所以矿工是干嘛的，就是耗费电力、算力来随机生成这个nounce值，来使得三者的哈希值满足条件，进而形成区块。这个过程，就叫做挖矿，也可以用POW(工作量证明)来表示，表示你浪费了电力、物力来算这个nounce值，有资格获得小费，也就是比特币。</p><h3 id="交易广播"><a href="#交易广播" class="headerlink" title="交易广播"></a>交易广播</h3><p>前面比较笼统的说了相关交易和比特币以及挖矿的问题，这里我们就具体说下其实现问题。</p><p>一笔交易，形成后(还没有进入区块，只是A付了钱)，会向全网进行广播，也就是所有节点都收到了这笔交易的记录，节点对这个记录进行验证，也就是验证A是不是付了钱、B的账户地址等等问题，验证成功后，节点就将这个记录，放进交易缓存池，这个池子里放了很多的交易记录，但还没有形成区块，等着矿工去里面选呢，选小费高的记录去形成区块。这就是广播的第一个使用的地方。让这笔交易进入全网。</p><p>因为矿工是很多的，所以当几个矿工同时在计算该链上下一个区块时，就存在先后顺序了。我们用下图来表示</p><p><img src="https://i.loli.net/2020/09/28/h1EqtTXrSnxuWmK.png" alt="4.png"></p><p>可以看到，ABC同时计算一个区块，此时A先算出来了，他就会立刻进行广播表示自己算出来了，然后BC收到广播后，就会停止计算并验证A是否计算正确，正确了的话，就将这个区块上链了，然后大家重新去缓存池里拿交易上链。这就是一个竞争的过程。</p><p>还有一种情况，就是两个人一起完成了计算，因为只要保证算出来前几位为0即可，情况是很多的，所以可能两个不一样的区块但都满足条件。我们考虑AB同时计算出来，此时，又会如何呢，我们看下图</p><p><img src="https://i.loli.net/2020/09/28/d5yiGButSOYo7P8.png" alt="5.png"></p><p>区块链会将两个区块都上链，然后让大家继续计算，因为两个区块后面的区块大家也都能进行计算，所以会存在某个链上(A和B链)先生成下一个区块C的情况，例如A后先计算出来一个区块C，此时C就会进行广播了，广播后，B就被抛弃了，A+C作为主链了。当然如果B上先生成也是同理。此时另一个区块被抛弃后，里面的交易记录就重新回到了缓存池，那矿工的小费呢，下面继续说。</p><p>这就牵扯到区块验证问题了，因为存在这种同时计算出区块的问题，所以区块链中规定了，当前区块形成后，在该区块后再追加6个区块后，这个区块里的交易才算真正完成，矿工才能拿到钱，即保证这个区块不会被抛弃。那为何是6个区块呢，因为根据相关计算，在领先6个区块的情况下，不可能存在一个新的链(从那个区块开始)替代该链，即不会存在一个比该链更长的链来替代。进而保证交易的完成，小费也能成功进入矿工手里。</p><h3 id="merkle-tree"><a href="#merkle-tree" class="headerlink" title="merkle tree"></a>merkle tree</h3><p>然后这里再说一下前面提到的merkle tree，这是可以看作一个数据结构，也就是一个二叉树，但这个树是一棵完美二叉树。</p><p>这棵树是怎么形成的呢，所有的交易作为叶节点，然后两两进行哈希形成父节点，如果是奇数个叶节点，则会复制一个叶节点，使其自身和自身哈希，然后父节点也同样两两哈希，一直到形成一个根节点。而区块头部信息里，就存的是该根节点的值。</p><p>具体的实现可以参考这篇博文<a href="https://www.cnblogs.com/fengzhiwu/p/5524324.html" target="_blank" rel="noopener">merkle tree</a></p><p>然后这棵树有什么用呢，可以用来验证，验证什么呢，验证某一笔交易是否存在于区块链中，具体的验证方法，也就是和merkle tree原理相关。参考上面博文。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>希望这篇博文能对大家有所帮助。</p>]]></content>
      
      
      <categories>
          
          <category> 学习篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu安装RabbitMQ教程</title>
      <link href="/2020/09/27/ubuntu%E8%A3%85rabbitmq/"/>
      <url>/2020/09/27/ubuntu%E8%A3%85rabbitmq/</url>
      
        <content type="html"><![CDATA[<h1 id="Ubuntu安装RabbitMQ教程"><a href="#Ubuntu安装RabbitMQ教程" class="headerlink" title="Ubuntu安装RabbitMQ教程"></a>Ubuntu安装RabbitMQ教程</h1><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>本篇主要给大家介绍ubuntu安装rabbitmq的过程以及相关遇到的坑，同时也避免自己忘记，所以写下这篇博文供大家学习。</p><a id="more"></a><h3 id="相关版本"><a href="#相关版本" class="headerlink" title="相关版本"></a>相关版本</h3><p>操作系统：Linux阿里云服务器</p><p>ubuntu：18.04（root用户）</p><p>rabbitmq：3.8.8</p><p>erlang：23.0.3（Ubuntu Xenial 64bit）</p><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h4 id="erlang安装"><a href="#erlang安装" class="headerlink" title="erlang安装"></a>erlang安装</h4><p>因为rabbitmq由erlang语言编写，所以安装之前需要安装erlang语言环境，由于ubuntu本身使用的apt-get源里的erlang比较老，所以这里我们是直接去官网下载安装。</p><p>首先进入erlang官网下载页</p><p><a href="https://www.erlang-solutions.com/resources/download.html" target="_blank" rel="noopener">https://www.erlang-solutions.com/resources/download.html</a></p><p>然后往下找到自己想要下载的版本，erlang的版本是根据rabbitmq的版本来的，可以查看rabbitmq官网中的Erlang Versions，<a href="https://www.rabbitmq.com/which-erlang.html" target="_blank" rel="noopener">点这里</a>来查看自己想下载的rabbitmq对应所支持的erlang版本，然后再到下载页面进行下载，同时需要注意自己系统的版本和相应的指令集（amd还是arm），如下图</p><p><img src="https://i.loli.net/2020/09/28/5qZCA4xUKTIVoJW.png" alt="1.png"></p><p>然后下载到自己电脑后，就通过相关shell传到自己的服务器里去，进入相应的目录，然后通过下面命令进行解压就可以了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -i esl-erlang_版本号_ubuntu_artful_amd64.deb</span><br></pre></td></tr></table></figure><p>当然可能会存在缺少相关依赖的情况，可通过以下命令进行相应依赖的安装，然后重新执行上面↑的命令就可以了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get -f install</span><br></pre></td></tr></table></figure><p>安装完成后，可以通过命令行输入<code>erl</code>命令查看自己是否安装成功以及安装的版本。如下图</p><p><img src="https://i.loli.net/2020/09/28/3wYV67ZJ4fTHONh.png" alt="2.png"></p><h4 id="rabbitmq安装"><a href="#rabbitmq安装" class="headerlink" title="rabbitmq安装"></a>rabbitmq安装</h4><p>然后erlang安装完成后我们就直接进入rabbitmq的安装，为了安装的方便，这里我也是选择的对相应的包进行下载后再安装的方式。</p><p>首先在服务器上安装好相关依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 更新</span><br><span class="line">apt-get update</span><br><span class="line"></span><br><span class="line">apt-get -y install socat logrotate init-system-helpers adduser</span><br><span class="line">apt-get -y install wget</span><br><span class="line"></span><br><span class="line"># 下载包</span><br><span class="line">wget https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.8/rabbitmq-server_3.8.8-1_all.deb</span><br><span class="line"></span><br><span class="line"># 安装</span><br><span class="line">dpkg -i rabbitmq-server_3.8.8-1_all.deb</span><br></pre></td></tr></table></figure><p>上面<code>wget https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.8/rabbitmq-server_3.8.8-1_all.deb</code>命令中的版本号可自己指定，然后因为该网站是外网，所以可能下载速度很慢，也可以选择自己在本地电脑访问相应的地址下载好后再通过shell传输到服务器进行安装，会更快一下。</p><p>然后安装完成后就可以通过以下命令对rabbitmq服务进行启动和关闭了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service rabbitmq-server start # 启动服务</span><br><span class="line">service rabbitmq-server stop # 停止服务</span><br><span class="line">service rabbitmq-server restart # 重启服务</span><br></pre></td></tr></table></figure><p>然后为了操作rabbitmq的方便，我们还可以开启管理界面，使用以下命令即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure><p>然后可以访问ip:15672来查看该页面了，如下图</p><p><img src="https://i.loli.net/2020/09/28/zkW5bhGHVmvyPYJ.png" alt="3.png"></p><p>然后该页面提供默认的账号密码进行登录，账户密码都是guest，但是因为rabbitmq的配置问题，他只允许本机登录，所以会出现无法登录的情况，这时就需要进行相关配置文件的配置</p><p>因为这个是高版本，所以没有默认创建配置文件，所以需要我们自己创建rabbitmq.conf文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/rabbitmq/rabbitmq.conf</span><br></pre></td></tr></table></figure><p>然后在github上复制或者下载配置文件模板，<a href="https://github.com/rabbitmq/rabbitmq-server/blob/v3.7.x/docs/rabbitmq.conf.example" target="_blank" rel="noopener">点这里</a>，然后进行相应的修改，将<strong>loopback_users.guest = false</strong>这一行前的##进行去除即可，如下图，</p><p><img src="https://i.loli.net/2020/09/28/CypmLvHd6PjTfuB.png" alt="4.png"></p><p>然后再进行登录就能成功了</p><p>然后相关的其他操作就靠大家自己摸索了</p><hr><p><strong><em>如有谬误请不吝指正，方便立马修改以防止误导他人</em></strong></p>]]></content>
      
      
      <categories>
          
          <category> 配置篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java自学总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java框架</title>
      <link href="/2020/08/30/Spring/"/>
      <url>/2020/08/30/Spring/</url>
      
        <content type="html"><![CDATA[<h1 id="Java框架学习"><a href="#Java框架学习" class="headerlink" title="Java框架学习"></a>Java框架学习</h1><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><a id="more"></a><h3 id="Spring-IOC"><a href="#Spring-IOC" class="headerlink" title="Spring IOC"></a>Spring IOC</h3><pre><code>1. Spring开发步骤    1. 导入坐标    2. 创建Bean    3. 创建applicationContext.xml    4. 在配置文件中进行配置(&lt;bean&gt;&lt;/bean&gt;)    5. 创建ApplicationContext对象getBean(提供配置时的id)     * 注意：        1. jdk版本问题，需要在project structure和settings中对jdk版本进行选择和更改        2. idea有自带的maven，自己安装了后应改为自己的maven        3. 更换aliyun如果还是无法下载，可以自己下载后放入对应仓库中再进行reload project        4. dependency容易爆红2. Spring配置文件    2.1 Bean标签基本配置        默认情况用反射调用无参构造创建对象，基本属性：id(唯一标识)、class(Bean的全类名)    2.2 Bean标签范围配置        scope：对象作用范围            * singleton：默认值，单例                * 当Spring核心文件(配置文件)被加载时，实例化配置的Bean实例，且一直存在直到容器销毁或应用卸载            * prototype：多例的                * 在调用getBean方法时实例化Bean，对象在使用中就活着，长时间不使用会被Java垃圾回收机制销毁            * request：web项目中，Spring创建一个Bean的对象，将对象存入request域            * session：web项目中，Spring创建一个Bean的对象，将对象存入session域            * global session：web项目中，应用在Portlet环境，如果没有Portlet环境那么global session相当于session    2.3 Bean生命周期配置        * init-method：指定类中初始化方法名称        * destroy-method：指定类中销毁方法名称    2.4 Bean实例化三种方式        * 无参构造方法        * 工厂静态方法            * 配置bean中的factory和factory-method属性                &lt;bean id=&quot;userDao&quot; class=&quot;xxx.xxx.xxxfactory&quot; factory-method=&quot;xxx()&quot;&gt;&lt;/bean&gt;        * 工厂实例方法            * 配置两个bean                &lt;bean id=&quot;factory&quot; class=&quot;xxx.xxx.xxxfactory&quot;&gt;&lt;/bean&gt;                &lt;bean id=&quot;userDao&quot; factory-bean=&quot;factory&quot; factory-method=&quot;xxx()&quot;&gt;&lt;/bean&gt;    2.5 Bean依赖注入        理解为何需要依赖注入：https://www.bilibili.com/video/BV1WZ4y1H7du?p=14        依赖注入(dependency injection)：Spring框架核心IOC的具体实现        注入方式：            * 构造方法                * 配置bean                    &lt;bean id=&quot;userDao&quot; class=&quot;com.dbettkk.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;                    &lt;bean id=&quot;userService&quot; class=&quot;com.dbettkk.service.impl.UserServiceImpl&quot;&gt;                        &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/constructor-arg&gt;                    &lt;/bean&gt;                    * 注意：constructor-arg中的name属性是UserServiceImpl的构造方法的参数部分，而ref属性则是上面已经配置好的bean的id。            * set方法                * 配置bean                    &lt;bean id=&quot;userDao&quot; class=&quot;com.dbettkk.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;                    &lt;bean id=&quot;userService&quot; class=&quot;com.dbettkk.service.impl.UserServiceImpl&quot;&gt;                        &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt;                    &lt;/bean&gt;                    * 注意：property中的name属性是UserServiceImpl的setXxx()方法的xxx部分，而ref属性则是上面已经配置好的bean的id。                    * 也可以使用p命名空间进行简化，然后在bean中通过属性方式进行配置，同理p-xxx中的xxx是setXxx()方法的xxx而，属性的值则是上面所配置的bean的id值                        * xmlns=&quot;http://www.springframework.org/schema/p&quot;                        * &lt;bean id=&quot;userService&quot; class=&quot;com.dbettkk.service.impl.UserServiceImpl&quot; p:userDao-ref=&quot;userDao&quot;&gt;&lt;/bean&gt;        依赖注入的数据类型：            * 普通数据类型            * 引用数据类型            * 集合数据类型                * list、map、property                * 如果是基本数据类型就是value或者不加ref的属性，如果是引用数据类型则用ref属性                * 例如配置Map&lt;String, User&gt;                    &lt;property name=&quot;userMap&quot;&gt;                        &lt;map&gt;                            &lt;entry key=&quot;1&quot; value-ref=&quot;user&quot;&gt;&lt;/entry&gt;                        &lt;/map&gt;                    &lt;/property&gt;                    * 其中key代表基本数据类型，如果Map的key是引用数据类型，则使用key-ref，value同理value/value-ref    2.6 引入其他配置文件(分模块开发)        * 实际开发中，因为需要配置的东西很多，全写一起不方便，可以拆分为多个配置文件applicationContext-xxx，然后在主配置文件中使用import进行引入        * &lt;import resource=&quot;applicationContext-dao.xml&quot;&gt;&lt;/import&gt;    2.7 小结        &lt;bean&gt;标签            id属性：容器中Bean对象的唯一标识            class属性：要实例化的Bean的全限定名            scope属性：Bean作用范围，常用为singleton和prototype            &lt;property&gt;标签：属性注入                name属性：属性名称                value属性：注入的普通属性值                ref属性：注入的对象引用值(已经配置好的bean的id)                &lt;list&gt;标签                &lt;map&gt;标签                &lt;properties&gt;标签标签            &lt;constructor-arg&gt;标签            &lt;import&gt;标签：导入其他Spring的分文件3. Spring相关API    3.1 ApplicationContext相关的继承体系        众多接口-抽象类-实现类    3.2 ApplicationContext的实现类        * ClassPathXmlApplicationContext            * 从类的根路径下加载配置文件        * FileSystemXmlApplicationContext            * 从磁盘路径加载配置文件(绝对路径)        * AnnotationConfigApplicationContext            * 使用注解配置容器对象时，使用此类创建spring容器，读取注解    3.3 getBean()方法使用        参数：            * id(String)：可以获取多个id不同class相同的bean，不会发生冲突            * 字节码文件(Class)：不用进行强转，如果有多个id不同class相同的bean则会报错4. Spring配置数据源    4.1 数据源(连接池)的作用        * 提高程序性能        * 实例化数据源，初始化部分连接资源        * 使用连接资源时从数据源中获取        * 使用完毕后将连接资源归还给数据源    4.2 抽取jdbc配置文件        1. 代码中加载            * 使用ResourceBundle加载配置文件并获取到值后用dataSource进行配置即可        2. Spring配置文件中加载            1. 引入context命名空间和约束路径            2. 使用context:property-placeholder并设置locations属性为properties文件位置            3. 使用SPEL表达式${key}获取properties配置文件中key对应的值并给bean标签下的property标签的value值            &lt;context:property-placeholder location=&quot;classpath:xx.properties&quot;/&gt;            &lt;property name=&quot;xxx&quot; value=&quot;${key}&quot;/&gt;    4.2 Spring配置数据源</code></pre><h4 id="Spring注解开发"><a href="#Spring注解开发" class="headerlink" title="Spring注解开发"></a>Spring注解开发</h4><pre><code>1. Spring原始注解    * Spring原始注解主要是替代&lt;Bean&gt;配置        * @Component：使用在类上用于实例化Bean        * @Controller：使用在web层类上用于实例化Bean        * @Service：使用在Service层类用于实例化Bean        * @Repository：使用在dao层类用于实例化Bean            * 这三个和Component是一样的，只是具有语义，方便理解        * @Autowired：使用在字段上根据类型依赖注入 ref        * @Qualifier：结合@Autowired一起使用用于根据名称进行依赖注入        * @Resource：相当于@Autowired+@Qualified,根据名称进行依赖注入        * @Value：注入普通属性            * 可以使用SPEL表达式-@Value(&quot;${key}&quot;)        * @Scope：作用范围        * @PostConstruct：init-method        * @PreDestroy：destroy-method    * 使用注解开发时，需要在配置文件中进行组件扫描        * &lt;context:component-scan base-package=&quot;com.dbettkk&quot;/&gt;        * base-package：基本包，扫描该包以及子包的注解，以便识别    * 注意：        * 使用注解开发，可以不用写set方法        * 如果Spring容器中直存在一种类型的Bean，则相应的属性可以不写@Qualifier，只写@Autowired，默认从Spring容器中进行匹配        * 如果想要按照名称进行匹配，则需要@Autowired+@Qualifier        * 也可以将两个注解替换为@Resource(name=&quot;&quot;)，值为@Qualifier的value2. Spring新注解    * 非自定义的Bean的配置&lt;bean&gt;    * 加载properties文件的配置：&lt;context:property-placeholder&gt;    * 组件扫描的配置：&lt;context:component-scan&gt;    * 引入其他文件：&lt;import&gt;    新注解：        * @Configuration：用于指定当前类时一个Spring配置类，当创建容器时会从该类上加载        * @ComponentScan：用于指定Spring在初始化容器时要扫描的包，作用和&lt;context:component-scan&gt;一致        * @Bean：使用在方法上，标注将该方法的返回值，存储在Spring容器中        * @PropertySource：用于加载.properties文件中的配置        * @import：用于导入其他配置类</code></pre><h4 id="Spring集成Junit"><a href="#Spring集成Junit" class="headerlink" title="Spring集成Junit"></a>Spring集成Junit</h4><pre><code>1. 原始Junit测试Spring的问题    * 在每个测试中都需要两行代码来获取ApplicationContext对象和使用getBean()方法获取想要测试的对象，冗余2. 解决方案    * 让SpringJunit负责创建Spring容器，但是需要将配置文件名称告诉它    * 将需要进行测试的Bean直接在测试类中进行注入3. 集成Junit步骤    1. 导入Spring集成Junit的坐标    2. 使用@Runwith注解替换原来的运行期        * @RunWith(SpringJUnit4ClassRunner.class)    3. 使用@ContextConfiguration指定配置文件或配置类        * 配置文件直接写，配置类需要指定@ContextConfiguration(classes = {SpringConfiguration.class})    4. 使用@Autowired注入需要测试的对象    5. 创建测试方法进行测试</code></pre><h3 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h3><h4 id="Spring-AOP-简介"><a href="#Spring-AOP-简介" class="headerlink" title="Spring AOP 简介"></a>Spring AOP 简介</h4><pre><code>1. AOP概念    面向切面编程，是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术    AOP是OOP的延续，是软件开发的一个热点，也是Spring框架中的一个重要内容。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各个部分之间的耦合度降低，提高程序的可重用性，同时提高开发效率。2. AOP作用及优势    * 作用：在程序运行期间，在不修改源码的情况下对方法进行功能增强    * 优势：减少重复代码，提高开发效率，并且便于维护3. AOP的底层实现    AOP的底层是通过Spring提供的动态代理技术实现的。运行期间，Spring通过动态代理技术动态的生成代理对象，代理对象方法执行时进行增强功能的介入，再去调用目标的uix的方法，完成功能的增强。4. AOP的动态代理技术    * JDK代理：基于接口的动态代理技术    * cglib代理：基于父类的动态代理技术5. JDK的动态代理    final Advice advice = new Advice();   // 获得增强对象    final Target target = new Target();    // 返回值就是生成的动态代理对象    TargetInterface proxy = (TargetInterface) Proxy.newProxyInstance(            target.getClass().getClassLoader(), // 目标对象的类加载器            target.getClass().getInterfaces(),  // 目标对象相同的接口字节码对象数组            new InvocationHandler() {                // 调用代理对象的任何方法，实质执行的为invoke方法                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {                    advice.before();// 前置增强                    method.invoke(target, args);// 执行目标方法                    advice.after();                    return null;                }            }    );    proxy.save();   // 调用代理对象的方法6. cglib的动态代理    final Advice advice = new Advice();   // 获得增强对象    final Target target = new Target();    // 返回值就是生成的动态代理对象 基于cglib    // 1.创建增强器    Enhancer enhancer = new Enhancer();    // 2.设置父类 (目标)    enhancer.setSuperclass(Target.class);    // 3.设置回调    enhancer.setCallback(new MethodInterceptor() {        public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {            advice.before(); // 执行前置            Object invoke = method.invoke(target, args);            advice.after(); // 执行后置            return invoke;        }    });    // 4.生成代理对象    Target proxy = (Target) enhancer.create();    proxy.save();7. AOP相关概念    * Target(目标对象)：代理的目标对象    * Proxy(代理)：一个类被AOP植入增强后，就产生一个结果代理类    * Joinpoint(连接点)：所谓的连接点就是指那些被拦截到的点，spring中，这些点指的是方法，因为spring只支持方法类型的连接点——(可以被增强的方法称为连接点)    * Pointcut(切入点)：所谓切入点是指我们要对哪些Joinpoint进行拦截的定义——(实际被增强的方法称为切入点)    * Advice(增强/通知)：所谓通知/增强是指拦截到Jpinpoint之后所要做得事情就是通知    * Aspect(切面)：是切入点和通知的结合    * Weaving(织入)：是指把增强应用到目标对象来创建新的代理对象的过程。spring采用动态代理织入，而AaspectJ采用编译期织入好肉类装载期织入——(就是将你的切点和增强结合的过程称为织入)8. AOP开发明确的事项    1. 需要编写的内容        * 业务核心代码(目标类的目标方法)        * 切面类，切面类中有通知(增强功能方法)        * 配置文件中配置织入关系，即将哪些溶质与哪些连接点进行结合    2. AOP技术实现的内容        * Spring框架监控切入点方法的执行，一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象相应位置，将通知对应的功能织入，完成完整的代码逻辑运行。    3. AOP底层使用哪种代理方式        在spring中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。9. 小结    * aop：面向切面编程    * aop底层实现：基于JDK和Cglib的动态代理    * aop重点概念：        * Ponitcut(切入点)：被增强的方法        * Advice(通知/增强)：封装增强业务逻辑的方法        * Aspect(切面)：切点+通知        * Weaving(织入)：将切点与通知结合的过程    * 开发明确事项：        谁是切点(切点表达式配置)        谁是通知(切面类中的增强方法)        将切点和通知织入配置</code></pre><h4 id="基于XML的AOP开发"><a href="#基于XML的AOP开发" class="headerlink" title="基于XML的AOP开发"></a>基于XML的AOP开发</h4><pre><code>1. 快速入门    1. 导入AOP相关坐标    2. 创建目标接口和目标类（内部有切点）    3. 创建切面类（内部有增强方法）    4. 将目标类和切面类的对象创建权交给spring    5. 在applicationContext.xml中配置织入关系        * &lt;aop:config&gt;&lt;aop:aspect ref=&quot;切面类&quot;&gt;&lt;aop:before method=&quot;通知方法名称&quot; pointcut=&quot;切点表达式&quot;/&gt;&lt;/aop:aspect&gt;&lt;/aop:config&gt;    6. 测试代码2. XML配置aop详解    1. 切点表达式写法        * execution([修饰符] 返回值类型 包名.类名.方法名(参数))            * 访问修饰符可以不写            * 返回值类型、包名、类名、方法名可以使用&apos;*&apos;代表任意            * 包名和类名之间一个点.代表当前包下的类，两个点..代表当前包及其子包下的类            * 参数列表可以使用两个点..表示任意个数、任意类型的参数列表    2. 通知的类型        * &lt;aop:通知类型 method=&quot;&quot; pointcut=&quot;切点表达式&quot;/&gt;            * 前置通知：&lt;aop:before&gt;            * 后置通知：&lt;aop:after-returning&gt;            * 环绕通知：前置+后置-&lt;aop:around&gt;            * 异常抛出通知：&lt;aop:after-throwing&gt;            * 最终通知：&lt;aop:after&gt;    3. 切点表达式的抽取        当多个增强的切点表达式相同时，可以进行抽取&lt;aop:pointcut&gt;，在增强中使用pointcut-ref进行引用        &lt;aop:aspect ref=&quot;myAspect&quot;&gt;            &lt;!--抽取切点表达式--&gt;            &lt;aop:pointcut id=&quot;myPointcut&quot; expression=&quot;execution(public void com.dbettkk.aop.Target.save())&quot;/&gt;            &lt;!--切面=切点+通知--&gt;            &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;myPointcut&quot;/&gt;            &lt;aop:after-returning method=&quot;afterReturning&quot; pointcut-ref=&quot;myPointcut&quot;/&gt;            &lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;myPointcut&quot;/&gt;            &lt;aop:after-throwing method=&quot;afterThrowing&quot; pointcut-ref=&quot;myPointcut&quot;/&gt;            &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;myPointcut&quot;/&gt;        &lt;/aop:aspect&gt;</code></pre><h4 id="基于注解的AOP开发"><a href="#基于注解的AOP开发" class="headerlink" title="基于注解的AOP开发"></a>基于注解的AOP开发</h4><pre><code>1. 快速入门    1. 创建目标接口和目标类（内部有切点）    2. 创建切面类（内部有增强方法）    3. 将目标类和切面类的对象创建权交给spring    4. 在切面类中使用注解配置织入关系    5. 在配置文件中开启组件扫描和AOP的自动代理        &lt;context:component-scan base-package=&quot;com.xxx&quot;/&gt;        &lt;aop:aspectj-autoproxy/&gt;    6. 测试代码2. 注解配置AOP详解    1. 通知类型：语法-@通知注解(&quot;切点表达式&quot;)        * @Before        * @AfterReturning        * @After        * @Around        * @AfterThrowing    2. 切点表达式的抽取        抽取方式为在切面类内部定义方法，在该方法上使用@Pointcut注解定义切点表达式，然后在增强注解中进行引用。        @Before(&quot;pointcut()&quot;)// 配置前置增强        public void before(){            System.out.println(&quot;前置增强...&quot;);        }        @Pointcut(&quot;execution(* com.dbettkk.anno.Target.save(..))&quot;)        public void pointcut() {}</code></pre><h3 id="Spring-JdbcTemplate基本使用"><a href="#Spring-JdbcTemplate基本使用" class="headerlink" title="Spring JdbcTemplate基本使用"></a>Spring JdbcTemplate基本使用</h3><pre><code>1. 概述    是spring框架中提供的一个对象，是对原始繁琐的Jdbc API对象的简单封装。spring框架为我们提供了很多模板类。JdbcTemplate、HibernateTemplate、RedisTemplate、JmsTemplate2. 开发步骤    1. 导入spring-jdbc和spring-tx坐标    2. 创建数据库表和实体    3. 创建JdbcTemplate对象        JdbcTemplate template = new JdbcTemplate();        template.setDataSource(dataSource);    4. 执行数据库操作        template.update(sql, params)        template.query(sql, Mapper, params)    查询多个对象        template.queryForObject(sql, Mapper/required Class, params)3. Spring产生JdbcTemplate对象    &lt;!--加载properties文件--&gt;    &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;    &lt;!--配置数据源对象--&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;        &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot;/&gt;        &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;/&gt;        &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;    &lt;/bean&gt;    &lt;!--配置JdbcTemplate对象--&gt;    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;4. 常用操作    CRUD</code></pre><h3 id="Spring的事务控制"><a href="#Spring的事务控制" class="headerlink" title="Spring的事务控制"></a>Spring的事务控制</h3><pre><code>编程式-调用api声明式-配置文件</code></pre><h4 id="编程式事务控制相关对象"><a href="#编程式事务控制相关对象" class="headerlink" title="编程式事务控制相关对象"></a>编程式事务控制相关对象</h4><pre><code>1. PlatformTransectionManager：该接口是spring的事务管理器，它里面提供了我们常用的操作事务的方法    * getTransection(TransectionDefination defination)    获取状态    * commit    * rollback    注意：不同的Dao层技术则有不同的实现类。该接口只规定控制事务的方法2. TransectionDefination：是事务定义的信息对象    * getIsolationLevel()：获取事务隔离级别——五类    * getPropogationBehavior()：获取事务的传播行为        * REQUIRED:如果当前没有事务，就新建一个事务，如果已经存在一个事务，则加入这个事务(默认值)        * SUPPORTS:支持当前事务，如果当前没有事务，就以非事务方式运行        ...    * getTimeout()：获取超时时间    * isReadOnly()：是否只读3. TransecionStatus：提供事务具体的运行状态    * hasSavePoint()    * isCompleted()    * isNewTransection()    * isRollbackOnly()</code></pre><h4 id="基于XML的声明式事务控制"><a href="#基于XML的声明式事务控制" class="headerlink" title="基于XML的声明式事务控制"></a>基于XML的声明式事务控制</h4><pre><code>1. 概念    采用声明的方式来处理事务，即在配置文件中声明，来代替硬编码的方式    作用：        * 不侵入开发的组件        * 在不需要事务管理的时候，只要在设定文件上修改一下即可        注意：底层就是AOP2. 声明式事务控制的实现    * 谁是切点    * 谁是通知    * 配置切面3. 切点方法的事务参数的配置    &lt;tx:advice id=&quot;txAdvice&quot; transection-manager=&quot;transactionManager&quot;&gt;        &lt;tx:attributes&gt;            &lt;tx:method name=&quot;*&quot;/&gt;        &lt;/tx:attributes&gt;    &lt;/tx:advice&gt;    其中&lt;tx:method&gt;代表切点方法的事务参数的配置        * name：切点方法名        * isolation：事务隔离级别        * propogation：事务传播型位        * timeout：超时时间        * read-only：是否只读    其他相关配置    &lt;bean id=transactionManager&quot; class=&quot;jdbc模板&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;    &lt;aop:config&gt;        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;切点表达式&quot;/&gt;    &lt;/aop:config&gt;4. 小结    * 平台事务管理器配置    * 事务通知的配置    * 事务aop织入的配置</code></pre><h4 id="基于注解的声明式事务控制"><a href="#基于注解的声明式事务控制" class="headerlink" title="基于注解的声明式事务控制"></a>基于注解的声明式事务控制</h4><pre><code>1. 注解配置声明式事务控制解析    1. 使用@Transectional在需要进行事务控制的类或者方法上进行修饰，注解可用的属性同xml配置。且在类上使用该注解表示该类下的所有方法都是以同一套参数配置    2. XML配置文件中要开启事务的注解驱动&lt;tx:annotation-driven/&gt;2. 知识要点    * 平台事务管理器配置(xml方式)    * 事务通知的配置(@Transectional注解配置)    * 事务注解驱动的配置&lt;tx:annotation-driven/&gt;</code></pre><h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><h4 id="Spring与Web环境的集成"><a href="#Spring与Web环境的集成" class="headerlink" title="Spring与Web环境的集成"></a>Spring与Web环境的集成</h4><pre><code>1. ApplicationContext应用上下文获取方式    应用上下文是通过new ClassPathXmlApplicationContext(配置文件路径)获取的，但是每次写Servlet获得Bean都需要加载配置文件，存在弊端，加载多次。    在Web项目中可以使用ServletContextListener监听Web应用启动，在其启动时，加载配置文件，创建ApplicationContext对象，将其存储在最大的域servletContext域中，就可以在任意位置获取上下文对象了2. Spring提供获取应用上下文的工具    上述分析不用动手实现，Spring提供了监听器ContextLoaderListener就是对上述功能的封装，还监听器内部加载Spring配置文件，创建应用上下文对象，并存储到ServletContext域中，提供工具类WebApplicationContextUtils供使用者获取应用上下文对象。    我们需要做的有两件事        * 在web.xml中配置COntextLoaderListener监听器(导入spring-web坐标)        * 使用WebApplicationContextUtils工具类获得上下文对象</code></pre><h4 id="SpringMVC的简介"><a href="#SpringMVC的简介" class="headerlink" title="SpringMVC的简介"></a>SpringMVC的简介</h4><pre><code>1. SpringMVC概述    SpringMVC是基于Java实现的MVC设计模型的请求驱动类型的轻量级WEB框架    SpringMVC已经称为目前最主流的MVC框架之一。通过一套注解，让简单的Java类称为处理请求的控制器，而无需实现任何接口，同时支持RESTful编程风格的请求2. SpringMVC开发步骤    1. 导入SpringMVC包    2. 配置SpringMVC核心控制器DispatherServlet    3. 编写控制器(POJO-简单的JavaBean)和视图页面    4. 将Controller使用注解配置到Spring容器中(@Component,@Controller)    5. 配置spring-mvc.xml(组件扫描)    6. 执行访问测试    </code></pre><h4 id="SpringMVC组件解析"><a href="#SpringMVC组件解析" class="headerlink" title="SpringMVC组件解析"></a>SpringMVC组件解析</h4><pre><code>1. SpringMVC执行流程    1. 用户发送请求至前端控制器DispatherServlet    2. DispatherServlet收到请求调用HandlerMapping处理器映射器    3. 处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象以及处理器拦截器一并返回给DispatherServlet    4. DispatherServlet调用HandlerAdapter处理器适配器    5. HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)    6. Controller执行完成后返回ModelAndView    7. HandlerAdapter将Controller执行结果ModelAndView返回给DispatherServlet    8. DispatherServlet将ModelAndView传给ViewResolver视图解析器    9. ViewResolver解析后返回具体View    10. DispatherServlet根据View进行渲染视图(将模型数据填充至视图中)。DispatherServlet响应用户2. SpringMVC注解解析     @RequestMapping：用于建立请求URL和处理请求方法之间的对应关系     位置：         * 类上：请求URL的以及访问目录，不写的话默认为应用的根目录         * 方法上：请求URL的第二级访问目录，与类上使用的@RequestMapping标注的以及目录一起组成访问虚拟路径     参数         * value：         * method：指定请求方式        * params:用于指定限制请求参数的条件，支持简单的表达式            * params = {&quot;accountNmae&quot;}：表示请求参数必须要accountName            * params = {&quot;money!100&quot;}：表示请求参数money不能是1004. SpringMVC的xml配置解析5. 知识要点    SpringMVC相关组件        * 前端控制器：DispatherServlet        * 处理器映射器：HandlerMapping        * 处理器适配器：HandlerAdapter        * 处理器：Handler        * 视图解析器：ViewResolver        * 视图：View    SpringMVC的注释和配置        * 请求映射注解：@RequestMapping        * 视图解析器配置：            REDIRECT_URL_PREFIX=&quot;redirect:&quot;            FORWARD_URL_PREFIX=&quot;forward:&quot;            prefix=&quot;&quot;            suffix=&quot;&quot;            &lt;!--手动配置内部资源视图解析器--&gt;            &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;                &lt;property name=&quot;prefix&quot; value=&quot;/jsp&quot;/&gt;                &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;            &lt;/bean&gt;</code></pre><h4 id="SpringMVC的数据响应"><a href="#SpringMVC的数据响应" class="headerlink" title="SpringMVC的数据响应"></a>SpringMVC的数据响应</h4><pre><code>1.    SpringMVC数据响应的方式    1. 页面跳转        * 直接返回字符串        * 通过ModelAndView对象返回    2. 回写数据        * 直接返回字符串        * 返回对象或集合2. 页面跳转    1. 直接返回字符串形式        此方式会将返回的字符串与视图解析器的前后缀拼接后跳转    2. 返回ModelAndView对象        对ModelAndView对象进行添加视图和数据然后进行返回3. 回写数据    1. 直接返回字符串形式        1. 通过框架注入的Response对象，使用response.getWriter().print()方法进行回写        2. 如果要直接返回字符串形式，因为框架会默认认为是页面跳转，所以需要通过@ResponseBody注解告知SpringMVC框架，方法返回的字符串不是跳转，而是直接在http响应体中返回    2. 回写对象或集合        为处理器适配器配置消息转换参数，指定使用jackson进行对象或集合的转换            &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt;                &lt;property name=&quot;messageConverters&quot;&gt;                    &lt;list&gt;                        &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;/&gt;                    &lt;/list&gt;                &lt;/property&gt;            &lt;/bean&gt;        mvc注解驱动            &lt;mvc:annotation-driven/&gt;            使用该驱动能默认底层实现jackson转换器4. 知识要点    数据响应方式        1）页面跳转        2）回写数据</code></pre><h4 id="SpringMVC获得请求数据"><a href="#SpringMVC获得请求数据" class="headerlink" title="SpringMVC获得请求数据"></a>SpringMVC获得请求数据</h4><pre><code>1. 获得请求参数    * 基本类型参数    * POJO类型参数    * 数组类型参数    * 集合类型参数2. 获得基本类型参数    Controller中的业务方法的参数名称要与请求参数的name一致，参数值会自动映射匹配3. 获得POJO类型参数    Controller中的业务方法的POJO参数的属性名与请求参数的name一致，参数值会自动映射匹配4. 获得数组类型参数    Controller中的业务方法的数组名称与请求参数的name一致，参数值会自动映射匹配5. 获得集合类型参数    获得集合参数时，要将集合参数包装到一个POJO中才可以。    当使用ajax提交时，可以指定contentType为json形式，那么在方法参数位置使用@RequestBody可以直接接收集合数据而无需使用POJO进行包装6. 请求数据乱码问题    当post请求时，数据会出现乱码，我们可以设置一个过滤器来进行编码的过滤。7. 参数绑定注解@RequestParam    当请求的参数名称与Controller的业务方法参数不一致时，需要通过@RequestParam注解显式的绑定    * value：与请求参数名称相同    * required：此在指定的请求参数是否必须包括，默认为true，没有参数则报错    * defaultValue：当没有指定请求参数式，则使用指定的默认值赋值8. 获得Restful风格的参数    Restful是一种软件架构风格、设计风格，而不是标准，提供以组设计原则和约束条件，主要用于客户端和服务器交互类的软件，基于这个风格的设计的软件可以更简洁、有层次，更易实现缓存    Restful风格的请求是使用&quot;url+请求方式&quot;表示一次请求目的。        * GET        * POST        * PUT        * DELETE    在SpringMVC中可以使用占位符进行参数绑定，在业务方法中可以使用@PathVariable注解进行占位符的匹配获取工作9. 自定义类型转换器    * SpringMVC默认提供一些常用的类型转换器    * 但不是所有数据类型都提供了转换器，没有提供的就需要自定义转换器    自定义类型转换的开发步骤        1. 定义转换器，实现Converter接口        2. 在配置文件中声明转换器        3. 在&lt;annotation-driven&gt;中引用转换器10. 获得请求头    1. @RequestHeader：可获得请求头信息 相当于request.getHeader(name)        * value：请求头名称        * required：是否必须携带    2. @CookieValue：可以直接获得Cookie值        * value：指定cookie名称        * required：是否必须携带11. 文件上传    文件上传客户端三要素        1. 表单项type=&quot;file&quot;        2. 表单提交方式为post        3. 表单的enctype属性是多部分表单形式，及enctype=&quot;multipart/form-data&quot;    文件上传原理        * 当form表单修改为多部分表单时，request.getParamter()将失效        * enctype=&quot;application/x-www-form-urlencoded&quot;时，form表单的正文内容格式是：key=value&amp;key=value        * 当form表单的enctype取值为Mutipart/form-data时，请求正文内容就变成多部分形式12. 单文件上传步骤    1. 导入fileupload和io坐标    2. 配置文件上传解析器    3. 编写文件上传代码13. 单文件上传实现14. 多文件上传    页面上使用相同name的多个input项，在服务器端使用MultipartFile[]进行接收即可</code></pre><h4 id="SpringMVC拦截器"><a href="#SpringMVC拦截器" class="headerlink" title="SpringMVC拦截器"></a>SpringMVC拦截器</h4><pre><code>1. 拦截器interceptor的使用    SpringMVC的拦截器类似于Servlet开发中的过滤器Filter，用于对处理器进行预处理和后处理    将拦截器按一定的顺序连结成一条链，这条链称为拦截器链。在访问时，拦截器链中的拦截器就会按照配置的顺序调用，拦截器也是AOP思想的具体实现2. 拦截器和过滤器区别    * 使用范围        Filter：任何JavaWeb工程都能使用        Interceptor：SpringMVC的一部分，只有使用框架的项目能使用    * 拦截范围        Filter：在url-pattern中配置了/*之后，可以对所有访问的资源进行拦截        Interceptor：只会拦截访问的控制器方法，如果访问的是jsp、html、css、img或者js是不会进行拦截的3. 拦截器快速入门    自定义拦截器        1. 创建拦截器实现HandlerInterceptor接口        2. 配置拦截器        3. 测试拦截器的拦截效果4. 拦截器方法说明    * preHandle()：请求处理之前调用，返回类型为Boolean，true为放行    * postHandle()：请求处理之后、视图返回前调用，可对ModelAndView对象进行操作    * afterCompletion()：整个请求结束之后，渲染了视图之后5. 案例-用户登录权限控制    需求：用户没有登录的情况下，不能对后台菜单进行访问，点击菜单跳转到登录页面</code></pre><h4 id="Spring练习-环境搭建"><a href="#Spring练习-环境搭建" class="headerlink" title="Spring练习 环境搭建"></a>Spring练习 环境搭建</h4><pre><code>1. 环境搭建步骤    1. 创建工程    2. 导入静态页面    3. 导入需要坐标    4. 创建包结构    5. 导入数据库脚本    6. 创建POJO类    7. 创建配置文件2. 角色列表的展示步骤分析    1. 点击角色管理菜单发送请求到服务器端    2. 创建RoleController和showList()方法    3. 创建RoleService和showList()方法    4. 创建RoleDao和findAll()方法    5. 使用JdbcTemplate完成查询操作    6. 将查询数据存储到Model中    7. 转发到role-list.jsp页面进行展示3. 角色添加的步骤分析    1. 点击列表页面新建按钮跳转到角色添加页面    2. 输入角色信息，点击保存按钮，表单数据提交服务器    3. 编写RileController的save()方法    4. 编写RoleService的save()方法    5. 编写RoleDao的save()方法    6. 使用JdbcTemplate保存Role数据到sys_role    7. 跳转回角色列表界面</code></pre><h4 id="SpringMVC异常处理"><a href="#SpringMVC异常处理" class="headerlink" title="SpringMVC异常处理"></a>SpringMVC异常处理</h4><pre><code>1. 异常处理的思路    就两类异常 通过捕获异常或规范代码进行处理    系统的Dao、Service、Controller出现异常都进行抛出，最后由SpringMVC前端控制器交由异常处理器进行异常处理。2. 异常处理的两种方式    * 使用SpringMVC提供的简单异常处理器SimpleMappingExceptionResolver    * 使用Spring异常处理接口HandlerExceptionResolver自定义自己的异常处理器3. 简单异常处理器SimpleMappingExceptionResolver    SpringMVC已经定义好，使用时，根据项目情况进行相应异常与视图的映射配置    &lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt;        &lt;property name=&quot;defaultErrorView&quot; value=&quot;error&quot;/&gt;        &lt;property name=&quot;exceptionMappings&quot;&gt;            &lt;map&gt;                &lt;entry key=&quot;java.lang.ClassCastException&quot; value=&quot;error1&quot;/&gt;                &lt;entry key=&quot;MyException&quot; value=&quot;error2&quot;/&gt;            &lt;/map&gt;        &lt;/property&gt;    &lt;/bean&gt;4. 自定义异常处理步骤    1. 创建异常处理器实现HandlerExceptionResolver    2. 配置异常处理器    3. 编写异常页面    4. 测试异常跳转</code></pre><h3 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h3><h4 id="MyBatis简介"><a href="#MyBatis简介" class="headerlink" title="MyBatis简介"></a>MyBatis简介</h4><pre><code>1. 原始jdbc操作2. 原始jdbc操作的分析    * 问题：        1. 数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能        2. sql语句在代码中硬编码，造成代码不易维护，实际应用sql变化可能较大，sql变动需要改变java代码        3. 查询操作，需要手动将结果集中的数据手动封装到试题中，插入操作时，需要手动将实体的数据设置到sql的占位符位置    * 解决方案        1. 使用数据库连接池初始化连接资源        2. 将sql语句抽取到xml配置文件中        3. 使用反射、内省等底层技术，自动将实体与表进行属性与字段的自动映射3. 什么是Mybatis    * mybatis是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。    * mybatis通过xml或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句    * 最后由mybatis框架执行sql并将结果映射为java对象并返回。采用ORM思想解决了实体和数据库映射的问题，对jdbc进行封装，屏蔽了jdbc api底层访问细节，使我们不用于jdbc api打交道就可以完成对数据库的持久化操作</code></pre><h4 id="MyBatis快速入门"><a href="#MyBatis快速入门" class="headerlink" title="MyBatis快速入门"></a>MyBatis快速入门</h4><pre><code>1. Mybatis开发步骤    1. 添加Mybatis坐标    2. 创建user数据表    3. 编写User实体类    4. 编写映射文件UserMapper.xml(SQL语句)    5. 编写核心文件SqlMapConfig.xml(MyBatis核心配置)    6. 编写测试类2. 环境搭建3. 编写测试代码4. 知识小结</code></pre><h4 id="MyBatis映射文件概述"><a href="#MyBatis映射文件概述" class="headerlink" title="MyBatis映射文件概述"></a>MyBatis映射文件概述</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;userMapper&quot;&gt;    &lt;select id=&quot;findAll&quot; resultType=&quot;com.dbettkk.domain.User&quot;&gt;        SELECT * FROM user    &lt;/select&gt;&lt;/mapper&gt;</code></pre><h4 id="MyBatis增删改查操作"><a href="#MyBatis增删改查操作" class="headerlink" title="MyBatis增删改查操作"></a>MyBatis增删改查操作</h4><pre><code>1. 插入数据库操作    注意问题：        * 插入语句使用insert标签        * 在映射文件中使用parameterType属性指定要插入的数据类型        * Sql语句中使用#{实体属性名}方式引用实体中的属性值        * 插入操作使用的API是sqlSession.insert(&quot;命名空间.id&quot;, 实体对象)        * 插入操作设计数据库数据变化，所以要使用sqlSeesion对象显式的提交事务，即sqlSession.commit()2. 更新操作    注意问题        * 使用update标签        * sql语句使用#{实体属性名}方式引用实体中的属性值        * 更新操作使用的API是sqlSession.update(&quot;命名空间.id&quot;, Object);        3. 删除操作    注意问题        * 使用delete标签        * sql语句使用#{任意字符串}方式引用传递的单个参数        * 删除操作使用的API是sqlSession.delete(&quot;命名空间.id&quot;, Object);4. 知识小结</code></pre><h4 id="MyBatis核心配置文件概述"><a href="#MyBatis核心配置文件概述" class="headerlink" title="MyBatis核心配置文件概述"></a>MyBatis核心配置文件概述</h4><pre><code>1. 核心配置文件层级关系    * configuration配置        * properties属性        * settings设置        * typeAllases类型别名        * typeHandlers类型处理器        * objectFactory对象工厂        * plugins插件        * environments环境            * environment环境变量                * transactionManager事务管理器                * dataSource数据源        * databaseProvider数据库厂商标识        * mappers映射器2. 常用配置解析    1. enviroments标签：数据库环境的配置，支持多环境的配置 需指定默认环境        事务管理器类型有两种            * JDBC：直接使用JDBC的提交和回滚，依赖于从数据源得到的连接来管理事务作用域            * MANAGED：这个配置几乎没做什么，从不提交或回滚一个连接，它让容器来管理事务的整个生命周期(比如JEE应用服务器的上下文)，默认情况下会关闭连接，需要配置相关属性。        数据源类型有三种：            * UNPOOLED：知识每次被请求时打开和关闭连接            * POOLED：这种数据源的实现利用池的概念将JDBC连接对象组织起来            * JDNI：这个数据源的实现是为了能在如EJB或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后防止一个JNDI上下文的引用    2. mapper标签：加载映射        * 使用相对于类路径的资源引用，例如&lt;mapper resource=&quot;com/dbettkk/mapper/UserMapper.xml&quot;/&gt;        * 使用完全限定资源定位符(URL)，绝对路径        * 使用映射器接口实现类的完全限定类名，例如&lt;mapper class=&quot;全限定类名&quot;/&gt;        * 将包内的映射器接口实现全部注册为映射器，例如：&lt;package name=&quot;包名&quot;/&gt;    3. properties标签：该标签可以加载额外配置的properties文件        * &lt;properties resource=&quot;jdbc.properties&quot;/&gt;    4. typeAliases标签：定义别名        mybatis框架已经为我们设置好了一些常用类型的别名string、long、int、double、boolean        &lt;typeAliases&gt;            &lt;typeAlias type=&quot;com.dbettkk.domain.User&quot; alias=&quot;user&quot;/&gt;        &lt;/typeAliases&gt;</code></pre><h4 id="MyBatis相应的API"><a href="#MyBatis相应的API" class="headerlink" title="MyBatis相应的API"></a>MyBatis相应的API</h4><pre><code>1. SqlSession工厂构造器SqlSessionFactoryBuilder    通过加载mybatis的核心文件的输入流的形式构建一个SqlSessionFactory对象    // 加载核心配置文件    InputStream stream = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);    // 获得session工厂对象    SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(stream);    // 获得session会话对象    SqlSession sqlSession = factory.openSession();2. SqlSession工厂对象SqlSessionFactory    * openSession() 默认开启一个事务，该事务不会自动提交，需要手动提交    * openSession(boolean autoCommit) 设置参数 是否自动提交3. SqlSession会话对象    insert、update、delete方法    &lt;T&gt; T selectOne()、&lt;E&gt; List&lt;E&gt; selectList()    rollback、commit方法</code></pre><h4 id="MyBatis的Dao层实现"><a href="#MyBatis的Dao层实现" class="headerlink" title="MyBatis的Dao层实现"></a>MyBatis的Dao层实现</h4><pre><code>1. 传统开发方式：接口和实现都需要编写2. 代理开发方式：只需要编写Mapper接口    遵循以下规范        1. Mapper.xml文件中的namespace与mapper接口全限定名相同        2. Mapper接口方法名和Mapper.xml中定义的每个statement的id相同        3. Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType的类型相同        4. Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType类型相同    InputStream stream = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);    SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(stream);    SqlSession sqlSession = factory.openSession();    UserMapper mapper = sqlSession.getMapper(UserMapper.class);    通过接口来执行方法</code></pre><h4 id="MyBatis映射文件深入"><a href="#MyBatis映射文件深入" class="headerlink" title="MyBatis映射文件深入"></a>MyBatis映射文件深入</h4><pre><code>1. 动态sql语句    动态sql &lt;if&gt;    动态sql &lt;foreach&gt;2. sql片段抽取    将重复的sql片段进行抽取&lt;include&gt;和&lt;sql&gt;标签3. 小结    &lt;select&gt;&lt;insert&gt;&lt;update&gt;&lt;delete&gt; 增删改查    &lt;where&gt;&lt;if&gt;&lt;foreach&gt; if和foreach    &lt;sql&gt;&lt;include&gt; sql片段抽取</code></pre><h4 id="MyBatis核心配置文件深入"><a href="#MyBatis核心配置文件深入" class="headerlink" title="MyBatis核心配置文件深入"></a>MyBatis核心配置文件深入</h4><pre><code>1. typeHandler标签：类型处理器    可以重写或者自定义类型处理器，实现TypeHandler接口或继承BaseTypeHandler类    开发步骤        1. 定义转换类继承类BaseTypeHandler&lt;T&gt;        2. 覆盖四个未实现的方法，其中setNonNullParameter为java程序设置数据到数据库的回调方法，getNullableResult为查询时mysql的字符串类型转换成java的Type类型的方法        3. 在MyBatis核心配置文件中注册        4. 测试2. plugins标签：插件标签    分页助手插件 使用简单方式获得分页数据    还能获取相关的分页信息PageInfo&lt;User&gt; pageInfo = new PageInfo&lt;User&gt;(userList);    开发步骤        1. 导入统一PageHelper坐标        2. 在mybatis核心配置文件中进行配置        3. 测试分页数据获取</code></pre><h4 id="MyBatis的多表操作"><a href="#MyBatis的多表操作" class="headerlink" title="MyBatis的多表操作"></a>MyBatis的多表操作</h4><pre><code>1. 一对一查询    &lt;resultMap id=&quot;orderMap&quot; type=&quot;order&quot;&gt;        &lt;!--            手动指定字段与实体属性的映射关系                column: 字段名称                property: 属性名称        --&gt;        &lt;id column=&quot;oid&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;ordertime&quot; property=&quot;ordertime&quot;/&gt;        &lt;result column=&quot;total&quot; property=&quot;total&quot;/&gt;        &lt;!--&lt;result column=&quot;uid&quot; property=&quot;user.id&quot;/&gt;        &lt;result column=&quot;username&quot; property=&quot;user.username&quot;/&gt;        &lt;result column=&quot;password&quot; property=&quot;user.password&quot;/&gt;        &lt;result column=&quot;birthday&quot; property=&quot;user.birthday&quot;/&gt;--&gt;        &lt;!--            property: 指当前实体(order)属性 的名称(user)            javaType: 指当前实体(order)属性 的类型(User)        --&gt;        &lt;association property=&quot;user&quot; javaType=&quot;user&quot;&gt;            &lt;id column=&quot;uid&quot; property=&quot;id&quot;/&gt;            &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;            &lt;result column=&quot;password&quot; property=&quot;password&quot;/&gt;            &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;/&gt;        &lt;/association&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;findAll&quot; resultMap=&quot;orderMap&quot;&gt;        SELECT *, o.id oid FROM orders o, user u WHERE o.uid = u.id    &lt;/select&gt;2. 一对多查询    &lt;resultMap id=&quot;userMap&quot; type=&quot;user&quot;&gt;        &lt;id column=&quot;uid&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;        &lt;result column=&quot;password&quot; property=&quot;password&quot;/&gt;        &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;/&gt;        &lt;!--            配置集合属性                property: 集合名称                ofType: 集合中的数据类型        --&gt;        &lt;collection property=&quot;orderList&quot; ofType=&quot;order&quot; &gt;            &lt;!--封装order的数据--&gt;            &lt;id column=&quot;oid&quot; property=&quot;id&quot;/&gt;            &lt;result column=&quot;ordertime&quot; property=&quot;ordertime&quot;/&gt;            &lt;result column=&quot;total&quot; property=&quot;total&quot;/&gt;            &lt;!--&lt;association property=&quot;user&quot; javaType=&quot;user&quot;&gt;                &lt;id column=&quot;uid&quot; property=&quot;id&quot;/&gt;                &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;                &lt;result column=&quot;password&quot; property=&quot;password&quot;/&gt;                &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;/&gt;            &lt;/association&gt;--&gt;        &lt;/collection&gt;    &lt;/resultMap&gt;3. 多对多查询    和一对多类似 只有sql语句存在差别4. 知识小结    配置方式        一对一：&lt;resultMap&gt;        一对多：&lt;resultMap&gt;+&lt;collection&gt;        多对多：&lt;resultMap&gt;+&lt;collection&gt;</code></pre><h4 id="MyBatis注解开发"><a href="#MyBatis注解开发" class="headerlink" title="MyBatis注解开发"></a>MyBatis注解开发</h4><pre><code>1. MyBatis常用注解    * @Insert    * @Update    * @Delete    * @Select    * @Result：结果集封装    * @Results：多个结果集    * @One：实现一对一结果集封装    * @Many：实现一对多结果集封装2. 注解实现复杂映射开发    使用后四个注解完成复杂关系的配置    @Results =&gt; &lt;resultMap&gt;    @Result        * column        * property        * one        * many    @One =&gt; &lt;association&gt;        * select：指定多表查询的sqlmapper        @Result(column=&quot;&quot;, property=&quot;&quot;,one=@One(select=&quot;&quot;))    @Many =&gt; &lt;collection&gt;        * 指定子查询返回对象集合        @Result(column=&quot;&quot;, property=&quot;&quot;,many=@Many(select=&quot;&quot;))</code></pre><h3 id="SSM框架整合"><a href="#SSM框架整合" class="headerlink" title="SSM框架整合"></a>SSM框架整合</h3><pre><code>1. 原始方式整合2. Spring整合MyBatis    前半部分 将session工程将给Spring容器管理 从容器拿出mapper使用    后半部分 事务控制由Spring的声明式事务控制管理</code></pre><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><pre><code>1. Docker进程相关命令    * 启动 systemctl start docker    * 停止 systemctl stop docker    * 重启 systemctl restart docker    * 查看 systemctl status docker    * 设置开机启动 systemctl enable docker2. Docker镜像相关命令    * 查看镜像 docker images (-q) (-q查看所用镜像的id)    * 搜索镜像 docker search 镜像名称    * 拉取镜像 docker pull 镜像名称:镜像版本 # 可去dockerhub查看想要下载的版本    * 删除镜像         * docker rmi 镜像id(或者镜像名称)        * docker rmi `docker images -q`    # 删除所有镜像3. Docker容器相关命令    * 查看容器         * docker ps # 查看正在运行的容器        * docker ps -a # 查看所有容器    * 创建并启动容器 docker run 参数        * -i：保持容器运行。通常与 -t 同时使用。加入it这两个参数后，容器创建后自动进入容器中，exit退出容器后，容器自动关闭。        * -t：为容器重新分配一个伪输入终端，通常与 -i 同时使用。        * -d：以守护（后台）模式运行容器。创建一个容器在后台运行，需要使用docker exec 进入容器。退出后，容器不会关闭。        * -it 创建的容器一般称为交互式容器，-id 创建的容器一般称为守护式容器        * --name：为创建的容器命名。    * 进入容器 docker exe 参数        * 使用exit退出容器时 容器不会自动关闭    * 停止容器 docker stop 容器名称/容器id    * 启动容器 docker start 容器名称/容器id    * 删除容器 docker rm 容器名称/容器id    # 如果容器为运行状态 则无法删除    * 查看容器信息 docker inspect 容器名称4. 配置数据卷容器    * 创建启动c3数据卷容器，使用 –v 参数 设置数据卷        * docker run –it --name=c3 –v /volume ubuntu:16.04 /bin/bash     * 创建启动 c1 c2 容器，使用 –-volumes-from 参数 设置数据卷        * docker run –it --name=c1 --volumes-from c3 ubuntu:16.04 /bin/bash        * docker run –it --name=c2 --volumes-from c3 ubuntu:16.04 /bin/bash  </code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java自学总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django + Nginx + Uwsgi部署服务器</title>
      <link href="/2020/08/09/django+nginx+uwsgi%E9%83%A8%E7%BD%B2/"/>
      <url>/2020/08/09/django+nginx+uwsgi%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="Django-Nginx-Uwsgi部署服务器"><a href="#Django-Nginx-Uwsgi部署服务器" class="headerlink" title="Django + Nginx + Uwsgi部署服务器"></a>Django + Nginx + Uwsgi部署服务器</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>写这篇博客主要是为了记录一下自己部署的历程(太艰辛了)，同时也为了让其他人能够在看了本博文后能够少走弯路。希望这篇博文能够对大家有所帮助。</p><a id="more"></a><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>本人所使用的环境如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ubuntu 18.04.4(腾讯云服务器)</span><br><span class="line">python 3.6(服务器自带)</span><br><span class="line">mysql</span><br></pre></td></tr></table></figure><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>在上述环境的基础上进行部署django所需的环境的配置和搭建</p><p>首先是pip3的安装，这一步就不再赘述了。</p><p>然后是git的安装，直接<code>apt-get install git</code>就行了，主要是为了后面能够从github上clone源码。也可以通过<code>wget 项目地址.zip 下载地址</code>的方式下载项目zip包然后解压。 </p><p>然后是django所需环境的安装，可以通过虚拟环境的方式安装，也可以直接安装，因为本人是只用在服务器上部署这一个django项目，所以本人直接安装并没有通过虚拟环境，先导出requirements.txt然后在这里安装就可以了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><p>mysql的安装也不在这里说了，因为不是重点，大家度娘都能够解决。并且mysql的安装对部署的影响并不大。</p><p>然后则是uwsgi的安装了，uwsgi大家可以直接通过<code>pip install uwsgi</code>的方式完成安装，不过请确定是最新版，否则容易出现bug，安装完成后可以测试一下</p><p>首先在manage.py同一级目录下创建test.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(env, start_response)</span>:</span></span><br><span class="line">    start_response(<span class="string">'200 OK'</span>, [(<span class="string">'Content-Type'</span>,<span class="string">'text/html'</span>)])</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b"Hello World"</span></span><br></pre></td></tr></table></figure><p>然后运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsgi --http :8000 --wsgi-file test.py</span><br></pre></td></tr></table></figure><p>打开<code>&lt;公网ip:8000&gt;</code>看能否访问并看到hello world，如果能看到则没问题</p><p>然后是对nginx的安装，同理<code>apt-get install nginx</code>，安装完后，可以通过<code>service --status-all</code>查看niginx前面是否有+号，如果没问题，再访问<code>公网ip</code>，如果出现nginx的欢迎界面，则nginx安装成功</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>环境安装好了，接下来就是最重要的配置环节了。</p><p>首先是对uwsgi的配置，首先在manage.py同级目录下创建uwsgi.ini文件用于配置，配置内容如下</p><p>#对应是注释，复制的时候最好把中文删去，省去编码问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[uwsgi]</span><br><span class="line"># Django-related settings</span><br><span class="line">socket = 127.0.0.1:8888</span><br><span class="line"></span><br><span class="line"># the base directory (full path) 项目根地址 即manage.py所在目录</span><br><span class="line">chdir = /root/myblog</span><br><span class="line"></span><br><span class="line"># Django s wsgi file</span><br><span class="line">module = blog.wsgi:application</span><br><span class="line"></span><br><span class="line"># process-related settings</span><br><span class="line"># master 主进程</span><br><span class="line">master = true</span><br><span class="line"></span><br><span class="line"># maximum number of worker processes</span><br><span class="line">processes = 4</span><br><span class="line"># buffer-size 这个需要设置一下</span><br><span class="line">buffer-size = 30000</span><br><span class="line"># ... with appropriate permissions - may be needed</span><br><span class="line"># chmod-socket = 664</span><br><span class="line"># clear environment on exit</span><br><span class="line"># 日志文件</span><br><span class="line">daemonize = /root/myblog/mysite.log</span><br><span class="line">vacuum = true</span><br></pre></td></tr></table></figure><p>然后是对nginx的配置</p><p>首先了解一下nginx的配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">主配置文件：/etc/nginx/nginx.conf一般不用动</span><br><span class="line">可用配置文件：/etc/nginx/sites-available我们一般更改这里的配置文件</span><br><span class="line">已用配置文件：/etc/nginx/sites-enabled，已经启用的配置文件 我们在可用配置文件目录，新建一个xxx.conf此文件用于配置我们的项目。xxx可写自己的项目名称</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/nginx/sites-available</span><br><span class="line">vim xxx.conf</span><br><span class="line">// 如果不是root用户，可能需要先sudo创建文件然后chmod然后再进行vim修改</span><br></pre></td></tr></table></figure><p>然后在xxx.conf文件中写入以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">upstream django &#123;</span><br><span class="line">    server 127.0.0.1:8888; # for a web port socket (we&apos;ll use this first)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name 公网ip;</span><br><span class="line">    charset utf-8;</span><br><span class="line">    client_max_body_size 75M;  #上传文件大小限制</span><br><span class="line"></span><br><span class="line">    # 网站静态文件所在目录</span><br><span class="line">    location /static&#123;</span><br><span class="line">        alias /root/myblog/static;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    # 上传文件所在目录</span><br><span class="line">    location /media&#123;</span><br><span class="line">        alias /root/myblog/media;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    # 动态文件交给uwsgi处理</span><br><span class="line">    location / &#123;</span><br><span class="line">        uwsgi_pass 127.0.0.1:8888;</span><br><span class="line">        include /etc/nginx/uwsgi_params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将此文件再sites-enabled中创建一个软连接，表示此配置文件已经启用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /etc/nginx/sites-available/xxx.conf   /etc/nginx/sites-enabled/xxx.conf</span><br></pre></td></tr></table></figure><p>另外我们还需要将启动nginx的用户改为root，要不然会出现403 forbidden的错误。打开/etc/nginx/nginx.conf文件，将第一行中user后面的用户改为root即可。</p><p>然后需要对django进行一下小修改</p><p>首先是对settings.py中的debug改为false，allowed_host改为[‘*‘]或者[‘公网ip’]，这样才能访问到。</p><p>然后在最后加入<code>STATIC_ROOT = os.path.join(BASE_DIR,&#39;static&#39;)</code>，之后再进入项目执行<code>python3 manage.py collectstatic</code>执行之后就能看到项目中新增了一个static目录，这样nginx就能访问到了，才能正确加载项目的静态文件，否则访问的就是缺失css样式的项目</p><h2 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h2><p>然后就是将nginx重启服务并且将uwsgi启动的阶段了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo service nginx restart </span><br><span class="line">sudo uwsgi uwsgi.ini</span><br><span class="line">sudo killall -9 uwsgi</span><br></pre></td></tr></table></figure><p>第一行是nginx的重启，第二行则是启动uwsgi服务，最后一行是需要关闭uwsgi服务所需要执行的命令</p><p>启动uwsgi系统提示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[uWSGI] getting INI configuration from uwsgi.ini</span><br></pre></td></tr></table></figure><p>则代表启动成功了，现在就可以访问<code>公网ip:8000</code>访问你的项目了</p><p>如果出现问题，可查看uwsgi的日志文件，也就是前面所配置的<code>daemonize = /root/myblog/mysite.log</code>，从而帮助找到错误，进而解决。</p><h3 id="补充-前端部署"><a href="#补充-前端部署" class="headerlink" title="补充 前端部署"></a>补充 前端部署</h3><p>首先本地运行以下命令打包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>然后将生成的dist文件夹拷贝到服务器上的任意一个位置(下面配置)</p><p>然后将上文配置好的nginx的配置文件(<code>/etc/nginx/site-available/xxx.conf</code>)再次打开，再加入一个server即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;# 随意</span><br><span class="line">    server_name 公网ip;</span><br><span class="line">    root /root/django/dist;# 你自己放dist的路径</span><br><span class="line">    location / &#123;</span><br><span class="line">      try_files $uri $uri/ @router;</span><br><span class="line">      index index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">    location @router &#123;</span><br><span class="line">       rewrite ^.*$ /index.html last; # 防止刷新404</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后重启nginx服务即配置完毕(比后端好配置多了)</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>需要注意的点是，uwsgi的socket和nginx里的配置一定要一样，同时不要使用8000端口(不要问我怎么知道的)，上文使用的是8888端口，同时需要查看相应端口的防火墙是否已经打开，如果出现问题可以在服务器上通过<code>curl</code>进行本地访问测试。</p>]]></content>
      
      
      <categories>
          
          <category> 部署篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb</title>
      <link href="/2020/07/03/JavaWeb/"/>
      <url>/2020/07/03/JavaWeb/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaWeb"><a href="#JavaWeb" class="headerlink" title="JavaWeb"></a>JavaWeb</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><pre><code>主要用于记录JavaWeb的学习过程，希望对大家有所帮助。该学习是基于黑马的JavaWeb课程，感兴趣的盆友可以在b站搜索javaweb进行观看学习。</code></pre><a id="more"></a><h2 id="Day-01-内容"><a href="#Day-01-内容" class="headerlink" title="Day 01 内容"></a>Day 01 内容</h2><p><em>04/07/2020</em> </p><pre><code>* Junit单元测试* 反射* 注解</code></pre><h3 id="Junit单元测试："><a href="#Junit单元测试：" class="headerlink" title="Junit单元测试："></a>Junit单元测试：</h3><pre><code>* 测试分类：    * 黑盒测试：不需要写代码，给输入值，看程序能否输出期望值。            * 白盒测试：需要写代码。关注程序具体的执行流程。* Junit使用：白盒测试    * 步骤：        1. 定义一个测试类(测试用例)            * 建议：                * 测试类名：被测试的类名Test    calculatorTest                * 包名：xxx.xxx.xxx.test        2. 定义测试方法：可以独立运行            * 建议：                * 方法名：test测试的方法名    testadd                * 返回值：void                * 参数列表：空参        3. 给方法加@Test        4. 导入Junit依赖环境    * 判定结果：        * 红色：失败        * 绿色：成功        * 一般我们会使用断言操作来处理结果：            * Assert.assertEquals(期望的结果, 运算的结果);    * 补充        * @before：            * 修饰的方法会在测试方法之前被自动执行        * @after：            * 修饰的方法会在测试方法执行之后被自动执行</code></pre><h3 id="反射：框架设计的灵魂"><a href="#反射：框架设计的灵魂" class="headerlink" title="反射：框架设计的灵魂"></a>反射：框架设计的灵魂</h3><pre><code>* 框架：半成品软件。可以在框架的基础上进行软件开发，简化编码* 反射：将类的各个组成部分封装为其他对象，这就是反射机制    * 好处：        1. 可以在程序运行过程中，操作这些对象。        2. 可以解耦，提高程序的可扩展性* 获取Class对象的方式：    1. Class.forName(&quot;全类名&quot;); 将字节码文件加载进内存，返回Class对象        * 多用于配置文件，将类名定义在配置文件中。读取文件，加载类    2. 类名.class; 通过类名的属性class来获取        * 多用于参数的传递    3. 对象.getClass(); getClass()方法在Object类中定义        * 多用于对象的获取字节码的方式* 结论：同一个字节码文件(*.class)在一次程序的运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。* Class对象功能：    * 获取功能：        1. 获取成员变量们            * Field[] getFileds()            * Filed getFiled(String name)            * Field[] getDeclaredFileds()            * Filed getDeclaredFiled(String name)        2. 获取构造方法们            * Constructor&lt;?&gt;[] getConstructors()            * Constructor\&lt;?\&gt; getConstructor(类\&lt;?\&gt;... parameterTypes)            * Constructor&lt;?&gt;[] getDeclaredConstructors()            * Constructor\&lt;?\&gt; getDeclaredConstructor(类\&lt;?\&gt;... parameterTypes)        3. 获取成员方法们            * Method[] getMethods()            * Method getMethod(String name)            * Method[] getDeclaredMethods()            * Method getDeclaredMethod(String name)        4. 获取类名            * String getName()* Field：成员变量    * 操作：        1. 设置值            * void set(Object obj, Object value)        2. 获取值            * get(Object obj)        3. 忽略访问权限修饰符的安全检查            * setAccessible(true)：暴力反射* Constructor：构造方法    * 创建对象：        * T newInstance(Object... initargs)        * 如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法* Method：方法对象    * 执行方法：        * Object invoke(Object obj, Object... args)    * 获取方法名称：        * String getName()获取方法名* 案例：    * 需求：写一个&quot;框架&quot;，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法。    * 实现：        1. 配置文件        2. 反射    * 步骤：        1. 将需要创建的对象的全类名和需要执行的方法定义在配置文件中        2. 在程序中去加载读取配置文件        3. 使用反射技术来加载类文件进内存        4. 创建对象        5. 执行方法</code></pre><h3 id="注解："><a href="#注解：" class="headerlink" title="注解："></a>注解：</h3><pre><code>* 概念：说明程序的。给计算机看的。* 注释：用文字描述程序。给程序员看的。* 概念描述：    * jdk1.5之后的新特性    * 说明程序的    * 使用注解：@注解名称* 作用分类    * 编写文档：生成文档【doc文档】    * 代码分析：通过注解对代码进行分析【使用反射】    * 编译检查：让编辑器能实现基本的编译检查【@Override】* JDK中预定义的一些注解    * @Override：检测被该注解标注的方法是否是继承自父类(接口)的    * @Deprecated：将该注解标注的内容，表示已过时    * @SuppressWarnings：压制警告        * 一般传递参数all    @SuppressWarnings(&quot;all&quot;)* 自定义注解    * 格式：        * 元注解        * public @interface 注解名称() {            属性列表;        }    * 本质：注解本质上就是一个接口，该接口默认继承Annotation        * public interface 注解名称 extends java.lang.annotation.Annotation {}    * 属性：接口中的抽象方法        * 要求：            1. 属性的返回值类型有下列取值：                * 基本数据类型                * String                * 枚举                * 注解                * 以上类型的数组            2. 定义了属性，在使用时需要给属性赋值                1. 如果定义属性时，使用default关键字给属性默认初始值，则使用注解时可以不进行属性的赋值                2. 如果只有一个属性需要赋值，并且属性的名称为value，则value可以省略，直接定义值即可【@SuppressWarnings】                3. 数组赋值时，值使用{}包裹，如果数组中只有一个值，则{}可以省略* 元注解：用于描述注解的注解    * @Target：描述注解能够作用的位置        * ElementType取值：        * TYPE：可以作用于类上        * METHOD：可以作用于方法上        * FIELD：可以作用于成员变量上    * @Retention：描述注解被保留的一个阶段        * @Rentention(RententionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到    * @Documented：描述注解是否被抽取到api文档中    * @Inherited：描述注解是否被子类继承* 在程序中使用(解析)注解：获取注解中定义的属性值    1. 获取注解定义的位置的对象    【Class，Method，Field】    2. 获取指定的注解        * getAnnotation(Class)        * public class ProImpl implements Pro{              public String className(){                  return &quot;day01.annotation.Demo1&quot;;              }              public String methodName(){                  return &quot;show&quot;;              }          }    3. 调用注解中的抽象方法，获取配置的属性值* 小结    1. 以后大多数时候，我们会使用注解，而不是自定义注解    2. 注解给谁用？        1. 编译器        2. 给解析程序用    3. 注解不是程序的一部分，可以理解为注解就是一个标签</code></pre><hr><h2 id="Day-02-内容"><a href="#Day-02-内容" class="headerlink" title="Day 02 内容"></a>Day 02 内容</h2><p><em>05/07/2020</em></p><pre><code>* 数据库的基本概念* MySQL数据库软件    * 安装    * 卸载    * 配置* SQL</code></pre><h3 id="数据库的基本概念"><a href="#数据库的基本概念" class="headerlink" title="数据库的基本概念"></a>数据库的基本概念</h3><pre><code>1. 数据库的英文单词：DataBase 简称 ： DB2. 什么是数据库？    * 用于存储和管理数据的仓库。3. 数据库的特点：    1. 持久化存储数据的。其实数据库就是一个文件系统    2. 方便存储和管理数据    3. 使用了统一的方式来操作数据库 -- SQL4. 常见的数据库软件        * 参见《MySQL基础.pdf》</code></pre><h3 id="MySQL数据库软件"><a href="#MySQL数据库软件" class="headerlink" title="MySQL数据库软件"></a>MySQL数据库软件</h3><pre><code>1. 安装    * 参见《MySQL基础.pdf》2. 卸载    1. 去mysql的安装目录找到my.ini文件        * 复制 datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data&quot;    2. 卸载MySQL    3. 删除C:/ProgramData目录下的MySQL文件夹。3. 配置    * MySQL服务启动        1. 手动        2. cmd--&gt; services.msc 打开服务的窗口        3. 使用管理员打开cmd            * net start mysql ：启动mysql的服务            * net stop mysql ：关闭mysql的服务    * MySQL登录        1. mysql -uroot -p【password】        2. mysql -h【ip】 -uroot -p【连接目标的password】        3. mysql --host=【ip】 --user=root --password=【密码】    * MySQL退出        1. exit        2. quit    * MySQL目录结构        1. MySQL安装目录            * 配置文件 my.ini        2. MySQL数据目录            * 几个概念                * 数据库：文件夹                * 表：文件                * 数据：数据</code></pre><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><pre><code>1. 什么是SQL?    Structured Query Language：结构化编程语言    其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为&quot;方言&quot;2. SQL通用语法    1. SQL语句可以单行或多行书写，以分号结尾。    2. 可使用空格和缩进来增强语句的可读性。    3. MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。    4. 3种注释        * 单行注释：-- 注释内容 或 # 注释内容(mysql 特有)        * 多行注释：/* 注释 */3. SQL分类    1) DDL(Data Definition Language)数据定义语言用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等    2) DML(Data Manipulation Language)数据操作语言用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等    3) DQL(Data Query Language)数据查询语言用来查询数据库中表的记录(数据)。关键字：select, where 等    4) DCL(Data Control Language)数据控制语言(了解)用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等</code></pre><h3 id="DDL：操作数据库、表"><a href="#DDL：操作数据库、表" class="headerlink" title="DDL：操作数据库、表"></a>DDL：操作数据库、表</h3><pre><code>1. 操作数据库：CRUD    1. C(Create):创建        * 创建数据库：            * create database 数据库名称;        * 创建数据库，判断不存在，再创建：            * create database if not exists 数据库名称;        * 创建数据库，并指定字符集            * create database 数据库名称 character set 字符集名;        * 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk            * create database if not exists db4 character set gbk;    2. R(Retrieve)：查询        * 查询所有数据库的名称:            * show databases;        * 查询某个数据库的字符集:查询某个数据库的创建语句            * show create database 数据库名称;    3. U(Update):修改        * 修改数据库的字符集            * alter database 数据库名称 character set 字符集名称;    4. D(Delete):删除        * 删除数据库            * drop database 数据库名称;        * 判断数据库存在，存在再删除            * drop database if exists 数据库名称;    5. 使用数据库        * 查询当前正在使用的数据库名称            * select database();        * 使用数据库            * use 数据库名称;2. 操作表    1. C(Create):创建        1. 语法：            create table 表名(                列名1 数据类型1,                列名2 数据类型2,                ....                列名n 数据类型n            );            * 注意：最后一列，不需要加逗号（,）            * 数据库类型：                 1. int：整数类型                    * age int,                2. double:小数类型                    * score double(5,2)                3. date:日期，只包含年月日，yyyy-MM-dd                4. datetime:日期，包含年月日时分秒     yyyy-MM-dd HH:mm:ss                5. timestamp:时间戳类型    包含年月日时分秒     yyyy-MM-dd HH:mm:ss                        * 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值                6. varchar：字符串                    * name varchar(20):姓名最大20个字符                    * zhangsan 8个字符  张三 2个字符         * 创建表：            create table student(                id int,                name varchar(32),                age int ,                score double(4,1),                birthday date,                insert_time timestamp            );        * 复制表：            * create table 表名 like 被复制的表名;              2. R(Retrieve)：查询        * 查询某个数据库中所有的表名称            * show tables;        * 查询表结构            * desc 表名;    3. U(Update):修改        1. 修改表名            alter table 表名 rename to 新的表名;        2. 修改表的字符集            alter table 表名 character set 字符集名称;        3. 添加一列            alter table 表名 add 列名 数据类型;        4. 修改列名称 类型            alter table 表名 change 列名 新列别 新数据类型;            alter table 表名 modify 列名 新数据类型;        5. 删除列            alter table 表名 drop 列名;    4. D(Delete):删除        * drop table 表名;        * drop table if exists 表名 ;                    </code></pre><ul><li>客户端图形化工具：SQLYog</li></ul><pre><code>1. 添加数据：    * 语法：        * insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n);    * 注意：        1. 列名和值要一一对应。        2. 如果表名后，不定义列名，则默认给所有列添加值            insert into 表名 values(值1,值2,...值n);        3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来2. 删除数据：    * 语法：        * delete from 表名 [where 条件]    * 注意：        1. 如果不加条件，则删除表中所有记录。        2. 如果要删除所有记录            1. delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作            2. TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。3. 修改数据：    * 语法：        * update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件];    * 注意：        1. 如果不加任何条件，则会将表中所有记录全部修改。</code></pre><hr><h2 id="Day-03-内容"><a href="#Day-03-内容" class="headerlink" title="Day 03 内容"></a>Day 03 内容</h2><p><em>06/07/2020</em></p><pre><code>1. DQL:查询语句    1. 排序查询    2. 聚合函数    3. 分组查询    4. 分页查询2. 约束3. 多表之间的关系4. 范式5. 数据库的备份和还原</code></pre><h3 id="DQL-查询语句"><a href="#DQL-查询语句" class="headerlink" title="DQL:查询语句"></a>DQL:查询语句</h3><h3 id="DQL：查询表中的记录"><a href="#DQL：查询表中的记录" class="headerlink" title="DQL：查询表中的记录"></a>DQL：查询表中的记录</h3><pre><code>* select * from 表名;1. 语法：    select         字段列表    from        表名列表    where        条件列表    group by        分组字段    having        分组之后的条件    order by        排序    limit        分页限定2. 基础查询    1. 多个字段的查询        select 字段名1，字段名2... from 表名;        * 注意：            * 如果查询所有字段，则可以使用*来替代字段列表。    2. 去除重复：        * distinct    3. 计算列        * 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）        * ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null            * 表达式1：哪个字段需要判断是否为null            * 表达式2：如果该字段为null后的替换值。    4. 起别名：        * as：as也可以省略3. 条件查询    1. where子句后跟条件    2. 运算符        * &gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt;        * BETWEEN...AND          * IN( 集合)         * LIKE：模糊查询            * 占位符：                * _:单个任意字符                * %：多个任意字符        * IS NULL          * and  或 &amp;&amp;        * or  或 ||         * not  或 !            -- 查询年龄大于20岁            SELECT * FROM student WHERE age &gt; 20;            SELECT * FROM student WHERE age &gt;= 20;            -- 查询年龄等于20岁            SELECT * FROM student WHERE age = 20;            -- 查询年龄不等于20岁            SELECT * FROM student WHERE age != 20;            SELECT * FROM student WHERE age &lt;&gt; 20;            -- 查询年龄大于等于20 小于等于30            SELECT * FROM student WHERE age &gt;= 20 &amp;&amp;  age &lt;=30;            SELECT * FROM student WHERE age &gt;= 20 AND  age &lt;=30;            SELECT * FROM student WHERE age BETWEEN 20 AND 30;            -- 查询年龄22岁，18岁，25岁的信息            SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25            SELECT * FROM student WHERE age IN (22,18,25);            -- 查询英语成绩为null            SELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = （!=） 判断            SELECT * FROM student WHERE english IS NULL;            -- 查询英语成绩不为null            SELECT * FROM student WHERE english  IS NOT NULL;            -- 查询姓马的有哪些？ like            SELECT * FROM student WHERE NAME LIKE &apos;马%&apos;;            -- 查询姓名第二个字是化的人            SELECT * FROM student WHERE NAME LIKE &quot;_化%&quot;;            -- 查询姓名是3个字的人            SELECT * FROM student WHERE NAME LIKE &apos;___&apos;;            -- 查询姓名中包含德的人            SELECT * FROM student WHERE NAME LIKE &apos;%德%&apos;;</code></pre><p>中间的部分内容在这里没有给出，因为本人这部分内容已经掌握，所以未给出。</p><h3 id="今日内容"><a href="#今日内容" class="headerlink" title="今日内容"></a>今日内容</h3><pre><code>1. 多表查询2. 事务3. DCL</code></pre><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><pre><code>* 查询语法：    select        列名列表    from        表名列表    where....* 准备sql    # 创建部门表    CREATE TABLE dept(        id INT PRIMARY KEY AUTO_INCREMENT,        NAME VARCHAR(20)    );    INSERT INTO dept (NAME) VALUES (&apos;开发部&apos;),(&apos;市场部&apos;),(&apos;财务部&apos;);    # 创建员工表    CREATE TABLE emp (        id INT PRIMARY KEY AUTO_INCREMENT,        NAME VARCHAR(10),        gender CHAR(1), -- 性别        salary DOUBLE, -- 工资        join_date DATE, -- 入职日期        dept_id INT,        FOREIGN KEY (dept_id) REFERENCES dept(id) -- 外键，关联部门表(部门表的主键)    );    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&apos;孙悟空&apos;,&apos;男&apos;,7200,&apos;2013-02-24&apos;,1);    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&apos;猪八戒&apos;,&apos;男&apos;,3600,&apos;2010-12-02&apos;,2);    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&apos;唐僧&apos;,&apos;男&apos;,9000,&apos;2008-08-08&apos;,2);    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&apos;白骨精&apos;,&apos;女&apos;,5000,&apos;2015-10-07&apos;,3);    INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&apos;蜘蛛精&apos;,&apos;女&apos;,4500,&apos;2011-03-14&apos;,1);* 笛卡尔积：    * 有两个集合A,B .取这两个集合的所有组成情况。    * 要完成多表查询，需要消除无用的数据* 多表查询的分类：    1. 内连接查询：        1. 隐式内连接：使用where条件消除无用数据            * 例子：            -- 查询所有员工信息和对应的部门信息            SELECT * FROM emp,dept WHERE emp.`dept_id` = dept.`id`;            -- 查询员工表的名称，性别。部门表的名称            SELECT emp.name,emp.gender,dept.name FROM emp,dept WHERE emp.`dept_id` = dept.`id`;            SELECT                 t1.name, -- 员工表的姓名                t1.gender,-- 员工表的性别                t2.name -- 部门表的名称            FROM                emp t1,                dept t2            WHERE                 t1.`dept_id` = t2.`id`;        2. 显式内连接：            * 语法： select 字段列表 from 表名1 [inner] join 表名2 on 条件            * 例如：                * SELECT * FROM emp INNER JOIN dept ON emp.`dept_id` = dept.`id`;                    * SELECT * FROM emp JOIN dept ON emp.`dept_id` = dept.`id`;            3. 内连接查询：            1. 从哪些表中查询数据            2. 条件是什么            3. 查询哪些字段    2. 外链接查询：        1. 左外连接：            * 语法：select 字段列表 from 表1 left [outer] join 表2 on 条件；            * 查询的是左表所有数据以及其交集部分。            * 例子：                -- 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称                SELECT     t1.*,t2.`name` FROM emp t1 LEFT JOIN dept t2 ON t1.`dept_id` = t2.`id`;        2. 右外连接：            * 语法：select 字段列表 from 表1 right [outer] join 表2 on 条件；            * 查询的是右表所有数据以及其交集部分。            * 例子：                SELECT     * FROM dept t2 RIGHT JOIN emp t1 ON t1.`dept_id` = t2.`id`;    3. 子查询：        * 概念：查询中嵌套查询，称嵌套查询为子查询。            -- 查询工资最高的员工信息            -- 1 查询最高的工资是多少 9000            SELECT MAX(salary) FROM emp;            -- 2 查询员工信息，并且工资等于9000的            SELECT * FROM emp WHERE emp.`salary` = 9000;            -- 一条sql就完成这个操作。子查询            SELECT * FROM emp WHERE emp.`salary` = (SELECT MAX(salary) FROM emp);        * 子查询不同情况            1. 子查询的结果是单行单列的：                * 子查询可以作为条件，使用运算符去判断。 运算符： &gt; &gt;= &lt; &lt;= =                *                 -- 查询员工工资小于平均工资的人                SELECT * FROM emp WHERE emp.salary &lt; (SELECT AVG(salary) FROM emp);            2. 子查询的结果是多行单列的：                * 子查询可以作为条件，使用运算符in来判断                -- 查询&apos;财务部&apos;和&apos;市场部&apos;所有的员工信息                SELECT id FROM dept WHERE NAME = &apos;财务部&apos; OR NAME = &apos;市场部&apos;;                SELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2;                -- 子查询                SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME = &apos;财务部&apos; OR NAME = &apos;市场部&apos;);            3. 子查询的结果是多行多列的：                * 子查询可以作为一张虚拟表参与查询                -- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息                -- 子查询                SELECT * FROM dept t1 ,(SELECT * FROM emp WHERE emp.`join_date` &gt; &apos;2011-11-11&apos;) t2                WHERE t1.id = t2.dept_id;                -- 普通内连接                SELECT * FROM emp t1,dept t2 WHERE t1.`dept_id` = t2.`id` AND t1.`join_date` &gt;  &apos;2011-11-11&apos;    * 多表查询练习            -- 部门表            CREATE TABLE dept (              id INT PRIMARY KEY PRIMARY KEY, -- 部门id              dname VARCHAR(50), -- 部门名称              loc VARCHAR(50) -- 部门所在地            );            -- 添加4个部门            INSERT INTO dept(id,dname,loc) VALUES             (10,&apos;教研部&apos;,&apos;北京&apos;),            (20,&apos;学工部&apos;,&apos;上海&apos;),            (30,&apos;销售部&apos;,&apos;广州&apos;),            (40,&apos;财务部&apos;,&apos;深圳&apos;);            -- 职务表，职务名称，职务描述            CREATE TABLE job (              id INT PRIMARY KEY,              jname VARCHAR(20),              description VARCHAR(50)            );            -- 添加4个职务            INSERT INTO job (id, jname, description) VALUES            (1, &apos;董事长&apos;, &apos;管理整个公司，接单&apos;),            (2, &apos;经理&apos;, &apos;管理部门员工&apos;),            (3, &apos;销售员&apos;, &apos;向客人推销产品&apos;),            (4, &apos;文员&apos;, &apos;使用办公软件&apos;);            -- 员工表            CREATE TABLE emp (              id INT PRIMARY KEY, -- 员工id              ename VARCHAR(50), -- 员工姓名              job_id INT, -- 职务id              mgr INT , -- 上级领导              joindate DATE, -- 入职日期              salary DECIMAL(7,2), -- 工资              bonus DECIMAL(7,2), -- 奖金              dept_id INT, -- 所在部门编号              CONSTRAINT emp_jobid_ref_job_id_fk FOREIGN KEY (job_id) REFERENCES job (id),              CONSTRAINT emp_deptid_ref_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept (id)            );            -- 添加员工            INSERT INTO emp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id) VALUES             (1001,&apos;孙悟空&apos;,4,1004,&apos;2000-12-17&apos;,&apos;8000.00&apos;,NULL,20),            (1002,&apos;卢俊义&apos;,3,1006,&apos;2001-02-20&apos;,&apos;16000.00&apos;,&apos;3000.00&apos;,30),            (1003,&apos;林冲&apos;,3,1006,&apos;2001-02-22&apos;,&apos;12500.00&apos;,&apos;5000.00&apos;,30),            (1004,&apos;唐僧&apos;,2,1009,&apos;2001-04-02&apos;,&apos;29750.00&apos;,NULL,20),            (1005,&apos;李逵&apos;,4,1006,&apos;2001-09-28&apos;,&apos;12500.00&apos;,&apos;14000.00&apos;,30),            (1006,&apos;宋江&apos;,2,1009,&apos;2001-05-01&apos;,&apos;28500.00&apos;,NULL,30),            (1007,&apos;刘备&apos;,2,1009,&apos;2001-09-01&apos;,&apos;24500.00&apos;,NULL,10),            (1008,&apos;猪八戒&apos;,4,1004,&apos;2007-04-19&apos;,&apos;30000.00&apos;,NULL,20),            (1009,&apos;罗贯中&apos;,1,NULL,&apos;2001-11-17&apos;,&apos;50000.00&apos;,NULL,10),            (1010,&apos;吴用&apos;,3,1006,&apos;2001-09-08&apos;,&apos;15000.00&apos;,&apos;0.00&apos;,30),            (1011,&apos;沙僧&apos;,4,1004,&apos;2007-05-23&apos;,&apos;11000.00&apos;,NULL,20),            (1012,&apos;李逵&apos;,4,1006,&apos;2001-12-03&apos;,&apos;9500.00&apos;,NULL,30),            (1013,&apos;小白龙&apos;,4,1004,&apos;2001-12-03&apos;,&apos;30000.00&apos;,NULL,20),            (1014,&apos;关羽&apos;,4,1007,&apos;2002-01-23&apos;,&apos;13000.00&apos;,NULL,10);            -- 工资等级表            CREATE TABLE salarygrade (              grade INT PRIMARY KEY,   -- 级别              losalary INT,  -- 最低工资              hisalary INT -- 最高工资            );            -- 添加5个工资等级            INSERT INTO salarygrade(grade,losalary,hisalary) VALUES             (1,7000,12000),            (2,12010,14000),            (3,14010,20000),            (4,20010,30000),            (5,30010,99990);            -- 需求：            -- 1.查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述            /*                分析：                    1.员工编号，员工姓名，工资，需要查询emp表  职务名称，职务描述 需要查询job表                    2.查询条件 emp.job_id = job.id            */            SELECT                 t1.`id`, -- 员工编号                t1.`ename`, -- 员工姓名                t1.`salary`,-- 工资                t2.`jname`, -- 职务名称                t2.`description` -- 职务描述            FROM                 emp t1, job t2            WHERE                 t1.`job_id` = t2.`id`;            -- 2.查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置            /*                分析：                    1. 员工编号，员工姓名，工资 emp  职务名称，职务描述 job  部门名称，部门位置 dept                    2. 条件： emp.job_id = job.id and emp.dept_id = dept.id            */            SELECT                 t1.`id`, -- 员工编号                t1.`ename`, -- 员工姓名                t1.`salary`,-- 工资                t2.`jname`, -- 职务名称                t2.`description`, -- 职务描述                t3.`dname`, -- 部门名称                t3.`loc` -- 部门位置            FROM                 emp t1, job t2,dept t3            WHERE                 t1.`job_id` = t2.`id` AND t1.`dept_id` = t3.`id`;            -- 3.查询员工姓名，工资，工资等级            /*                分析：                    1.员工姓名，工资 emp  工资等级 salarygrade                    2.条件 emp.salary &gt;= salarygrade.losalary and emp.salary &lt;= salarygrade.hisalary                        emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary            */            SELECT                 t1.ename ,                t1.`salary`,                t2.*            FROM emp t1, salarygrade t2            WHERE t1.`salary` BETWEEN t2.`losalary` AND t2.`hisalary`;            -- 4.查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级            /*                分析：                    1. 员工姓名，工资 emp ， 职务名称，职务描述 job 部门名称，部门位置，dept  工资等级 salarygrade                    2. 条件： emp.job_id = job.id and emp.dept_id = dept.id and emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary            */            SELECT                 t1.`ename`,                t1.`salary`,                t2.`jname`,                t2.`description`,                t3.`dname`,                t3.`loc`,                t4.`grade`            FROM                 emp t1,job t2,dept t3,salarygrade t4            WHERE                 t1.`job_id` = t2.`id`                 AND t1.`dept_id` = t3.`id`                AND t1.`salary` BETWEEN t4.`losalary` AND t4.`hisalary`;            -- 5.查询出部门编号、部门名称、部门位置、部门人数            /*                分析：                    1.部门编号、部门名称、部门位置 dept 表。 部门人数 emp表                    2.使用分组查询。按照emp.dept_id完成分组，查询count(id)                    3.使用子查询将第2步的查询结果和dept表进行关联查询            */            SELECT                 t1.`id`,t1.`dname`,t1.`loc` , t2.total            FROM                 dept t1,                (SELECT                    dept_id,COUNT(id) total                FROM                     emp                GROUP BY dept_id) t2            WHERE t1.`id` = t2.dept_id;            -- 6.查询所有员工的姓名及其直接上级的姓名,没有领导的员工也需要查询            /*                分析：                    1.姓名 emp， 直接上级的姓名 emp                        * emp表的id 和 mgr 是自关联                    2.条件 emp.id = emp.mgr                    3.查询左表的所有数据，和 交集数据                        * 使用左外连接查询            */            /*            select                t1.ename,                t1.mgr,                t2.`id`,                t2.ename            from emp t1, emp t2            where t1.mgr = t2.`id`;            */            SELECT                 t1.ename,                t1.mgr,                t2.`id`,                t2.`ename`            FROM emp t1            LEFT JOIN emp t2            ON t1.`mgr` = t2.`id`;</code></pre><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><pre><code>1. 事务的基本介绍    1. 概念：        * 如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败    2. 操作：        1. 开启事务：start transection        2. 回滚：rollback        3. 提交：commit    3. MySQL数据库中事务默认提交        * 事务提交的两种方式：            * 自动提交：                * mysql就是自动提交的                * 一条DML(增删改)语句会自动提交一次事务。            * 手动提交：                * Oracle数据库默认是手动提交事务                * 需要先开启事务，再提交        * 修改事务的默认提交方式：            * 查看事务的默认提交方式：SELECT @@autocommit; -- 1 代表自动提交  0 代表手动提交            * 修改默认提交方式： set @@autocommit = 0;2. 事务的四大特征    1. 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。    2. 持久性：当事务提交或回滚后，数据库会持久化的保存数据。    3. 隔离性：多个事务之间。相互独立。    4. 一致性：事务操作前后，数据总量不变3. 事务的隔离级别（了解）    * 概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。    * 存在问题：        1. 脏读：一个事务，读取到另一个事务中没有提交的数据        2. 不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。        3. 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。    * 隔离级别：        1. read uncommitted：读未提交            * 产生的问题：脏读、不可重复读、幻读        2. read committed：读已提交 （Oracle）            * 产生的问题：不可重复读、幻读        3. repeatable read：可重复读 （MySQL默认）            * 产生的问题：幻读        4. serializable：串行化            * 可以解决所有的问题        * 注意：隔离级别从小到大安全性越来越高，但是效率越来越低        * 数据库查询隔离级别：            * select @@tx_isolation;        * 数据库设置隔离级别：            * set global transaction isolation level  级别字符串;    * 演示：        set global transaction isolation level read uncommitted;        start transaction;        -- 转账操作        update account set balance = balance - 500 where id = 1;        update account set balance = balance + 500 where id = 2;</code></pre><h3 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h3><pre><code>* SQL分类：    1. DDL：操作数据库和表    2. DML：增删改表中数据    3. DQL：查询表中数据    4. DCL：管理用户，授权* DBA：数据库管理员* DCL：管理用户，授权    1. 管理用户        1. 添加用户：            * 语法：CREATE USER &apos;用户名&apos;@&apos;主机名&apos; IDENTIFIED BY &apos;密码&apos;;        2. 删除用户：            * 语法：DROP USER &apos;用户名&apos;@&apos;主机名&apos;;        3. 修改用户密码：            UPDATE USER SET PASSWORD = PASSWORD(&apos;新密码&apos;) WHERE USER = &apos;用户名&apos;;            UPDATE USER SET PASSWORD = PASSWORD(&apos;abc&apos;) WHERE USER = &apos;lisi&apos;;            SET PASSWORD FOR &apos;用户名&apos;@&apos;主机名&apos; = PASSWORD(&apos;新密码&apos;);            SET PASSWORD FOR &apos;root&apos;@&apos;localhost&apos; = PASSWORD(&apos;123&apos;);            * mysql中忘记了root用户的密码？                1. cmd -- &gt; net stop mysql 停止mysql服务                    * 需要管理员运行该cmd                2. 使用无验证方式启动mysql服务： mysqld --skip-grant-tables                3. 打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功                4. use mysql;                5. update user set password = password(&apos;你的新密码&apos;) where user = &apos;root&apos;;                6. 关闭两个窗口                7. 打开任务管理器，手动结束mysqld.exe 的进程                8. 启动mysql服务                9. 使用新密码登录。        4. 查询用户：            -- 1. 切换到mysql数据库            USE myql;            -- 2. 查询user表            SELECT * FROM USER;            * 通配符： % 表示可以在任意主机使用用户登录数据库    2. 权限管理：        1. 查询权限：            -- 查询权限            SHOW GRANTS FOR &apos;用户名&apos;@&apos;主机名&apos;;            SHOW GRANTS FOR &apos;lisi&apos;@&apos;%&apos;;        2. 授予权限：            -- 授予权限            grant 权限列表 on 数据库名.表名 to &apos;用户名&apos;@&apos;主机名&apos;;            -- 给张三用户授予所有权限，在任意数据库任意表上            GRANT ALL ON *.* TO &apos;zhangsan&apos;@&apos;localhost&apos;;        3. 撤销权限：            -- 撤销权限：            revoke 权限列表 on 数据库名.表名 from &apos;用户名&apos;@&apos;主机名&apos;;            REVOKE UPDATE ON db3.`account` FROM &apos;lisi&apos;@&apos;%&apos;;</code></pre><h2 id="Day-04-内容："><a href="#Day-04-内容：" class="headerlink" title="Day 04 内容："></a>Day 04 内容：</h2><p><em>07/07/2020</em></p><pre><code>1. JDBC基本概念2. 快速入门3. 对JDBC中各个接口和类详解</code></pre><h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><pre><code>1. 概念：Java DataBase Connectivity    Java数据库连接，Java语言操作数据库    * JDBC本质：其实是官网(sun公司)定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商可以去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口(JDBC)编程，真正执行的代码是驱动jar包中的实现类2. 快速入门：    * 步骤：        1. 导入驱动jar包 mysql-connnector-java-x.x.x-bin.jar            1. 复制mysql-connnector-java-x.x.x-bin.jar包到项目libs目录下            2. 右键--&gt;Add as library        2. 注册驱动        3. 获取数据库的连接对象 Connection        4. 定义sql        5. 获取执行sql语句的对象 Statement        6. 执行sql，接收返回结果        7. 处理结果        8. 释放资源    * 代码实现：        // 1.导入驱动jar包        // 2.注册驱动        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);        // 3.获取数据库连接对象        Connection connection = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db1&quot;,                &quot;root&quot;, &quot;********&quot;);        // 4.定义sql语句        String sql = &quot;insert into test values(1, \&quot;test\&quot;)&quot;;        // 5.获取执行sql的对象Statement        Statement statement = connection.createStatement();        // 6.执行sql        int count = statement.executeUpdate(sql);        // 7.处理结果        System.out.println(count);        // 8.释放资源        statement.close();        connection.close();3. 详解各个对象    1. DriverManager: 驱动管理对象        * 功能：            1. 注册驱动：告诉程序该使用哪一个数据库驱动jar包                static void registerDriver(Driver driver): 注册给定的驱动程序 DriverManager                写代码使用: Class.forName(&quot;com.mysql.jdbc.Driver&quot;);                通过查看源码发现: 在com.mysql.jdbc.Driver类中存在静态代码块                static {                    try {                        DriverManager.registerDriver(new Driver());                    } catch (SQLException var1) {                        throw new RuntimeException(&quot;Can&apos;t register driver!&quot;);                    }                }                注意：mysql5之后的驱动jar包可以省略注册驱动的步骤            2. 获取数据库连接：                * 方法: static Connerction getConnection(String url, String user, String password)                * 参数：                    * url：指定连接的路径                        * 语法: jdbc:mysql://ip地址(域名):端口号/数据库名称                        * 例子: jdbc:mysql://localhost:3306/db1                        * 细节: 如果连接的是本机mysql服务器，并且mysql服务默认端口为3306，则url可以简写为jdbc:mysql:///数据库名称                    * user：用户名                    * password：密码    2. Connection: 数据库连接对象        1. 功能：            1. 获取执行sql的对象                * Statement createStatement()                * PreparedStatement prepareStatement(String sql)            2。 管理事务：                * 开启事务: void setAutoCommit(boolean autoCommit)    : 调用该方法设置参数为false，即开启事务                * 提交事务: void commit()                * 回滚事务: void rollback()    3. Statement: 执行sql的对象        1. 执行sql            1. booleann execute(String sql) : 可以执行任意的sql 了解            2. int executeUpdate(String sql) : 执行DML(insert、update、delete)语句、DDL(create、alter、drop)语句                * 返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0执行成功 反之失败            3. ResultSet executeQuery(String sql) : 执行DQL(select)语句        2. 练习：            1. account表 添加一条记录            2. account表 修改记录            3. account表 删除一条记录            代码:                Connection connection = null;                Statement statement = null;                try {                    // 1.注册驱动                    Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);                    // 2.定义sql                    String sql = &quot;insert into account values(null, &apos;王五&apos;, 3000)&quot;;                    // 3.获取Connection对象                    connection= DriverManager.getConnection(&quot;jdbc:mysql:///db1&quot;,                            &quot;root&quot;, &quot;******&quot;);                    // 4.获取执行sql的对象                    statement = connection.createStatement();                    // 5.执行sql                    int count = statement.executeUpdate(sql);                    // 6.处理结果                    System.out.println(count);                    if(count &gt; 0){                        System.out.println(&quot;添加成功&quot;);                    }else{                        System.out.println(&quot;添加失败&quot;);                    }                } catch (ClassNotFoundException | SQLException e) {                    e.printStackTrace();                } finally {                    // 避免空指针异常                    if(statement != null){                        try {                            statement.close();                        } catch (SQLException throwables) {                            throwables.printStackTrace();                        }                    }                    if(connection != null){                        try {                            connection.close();                        } catch (SQLException throwables) {                            throwables.printStackTrace();                        }                    }                }    4. ResultSet: 结果集对象，封装查询结果        * next()：游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，返回boolean值        * getXxx(参数)：获取数据            * Xxx代表数据类型    如: int getInt()            * 参数：                1. int: 代表列的编号，从1开始                2. String: 代表列名称        * 注意：            * 使用步骤：                1. 游标向下移动一行                2. 判断是否有数据                3. 获取数据            while(rs.next()){...}        * 练习：            * 定义一个方法，查询emp表的数据将其封装为对象，然后装载集合，返回。                1. 定义Emp类                2. 定义方法 public List&lt;Emp&gt; findAll(){}                3. 实现方法 select * from emp;    5. PreparedStatement: 执行sql的对象        1. SQL注入问题: 在拼接SQL时，有一些sql的特殊关键字参与字符串的拼接，会造成安全性问题            1. 输入用户随便，输入密码：a&apos; or &apos;a&apos; = &apos;a            2. sql : select * from USER where username = &apos;xxx&apos; and password = &apos;a&apos; or &apos;a&apos; = &apos;a&apos;;        2. 解决sql注入问题：使用PreparedStatement来解决        3. 预编译的SQL：参数使用?作为占位符        4. 步骤：            1. 导入驱动jar包 mysql-connnector-java-x.x.x-bin.jar            2. 注册驱动            3. 获取数据库的连接对象 Connection            4. 定义sql                * 注意：sql的参数使用?作为占位符。如: select * from user where username = ? and password = ?            5. 获取执行sql语句的对象 PreparedStatement    Connection.preparedStatement(String sql)            6. 给?赋值:                * 方法：setXxx(参数1, 参数2)                    * 参数1: ?的位置编号 从1 开始                    * 参数2: ?的值            7. 执行sql，接收返回结果，不需要传递sql语句            8. 处理结果            9. 释放资源        5. 注意：后期都会使用PreparedStatement来完成增删改查的所有操作            1. 可以防止sql注入            2. 效率更高</code></pre><h3 id="抽取JDBC工具类-JDBCUtils"><a href="#抽取JDBC工具类-JDBCUtils" class="headerlink" title="抽取JDBC工具类 : JDBCUtils"></a>抽取JDBC工具类 : JDBCUtils</h3><pre><code>* 目的：简化书写* 分析：    1. 注册驱动也抽取    2. 抽取一个方法获取连接对象        * 需求：不想传递参数(麻烦)，还得保证工具类的通用性。        * 解决：配置文件            jdbc.properties                url=                user=                password=    3. 抽取一个方法释放资源* 代码实现：    public class JDBCUtils {        private static String url;        private static String user;        private static String password;        private static String driver;        /**         * 文件的读取只需要读取一次即可拿到这些值，使用静态代码块完成         */        static {            try {                // 读取资源文件，获取值。                // 1.创建Properties集合类                Properties pro = new Properties();                // 获取src路径下的文件的方式---&gt;ClassLoader 类加载器                ClassLoader classLoader = JDBCUtils.class.getClassLoader();                URL result = classLoader.getResource(&quot;jdbc.properties&quot;);                String path = result.getPath();                // 2.加载文件                pro.load(new FileReader(path));                // 3.获取属性赋值                url = pro.getProperty(&quot;url&quot;);                user = pro.getProperty(&quot;user&quot;);                password = pro.getProperty(&quot;password&quot;);                driver = pro.getProperty(&quot;driver&quot;);                // 4.注册驱动                try {                    Class.forName(driver);                } catch (ClassNotFoundException e) {                    e.printStackTrace();                }            } catch (IOException e) {                e.printStackTrace();            }        }        /**         * 获取连接         * @return 连接对象         */        public static Connection getConnection() throws SQLException {            return DriverManager.getConnection(url, user, password);        }        /**         * 释放资源         * @param statement         * @param connection         */        public static void close(Statement statement, Connection connection){            if(statement != null){                try {                    statement.close();                } catch (SQLException throwables) {                    throwables.printStackTrace();                }            }            if(connection != null){                try {                    connection.close();                } catch (SQLException throwables) {                    throwables.printStackTrace();                }            }        }        public static void close(ResultSet resultSet, Statement statement, Connection connection){            if(statement != null){                try {                    statement.close();                } catch (SQLException throwables) {                    throwables.printStackTrace();                }            }            if(connection != null){                try {                    connection.close();                } catch (SQLException throwables) {                    throwables.printStackTrace();                }            }            if(resultSet != null){                try {                    resultSet.close();                } catch (SQLException throwables) {                    throwables.printStackTrace();                }            }        }    }    * 练习：        * 需求：            1. 通过键盘录入用户名和密码            2. 判断用户是否登录成功                * select * from USER where username = &apos;&apos; and password = &apos;&apos;;                * 如果这个sql有查询结果，则成功，反之失败        * 步骤：            1. 创建数据库表 user                CREATE TABLE USER(                    id INT PRIMARY KEY AUTO_INCREMENT,                    username varchar(32),                    password varchar(32)                );                INSERT INTO USER VALUES(NULL,&apos;zhangsan&apos;,&apos;123&apos;);                INSERT INTO USER VALUES(NULL,&apos;lisi&apos;,&apos;234&apos;);            2. 创建一个类            ......</code></pre><h3 id="JDBC控制事务"><a href="#JDBC控制事务" class="headerlink" title="JDBC控制事务"></a>JDBC控制事务</h3><pre><code>1. 事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则者多个步骤要么同时成功，要么同时失败。2. 操作：    1. 开启事务    2. 提交事务    3. 回滚事务3. 使用Connection对象来管理事务    * 开启事务: void setAutoCommit(boolean autoCommit)    : 调用该方法设置参数为false，即开启事务        * 在执行sql之前开启事务(在获得连接后开启)    * 提交事务: void commit()        * 当所有sql都执行完提交事务    * 回滚事务: void rollback()        * 在catch中回滚事务</code></pre><hr><h2 id="Day-05-内容："><a href="#Day-05-内容：" class="headerlink" title="Day 05 内容："></a>Day 05 内容：</h2><pre><code>1. 数据库连接池2. Spring JDBC : JDBC Template</code></pre><h3 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h3><pre><code>1. 概念：其实就是一个容器(集合)，存放数据库连接的容器    当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。2. 好处：    1. 节约资源    2. 用户访问高效3. 实现：    1. 标准接口：DataSource    javax.sql包下的        1. 方法：            * 获取连接：getConnection()            * 归还连接：Connection.close()                如果连接对象Connection是从连接池中获取的，那么调用Connection.close()，则不会再关闭连接，而是归还连接。    2. 一般我们不去实现它，由数据库厂商实现        1. C3P0：数据库连接池技术        2. Druid：数据库连接池实现技术，由阿里巴巴提供的4. C3P0：数据库连接池技术    * 步骤：        1. 导入jar包 (两个)c3p0-0.6.5.2.jar mchange-commons-java-0.2.12.jar            * 不要忘记导入数据库驱动jar包        2. 定义配置文件：            * 名称：c3p0.properties 或者 c3p0-config.xml            * 路径：直接将文件放在src目录下即可        3. 创建核心对象：数据库连接池对象 ComboPooledDataSource        4. 获取连接：getConnection()5. Druid：数据库连接池实现技术，由阿里巴巴提供的    1. 步骤：        1. 导入jar包 druid-1.0.9.jar        2. 定义配置文件：            * 是properties形式的            * 可以叫任意名称，可以放在任意目录下        3. 加载配置文件     Properties        4. 获取数据库连接池对象：通过工厂类来获取    DruidDataSourceFactory        5. 获取连接：getConnection()    2. 定义工具类        1. 定义一个类 JDBCUtils        2. 提供静态代码块加载配置文件，初始化连接池对象        3. 提供方法            1. 获取连接方法：通过数据库连接池获取连接            2. 释放资源            3. 获取连接池的方法            代码:                /**                 * Druid连接池的工具类                 */                public class JDBCUtils {                    // 1.定义成员变量 DataSource                    private static DataSource ds;                    static {                        try {                            // 1.加载配置文件                            Properties pro = new Properties();                            pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;));                            // 2.获取DataSource                            ds = DruidDataSourceFactory.createDataSource(pro);                        } catch (Exception e) {                            e.printStackTrace();                        }                    }                    /**                     * 获取连接                     */                    public static Connection getConnection() throws SQLException {                        return ds.getConnection();                    }                    /**                     * 释放资源                     * @param statement                     * @param connection                     */                    public static void close(Statement statement, Connection connection){                        if(statement != null){                            try {                                statement.close();                            } catch (SQLException throwables) {                                throwables.printStackTrace();                            }                        }                        if(connection != null){                            try {                                connection.close();                            } catch (SQLException throwables) {                                throwables.printStackTrace();                            }                        }                    }                    public static void close(ResultSet resultSet, Statement statement, Connection connection){                        if(statement != null){                            try {                                statement.close();                            } catch (SQLException throwables) {                                throwables.printStackTrace();                            }                        }                        if(connection != null){                            try {                                connection.close();                            } catch (SQLException throwables) {                                throwables.printStackTrace();                            }                        }                        if(resultSet != null){                            try {                                resultSet.close();                            } catch (SQLException throwables) {                                throwables.printStackTrace();                            }                        }                    }                    /**                     * 获取连接池方法                     */                    public static DataSource getDataSource(){                        return ds;                    }                }</code></pre><h3 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h3><pre><code>* Spring框架对JDBC的简单封装。提供了JDBC Template对象简化JDBC的开发* 步骤：    1. 导入jar包    2. 创建JdbcTemplate对象。依赖于数据源DataSource        * JdbcTemplate template = new JdbcTemplate(ds);    3. 调用JdbcTemplate的方法来完成CRUD的操作        * update(): 执行DML语句。增、删、改语句        * queryForMap(): 查询结果，将结果集封装为Map集合，将列名作为key，将值作为value，将这条记录封装为value            * 注意：这个方法查询的结果集长度只能是1        * queryForList(): 查询结果，将结果集封装为list集合            * 注意：将每一条记录封装为Map集合，再将Map集合装载在List集合中        * query(): 查询结果，将结果封装为JavaBean对象            * query方法的参数：RowMapper                * 一般使用BeanPropertiyRowMapper实现类。可以完成数据到JavaBean的自动封装。                * new BeanPropertyRowMapper&lt;类型&gt;(类型.class)        * queryForObject(): 查询结果，将结果封装为对象            * 一般用于聚合函数的查询     4. 练习：        * 需求：            1. 修改1号数据的 salary 为 10000            2. 添加一条记录            3. 删除刚才添加的记录            4. 查询id为1的记录，将其封装为Map集合            5. 查询所有的记录，将其封装为List集合            6. 查询所有记录，将其封装为Emp对象的List集合            7. 查询总的记录数</code></pre><hr><h2 id="Day-06-内容："><a href="#Day-06-内容：" class="headerlink" title="Day 06 内容："></a>Day 06 内容：</h2><pre><code>1. web概念概述2. HTML</code></pre><h3 id="web概念概述"><a href="#web概念概述" class="headerlink" title="web概念概述"></a>web概念概述</h3><pre><code>* JavaWeb：    * 使用Java语言开发基于互联网的项目* 软件的架构：    1. C/S：Client/Server 客户端/服务器端        * 在用户本地有一个客户端程序，在远程有一个服务器端程序        * 如：QQ，迅雷...        * 优点：            1. 用户体验好        * 缺点：            1. 开发、安装、部署、维护麻烦    2. B/S：Browser/Server 浏览器/服务器端        * 只需要一个浏览器，用户通过不同的网址(URL)，可以访问远程不同的服务器端程序        * 优点：            1. 开发、安装、部署、维护简单        * 缺点：            1. 如果应用过大，用户的体验可能会受到影响            2. 对硬件要求过高* B/S架构详解    * 资源分类：        1. 静态资源：            * 使用静态网页开发技术发布的资源            * 特点：                * 所有用户访问，得到的结果是一样的                * 如：文本、图片、音频、视频，HTML,CSS,JavaScript                * 如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏览器，浏览器中内置了静态资源的解析引擎        2. 动态资源：            * 使用动态网页技术发布的资源            * 特点：                * 所有用户访问，得到的结果可能不一样                * 如：jsp/servlet,php,asp...                * 如果用户请求的是动态资源，那么服务器将会执行动态资源，转换为静态资源，再发送给浏览器    * 我们要学习动态资源，必须先学习静态资源！    * 静态资源：        * HTML：用于搭建基础网页，展示页面的内容        * CSS：用于美化页面，布局页面        * JavaScript：控制页面的元素，让页面有一些动态的效果</code></pre><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><pre><code>1. 概念：是最基础的网页开发语言    * Hyper Text Markup Language 超文本标记语言        * 超文本：            * 超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本。        * 标记语言：            * 由标签构成的语言。&lt;标签名称&gt; 如html, xml            * 标记语言不是编程语言2. 快速入门：    * 语法：        1. html文档后缀名 .html 或者 .htm        2. 标签分为            1. 围堵标签：有开始标签和结束标签。如 &lt;html&gt; &lt;/html&gt;            2. 自闭和标签：开始标签和结束标签在一起。 如 &lt;br /&gt;        3. 标签可以嵌套：            需要正确嵌套，不能你中有我，我中有你            错误: &lt;a&gt;&lt;b&gt;&lt;/a&gt;&lt;/b&gt;            正确: &lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt;        4. 在开始标签中可以定义属性。属性是由键值对组成，值需要用引号(单双都可)引起来        5. html的标签不区分大小写，建议使用小写。3. 标签学习：    1. 文件标签：构成html最基本的标签        * html:html文档的根标签        * head:头标签。用于指定html文档的一些属性。引入外部的资源        * title:标题标签        * body：体标签        * &lt;!DOCTYPE html&gt;:html5中定义改文档是html文档    2. 文本标签：和文本有关的标签        * 注释：&lt;!-- --&gt;        * &lt;h1&gt; to &lt;h6&gt;：标题标签            * h1~h6字体大小主键递减        * &lt;p&gt;：段落标签        * &lt;br&gt;：换行标签        * &lt;hr&gt;：展示一条水平线            * 属性：                * color：颜色                * width：宽度                * size：高度                * align：对齐方式                    * center：居中                    * left：左对齐                    * right：右对齐        * &lt;b&gt;：字体加粗        * &lt;i&gt;：字体斜体        * &lt;font&gt;：字体标签            * 属性：                * color：颜色                * size：大小                * face：字体        * &lt;center&gt;：文本居中        * 属性定义：            * color：                1. 英文单词：red,green,blue                2. rgb(值1, 值2, 值3):值的范围：0~255    如 rgb(0,0,2555)                3. #值1值2值3：值的范围：00~FF。 如: #FF00FF            * width:                1. 数值：width=&apos;20&apos;，数值的单位，默认是 px(像素)                2. 数值% ：占比相对于父元素的比例        * 案例            ...    3. 图片标签        * img：展示图片            * 属性：                * src：指定图片位置            * 相对路径：                * 以.开头的路径                    * ./: 代表当前目录    ./image/1.jpg                    * ../: 代表上一级目录    4. 列表标签：        * 有序列表：            * ol            * li        * 无序标签：            * ul            * li    5. 链接标签        * a：定义一个超链接            * 属性：                * href：指定访问资源的URL(统一资源定位符)                * target：指定打开资源的方式                    * _self：默认值，在当前页面打开                    * _blank：在空白页面打开    6. div和span：        * div：每个div占满一整行。块级标签        * span：文本信息在一行展示，行内标签，内联标签。    7. 语义化标签：html5中为了提高程序的可读性，提供了一些标签        1. &lt;header&gt;: 页眉        2. &lt;footer&gt;: 页脚    8. 表格标签        * table：定义表格            * width：宽度            * border：边框            * cellpadding：定义内容和单元格的距离            * cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条。            * bgcolor：背景色            * align：对齐方式        * tr：定义行            * bgcolor：背景色            * align：对齐方式        * td：定义单元格            * colspan：合并行            * rowspan：合并列        * th：定义表头单元格        * &lt;caption&gt;：表格标题        * &lt;thead&gt;：表示表格的头部分        * &lt;tbody&gt;：表示表格的体部分        * &lt;tfoot&gt;：表示表格的脚部分</code></pre><h3 id="案例：旅游网站首页"><a href="#案例：旅游网站首页" class="headerlink" title="案例：旅游网站首页"></a>案例：旅游网站首页</h3><pre><code>1. 确定使用table来完成布局2. 如果某一行只有一个单元格，则使用&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;3. 如果某一行有多个单元格，则使用    &lt;tr&gt;        &lt;td&gt;            &lt;table&gt;&lt;/table&gt;        &lt;/td&gt;    &lt;/tr&gt;</code></pre><hr><h2 id="Day-07-内容："><a href="#Day-07-内容：" class="headerlink" title="Day 07 内容："></a>Day 07 内容：</h2><pre><code>1. HTML标签：表单标签2. CSS：</code></pre><h3 id="HTML标签：表单标签"><a href="#HTML标签：表单标签" class="headerlink" title="HTML标签：表单标签"></a>HTML标签：表单标签</h3><pre><code>* 表单：    * 概念：用于采集用户输入的数据的。用于和服务器进行交互。    * form: 用于定义表单的。可以定义一个范围，范围代表用户采集数据的范围        * 属性：            * action：指定提交数据的URL            * method：指定提交方式                * 分类：一共七种，两种比较常用                    * GET：                        1. 请求参数会在地址栏中显示，会封装到请求行中(HTTP协议后讲解)                        2. 请求参数的大小是有限制的                        3. 不太安全                    * POST：                        1. 请求参数不会在地址栏中显示，会封装在请求体中(HTTP协议后讲解)                        2. 请求参数的大小没有限制                        3. 较为安全        * 表单项中的数据要想被提交，必须指定其name属性* 表单项标签：    * input：可以通过type属性值，改变元素展示的样式        * type属性：            * text：文本输入框，默认值                * placeholder：指定输入框的提示信息，当输入框的内容发生变化，会自动清楚提示信息            * password：密码输入框            * radio：单选框                * 注意：                    1. 要想让多个单选框实现单选的效果，则多个单选框的name属性值必须一样                    2. 一般会给每一个单选框提供value属性，指定其被选中后提交的值                    3. checked属性，可以指定默认值            * checkbox：复选框                * 注意：                    1. 一般会给每一个单选框提供value属性，指定其被选中后提交的值                    2. checked属性，可以指定默认值            * file：文件选择框            * hidden：隐藏域，用于提交一些信息            * 按钮：                * submit： 提交按钮，用于提交表单                * button：普通按钮                * image：图片提交按钮        * label：指定输入项的文字描述信息            * 注意                * label的for属性一般会和input的id属性值对应。如果对应了，则点击label区域，会让input输入框获取焦点    * select：下拉列表        * 子元素option，指定列表项    * textarea：文本域        * cols：指定列数        * rows：指定行数</code></pre><h3 id="CSS-页面美化和布局控制"><a href="#CSS-页面美化和布局控制" class="headerlink" title="CSS: 页面美化和布局控制"></a>CSS: 页面美化和布局控制</h3><pre><code>1. 概念：Cascading Style Sheets 层叠样式表    * 层叠：多个样式可以作用在同一个html的元素上，同时生效2. 好处：    1. 功能强大    2. 将内容展示和样式控制分类        * 降低耦合度，解耦        * 让分工合作更容易        * 提高开发效率3. CSS的使用：CSS和HTML结合方式    1. 内联样式        * 在标签内使用style属性指定css代码        * 如    &lt;div style=&quot;color:red;&quot;&gt;&lt;/div&gt;    2. 内部样式        * 在head标签内部定义style标签，style的标签内容就是css代码        * 如                &lt;style&gt;                div{                    color:blue;                }            &lt;/style&gt;            &lt;div&gt;&lt;/div&gt;    3. 外部样式        1. 定义css资源文件        2. 在head标签内定义link标签，引入外部资源文件    * 注意：        * 1、2、3种方式，作用范围越来越大        * 1方式不常用，后期常用2、3        * 第3种格式可以写为：            &lt;style&gt;                @import &quot;css/a.css&quot;;            &lt;/style&gt;4. css语法：    * 格式：        选择器 {            属性名1:属性值1;            属性名2:属性值2;            ...        }    * 选择器：筛选具有相似特征的元素    * 注意：        * 每一对属性需要用分号隔开，最后一对属性可以不加5. 选择器：    * 分类：        1. 基础选择器            1. id选择器：选择具体的id属性值的元素，建议在一个html界面中id值唯一                * 语法：#id属性值{}            2. 元素选择器：选择具有相同标签的元素                * 语法：标签名称{}                * 注意：id选择器优先级高于元素选择器            3. 类选择器：选择具有相同的class属性的元素                * 语法：.class属性值{}                * 注意：类选择器优先级高于元素选择器        2. 扩展选择器：            1. 选择所有元素                * 语法：* {}            2. 并集选择器                * 语法：选择器1,选择器2 {}            3. 子选择器：筛选选择器1元素下的选择器2                * 语法：选择器1 选择器2 {}            4. 父选择器：筛选选择器2父元素选择器1                * 语法：选择器1 &gt; 选择器2 {}            5. 属性选择器：选择元素名称，属性名=属性值的元素                * 语法：元素名称[属性名=&quot;属性值&quot;] {}            6. 伪类选择器：选择一些元素具有的状态                * 语法：元素:状态 {}                * 如：&lt;a&gt;                    * 状态：                        * link：初始化的状态                        * visited：被访问过的状态                        * active：正在访问状态                        * hover：鼠标悬浮状态6. 属性    1. 字体、文本        * font-size：字体大小        * color：文本颜色        * text-alion：对齐方式        * line-height：行高    2. 背景        * background：复合属性    3. 边框        * border：设置边框，复合属性    4. 尺寸        * width：宽度        * height：高度    5. 盒子模型：控制布局        * margin：外边距        * padding：内边距            * 默认情况下内边距会影响整个盒子的大小            * box-sizing: border-box        * float：浮动            * left            * right</code></pre><hr><h2 id="Day-08-内容："><a href="#Day-08-内容：" class="headerlink" title="Day 08 内容："></a>Day 08 内容：</h2><pre><code>1. JavaScript基础</code></pre><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript:"></a>JavaScript:</h3><pre><code>* 概念：一门客户端脚本语言    * 运行在客户端浏览器中。每一个浏览器都有JavaScript的解析引擎    * 脚本语言：不需要编译，直接就可以被浏览器解析执行了* 功能：    * 可以来增强用户和HTML页面的交互过程，可以来控制HTML元素，让页面有一些动态的效果，增强用户的体验。* JavaScript发展史：    1. 1992年，Nombase公司，开发出第一门客户端脚本语言，专门用于表单的校验。命名为：C--，后来更名为：ScriptEase    2. 1995年，Netscape(网景)公司，开发了一门客户端脚本语言：LiveScript。请来SUN公司的专家，修改LiveScript，命名为JavaScript    3. 1996年，微软抄袭JavaScript开发出JScript语言    4. 1997年，ECMA(欧洲计算机制造商协会)，ECMAScript，就是所有客户端脚本语言的标准。    * JavaScript = ECMAScript + JavaScript自己特有的东西(BOM + DOM)* ECMAScript：客户端脚本语言的标准    1. 基本语法：        1. 与HTML结合方式            1. 内部JS：                * 定义&lt;script&gt;，标签体内容就是js代码            2. 外部JS：                * 定义&lt;script&gt;，通过src属性引入外部的js文件            * 注意：                1. &lt;script&gt;可以定义在html页面的任何地方，但是定义的位置会影响执行的顺序。                2. &lt;script&gt;可以定义多个。        2. 注释            1. 单行注释：// 注释内容            2. 多行注释：/* 注释内容 */        3. 数据类型：            1. 原始数据类型(基本数据类型)：                1. number：数字。 整数/小数/NaN(not a number 一个不是数字的数字类型)                2. string：字符串。 字符串 &apos;abc&apos; &quot;a&quot;                3. boolean：true和false                4. null：一个对象为空的占位符                5. undefined：未定义。如果一个变量没有给初始化值，则会被默认为undefined            2. 引用数据类型：对象        4. 变量            * 变量：一小块存储数据的内存空间            * Java语言是强类型语言，而JavaScript是弱类型语言                * 强类型：在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据。                * 弱类型：在开辟变量存储空间时，不定义空间将来存储的数据的数据类型。可以存储任意类型的数据。            * 语法：                * var 变量名 = 初始化值;            * typeof运算符：获取变量的类型                * 注：null运算符后得到的时object        5. 运算符            1. 一元运算符：只有一个运算数的运算符                ++ -- +(正号)            2. 算数运算符                + - * / %            3. 赋值运算符                = += -= ...            4. 比较运算符                &gt; &lt; &gt;= &lt;= == ===(全等于)                * 比较方式                    1. 类型相同，直接比较                        * 字符串，按照字典顺序比较，按位逐一比较，直到得出大小为止。                    2. 类型不同，先进行类型转换，再比较                        * ===，全等于，在比较前先判断类型，如果类型不一样，则直接返回false            5. 逻辑运算符                &amp;&amp; || !                * 其他类型转boolean                    1. number：0或NaN为假，其他为真                    2. string：除了空字符串(&quot;&quot;)，其他都是true                    3. null&amp;undefined：false                    4. 对象：所有对象都为true                * 可用if(obj)判断                    1. obj为空字符串                    2. obj为null或者undefined            6. 三元运算符                ? :        6. 流程控制语句：            1. if...else...            2. swtich                * 在java种，switch语句可以接受的数据类型： byte int short char enum(1.5) String(1.7)                * 在JS种，swtich语句可以接受任意的原始数据类型            3. while            4. do...while            5. for        7. JS特殊语法：            1. 语句以;结尾，如果一行只有一条语句，则可以省略            2. 变量的定义使用var关键字，也可以不使用                * 用，定义的变量是局部变量                * 不用，定义的变量是全局变量    2. 基本对象：        * Function：函数对象            1. 创建                1. var 方法名 = new Function(形式参数列表, 方法体);                2. function 方法名(形式参数列表) {方法体}                3. var 方法名 = function(形式参数列表) {方法体}            2. 方法            3. 属性                length:代表形参的个数            4. 特点                1. 方法定义是，形参的类型不用写，返回值类型也不写                2. 方法是一个对象，如果定义名称相同的方法，会覆盖                3. 在JS中，方法的调用只与方法的名称有关，和参数列表无关                4. 在方法声明中有一个隐藏的内置对象(数组)，arguments，封装所有的实际参数            5. 调用                方法名称(实际参数列表);        * Array：数组对象            1. 创建：                1. var arr = new Array(元素列表);                2. var arr = new Array(默认长度);                3. var arr = [元素列表];            2. 方法                join(参数)：将数组中的元素按照指定的分隔符拼接为字符串                push(参数)：往数组最后添加一个元素            3. 属性                length：数组长度            4. 特点                1. JS中，数组元素的类型可变的。                2. JS中，数组的长度是可变的。        * Boolean        * Date：日期对象            1. 创建                var date  = new Date();            2. 方法                toLocaleString()：返回当前Date对象对应的实际本地字符串格式                getTime():获取毫秒值，返回当前日期对象描述的时间和1970年1月1日零点的毫秒值差        * Math：数学对象            1. 创建：                * 特点：Math对象不用创建直接使用。    Math.方法名();            2. 方法：                random()：返回0~1之间的随机数。含0不含1                cell(x)：向上取整                floor(x)：向下取整                round(x)：四舍五入            3. 属性                PI        * NUmber        * String        * RegExp：正则表达式对象            1. 正则表达式：定义字符串的组成规则。                1. 单个字符:[]                    如：[a] [ab] [a-zA-Z0-9]                    * 特殊符合代表特殊含义的单个字符                        \d:单个数字字符[0-9]                        \w:单个单词字符[a-zA-Z0-9_]                2. 量词符号：                    ?:表示出现0次或1次                    *:表示出现0次或多次                    +:出现一次或多次                    {m,n}:表示数量 m&lt;=数量&lt;=n                        * m如果缺省：{,n}:最多n次                        * n如果缺省：{m,}:最少m次                3. 开始结束符号                    * ^：开始                    * $：结束            2. 正则对象：                1. 创建：                    1. var reg = new RegExp(&quot;正则表达式&quot;); 注意反斜线的转义\\                    2. var reg = /正则表达式/;                2. 方法                    1. test(参数)：验证指定的字符串是否符合正则表达式        * Global            1. 特点：全局对象，这个Global中封装的方法不需要对象就可以直接调用。    方法名();            2. 方法：                encodeURI():url编码                decodeURI():url解码                encodeURIComponent():url编码，编码的字符更多                decodeURIComponent():url解码                parseInt():将字符串转为数字                    * 注意判断每一个字符是否是数字，直到不是数字为止，将前面数字的部分转为number                    * 没有数字转为NaN                isNaN():判断一个值是否为NaN                    * 参与的==比较都为false 包括其自身参与的比较                eval():将JS字符串转换为脚本运行            3. URL编码                * GBK编码：一个汉字两个字节                * UTF-8编码：一个汉字三个字节* BOM* DOM</code></pre><hr><h2 id="Day-09-内容"><a href="#Day-09-内容" class="headerlink" title="Day 09 内容:"></a>Day 09 内容:</h2><pre><code>1. JavaScript：    1. ECMAScript    2. BOM    3. DOM：        1. 事件</code></pre><h3 id="DOM简单学习：为了满足案例要求"><a href="#DOM简单学习：为了满足案例要求" class="headerlink" title="DOM简单学习：为了满足案例要求"></a>DOM简单学习：为了满足案例要求</h3><pre><code>* 功能：控制HTML文档的内容* 代码：获取页面标签(元素)对象    Element    * document.getElementById(&quot;id值&quot;);    通过元素id获取元素对象* 操作Element对象：    1. 修改属性值：        1. 明确获取的对象是哪一个        2. 查看API文档，找其中有哪些属性可以设置    2. 修改标签体内容：        * 属性：innerHTML</code></pre><h3 id="事件简单学习"><a href="#事件简单学习" class="headerlink" title="事件简单学习"></a>事件简单学习</h3><pre><code>* 功能：某些组件被执行了某些操作后，触发某些代码的执行。* 如何绑定事件    1. 直接在HTML标签上，指定事件的属性，属性值就是JS代码        1. 事件：onclick--- 单击事件    2. 通过JS获取元素对象，指定事件属性，设置一个函数</code></pre><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><pre><code>* 分析    1. 获取图片对象    2. 绑定单击事件    3. 每次点击切换图片        * 规则，如果on换为off，反之亦然        * 使用标记flag完成</code></pre><h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3><pre><code>1. 概念：Browser Object Model 浏览器对象模型    * 将浏览器的各个部分封装成对象。2. 组成    * Window：窗口对象    * Navigator：浏览器对象    * Screen：显示器屏幕对象    * History：历史记录对象    * Location：地址栏对象3. Window：窗口对象    1. 创建    2. 方法        1. 与弹出框有关的方法            alert()    弹出警告框            confirm()    弹出对话框(确认或者取消)                * 如果点击确定 返回true                * 点击取消 返回false            prompt()    弹出可输入的对话框                * 返回值，获取用画输入的内容        2. 与打开关闭有关的方法            close() 关闭浏览器窗口                * 谁调用关谁            open() 打开一个浏览器窗口                * 返回新的Window对象        3. 与定时器有关的方法            setTimeout()    在指定的毫秒数后调用函数或计算表达式。                * 参数：                    1. js代码或者方法对象                    2. 毫秒值                * 返回值：唯一标识，用于取消定时器            clearTimeout()    取消由setTimeout()方法设置的timeout。            setInterval()    按照指定的周期（以毫秒计）来调用函数或计算表达式。            clearInterval()    取消由setInterval()设置的timeout。    3. 属性        1. 获取其他BOM对象            history            location            Navigator            Screen        2. 获取DOM对象            document    4. 特点        * Window对象不需要创建可以直接使用 window来使用 window.方法名();        * window引用可以省略。    方法名();4. Location：地址栏对象    1. 创建(获取)：        1. window.location        2. location    2. 方法        * reload() 重新加载当前文档 刷新    3. 属性        * href 设置或返回完整的URL5. History：历史记录对象    1. 创建(获取):        1. window.history        2. history    2. 方法：        * back()    加载history列表中的前一个 URL。        * forward()    加载history列表中的下一个 URL。        * go(参数)    加载history列表中的某个具体页面。            * 参数                * 正数：前进几个历史记录                * 负数：后退几个历史记录    3. 属性        * length    返回浏览器历史列表中的 URL 数量。</code></pre><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><pre><code>* 概念：Document Object Model 文档对象模型    * 将标记语言文档的各个部分，封装为对象。可以使用这些对象，对标记语言文档进行CRUD的动态操作* W3C DOM 标准被分为3个不同的部分：    * 核心DOM - 针对任何结构化文档的标准模型        * Document：文档对象        * Element：元素对象        * Attribute：属性对象        * Text：文本对象        * Comment：注释对象        * Node：节点对象，其他5个的父对象    * XML DOM - 针对XML文档的标准模型    * HTML DOM - 针对HTML文档的标准模型 * 核心DOM模型：    * Document：文档对象        1. 创建(获取)，在html dom模型中可以使用window对象来获取            1. window.document            2. document        2. 方法            1. 获取Element对象：                1. getElementById()：根据id属性值获取元素对象，id属性值一般唯一                2. getElementByTagName()：根据元素名称获取元素对象们，返回值是一个数组                3. getElementByClassName()：根据Class属性值获取元素对象们，返回值是一个数组                4. getElementByName()：根据name属性值获取元素对象们，返回值是一个数组            2. 创建其他DOM对象                createAttribute(name)                createComment()                createElement()                createTextNode()    * Element：元素对象        1. 创建(获取)，通过document来获取和创建        2. 方法：            1. removeAttribute()：删除属性            2. setAttribute()：设置属性    * Node：节点对象，其他5个的父对象        * 特点：所有dom对象都可以被认为是一个节点        * 方法：            * CRUD dom树                * appendChild()：向节点的子节点列表的结尾添加新的子节点。                * removeChild()：删除（并返回）当前节点的指定子节点。                * replaceChild()：用新节点替换一个子节点。        * 属性            * parentNode：返回节点的父节点。* HTML DOM    1. 标签体的设置和获取：innerHTML    2. 使用html元素对象和属性    3. 控制样式        1. 使用元素的style属性来设置            如： div.style.fontSize = &quot;20px&quot;;        2. 提前定义好类选择器的样式，通过元素的className属性来设置其class属性值</code></pre><h3 id="事件监听机制"><a href="#事件监听机制" class="headerlink" title="事件监听机制"></a>事件监听机制</h3><pre><code>* 概念：某些组件被执行了某些操作后，触发某些代码的执行。    * 事件：某些操作    如：单击、双击、键盘    * 事件源：组件    如：按钮、文本输入框    * 监听器：代码        * 注册监听：将事件源、事件、监听器绑定在一起。当事件源上发生了某个事件，则触发执行某个监听器代码* 常见的事件：    1. 点击事件：        1. onclick：单击事件。        2. ondblclick：双击事件。    2. 焦点事件：        1. onblur：失去焦点。            * 一般用于表单验证        2. onfocus：元素获得焦点。    3. 加载事件        1. onload：一张页面或一张图像加载完成。    4. 鼠标事件        1. onmousedown    鼠标按钮被按下。            * 定义方法时，定义一个形参，接收event对象。            * event对象的button属性可以获取鼠标哪个键被点击了        2. onmousemove    鼠标被移动。        3. onmouseout    鼠标从某元素移开。        4. onmouseover    鼠标移到某元素之上。        5. onmouseup    鼠标按键被松开。    5. 键盘事件        1. onkeydown    某个键盘按键被按下。        2. onkeyup    某个键盘按键被松开。        3. onkeypress    某个键盘按键被按下并松开。    6. 选择和改变        1. onchange    域的内容被改变。        2. onselect    文本被选中。    7. 表单事件        1. onsubmit 确认按钮被点击。            * 可以阻止表单的提交                * 方法返回false，则表单被阻止提交                * 注意：                    如果在标签中使用onsubmit 如&lt;form onsubmit=&apos;false&apos;&gt;&lt;/from&gt;                    这样是无法实现的，原因是在系统进行创建html页面时会调用onsubmit = function(){&quot;onsubmit=内的内容&quot;}也就是onsubmit = function(){false}，这个就相当于是没有返回值的，所以无法完成，要想完成，可以通过&lt;form onsubmit=&apos;return false&apos;&gt;&lt;/from&gt;这样来完成，或者在script标签中通过DOM获取form对象设置onsubmit来完成，即document.getElementById(&apos;form&apos;).onsubmit=function (){return false};即可        2. onreset    重置按钮被点击。* 案例    ...    见相应教程 这里就不赘述了    https://www.bilibili.com/video/BV1J4411877m?p=189    https://www.bilibili.com/video/BV1J4411877m?p=190</code></pre><hr><h2 id="Day-10-内容："><a href="#Day-10-内容：" class="headerlink" title="Day 10 内容："></a>Day 10 内容：</h2><pre><code>1. Bootstrap</code></pre><h3 id="Boostrap"><a href="#Boostrap" class="headerlink" title="Boostrap"></a>Boostrap</h3><pre><code>1. 概念：一个前端开发的框架。Bootstrap是美国Twitter公司的设计师Mark Otto和Jacob Thornton合作基于HTML、CSS、JavaScript 开发的简洁、直观、强悍的前端开发框架，使得 Web 开发更加快捷。    * 框架：一个半成品软件，开发人员可以在框架基础上，再进行开发，简化编码    * 好处        1. 定义了很多css样式和js插件。我们开发人员可以直接使用这些样式和插件得到丰富的页面效果。        2. 响应式布局。            * 同一套页面可以兼容不同分辨率的设备。2. 快速入门    1. 下载Bootstrap    2. 在项目中将这三个文件夹复制    3. 创建html页面，引入必要的资源文件</code></pre><h3 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h3><pre><code>* 同一套页面可以兼容不同分辨率的设备。* 实现：依赖于栅格系统——将一行平均分成12个格子，可以去指定元素占几个格子* 步骤：    1. 定义容器，相当于之前的table        * 容器分类：            1. container：两边留白            2. container-fluid：每一种设备都是100%宽度    2. 定义行，相当于之前的tr        样式：row    3. 定义元素。指定该元素在不同的设备上所占的格子数目。    样式：col-设备代号-格子数目        * 设备代号:            1. xs：超小屏幕 手机 (&lt;768px)：col-xs-12            2. sm：小屏幕 平板 (≥768px)            3. md：中等屏幕 桌面显示器 (≥992px)            4. lg：大屏幕 大桌面显示器 (≥1200px)    * 注意：        1. 一行中如果格子数目超过12，则超出部分自动换行        2. 栅格类属性可以向上兼容，栅格类适用于与屏幕宽度大于或等于分界点大小的设备         3. 如果真实设备宽度小于了设置的栅格类属性的设备代码的最小值，元素会占满一整行</code></pre><h3 id="CSS样式和JS插件"><a href="#CSS样式和JS插件" class="headerlink" title="CSS样式和JS插件"></a>CSS样式和JS插件</h3><pre><code>1. 全局CSS样式:    * 按钮：class=&quot;btn btn-default&quot;    * 图片        * class=&quot;img-responsive&quot;: 图片任意尺寸占100%        * 形状：class=&quot;img-rounded&quot; ...见文档    * 表格        * class=&quot;table&quot;        * class=&quot;table-hover&quot;    * 表单        * 给表单项添加：class=&quot;form-control&quot;2. 组件：    * 导航条    * 分页条3. 插件：    * 轮播图</code></pre><hr><h2 id="Day-11-内容："><a href="#Day-11-内容：" class="headerlink" title="Day 11 内容："></a>Day 11 内容：</h2><pre><code>1. XML    1. 概念    2. 语法    3. 解析</code></pre><h3 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h3><pre><code>1. 概念：Extensible Markup Language 可扩展标记语言    * 可扩展：标签都是自定义的。    &lt;user&gt; &lt;student&gt;    * 功能：        * 存储数据            1. 配置文件            2. 在网络中传输    * xml和html的区别：        1. xml标签都是自定义的，html的标签是预定义。        2. xml的语法严格，html语法松散。        3. xml是存储数据，html是展示数据的。    * w3c：万维网联盟2. 语法    * 基本语法：        1. xml后缀名 .xml        2. xml第一行必须定义为文档声明        3. xml文档中有且仅有一个根标签        4. 属性值必须使用引号引起来(单双都可)        5. 标签必须正确关闭        6. xml标签名称区分大小写    * 快速入门        &lt;?xml versionm=&apos;1.0&apos; ?&gt;        &lt;users&gt;            &lt;user id=&apos;1&apos;&gt;                &lt;name&gt;zhangsan&lt;/name&gt;            &lt;/user&gt;            &lt;user id=&apos;2&apos;&gt;                &lt;name&gt;lisi&lt;/name&gt;            &lt;/user&gt;        &lt;/users&gt;    * 组成部分：        1. 文档声明            1. 格式：&lt;?xml 属性列表 ?&gt;            2. 属性列表                * version：版本号，必须的属性                * encoding：编码方式，告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1                * standalone：是否独立                    * 取值：                        * yes：不依赖其他文件                        * no：依赖其他文件        2. 指令(了解)：结合css            * &lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;a.css&quot; ?&gt;        3. 标签：标签名称是自定义的            * 规则：                * 名称可以包含字母、数字以及其他的字符                * 名称不能以数字或者标点符号开始                * 名称不能以字母xml或者(XML、Xml等等)开始                * 名称不能包含空格        4. 属性：            id属性值唯一        5. 文本            * CDATA区：在该区域中的数据会被原样展示                * 格式:&lt;![CDATA[数据]]&gt;    * 约束：规定xml文档的书写规则        * 作为框架的使用者(程序员)：            1. 能够在xml中引入约束文档            2. 能够简单读懂约束文档        * 分类：            1. DTD：一种简单的约束技术            2. Schema：一种复杂的约束技术        * DTD：            * 引入dtd文档到xml文档中                * 内部dtd，将约束规则定义在xml文档中                * 外部dtd，将约束规则定义在外部dtd文件中                    * 本地：&lt;!DOCTYPE 根标签名 SYSTEM &quot;dyd文件的位置&quot;&gt;                    * 网络：&lt;!DOCTYPE 根标签名 PUBLIC &quot;dtd文件的名字&quot; &quot;dyd文件的位置url&quot;&gt;        * Schema：            * 引入：                1. 填写xml文档的根元素                2. 引入xsi前缀 xmlns:xsi=&quot;...&quot;                3. 引入xsd文件命名空间 xsi:schemaLocation=&quot;... ...&quot;(键值对的形式 前面代表名称 后面代表路径)                4. 为每一个xsd约束声明一个前缀作为标识 xmlns:(自定义前缀)=&quot;...&quot;3. 解析：操作xml文档，将文档中的数据读取到内存中    * 操作xml文档        1. 解析(读取)：将文档中的数据读取到内存中        2. 写入：将内存中的数据保存到xml文档中，持久化的存储    * 解析xml的方式：        1. DOM：将标记语言文档一次性加载进内存，在内存中形成DOM树            * 优点：操作方便，可以对文档进行CRUD的所有操作            * 缺点：占内存        2. SAX：逐行读取，基于事件驱动的。            * 优点：不占内存。            * 缺点：只能读取，不能增删改    * xml常见的解析器：        1. JAXP：sun公司提供的解析器，支持dom和sax两种思想        2. DOM4J：一款非常优秀的解析器        3. Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。        4. PULL：Android操作系统内置的解析器，sax方式的。    * Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。        * 快速入门：            * 步骤：                1. 导入jar包                2. 获取Document对象                3. 获取对应的标签Element对象                4. 获取数据        * 代码            // 2.获取Document对象 根据xml文档获取            // 2.1获取studetns.xml路径            String res = JsoupDemo1.class.getClassLoader()                    .getResource(&quot;student.xml&quot;).getPath();            String path = java.net.URLDecoder.decode(res, &quot;utf-8&quot;);            // 2.2解析xml文档 加载文档进内存 获取dom树            Document document = Jsoup.parse(new File(path), &quot;utf-8&quot;);            // 3.获取元素对象 Element            Elements ele = document.getElementsByTag(&quot;name&quot;);            System.out.println(ele.size());            // 3.1获取第一个name的element对象            System.out.println(ele.get(0).text());    * 对象的使用：        1. Jsoup：工具类，可以解析html或xml文档，返回Document            * parse：解析html或xml文档，返回Document                * parse(File in, String charsetName)：解析html或xml文件的                * parse(String html)：解析xml或xml字符串                * parse(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象        2. Document：文档对象，代表内存中的dom树            * 获取Element对象                * getElementsByTag(String tagName)：根据标签名称获取元素对象集合                * getElementByAttribute(String key)：根据书写名称获取元素对象集合                * getElementByArributeValue(String key, String value)：根据对应的属性名和属性值获取元素对象集合                * getElementById(String id)：根据id属性值获取唯一的Element对象        3. Elements：元素Element对象的集合。可以当作ArrayList&lt;Element&gt;来使用        4. Element：元素对象            1. 获取子元素对象                * getElementsByTag(String tagName)：根据标签名称获取元素对象集合                * getElementByAttribute(String key)：根据书写名称获取元素对象集合                * getElementByArributeValue(String key, String value)：根据对应的属性名和属性值获取元素对象集合                * getElementById(String id)：根据id属性值获取唯一的Element对象            2. 获取属性值                * String attr(String key)：根据属性名称获取属性值            3. 获取文本内容                * String text()：获取所有子标签的纯文本内容                * String html()：获取标签体的所有内容，包括子标签的标签和文本内容        5. Node：节点对象            * 是Document和Element的父类    * 快捷查询方式：        1. selector：选择器            * 使用的方法：Elements select(String cssQuery)                * 语法：参考Selector类中定义的语法        2. Xpath：XPath即为XML路径语言（XML Path Language），它是一种用来确定XML文档中某部分位置的语言。            * 使用Jsoup的Xpath需要额外导入jar包            * 查询w3cschool的参考手册，使用xpath语法完成查询</code></pre><hr><h2 id="Day-12-内容："><a href="#Day-12-内容：" class="headerlink" title="Day 12 内容："></a>Day 12 内容：</h2><pre><code>1. web相关概念回顾2. web服务器软件：Tomcat3. Servlet入门学习</code></pre><h3 id="web相关概念回顾"><a href="#web相关概念回顾" class="headerlink" title="web相关概念回顾"></a>web相关概念回顾</h3><pre><code>1. 软件架构    1. C/S：客户端/服务器端    2. B/S：浏览器/服务器端2. 资源分类    1. 静态资源    2. 动态资源3. 网络通信三要素    1. IP    2. 端口    3. 传输协议</code></pre><h3 id="web服务器软件"><a href="#web服务器软件" class="headerlink" title="web服务器软件"></a>web服务器软件</h3><pre><code>* 服务器：安装了服务器软件的计算机* 服务器软件：接收用户的请求，处理请求，做出响应* web服务器软件：接收用户的请求，处理请求，做出响应    * 在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目    * web容器* 常见的java相关的web服务器软件：    * webLogic：oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。    * webSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。    * JBOSS：JBOSS公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。    * Tomcat：Apache基金组织，中小型JavaEE服务器，仅支持少量的JavaEE规范servlet/jsp。开源的免费的。* JavaEE：Java语言在企业级开发中使用的技术规范的综合，一共规范了13项大的规范* Tomcat：web服务器软件    1. 下载：官网下载    2. 安装：解压压缩包即可        * 注意：安装目录建议不要有中文空格    3. 卸载：删除该目录    4. 启动        * bin/startup.bat，双击运行该文件即可        * 访问：http://localhost:8080 访问自己 http://其他ip:8080 访问别人        * 可能遇到的问题            1. 黑窗口一闪而过                * 原因：没有正确配置JAVA_HOME环境变量                * 解决方案：正确配置JAVA_HOME环境变量            2. 启动报错：                1. 暴力：找到占用端口的进程并杀死                    * netstat -ano                2. 温柔：修改自身的端口号                    * config/server.xml                    * 一般会将tomcat的默认端口号修改为80，为http协议的默认端口号                        * 好处：访问时不用输入端口号    5. 关闭        1. 正常关闭            * bin/shutdown.bat            * ctrl+c        2. 强制关闭            * 点击启动窗口的X按钮    6. 配置：        * 部署项目的方式：            1. 直接将项目放到webapps目录下即可。                * /hello：项目的访问路径--&gt;虚拟目录                * 简化部署：将项目打成war包，再将war包放置到webapps目录下。                    * war包会自动解压缩            2. 配置conf/server.xml文件                在&lt;Host&gt;标签体中配置                &lt;Context docBase=&quot;文件路径&quot; path=&quot;虚拟目录&quot;/&gt;            3. 在conf/Catalina/localhost创建任意名称的xml文件，在文件中编写                &lt;Context docBase=&quot;文件路径&quot; /&gt; 虚拟目录即文件名称        * 静态项目和动态项目：            * 目录结构                * java动态项目的目录结构：                    -- 项目的根目录                        -- WEB-INF目录：                            -- web.xml：web项目的核心配置文件                            -- class目录：防止字节码文件的目录                            -- lib目录：放置依赖的jar包        * 将Tomcat集成到IDEA中，并且创建JavaEE的项目，部署项目</code></pre><h3 id="Servlet：-server-applet"><a href="#Servlet：-server-applet" class="headerlink" title="Servlet： server applet"></a>Servlet： server applet</h3><pre><code>* 概念：运行在服务器端的小程序    * Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则    * 将来我们自定义一个类，实现Servlet接口，复写方法* 快速入门：    1. 创建JavaEE的项目    2. 定义一个类，实现Servlet接口    3. 实现接口中的抽象方法    4. 配置Servlet        在web.xml中配置        &lt;servlet&gt;            &lt;servlet-name&gt;demo1&lt;/servlet-name&gt;            &lt;servlet-class&gt;web.servlet.day11.ServletDemo1&lt;/servlet-class&gt;        &lt;/servlet&gt;        &lt;servlet-mapping&gt;            &lt;servlet-name&gt;demo1&lt;/servlet-name&gt;            &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt;        &lt;/servlet-mapping&gt;* 执行原理    1. 当服务器接收到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径    2. 查找web.xml文件，是否有对应的&lt;url-pattern&gt;标签体内容    3. 如果有，则找到对应的&lt;servlet-class&gt;全类名    4. tomcat会将字节码文件加载进内容，并且创建其对象    5. 调用其方法* Servlet的生命周期    1. 被创建：执行init方法，只执行一次        * Servlet什么时候被创建？            * 默认情况下，第一次被访问时，Servlet被创建            * 可以配置指定Servlet的创建时机                * 在&lt;servlet&gt;标签下配置                    1. 第一次被访问时创建                        * &lt;load-on-startup&gt; 值为负数                    2. 在服务器启动时创建                        * &lt;load-on-startup&gt; 值为0或正整数        * Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的            * 多个用户同时访问时，可能存在线程安全问题            * 解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对其修改值    2. 提供服务：执行service方法，执行多次        * 每次访问Servlet时，Service方法都会被调用一次    3. 被销毁：执行destroy方法，只执行一次        * Servlet被销毁时执行。服务器关闭时，Servlet被销毁。        * 只有服务器正常关闭时，才会执行destroy方法。        * destroy方法在Servlet被销毁之前之前，一般用于释放资源。* Servlet3.0：    * 好处：        * 支持注解配置。可以不需要web.xml了。    * 步骤：        1. 创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml        2. 定义一个类，实现Servlet接口        3. 复写方法        4. 在类上使用@WebServlet注解，进行配置            * @WebServlet(&quot;资源路径&quot;)### IDEA与tomcat相关配置    1. IDEA会为每一个tomcat部署的项目建立一份配置文件        * 查看控制台的log:C:\Users\xxx\AppData\Local\JetBrains\IntelliJIdea2020.1\tomcat\_idea_JavaWeb    2. 工作空间项目    和     tomcat部署的web项目        * tomcat真正访问的是&quot;tomcat部署的web项目&quot;，&quot;tomcat部署的web项目&quot;对应着&quot;工作空间项目&quot;中web目录的资源        * WEB-INF目录下的资源无法被浏览器直接访问    3. 断点调试：使用&quot;小虫子&quot;启动debug启动</code></pre><hr><h2 id="Day-13-内容："><a href="#Day-13-内容：" class="headerlink" title="Day 13 内容："></a>Day 13 内容：</h2><pre><code>1. Servlet2. HTTP协议3. Request</code></pre><h3 id="Servlet："><a href="#Servlet：" class="headerlink" title="Servlet："></a>Servlet：</h3><pre><code>1. 概念2. 步骤3. 执行原理4. 生命周期5. Servlet3.0注解配置6. Servlet的体系结构    Servlet -- 接口        |    GenericServlet -- 抽象类        |    HttpServlet -- 抽象类    * GenericServlet：将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象        * 将来定义Servlet类时，可以继承GenericServlet，实现service()方法即可    * HttpServlet：对HTTP协议的一种封装，简化操作        1. 定义类继承HttpServlet        2. 复写doGet/doPost()方法7. Servlet相关配置    1. urlpartten：Servlet访问路径        * 一个Servlet可以定义多个访问路径 @WebServlet({&quot;/x&quot;,&quot;/xx&quot;})        * 路径定义规则            1. /xxx            2. /xxx/xxx 多层路径            3. *.do 必须在后面加.do才能访问</code></pre><h3 id="HTTP："><a href="#HTTP：" class="headerlink" title="HTTP："></a>HTTP：</h3><pre><code>* 概念：Hyper Text Transfer Protocol 超文本传输协议    * 传输协议：定义了，客户端和服务器端通信时，发送数据的格式    * 特点:        1. 基于TCP/IP的高级协议        2. 默认端口号：80        3. 基于请求/响应模型的：一次请求对应一次响应        4. 无状态的：每次请求之间相互独立，不能交互数据    * 历史版本：        * 1.0：每次请求响应都会建立新的连接        * 1.1：复用连接* 请求消息数据格式    1. 请求行        请求方式 请求url 请求协议/版本        GET /login.html HTTP/1.1        * 请求方式：            * HTTP协议有7种请求方式，常用的有两种                * GET                    1. 请求参数在请求行中，在url后。                    2. 请求的url长度有限制的                    3. 不太安全                * POST                    1. 请求参数在请求体中                    2. 请求的url长度是没有限制的                    3. 相对安全    2. 请求头：客户端浏览器告诉服务器一些信息        请求头名称: 请求头值        * 常见的请求头            1. User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息                * 可以在服务器端获取该头的信息，解决浏览器的兼容性问题            2. Refer:                * 告诉服务器，我(当前请求)从哪里来？                * 作用：                    1. 防盗链                    2. 统计工作    3. 请求空行        空行，就是用于分割POST请求的请求头和请求体的    4. 请求体(正文)        * 封装POST请求消息的请求参数的    * 字符串格式        GET /login.html HTTP/1.1        Host: localhost        ...: ...        username=zhangsan* 响应消息数据格式</code></pre><h3 id="Request："><a href="#Request：" class="headerlink" title="Request："></a>Request：</h3><pre><code>1. request对象和response对象的原理    1. request和response两个对象是由服务器创建的，我们来使用它们    2. request对象是来获取请求消息，response对象是来设置响应消息2. request对象继承体系结构    ServletRequest    -- 接口        | 继承    HttpServletRequest    -- 接口        | 实现    org.apache.catalina.connector.RequestFacade 类(tomcat)3. request功能：获取请求消息    1. 获取请求消息数据        1. 获取请求行数据            * GET /day14/demo1?name=zhangsan HTTP/1.1            * 方法：                1. 获取请求方式：GET                    * String getMethod()                2. (*)获取虚拟目录: /day14                    * String getContextPath()                3. 获取Servlet路径：/demo1                    * String getServletPath()                4. 获取get方式请求参数：name=zhangsan                    * String getQueryString()                5. (*)获取请求URI：/day14/demo1                    * String getRequestURI() :/day14/demo1                    * StringBuffer getRequestURL() :http://localhost/day14/demo1                    * URL：统一资源定位符                    * URI：统一资源标识符                6. 获取协议及版本：HTTP/1.1                    * String getProtocol()                7. 获取客户机ip地址                    * String getRemoteAddr()        2. 获取请求头数据            * 方法：                * (*)String getHeader(String name):通过请求头名称获取请求头的值                * Enumeration&lt;String&gt; getHeaderName():获取所有的请求头名称        3. 获取请求体数据            * 请求体：只有POST请求方式，菜有请求体，在请求体中封装了POST请求的请求参数            * 步骤：                1. 获取流对象                    * BufferReader getReader() :获取字符输入流，只能操作字符数据                    * ServletInputStream getInputStream() :获取字节输入流，可以操作所有数据                        * 在文件上传知识点后讲解                2. 再从流对象中拿数据    2. 其他功能：        1. 获取请求参数通用方式：不论get还是post请求方式都可以使用下列方法获取请求参数            1. String getParameter(String name): 根据参数名称获取参数值            2. String[] getParameterValues(String name): 根据参数名称获取参数值的数组            3. Enumeration&lt;String&gt; getParameterValueNames(): 获取所有的参数名称            4. Map&lt;String, String[]&gt; getParameterMap(): 获取所有参数的键值对集合            * 中文乱码问题：                * get方式：tomcat 8 已经将get方式乱码问题解决了                * post方式：会乱码                    * 解决：在设置参数前，设置request的编码request.setCharacterEncoding(&quot;utf-8&quot;);        2. 请求转发：一种在服务器内部的资源跳转方式            1. 步骤：                1. 通过request对象来获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path)                2. 使用RequestDispatcher对象进行转发：forward(ServletRequest request, ServletResponse response)            2. 特点：                1. 浏览器地址栏路径不发生变化                2. 只能转发到当前的服务器内部资源中                3. 转发是一次请求        3. 共享数据：            * 域对象：一个有作用范围的对象，可以在范围内共享数据            * request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据            * 方法：                1. void setAttribute(String name, Object obj): 存储数据                2. Object getAttribute(String name): 通过键获取值                3. void removeAttribute(): 通过键移除键值对        4. 获取ServletContext：            * ServletContext getServletContext()</code></pre><h3 id="案例：用户登录"><a href="#案例：用户登录" class="headerlink" title="案例：用户登录"></a>案例：用户登录</h3><pre><code>* 用户登录案例需求    1. 编写login.html登录界面        username &amp; password 两个输入框    2. 使用Druid数据库连接池技术，操作mysql，day14数据库中user表    3. 使用JdbcTemplate技术封装JDBC    4. 登录成功跳转到SuccessServlet展示：登录成功！用户名，欢迎您    5. 登录失败跳转到FailServlet展示：登录失败！用户名或密码错误* 分析* 开发    1. 创建项目，导入jar包，配置文件，创建html页面    2. 创建数据库环境    3. 创建包domain，创建类User    4. 创建包dao，创建类UserDao，提供login方法    5. 创建包util，创建类JDBCUtils，使用Druid连接池    6. 创建包web.servlet，创建类LoginServlet，完成登录具体逻辑    7. login.html中form表单的action路径写法        * 虚拟目录+Servlet的路径    8. BeanUtils工具类，简化数据封装        * 用于封装JavaBean        1. JavaBean：标准的Java类            1. 要求：                1. 类必须被public修饰                2. 必须提供空参的构造器                3. 成员变量必须使用private修饰                4. 提供公共的getter/setter方法            2. 功能：封装数据        2. 概念：            成员变量：            属性：setter/getter方法截取后的产物                例如：getUsername() --&gt; Username --&gt; username        3. 方法：            1. setProperty()            2. getProperty()            3. populate(Object obj, Map map)：将map集合的键值对信息，封装到对应的JavaBean对象中</code></pre><hr><h2 id="Day-14-内容："><a href="#Day-14-内容：" class="headerlink" title="Day 14 内容："></a>Day 14 内容：</h2><pre><code>1. HTTP协议：响应消息2. Response对象3. ServletContext对象</code></pre><h3 id="HTTP协议："><a href="#HTTP协议：" class="headerlink" title="HTTP协议："></a>HTTP协议：</h3><pre><code>1. 请求消息：客户端发送给服务器端的数据    * 数据格式：        1. 请求行        2. 请求头        3. 请求空行        4. 请求体2. 响应消息：服务器端发送给客户端的数据    * 数据格式        1. 响应行            1. 组成：协议/版本 响应状态码 状态码描述            2. 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态                1. 状态码都是3位数字                2. 分类：                    1. 1xx：服务器接收客户端消息，但没有接收完成，等待一段时间后，发送1xx状态码                    2. 2xx：成功。代表：200                    3. 3xx：重定向。代表：302(重定向)，304(访问缓存)                    4. 4xx：客户端错误。                        * 代表：                            * 404(路径没有对应的资源)，                            * 405(请求方式没有对应的doXxx方法)                    5. 5xx：服务器端错误。代表：500(服务器内部出现异常)        2. 响应头            1. 格式：头名称: 值            2. 常见的响应头：                1. Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式                2. Content-disposition：服务器告诉客户端以什么格式打开响应体数据                    * 值：                        * in-line：默认值在当前页面内打开                        * attachment;filename=xxx：以附件形式打开响应体。文件下载        3. 响应空行        4. 响应体：传输的数据    * 响应字符串格式        xxx</code></pre><h3 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a>Response对象</h3><pre><code>* 功能：设置响应消息    1. 设置响应行        1. 格式：HTTP/1.1 200 ok        2. 设置状态码：setStatus(int sc)    2. 设置响应头：setHeader(String name, String value)    3. 设置响应体:        * 使用步骤：            1. 获取输出流                * 字符输出流：PrintWriter getWriter()                * 字节输出流：ServletOutputStream getOutputStream()            2. 使用输出流，将数据输出到客户端浏览器中* 案例    1. 完成重定向        * 重定向：资源跳转的方式        * 代码实现：            response.sendRedirect(&quot;重定向的地址&quot;);        * 重定向的特点            1. 地址栏发生变化            2. 重定向可以访问其他站点(服务器)的资源            3. 重定向是两次请求，不能使用request对象来共享数据        * 转发的特点：            1. 转发地址栏路径不变            2. 转发只能访问当前服务器下的资源            3. 转发是一次请求，可以使用requset对象来共享数据        * forward 和 redirect 区别        * 路径写法            1. 路径分类                1. 相对路径：通过相对路径不能确定唯一资源                    * 如 ./index.html                    * 不以/开头，以.开头                    * 规则：找到当前资源和目标资源之间的相对位置关系                        * ./：当前目录                        * ../：后退一级目录                2. 绝对路径：通过绝对路径可以确定唯一资源                    * 如 http://localhost/...                    * 以/开头的路径                    * 规则：判断定义的路径是给谁用的？判断请求将来从哪发出                        * 给客户端浏览器使用：需要加虚拟目录（项目的访问路径）                            * 建议虚拟目录动态获取：request.getContextPath()                            * &lt;a&gt;，重定向                        * 给服务器使用：不需要加虚拟目录                            * 转发路径    2. 服务器输出字符数据到浏览器        * 步骤：            1. 获取字符输出流            2. 输出数据        * 注意            * 乱码问题                1. 获取的流的默认编码为ISO-8859-1                2. 设置该流的默认编码                3. 告诉浏览器响应体使用的编码                // 在获取流之前设置                response.setContentType(&quot;text/html;charset=utf-8&quot;);    3. 服务器输出字节数据到浏览器        * 步骤：            1. 获取字节输出流            2. 输出数据    4. 验证码        1. 本质：图片        2. 目的：防止恶意表单注册</code></pre><h3 id="ServletContext对象"><a href="#ServletContext对象" class="headerlink" title="ServletContext对象"></a>ServletContext对象</h3><pre><code>1. 概念：代表整个web应用，可以和程序的容器(服务器)通信2. 获取：    1. 通过request的对象获取        request.getServletContext();    2. 通过HttpServlet获取        this.getServletContext();3. 功能：    1. 获取MIME类型：        * MINE类型：在互联网通信过程中定义的一种文件数据类型            * 格式：大类型/小类型    image/jpeg        * 获取：String         * getMimeType(String file)    2. 域对象：共享数据        1. setAttribute()        2. getAttribute()        3. removeAttribute()        * ServletContext对象范围：所有用户所有请求的数据    3. 获取文件的真实(服务器)路径         1. 方法：String getRealPath(String path)            * web目录 -- /xxx.xxx            * WEB-INF目录 -- /WEB-INF/xxx.xxx            * src目录 -- /WEB-INF/classes/xxx.xxx</code></pre><h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><pre><code>* 文件下载雪球    1. 页面显示超链接    2. 点击超链接弹出下载提示框    3. 完成图片文件下载* 分析：    1. 超链接指向的资源如果能够被浏览器解析，则在浏览器中展示，如果不能解析，则弹出下载    2. 任何资源都必须弹出下载提示框    3. 使用响应头设置资源的打开方式：        * content-disposition:attachment;filename=xxx* 步骤    1. 定义页面，编写href属性，指向Servlet，传递资源名称filename    2. 定义Servlet        1. 获取文件名称        2. 使用字节输入流加载文件进内存        3. 指定response的响应头 content-disposition:attachment;filename=xxx        4. 将数据写出到response输出流* 问题：    * 中文文件名        * 解决思路：            1. 获取客户端使用的浏览器版本信息            2. 根据不同的版本信息，设置filename编码方式不同</code></pre><hr><h2 id="Day-15-内容："><a href="#Day-15-内容：" class="headerlink" title="Day 15 内容："></a>Day 15 内容：</h2><pre><code>1. 会话技术    1. Cookie    2. Session2. JSP：入门学习</code></pre><h3 id="会话技术"><a href="#会话技术" class="headerlink" title="会话技术"></a>会话技术</h3><pre><code>1. 会话：一次会话中包含多次请求和响应。    * 一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止2. 功能：在一次会话的范围内的多次请求间，共享数据3. 方式：    1. 客户端会话技术：Cookie    2. 服务器端会话技术：Session</code></pre><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><pre><code>1. 概念：客户端会话技术，将数据保存在客户端2. 快速入门：    * 使用步骤        1. 创建Cookie对象，绑定数据            * new Cookie(String name, String name)        2. 发送Cookie对象            * response.addCookie(Cookie cookie)        3. 获取Cookie，拿到数据            * Cookie[] request.getCookies()3. 实现原理    * 基于响应头set-cookie和请求头cookie实现4. cookie的细节    1. 一次可不可以发送多个cookie        * 可以        * 可以创建多个cookie对象，使用response调用多次addCookie方法发送cookie即可    2. cookie在浏览器中保存多长时间        1. 默认情况，当浏览器关闭后，Cookie数据被销毁        2. 持久化存储：            * setMaxAge(int second)                1. 正数：将Cookie数据写到硬盘的文件中。持久化存储。cookie存活时间                2. 负数：默认值                3. 零：删除cookie信息    3. cookie能不能存中文        * 在tomcat8之前，cookie中不能直接存储中文数据。            * 需要将中文数据转码 -- 一般采用url编码        * 在tomcat8之后，cookie中支持存储中文数据。但还是不支持特殊字符，建议使用url编码。    4. cookie共享问题        1. 假设在一个tomcat服务器中部署了多个web项目，那么在这些项目中，cookie能不能共享            * 默认情况cookie不能共享            * setPath(String path) : 设置cookie的共享范围，默认情况下设置当前的虚拟目录                * 如果要共享，则可以将path设置为&quot;/&quot;        2. 不同的tomcat服务器cookie共享问题            * setDomain(String path)：如果设置一级域名相同，那么多个服务器之间cookie可以共享                * setDomain(&quot;.baidu.com&quot;)，那么tieba.baidu.com和news.baidu.com中cookie可以共享5. cookie的特点和作用    1. cookie存储数据在客户端浏览器    2. 浏览器对于单个cookie的大小有限制(4kb)，以及对同一个域名下的总cookie的数量也有限制(20)    * 作用：        1. cookie一般用于存储少量的不太敏感的数据        2. 在不登录的情况下，完成服务器对客户端的身份识别6. 案例：记住上一次访问时间    1. 需求：        1. 访问一个Servlet，如果是第一次访问，则提示：您好，欢迎你首次访问。        2. 如果不是第一次访问，则提示：欢迎回来，您上次访问时间为：显示时间字符串。    2. 分析：        1. 可以采用cookie来完成        2. 在服务器中的Servlet判断是否有一个名为lastTime的cookie            1. 有，不是第一次访问                1. 响应数据：欢迎回来，您上次访问时间为...                2. 写回cookie：lastTime=...            2. 没有，是第一次访问                1. 响应数据：您好，欢迎您首次访问                2. 写回cookie：lastTime=...    3. 代码        /**         * cookie实现访问时间显示         */        @WebServlet(&quot;/CookieServlet&quot;)        public class CookieServlet extends HttpServlet {            protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {                response.setContentType(&quot;text/html;charset=utf-8&quot;);                Cookie[] cookies = request.getCookies();                boolean flag = false;                for (Cookie cookie : cookies) {                    if(&quot;lastTime&quot;.equals(cookie.getName())){                        flag = true;                        String decode = cookie.getValue();                        String time = URLDecoder.decode(decode, &quot;utf-8&quot;);                        response.getWriter().write(&quot;您好，您上次访问时间为&quot; + time);                        Date date = new Date();                        SimpleDateFormat s = new SimpleDateFormat(&quot;yyyy年MM月dd日 hh:mm:ss&quot;);                        time = s.format(date);                        String encode = URLEncoder.encode(time, &quot;utf-8&quot;);                        System.out.println(time);                        System.out.println(encode);                        cookie.setValue(encode);                        response.addCookie(cookie);                        break;                    }                }                if(cookies.length == 0 || cookies == null || !flag){                    Date date = new Date();                    SimpleDateFormat s = new SimpleDateFormat(&quot;yyyy年MM月dd日 hh:mm:ss&quot;);                    String time = s.format(date);                    String encode = URLEncoder.encode(time, &quot;utf-8&quot;);                    System.out.println(time);                    Cookie c = new Cookie(&quot;lastTime&quot;, encode);                    response.addCookie(c);                    response.getWriter().write(&quot;您好，欢迎您首次访问！&quot;);                }            }            protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {                doPost(request, response);            }        }</code></pre><h3 id="JSP：入门学习"><a href="#JSP：入门学习" class="headerlink" title="JSP：入门学习"></a>JSP：入门学习</h3><pre><code>1. 概念：    * Java Server Pages：java服务器端页面        * 可以理解为：一个特殊的页面，其中既可以指定定义html标签，又可以定义java代码        * 用于简化书写！！！2. 原理：    * JSP本质上就是一个Servlet3. JSP的脚本：JSP定义Java代码的方式    1. &lt;% 代码 %&gt;：定义的Java代码，在service方法中。service可以定义什么，该脚本中就可以定义什么。    2. &lt;%! 代码 %&gt;：定义的Java代码，在jsp转换后的java类的成员位置。    3. &lt;%= 代码 %&gt;：定义的Java代码，会输出到页面上。输出语句中可以定义什么，该脚本中就可以定义什么。4. JSP的内置对象    * 在jsp页面中不需要获取和创建就可以使用的对象    * jsp一共有9个内置对象    * 今天学习3个：        * request        * response        * out：字符输出流对象。可以将数据输出到页面上。和response.getWriter().write()类似            * response.getWriter().write()和out.write()的区别:                * 在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据。                * response.getWriter().write()数据输出永远在out.write()之前</code></pre><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><pre><code>1. 概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession2. 快速入门：    1. 获取HttpSession对象        * request.getSession()    2. 使用HttpSession对象        getAttribute()        setAttribute()        removeAttribute()3. 原理    * Session的实现是依赖于Cookie的。JSESSIONID4. 细节    1. 当客户端关闭后，服务器不关闭，两次获取的session是否是同一个        * 默认情况下不是。        * 如果需要相同，则可以创建cookie，键为JSESSIONID，设置最大存活时间，让cookie持久化保存。    2. 客户端不关闭，服务器关闭后，两次获取的session是同一个吗        * 不是同一个，但是要确保数据不丢失            * session的钝化：                * 服务器正常关闭之前，将session对象序列化到硬盘上            * session的活化：                * 在服务器正常启动后，将session文件转化为内存中的session对象即可。    3. session什么时候被销毁        1. 服务器关闭        2. session对象调用invalidate()        3. session默认失效时间 30分钟            选择性配置修改            web.xml -- &lt;session-config&gt;5. session的特点    1. session用于存储一次会话的多次请求的数据，存在服务器端    2. session可以存储任意类型，任意大小的数据        * session和cookie的区别            1. session存储数据在服务器端，而cookie在客户端            2. session没有数据大小限制，cookie有            3. session数据安全，cookie相对于不安全</code></pre><h3 id="案例：验证码"><a href="#案例：验证码" class="headerlink" title="案例：验证码"></a>案例：验证码</h3><pre><code>1. 案例需求    1. 访问带有验证码的登陆页面index.jsp    2. 用户输入用户名，密码以及验证码。        * 如果用户名和密码输入有误，跳转登录页面，提示：用户名或密码错误        * 如果验证码输入有误，则跳转登录页面，提示：验证码错误        * 如果全部输入正确，则跳转到success.jsp，显示：用户名，欢迎您2. 分析</code></pre><hr><h2 id="Day-16-内容："><a href="#Day-16-内容：" class="headerlink" title="Day 16 内容："></a>Day 16 内容：</h2><pre><code>1. JSP：    1. 指令    2. 注释    3. 内置对象2. MVC开发模式3. EL表达式4. JSTL标签5. 三层架构</code></pre><h3 id="JSP："><a href="#JSP：" class="headerlink" title="JSP："></a>JSP：</h3><pre><code>1. 指令    * 作用：用于配置JSP页面，导入资源文件    * 格式：        &lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2 ... %&gt;    * 分类        1. page        ：配置JSP页面的            * contentType：等同于response.setContentType()                1. 设置响应体的mime类型以及字符集                2. 设置当前jsp页面的编码（只能是高级的IDE才能生效，如果使用低级工具，则需要配置pageEncoding设置当前页面的字符集）            * import：导包            * erroePage：当前页面发生异常后，会自动跳转到指定的错误页面            * isErrorPage：标识当前页面是否是错误页面。                * true：是，可以使用内置对象exception。                * false：否。默认值，不能使用exception对象。        2. include  ：页面包含的。导入页面的资源文件            * &lt;%@inlcude file=&quot;top.jsp&quot; %&gt;        3. taglib    ：导入资源            * &lt;%@ tablib prefix=&quot;c&quot; uri=&quot;...&quot; %&gt;                * prefix：前缀2. 注释    1. html注释：        &lt;!-- --&gt;：只能注释html代码片段    2. jsp注释：推荐使用        &lt;%-- --%&gt;：可以注释所有3. 内置对象    * 在jsp页面中不需要创建，直接使用的对象    * 一共有9个：            变量名                    真实类型                    作用        * pageContext            PageContext                    当前页面共享数据，可以获取其他8个对象        * request                HttpRequest                    一次请求访问的多个资源(转发)        * session                HttpSession                    一次会话的多个请求间        * application            ServletContext                所有用户间共享数据        * response                HttpResponse                响应对象        * page                    Object                        当前页面(Servlet)的对象        * out                    JspWriter                    输出对象，数据输出到页面上        * config                ServletConfig                异常对象    Servlet的配置对象        * exception                Throwable</code></pre><h3 id="MVC：开发模式"><a href="#MVC：开发模式" class="headerlink" title="MVC：开发模式"></a>MVC：开发模式</h3><pre><code>1. jsp演变历史    1. 早期只有Servlet，只能使用response输出标签数据，非常麻烦    2. 后来有了jsp，简化了Servlet的开发，如果过度使用jsp，在jsp中既写大量java代码，又写html，造成难以维护，难以分工协作。    3. 再后来，java的web开发借鉴mvc开发模式，使得程序的设计更加合理2. MVC：    1. M：model，模型。JavaBean        * 完成具体的业务操作，如：查询数据库，封装对象    2. V：view，视图。JSP        * 展示数据    3. C：Controller，控制器。Servlet        * 获取用户的输入        * 调用模型        * 将数据交给视图进行展示    * 优缺点    1. 优点：        1. 耦合性低，方便维护，可以利于分工协作        2. 重用性高    2. 缺点：        1. 使得项目架构变得复杂，对开发人员要求高</code></pre><h3 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h3><pre><code>1. 概念：Expression Language 表达式语言2. 作用：替换和简化jsp页面中java代码的编写3. 语法：${表达式}4. 注意：    * jsp默认是支持EL表达式的。如果要忽略EL表达式        1. 设置jsp中page指令中：isELIgnored=“true” 忽略所有的el表达式        2. \${表达式}：忽略当前这个el表达式5. 使用    1. 运算        * 运算符：            1. 算数运算符： + - * /(div) %(mod)            2. 比较运算符： &gt; &lt; &gt;= &lt;= == !=            3. 逻辑运算符：&amp;&amp;(and) ||(or) !(not)            4. 空运算符：empty                * 功能：用于判断字符串、集合、数组对象是否为null或者长度是否为0                * ${empty list}：判断字符串、集合、数组对象是否为null或者长度是否为0                * ${not empty list}：判断字符串、集合、数组对象是否不为null，且长度大于0    2. 获取值        1. el表达式只能从域对象中获取值        2. 语法：            1. ${域名称.键名}：从指定域中获取指定键的值                * 域名称：                    1. pageScope        --&gt;    pageContext                    2. requestScope        --&gt;    request                    3. sessionScope        --&gt;    session                    4. applicationScope    --&gt;    application (ServletContext)                * 举例：在requset域中存储了name=张三                * 获取：${requestScope.name}            2. ${键名}：表示依次从最小的域中查找是否有该键对应的值，直到找到为止。            3. 获取对象、list集合、Map集合的值                1. 对象：${域名称.键名.属性名}                    * 本质上会去调用对象的getter方法                2. List集合：${域名称.键名[索引]}                3. Map集合：                    * ${域名称.键名.key名称}                    * ${域名称.键名[&quot;key名称&quot;]}        3. 隐式对象：            * el表达式中有11个隐式对象            * pageContext：                * 获取jsp其他8个内置对象                    * ${pageContext.request.contextPath}：动态获取虚拟目录</code></pre><h3 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a>JSTL</h3><pre><code>1. 概念：JavaServer Pages Tag Library JSP标准标签库    * 是由Apache组织提供的开源的免费的jsp标签2. 作用：用于简化和替换jsp页面上的java代码3. 使用步骤：    1. 导入JSTL相关jar包    2. 引入标签库：taglib指令    &lt;%@ taglib %&gt;    3. 使用标签4. 常用的JSTL标签    1. if            相当于Java代码的if语句        1. 属性：            * test 必须属性，接收boolean表达式                * 如果表达式为true，则显示if标签体内内容                * 如果为false则不展示                * 一般情况下，test属性会结合el表达式一起使用        2. 注意：c:if标签没有else情况，若需要，可以再定义一个c:if标签    2. choose        相当于Java代码的switch语句        1. 使用choose标签声明                        相当于switch声明        2. 使用when标签做判断                        相当于case        3. 使用otherwise标签做其他情况的声明        相当于default    3. foreach        相当于Java代码的for语句        1. for(int i=0; i&lt;5; i++)            * 属性：                * begin、end、step、var                * varStatus                    * index：索引                    * count：循环次数        2. for(User user : list)            * 属性：                * items --&gt; list                * var --&gt; user                * varStatus                    * 同上5. 练习：    * 需求：再request域中有一个存User对象的List集合。需要使用jstl和el将list集合数据展示到jsp页面的表格table中。</code></pre><h3 id="三层架构：软件设计架构"><a href="#三层架构：软件设计架构" class="headerlink" title="三层架构：软件设计架构"></a>三层架构：软件设计架构</h3><pre><code>1. 界面层(表示层)：用户看到的界面。用户可以通过界面上的组件和服务器进行交互2. 业务逻辑层：处理业务逻辑的。3. 数据访问层：操作数据存储文件的。</code></pre><p><img src="https://i.loli.net/2020/07/26/OnQ9LogXNdtaIjB.png" alt="1.png"></p><h3 id="案例：用户信息列表展示"><a href="#案例：用户信息列表展示" class="headerlink" title="案例：用户信息列表展示"></a>案例：用户信息列表展示</h3><pre><code>1. 需求：用户信息的增删改查操作2. 设计：    1. 技术选型：Servlet + JSP + Mysql + JDBCTemplate + Druid + BeanUtils + Tomcat    2. 数据库设计：        create database day17;    -- 创建数据库        use day17;    -- 使用数据库        create table user(    -- 创建表            id int primary key auto_increment,            name varchar(32) not null,            gender varchar(5),            age int,            address varchar(32),            qq varchar(20),            email varchar(50),        );3. 开发：    1. 环境搭建        1. 创建数据库环境        2. 创建项目，导入需要的jar包    2. 编码4. 测试5. 部署运维</code></pre><hr><h2 id="Day-17-内容："><a href="#Day-17-内容：" class="headerlink" title="Day 17 内容："></a>Day 17 内容：</h2><pre><code>1. 综合练习    1. 简单功能        1. 列表查询        2. 登录        3. 添加        4. 删除        5. 修改    2. 复杂功能        1. 删除选中        2. 分页查询            * 好处：                1. 减轻服务器内存的开销                2. 提升用户体验        3. 复杂条件查询</code></pre><h3 id="2-登录"><a href="#2-登录" class="headerlink" title="2. 登录"></a>2. 登录</h3><pre><code>1. 调整页面，加入验证码功能2. 代码实现</code></pre><hr><h2 id="Day-18-内容："><a href="#Day-18-内容：" class="headerlink" title="Day 18 内容："></a>Day 18 内容：</h2><pre><code>1. Filter：过滤器2. Listener：监听器</code></pre><h3 id="Filter：过滤器"><a href="#Filter：过滤器" class="headerlink" title="Filter：过滤器"></a>Filter：过滤器</h3><pre><code>1. 概念：    * 生活中的过滤器：净水器、空气净化器、土匪    * web中的过滤器：当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊功能。    * 过滤器的作用：        * 一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤...2. 快速入门：    1. 步骤：        1. 定义一个类，实现接口Filter        2. 复写方法        3. 配置拦截路径            1. web.xml            2. 注解3. 过滤器细节：    1. web.xml配置        * 和Servlet配置相似    2. 过滤器执行流程        1. 执行过滤器        2. 执行放行后的资源        3. 执行过滤器放行代码下方的代码    3. 过滤器生命周期方法        1. init：在服务器启动后，创建filter对象，调用该方法，只调用一次        2. doFilter：每一次请求被拦截都会执行，执行很多次        3. 在服务器关闭后，Filter对象被销毁，正常关闭的前提下，会执行一次    4. 过滤器配置详解        * 拦截路径配置：            1. 具体资源路径：/index.jsp            2. 目录拦截：/user/*    访问/user下的所有资源时，过滤器都会被执行            3. 后缀名拦截：*.jsp    访问所有后缀名为jsp资源时，过滤器都会被执行            4. 拦截所有资源：/*        * 拦截方式配置：资源被访问的方式            * 注解配置：                * 设置dispatcherTypes属性                    1. REQUEST：默认值。浏览器直接请求资源                    2. FORWARD：转发访问资源                    3. INCLUDE：包含访问资源                    4. ERROR：错误跳转资源                    5. ASYNC：异步访问资源            * web.xml配置                * 设置dispatcher标签即可    5. 过滤器链（配置多个过滤器）        * 执行顺序：如果有两个过滤器——过滤器1和过滤器2            1. 过滤器1            2. 过滤器2            3. 资源            4. 过滤器2            5. 过滤器1        * 过滤器先后顺序：            1. 注解配置：按照类名的字符串比较规则比较，值小的先执行                如：AFilter 和 BFilter，AFilter先执行            2. web.xml配置：谁定义在上谁先执行4. 案例    1. 案例1_登录验证        * 需求            1. 访问day17_case案例的资源，验证其是否登录            2. 如果登录，则放行            3. 否则，跳转到登录界面，提示“您尚未登录，请先登录”    2. 案例2_过滤敏感词汇        * 需求：            1. 对day17_case案例录入的数据进行敏感词汇过滤            2. 敏感词汇参考《敏感词汇.txt》            3. 如果时敏感词汇，替换为 ***        * 分析：            1. 对request对象进行增强。增强获取参数相关方法即可            2. 放行。传递代理对象        * 增强对象的功能：            * 设计模式：一些通用的解决固定问题的方式            1. 装饰模式            2. 代理模式                * 概念：                    1. 真实对象：被代理的对象                    2. 代理对象                    3. 代理模式：代理对象代理真实对象，达到增强真实对象功能的目的                * 实现方式：                    1. 静态代理：有一个类文件描述代理模式                    2. 动态代理：在内存中形成代理类                        * 实现步骤：                            1. 代理对象和真实对象实现相同的接口                            2. 代理对象 = Proxy.newProxyInstance();                            3. 使用代理对象调用方法                            4. 增强方法                        * 增强方式：                            1. 增强参数列表                            2. 增强返回值类型                            3. 增强方法体执行逻辑</code></pre><h3 id="Listener：监听器："><a href="#Listener：监听器：" class="headerlink" title="Listener：监听器："></a>Listener：监听器：</h3><pre><code>* 概念：web的三大组件之一。    * 事件监听机制        * 事件：一件事        * 事件源：事件发生的地方        * 监听器：一个对象        * 注册监听：将事件、事件源、监听器绑定在一起。当事件源上发生一个事件后，执行监听器代码* ServletContextListener：监听ServletContext对象的创建和销毁    * 方法        * void contextDestroyed(ServletContextEvent sce) :对象被销毁前调用        * void contextInitialized(ServletContextEvent sce) :对象被创建后调用    * 步骤：        1. 定义一个类，实现ServletContextListener接口        2. 复写方法        3. 配置            1. web.xml：&lt;listener&gt;标签                * 指定初始化参数    &lt;context-param&gt;标签            2. 注解：@WebListener</code></pre><hr><h2 id="Day-19-内容："><a href="#Day-19-内容：" class="headerlink" title="Day 19 内容："></a>Day 19 内容：</h2><pre><code>1. JQuery 基础：    1. 基本概念：一个JavaScript框架。简化JS开发        * jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。        * JavaScript框架：本质上就是一些js文件，封装了js的原生代码而已。    2. 快速入门        1. 步骤：            1. 下载JQuery                * 目前三大版本：                    * 1.xx——使用广泛，功能不再新增                    * 2.xx——很少人使用                    * 3.xx——支持最新浏览器                * jquery-xxx.js 和 jquery-xxx.min.js区别：                    1. jquery-xxx.js：开发版本。有良好的缩进和注释                    2. jquery-xxx.min.js：生产版本。没有缩进，体积小。            2. 导入JQuery的js文件：导入min.js文件            3. 使用                var div1 = $(&quot;#div1&quot;)    3. JQuery对象和JS对象的区别和转换        1. JQuery对象在操作时更加方便        2. JQuery对象和js对象方法不通用        3. 两者相互转换            * js --&gt; jq : jq对象[索引] 或者 jq对象.get(索引)            * jq --&gt; js : $(js对象)    4. 选择器：筛选具有相似特征的元素(标签)        1. 基本语法学习：            1. 事件绑定            2. 入口函数                * window.onload() = func 和 $(func) 的区别                    * 前者只能定义一次，如果定义多次，后边的会将前边定义的覆盖                    * 后者则可以定义多次            3. 样式控制        2. 分类            1. 基本选择器                1. 标签选择器(元素选择器)                    * $(&quot;html便签名&quot;)                2. id选择器                    * $(&quot;#id值&quot;)                3. 类选择器                    * $(&quot;.class值&quot;)                4. 并集选择器                    * $(&quot;选择器1,选择器2...&quot;)            2. 层级选择器                1. 后代选择器                    * $(&quot;A B&quot;) 选择A元素内部的所有B元素                2. 子选择器                    * $(&quot;A &gt; B&quot;) 选择A元素下内部的所有B子元素            3. 属性选择器                1. 属性名称选择器                    * $(&quot;A[属性名]&quot;) 包含指定属性的选择器                2. 属性选择器                    * $(&quot;A[属性名=&apos;值&apos;]&quot;) 包含指定属性等于指定值的选择器                    * $(&quot;A[属性名^=&apos;值&apos;]&quot;) 属性值为指定值开头的选择器                    * $(&quot;A[属性名$=&apos;值&apos;]&quot;) 属性值为指定值结尾的选择器                    * $(&quot;A[属性名!=&apos;值&apos;]&quot;) 属性值不为指定值或者不存在该属性的选择器                    * $(&quot;A[属性名*=&apos;值&apos;]&quot;) 属性值包含指定值选择器                3. 复合属性选择器                    * $(&quot;A[属性名=&apos;值&apos;][]...&quot;)            4. 过滤选择器                1. 首元素选择器                    * :first                2. 尾元素选择器                    * :last                3. 非元素选择器                    * :not(selector)                4. 偶数选择器                    * :even                5. 奇数选择器                    * :odd                6. 等于索引选择器                    * :eq(index)                7. 大于索引选择器                    * :gt(index)                8. 小于索引选择器                    * :lt(index)                9. 标题选择器                    * :header 获取标题元素(h1~h6)            5. 表单过滤选择器                 1. 可用元素选择器                     * :enabled                 2. 不可用元素选择器                     * :disabled                 3. 选中选择器                     * :checked    单选/多选框                 4. 选中选择器                     * :selected 下拉列表    5. DOM操作        1. 内容操作            1. html()：获取/设置元素的标签体内容    &lt;a&gt;&lt;font&gt;xxx&lt;/font&gt;&lt;/a&gt;    --&gt;    &lt;font&gt;xxx&lt;/font&gt;            2. text()：获取/设置元素的标签体纯文本内容    &lt;a&gt;&lt;font&gt;xxx&lt;/font&gt;&lt;/a&gt;    --&gt;    xxx            3. val()：获取/设置元素的value属性值        2. 属性操作            1. 通用属性操作                1. attr()：获取/设置元素的属性                2. removeAttr()：删除属性                3. prop()：获取/设置元素的属性                4. removeProp()：删除属性                * attr和prop区别：                    1. 如果操作的是元素的固有属性，则建议使用prop                    2. 如果操作的是元素自定义的属性，则建议使用attr            2. 对class属性的操作                1. addClass()：添加class属性值                2. removeClass()：删除class属性值                3. toggleClass()：切换class属性值                    * toggleClass(&quot;one&quot;): 如果存在class=&quot;one&quot;则将属性值one删除，如果不存在，则添加。                4. css()        3. CRUD操作:            1. append():父元素将子元素追加到末尾                * 对象1.append(对象2)：将对象2添加到对象1元素内部，并且在末尾            2. prepend():父元素将子元素追加到开头                * 对象1.prepend(对象2)：将对象2添加到对象1元素内部，并且在开头            3. appendTo():                * 对象1.append(对象2)：将对象1添加到对象2元素内部，并且在末尾            4. prependTo():                * 对象1.prepend(对象2)：将对象1添加到对象2元素内部，并且在开头            5. after():添加元素到对应元素后边                * 对象1.after(对象2)：将对象2添加到对象1后边。对象1和对象2是兄弟关系            6. before():添加元素到对应元素前边                * 对象1.after(对象2)：将对象2添加到对象1前边。对象1和对象2是兄弟关系            7. insertAfter():                * 对象1.after(对象2)：将对象1添加到对象2后边。对象1和对象2是兄弟关系            8. insertBefore():                * 对象1.after(对象2)：将对象1添加到对象2前边。对象1和对象2是兄弟关系            9. remove():移除元素                * 对象.remove()：将对象删除掉            10. empty():清空元素的所有后代元素                * 对象.empty()：将对象的后代元素全部清空，但是保留当前对象以及其属性节点    6. 案例        重要案例 需要时进行查看p383-386</code></pre><hr><h2 id="Day-20-内容"><a href="#Day-20-内容" class="headerlink" title="Day 20 内容"></a>Day 20 内容</h2><pre><code>1. Jquery 高级    1. 动画        1. 默认显示和隐藏方式            1. show([speed, [easing], [fn]])                1. 参数                    1. speed：动画速度。三个预定义的值(&quot;slow&quot;,&quot;normal&quot;,&quot;fast&quot;)或表示动画时长的毫秒值                    2. easing：用来指定切换效果，默认是&quot;swing&quot;,可用参数&quot;linear&quot;                        * swing：动画执行时效果是先慢，中间快，最后又慢                        * linear：动画执行时速度匀速                    3. fn：在动画完成时执行的函数，每个元素执行一次            2. hide([speed, [easing], [fn]])            3. toggle([speed, [easing], [fn]])        2. 滑动显示和隐藏方式            1. slidDown([speed, [easing], [fn]])            2. slideUp([speed, [easing], [fn]])            3. slideToggle([speed, [easing], [fn]])        3. 淡入淡出显示和隐藏方式            1. fadeIn([speed, [easing], [fn]])            2. fadeOut([speed, [easing], [fn]])            3. fadeToggle([speed, [easing], [fn]])    2. 遍历        1. js的遍历方式            * for(初始化值;循环结束条件;步长)        2. jq的遍历方式            1. jq对象.each(callback)                1. 语法：                    jquery对象.each(function(index, element){});                        * index:索引                        * element:元素对象                        * this:每一个元素对象                2. 回调函数返回值：                    * true：结束循环-break                    * false：结束本次循环，继续下次循环-continue            2. $.each(object, [callback])                * object可以为jq对象也可为js对象            3. for..of    3. 事件绑定        1. jquery标准的绑定方式            jq对象.事件方法(回调函数);            * 注：如果调用事件方法，不传递回调函数，则会触发浏览器默认行为                * 表单对象.submit();//表单提交        2. on绑定事件/off解除绑定            jq对象.on(&quot;事件名称&quot;, 回调函数);            jq对象.off(&quot;事件名称&quot;);                * 如果off方法不传递任何参数，则将组件上所有事件解绑        3. 事件切换：toggle            * jq对象.toggle(fn1, fn2, ...)                * 当单击jq对象对应的组件后，会执行fn1，第二次点击执行fn2....            * 注意该方法在1.9及以上的高版本被移除，需要使用jquery-migrate插件才能生效    4. 案例        抽奖小案例    5. 插件：增强jquery的功能        1. 实现方式：            1. $.fn.extend(object)                * 增强通过JQuery获取的对象的功能    $(&quot;#id&quot;)            2. $.extend(object)                * 增强JQuery对象自身的功能 $/JQuery</code></pre><hr><h2 id="Day-21-内容："><a href="#Day-21-内容：" class="headerlink" title="Day 21 内容："></a>Day 21 内容：</h2><pre><code>1. AJAX2. JSON</code></pre><h3 id="AJAX："><a href="#AJAX：" class="headerlink" title="AJAX："></a>AJAX：</h3><pre><code>1. 概念：Asynchronous JavaScript And XML    异步的JavaScript和XML    1. 异步和同步：客户端和服务器端相互通信的基础上        * 同步：客户端必须等待服务器端的响应，不能进行其他操作        * 异步：客户端不必须等待服务器端的响应，可以进行其他操作        提升用户的体验，不需要重新加载整个页面实现部分页面的更新2. 实现方式：    1. 原生的JS实现方式(了解)        * 参考w3school手册    2. JQuery实现方式        1. $.ajax()            * 语法：$.ajax({键值对});                $.ajax({                    url: &quot;&quot;,                    data: {                        xx: &quot;&quot;,                        yy: &quot;&quot;                    },                    success: function(){},                    error: function(){},                    dataType: &quot;&quot;                });        2. $.get()：发送GET请求            * 语法：$.get(url, [data], [callback], [type])        3. $.post()：发送POST请求            * 同上</code></pre><h3 id="JSON："><a href="#JSON：" class="headerlink" title="JSON："></a>JSON：</h3><pre><code>1. 概念：JavaScript Object Notation    JavaScript对象表示法    * json现在多用于存储和交换文本信息的语法    * 进行数据的传输    * 比XML更小更快更方便2. 语法：    1. 基本规则        * 数据在名称/值对中：json由键值对构成            * 键用引号引起来，也可以不使用引号            * 键的取值类型：                1. 数字(整数或浮点数)                2. 字符串(双引号)                3. 布尔值                4. 数组(方括号)                5. null                6. 对象(花括号)        * 数据由逗号分隔：多个键值对由逗号分隔        * 花括号保存对象：使用{}定义json格式        * 方括号保存数组：[]    2. 获取数据：        1. json对象.键名        2. json对象[&quot;键名&quot;]        3. 数组对象[索引]    3. JSON数据和Java对象的相互转换        * JSON解析器：            * 常见的解析器：Jsonlib、Gson、fastjson、jackson        1. JSON转为Java对象            1. 导入jackson相关jar包            2. 创建Jackson核心对象 ObjectMapper            3. 调用ObjectMapper的相关方法进行转换                1. readValue(json数据, Class)        2. Java对象转为JSON            1. 使用步骤：                1. 导入jackson相关jar包                2. 创建Jackson核心对象 ObjectMapper                3. 调用ObjectMapper的相关方法进行转换                    1. 转换方法：                        * writeValue(参数1, obj)                            参数1:                                File：将obj对象转为json字符串，并保存到对应的文件中                                Writer：将obj对象转为json字符串，并将json数据填充到字符输出流中                                OutputStream：将obj对象转为json字符串，并将json数据填充到字节输出流中                        * writeValueAsString(obj): 将对象转为json字符串                    2. 注解                        1. @JsonIgnore：排除属性                        2. @JsonFormat：属性值的格式化                            * @JsonFormat(pattern = &quot;yyyy-MM-dd&quot;)                        3. 复杂Java对象                            1. List：数组                            2. Map：和对象格式一致</code></pre><h3 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h3><pre><code>* 校验用户名是否存在    1. 服务器响应的数据，在客户端使用时，需要转为json的格式来使用        1. $get(type)：将最后一个参数指定为json        2. 在服务器端设置MIME类型，response.setContentType(&quot;application/json;charset=utf-8&quot;)</code></pre><hr><h2 id="Day-22-内容："><a href="#Day-22-内容：" class="headerlink" title="Day 22 内容："></a>Day 22 内容：</h2><pre><code>1. redis    1. 概念    2. 下载安装    3. 命令操作        1. 数据结构    4. 持久化操作    5. 使用Java客户端操作redis</code></pre><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3>]]></content>
      
      
      <categories>
          
          <category> 学习篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java自学总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb初探</title>
      <link href="/2020/06/25/summer%20study/"/>
      <url>/2020/06/25/summer%20study/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaWeb初探"><a href="#JavaWeb初探" class="headerlink" title="JavaWeb初探"></a>JavaWeb初探</h1><a id="more"></a><h2 id="Day-01"><a href="#Day-01" class="headerlink" title="Day 01"></a>Day 01</h2><p><em>25/06/2020</em></p><h3 id="JAVA反射"><a href="#JAVA反射" class="headerlink" title="JAVA反射"></a>JAVA反射</h3><h4 id="获取Class实例："><a href="#获取Class实例：" class="headerlink" title="获取Class实例："></a>获取Class实例：</h4><ul><li><p>通过静态变量class获取，即直接通过类名获取</p></li><li><p>通过调用Class.forName(name)方法获取，传递类完整名称为参数</p></li><li><p>通过实例变量的getClass()方法获取</p></li></ul><p>Class实例在JVM中是唯一的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example</span></span><br><span class="line">Class c1 = String<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Class c2 = Class.forName(<span class="string">"java.lang.String"</span>);</span><br><span class="line">String s = <span class="string">"hello"</span>;</span><br><span class="line">Class c3 = s.getClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可直接通过==符号判断两Class实例是否相同</span></span><br><span class="line"><span class="keyword">boolean</span> b = (c1 == c2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="访问字段"><a href="#访问字段" class="headerlink" title="访问字段"></a>访问字段</h4><ul><li>Field getField(name)：根据字段名获取某个public的field（包括父类）</li><li>Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）</li><li>Field[] getFields()：获取所有public的field（包括父类）</li><li>Field[] getDeclaredFields()：获取当前类的所有field（不包括父类）</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String num;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line">Field f1 = Student.class.getField("age");</span><br><span class="line">Field f2 = Student.class.getDeclaredField("num"); // 访问私有变量不能直接使用getField()方法</span><br></pre></td></tr></table></figure><p>Field对象的一些方法</p><ul><li><code>getName()</code>：返回字段名称，例如，<code>&quot;name&quot;</code>；</li><li><code>getType()</code>：返回字段类型，也是一个<code>Class</code>实例，例如，<code>String.class</code>；</li><li><code>getModifiers()</code>：返回字段的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li></ul><p>通过Field实例获取或修改字段的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 还是上面Student的例子</span></span><br><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line">f1 = s.getclass().getField(<span class="string">"age"</span>);</span><br><span class="line">f2 = s.getclass().getDeclaredField(<span class="string">"age"</span>);</span><br><span class="line">Object value = f1.get(s); <span class="comment">// 获取age字段的值 此处为0</span></span><br><span class="line">f2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object value = f2.get(s); <span class="comment">// 要想获得private修饰字段的值，需要使用setAccessible方法 不过这也不是万能的 有些是可以限制的</span></span><br><span class="line">f1.set(s, <span class="number">15</span>); <span class="comment">// 设置字段age的值 设置为15</span></span><br><span class="line">f2.set(s, <span class="string">"hello"</span>); <span class="comment">// 同理</span></span><br></pre></td></tr></table></figure><h4 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h4><ul><li><code>Method getMethod(name, Class...)</code>：获取某个<code>public</code>的<code>Method</code>（包括父类）</li><li><code>Method getDeclaredMethod(name, Class...)</code>：获取当前类的某个<code>Method</code>（不包括父类）</li><li><code>Method[] getMethods()</code>：获取所有<code>public</code>的<code>Method</code>（包括父类）</li><li><code>Method[] getDeclaredMethods()</code>：获取当前类的所有<code>Method</code>（不包括父类）</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> a, String s)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">Method m1 = Student.class.getMethod("get");</span><br><span class="line">Method m2 = Student.class.getDeclaredMethod("set", int.class, String.class); // 后面的可变参数代表该方法的参数列表</span><br></pre></td></tr></table></figure><p>Method对象的一些方法：</p><ul><li><code>getName()</code>：返回方法名称，例如：<code>&quot;getScore&quot;</code>；</li><li><code>getReturnType()</code>：返回方法返回值类型，也是一个Class实例，例如：<code>String.class</code>；</li><li><code>getParameterTypes()</code>：返回方法的参数类型，是一个Class数组，例如：<code>{String.class, int.class}</code>；</li><li><code>getModifiers()</code>：返回方法的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li></ul><p>invoke()方法，对Mehtod实例调用该方法，相当于调用Method对应的实例的方法，第一个参数为对象实例，后面跟可变参数，即该方法的参数列表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m1.invoke(); <span class="comment">// 相当于student.get()</span></span><br><span class="line">m2.setAccessible(<span class="keyword">true</span>); <span class="comment">// 和Field同理</span></span><br><span class="line">m2.invoke(<span class="number">1</span>, <span class="string">"jack"</span>);</span><br></pre></td></tr></table></figure><p>关于多态：</p><p>即在子类重写了父类方法时，反射机制又是如何呢？也同样遵循多态的原则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">P</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"p"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">P</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"c"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Method m = P.class.getMethod("prin");</span><br><span class="line">m.invoke(<span class="keyword">new</span> P()); <span class="comment">// p</span></span><br><span class="line">m.invoke(<span class="keyword">new</span> C()); <span class="comment">// c</span></span><br></pre></td></tr></table></figure><h4 id="调用构造方法"><a href="#调用构造方法" class="headerlink" title="调用构造方法"></a>调用构造方法</h4><p>通过反射创建实例：</p><ul><li><code>newInstance()方法</code>，要求该构造方法为public无参数构造方法</li><li>通过Constructor对象来实现能够调用任意的构造方法</li></ul><p>对于构造Constructor对象的方法：</p><ul><li><code>getConstructor(Class...)</code>：获取某个<code>public</code>的<code>Constructor</code>；</li><li><code>getDeclaredConstructor(Class...)</code>：获取某个<code>Constructor</code>；</li><li><code>getConstructors()</code>：获取所有<code>public</code>的<code>Constructor</code>；</li><li><code>getDeclaredConstructors()</code>：获取所有<code>Constructor</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Student s = Student<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>()</span>;</span><br><span class="line"><span class="comment">// Constructor</span></span><br><span class="line">Constructor c = Student<span class="class">.<span class="keyword">class</span>.<span class="title">getConstructor</span>(<span class="title">Student</span>.<span class="title">class</span>)</span>;</span><br><span class="line"><span class="comment">// 同样对于私有构造方法 需要调用setAccessible(true)方法</span></span><br><span class="line">Student s2 = (Student) c.newInstance(); <span class="comment">// 这里的newInstance方法可以传递参数 具体根据构造方法来对应</span></span><br></pre></td></tr></table></figure><h4 id="获取继承关系"><a href="#获取继承关系" class="headerlink" title="获取继承关系"></a>获取继承关系</h4><p>获取父类Class实例：</p><p>getSuperClass()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class i = <span class="keyword">int</span><span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Class n = i.getSuperClass(); <span class="comment">// 获取父类 也就是Number</span></span><br><span class="line">Class s = n.getSuperClass().getSuperClass(); <span class="comment">// 如果已经不存在父类 则返回null</span></span><br></pre></td></tr></table></figure><p>获取接口：</p><p>getInterfaces()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class i[] = <span class="keyword">int</span><span class="class">.<span class="keyword">class</span>.<span class="title">getInterfaces</span>()</span>; <span class="comment">// 因为存在多个接口 所以返回Class数组 </span></span><br><span class="line"><span class="comment">// 如果想获得父接口 也需要使用getInterfaces()方法 接口使用getSuperClass()方法会返回null</span></span><br></pre></td></tr></table></figure><p>两个Class对象判断是否为继承关系：</p><p>使用isAssignableFrom()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">Integer</span>.<span class="title">class</span>)</span>; <span class="comment">// true，因为Integer可以赋值给Number</span></span><br><span class="line"><span class="comment">// 可以类比instanceof</span></span><br></pre></td></tr></table></figure><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>可以在运行期动态创建某个<code>interface</code>的实例。</p><p>JDK提供的动态创建接口对象的方式，就叫动态代理。</p><p>即可以实现在不编写实现类的情况下，创建接口的实例。利用Proxy.newProxyInstance()方法</p><p>在运行期动态创建一个<code>interface</code>实例的方法如下：</p><ol><li>定义一个<code>InvocationHandler</code>实例，它负责实现接口的方法调用；</li><li>通过Proxy.newProxyInstance()创建interface实例，它需要3个参数：<ol><li>使用的<code>ClassLoader</code>，通常就是接口类的<code>ClassLoader</code>；</li><li>需要实现的接口数组，至少需要传入一个接口进去；</li><li>用来处理接口方法调用的<code>InvocationHandler</code>实例。</li></ol></li><li>将返回的<code>Object</code>强制转型为接口。</li></ol><p>但实质其实就是JDK帮我们自动编写了一个上述类（不需要源码，可以直接生成字节码），并不存在可以直接实例化接口的黑魔法。</p><p>参考：廖雪峰博客-Java</p><hr><h2 id="Day-02"><a href="#Day-02" class="headerlink" title="Day 02"></a>Day 02</h2><p><em>26/06/2020</em></p><h3 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h3><p>定义：XML全称为Extensible Markup Language，意思是可扩展的标记语言。XML语法上和HTML比较相似，但HTML中的元素是固定的，而XML的标签是可以由用户自定义的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--部分xml 例子--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">student</span> <span class="attr">number</span>=<span class="string">"1001"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>zhangSan<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">age</span>&gt;</span>23<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sex</span>&gt;</span>male<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">teacher</span> <span class="attr">name</span>=<span class="string">"liSi"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">wife</span> <span class="attr">id</span>=<span class="string">"xxx"</span>&gt;</span><span class="tag">&lt;<span class="name">name</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">name</span>&gt;</span><span class="tag">&lt;/<span class="name">wife</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">teacher</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="XML语法"><a href="#XML语法" class="headerlink" title="XML语法"></a>XML语法</h4><p>文档声明：</p><ul><li><p>文档声明必须为<code>&lt;?xml</code>开头，以<code>?&gt;</code>结束；</p></li><li><p>文档声明必须从文档的0行0列位置开始；</p></li><li><p>文档声明只有三个属性：</p><ul><li><p>versioin：指定XML文档版本。必须属性，因为我们不会选择1.1，只会选择1.0；</p></li><li><p>encoding：指定当前文档的编码。可选属性，默认值是utf-8；</p></li><li><p>standalone：指定文档独立性。可选属性，默认值为yes，表示当前文档是独立文档。如果为no表示当前文档不是独立的文档，会依赖外部文件。</p></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;no&quot;?&gt;</span><br></pre></td></tr></table></figure><p><strong>元素</strong></p><p>元素是XML文档中最重要的组成部分：</p><ul><li><p>普通元素的结构：开始标签、元素体、结束标签，例如：<code>&lt;hello&gt;大家好&lt;/hello&gt;</code>；</p></li><li><p>元素体：元素体可以是元素，也可以是文本，例如：<code>&lt;b&gt;&lt;a&gt;你好&lt;/a&gt;&lt;/b&gt;</code>，其中<code>&lt;b&gt;</code>元素的元素体是<code>&lt;a&gt;</code>元素，而<code>&lt;a&gt;</code>元素的元素体是文本；</p></li><li><p>空元素：空元素只有开始标签，而没有结束标签，例如：<code>&lt;c/&gt;</code>，但元素必须自己闭合。</p></li></ul><p>元素属性：</p><ul><li><p>属性是元素的一部分，它必须出现在元素的开始标签中；</p></li><li><p>属性的定义格式：属性名=属性值，其中属性值必须使用单引或双引；</p></li><li><p>一个元素可以有0~N个属性，但一个元素中不能出现同名属性；</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">student</span> <span class="attr">number</span>=<span class="string">"1001"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--.......--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>转义</strong></p><p>转义字符：例如<code>&lt;</code>,<code>&gt;</code>等等这类符号，需要使用相应的转义字符来代替。例如：<code>&lt;</code>用<code>&amp;lt;</code>代替。</p><p>CDATA段：由于使用转义字符会大大降低XML文档可读性，使用CDATA段就不会有这种问题，格式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span>&lt;![CDATA[&lt;a&gt;]]&gt;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意的是，在CDATA段中不能包含”]]&gt;”，即CDATA段的结束定界符。</p><p><strong>处理指令</strong></p><p>处理指令，简称PI（Processing instruction）。处理指令用来指挥解析器如何解析XML文档内容。</p><p>例如，在XML文档中可以使用xml-stylesheet指令，通知XML解析器，应用css文件显示xml文档内容。</p><p>放于文档声明下方</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="gbk"?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-stylesheet type="text/css" href="a.css"?&gt;</span></span><br></pre></td></tr></table></figure><p><strong>格式</strong></p><p>格式良好的XML就是格式正确的XML文档，只有XML的格式是良好的，XML解释器才能解释它。下面是对格式良好XML文档的要求：</p><ul><li><p>必须要有XML文档声明；</p></li><li><p>必须且仅能有一个根元素；</p></li><li><p>元素和属性的命名必须遵循XML要求：</p><ul><li><p>XML命名区分大小写，例如<code>&lt;a&gt;</code>和<code>&lt;A&gt;</code>是两上不同的元素；</p></li><li><p>名称中可以包含：字母、数字、下划线、减号，但不能以数字、减号开头；</p></li><li><p>不能以xml开头，无论是大写还是小写都不可以，例如<code>&lt;xml&gt;</code>、<code>&lt;Xml&gt;</code>、<code>&lt;XML&gt;</code>都是错误的；</p></li><li><p>不能包含空格，例如<code>&lt;ab cd&gt;</code>是错误的。</p></li></ul></li><li><p>元素之间必须合理包含，例如：<code>&lt;a&gt;&lt;b&gt;xxx&lt;/b&gt;&lt;/a&gt;</code>是合理的，而<code>&lt;a&gt;&lt;b&gt;xxx&lt;/a&gt;&lt;/b&gt;</code>就是错误的包含。</p></li></ul><h3 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h3><p>定义：DTD（Document Type Definition），文档类型定义，用来约束XML文档。或者可以把DTD理解为创建XML文档的结构！例如可以用DTD要求XML文档的根元素名为<code>&lt;students&gt;</code>，<code>&lt;students&gt;</code>中可以有1~N个<code>&lt;student&gt;</code>，<code>&lt;student&gt;</code>子元素为<code>&lt;name&gt;</code>、<code>&lt;age&gt;</code>和<code>&lt;sex&gt;</code>，<code>&lt;student&gt;</code>元素还有number属性。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--例子--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ELEMENT</span> <span class="attr">students</span> (<span class="attr">student</span>+)&gt;</span><span class="comment">&lt;!--students元素包含1-n个student元素--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ELEMENT</span> <span class="attr">student</span> (<span class="attr">name</span>,<span class="attr">age</span>,<span class="attr">sex</span>)&gt;</span><span class="comment">&lt;!--内容依次为name age sex三个元素--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ELEMENT</span> <span class="attr">name</span> (#<span class="attr">PCDATA</span>)&gt;</span><span class="comment">&lt;!--定义name元素内容为文本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ELEMENT</span> <span class="attr">age</span> (#<span class="attr">PCDATA</span>)&gt;</span><span class="comment">&lt;!--定义age元素内容为文本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ELEMENT</span> <span class="attr">sex</span> (#<span class="attr">PCDATA</span>)&gt;</span><span class="comment">&lt;!--定义sex元素内容为文本--&gt;</span></span><br></pre></td></tr></table></figure><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li><p>内部DTD：在XML文档内部嵌入DTD，只对当前XML文档有效；</p></li><li><p>外部DTD：独立的DTD文件，扩展名为.dtd；</p><ul><li><p>本地DTD：DTD文件在本地，不在网络上。自己项目，或本公司内部使用的；</p></li><li><p>公共DTD：DTD文件在网络上，不在本地。都是大公司或组织发布的，共大家使用！</p></li></ul></li></ul><p>内部DTD</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8" standalone="yes" ?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--内部DTD例子--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE students [</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT students (student+)&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT student (name, age, sex)&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT name (#PCDATA)&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT age (#PCDATA)&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT sex (#PCDATA)&gt;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">students</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>zhangSan<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">age</span>&gt;</span>23<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sex</span>&gt;</span>male<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">students</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>位置：内部DTD在文档声明下面，在根元素上面；</p></li><li><p>语法格式：放到<code>&lt;!DOCTYPE 根元素名称[ ]&gt;</code>之间；</p></li><li><p>只对当前XML文档有效；</p></li></ul><p>本地DTD</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8" standalone="no" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE students SYSTEM "students.dtd"&gt;</span><span class="comment">&lt;!--此处为dtd文件路径--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">students</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>zhangSan<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">age</span>&gt;</span>23<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sex</span>&gt;</span>male<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">students</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>位置：本地硬盘上；</p></li><li><p>语法格式：直接定义元素或属性即可；</p></li><li><p>本地所有XML文档都可以引用这个dtd文件；</p></li></ul><p>公共DTD</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8" standalone="no" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE students PUBLIC "-//qdmmy6//DTD ST 1.0//ZH" "http://www.qdmmy6.com/xml/dtds/st.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">students</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>zhangSan<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">age</span>&gt;</span>23<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sex</span>&gt;</span>male<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">students</span>&gt;</span></span><br></pre></td></tr></table></figure><p>格式为：<code>&lt;!DOCTYPE 根元素 PUBLIC &quot;DTD名称&quot; &quot;DTD网址&quot;&gt;</code></p><h4 id="DTD语法"><a href="#DTD语法" class="headerlink" title="DTD语法"></a>DTD语法</h4><h5 id="定义元素"><a href="#定义元素" class="headerlink" title="定义元素"></a>定义元素</h5><p>定义元素语法：<code>&lt;!ELEMENT 元素名 元素描述&gt;</code></p><ul><li><p><code>&lt;!ELEMENT name (#PCDATA)&gt;</code>，定义名为name的元素，内容为文本类型。</p></li><li><p><code>&lt;!ELEMENT student (name,age,sex)&gt;</code>，定义名为student元素，内容依次为name、age、sex元素；</p></li><li><p><code>&lt;!ELEMENT student ANY&gt;</code>，定义名为student元素，内容任意；</p></li><li><p><code>&lt;!ELEMENT student EMPTY&gt;</code>，定义名为student元素，不能有内容，即空元素，注意空元素是可以有属性的。 </p></li></ul><p>子元素出现次数</p><p>可以使用<code>*</code>、<code>+</code>、<code>?</code>来指定子元素出现的次数</p><p><code>*</code>：可以出现0~N次；<code>+</code>：可以出现1~N次；<code>?</code>：可以出现0~1次。</p><p>例如：<code>&lt;!ELEMENT student(name,age?,hobby*,grade+) &gt;</code>，定义student元素，第一子元素为name，必须且仅能出现一次，age是可有可无的，hobby可以出现0<del>N次，grade可以出现1</del>N次。</p><p>枚举类型子元素</p><p><code>&lt;!ELEMENT student (name | age | sex)&gt;</code>，表示student子元素为name、age、sex其中之一，必须仅且能选择其一。</p><h5 id="定义属性"><a href="#定义属性" class="headerlink" title="定义属性"></a>定义属性</h5><p>定义属性的语法：</p><p><code>&lt;!ATTLIST 元素名 属性名 属性类型 设置说明&gt;</code></p><p>例如：<code>&lt;!ATTLIST student number CDATA #REQUIRED&gt;</code>，给student元素定义属性number，类型为文本，这个默认是必须的。</p><p>属性设置说明：</p><p><code>#REQUIRED</code>：说明属性是必须的；<code>#IMPLIED</code>：说明属性是可选的；<code>默认值</code>：在不给出属性值时，使用默认值。</p><p> 属性的类型：</p><ul><li><p><code>CDATA</code>：文本类型；</p></li><li><p><code>Enumerated</code>：枚举类型；</p></li><li><p><code>ID</code>：ID类型，ID类型的属性用来标识元素的唯一性，即元素的ID属性值不能与其他元素的ID属性值相同；</p></li><li><p><code>IDREF</code>：ID引用类型，用来指定另一个元素，与另一个元素建立关联关系，IDREF类型的属性值必须是另一个元素的ID。</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--例子--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ELEMENT</span> <span class="attr">students</span> (<span class="attr">student</span>+) &gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">!ELEMENT</span> <span class="attr">student</span> <span class="attr">EMPTY</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">!ATTLIST</span> <span class="attr">student</span> <span class="attr">number</span> <span class="attr">ID</span> #<span class="attr">REQUIRED</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">!ATTLIST</span> <span class="attr">student</span> <span class="attr">name</span> <span class="attr">CDATA</span> #<span class="attr">REQUIRED</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">!ATTLIST</span> <span class="attr">student</span> <span class="attr">sex</span> (<span class="attr">male</span> | <span class="attr">female</span>) "<span class="attr">male</span>" &gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">!ATTLIST</span> <span class="attr">student</span> <span class="attr">friend</span> <span class="attr">IDREF</span> #<span class="attr">IMPLIED</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--上面为students.dtd文件内容--&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE students SYSTEM "students.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">students</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span> <span class="attr">number</span>=<span class="string">"itcast_001"</span> <span class="attr">name</span>=<span class="string">"zhangSan"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span> <span class="attr">number</span>=<span class="string">"itcast_002"</span> <span class="attr">name</span>=<span class="string">"liSi"</span> <span class="attr">sex</span>=<span class="string">"male"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span> <span class="attr">number</span>=<span class="string">"itcast_003"</span> <span class="attr">name</span>=<span class="string">"wangWu"</span> <span class="attr">sex</span>=<span class="string">"female"</span> <span class="attr">friend</span>=<span class="string">"itcast_002"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">students</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="定义实体"><a href="#定义实体" class="headerlink" title="定义实体"></a>定义实体</h5><p>将多而长的字符串定义为用简单符号表示的实体，从而在使用时只用使用该符号就可以了，方便且简洁。</p><p>实体分为两种：一般实体和参数实体。</p><ul><li><p>一般实体：在XML文档中使用；</p><ul><li>定义一般实体：<code>&lt;!ENTITY 实体名 &quot;实体值&quot;&gt;</code>，例如：<code>&lt;!ENTITY 大美女 &quot;白冰&quot;&gt;</code>；</li><li>一般实体引用：<code>&amp;实体名;</code>，例如<code>&lt;xxx&gt;&amp;大美女;&lt;/xxx&gt;</code>。</li></ul></li><li><p>参数实体：在DTD使用。</p><ul><li>定义参数实体：<code>&lt;!ENTITY % 实体名 &quot;实体值&quot;&gt;</code>，”%”与实体名之间的空格是必须的；例如：<code>&lt;!ENTITY % friend &quot;student friend IDREF #IMPLIED&quot;&gt;</code></li><li>参数实体引用：<code>%实体名;</code>；例如：<code>&lt;!ATTLIST %friend;&gt;</code></li></ul></li></ul><p>参数实体是在DTD内部使用，而不是在XML中使用。在内部DTD中使用参数实体会有诸多限制</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--参数实体例子--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ELEMENT</span> <span class="attr">students</span> (<span class="attr">student</span>+) &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ELEMENT</span> <span class="attr">student</span> <span class="attr">EMPTY</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ATTLIST</span> <span class="attr">student</span> <span class="attr">number</span> <span class="attr">ID</span> #<span class="attr">REQUIRED</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ATTLIST</span> <span class="attr">student</span> <span class="attr">name</span> <span class="attr">CDATA</span> #<span class="attr">REQUIRED</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ATTLIST</span> <span class="attr">student</span> <span class="attr">sex</span> (<span class="attr">male</span> | <span class="attr">female</span>) "<span class="attr">male</span>"&gt;</span></span><br><span class="line">&lt;!ENTITY % friend "&lt;!ATTLIST student friend IDREF #IMPLIED&gt;"&gt;&lt;!--定义--&gt;</span><br><span class="line">%friend;<span class="comment">&lt;!--使用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> <span class="attr">itcast</span> "北京传智播客教育科技有限公司"&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h3><p>特点：</p><ul><li><p>Schema是新的XML文档约束；</p></li><li><p>Schema要比DTD强大很多；</p></li><li><p>Schema本身也是XML文档，但Schema文档的扩展名为xsd，而不是xml。</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--students.xsd--&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xsd:schema</span> <span class="attr">xmlns</span>=<span class="string">"http://www.itcast.cn/xml"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsd</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">targetNamespace</span>=<span class="string">"http://www.itcast.cn/xml"</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">elementFormDefault</span>=<span class="string">"qualified"</span>&gt;</span><span class="comment">&lt;!--指定名称空间--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">"students"</span> <span class="attr">type</span>=<span class="string">"studentsType"</span>/&gt;</span><span class="comment">&lt;!--定义studentsType类型--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:complexType</span> <span class="attr">name</span>=<span class="string">"studentsType"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsd:sequence</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">"student"</span> <span class="attr">type</span>=<span class="string">"studentType"</span> <span class="attr">minOccurs</span>=<span class="string">"0"</span> <span class="attr">maxOccurs</span>=<span class="string">"unbounded"</span>/&gt;</span><span class="comment">&lt;!--指定其包含的student元素数目--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">xsd:sequence</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xsd:complexType</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:complexType</span> <span class="attr">name</span>=<span class="string">"studentType"</span>&gt;</span><span class="comment">&lt;!--定义studentType类型--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsd:sequence</span>&gt;</span><span class="comment">&lt;!--指定其元素按顺序出现--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"xsd:string"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">type</span>=<span class="string">"ageType"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">type</span>=<span class="string">"sexType"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">xsd:sequence</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">"number"</span> <span class="attr">type</span>=<span class="string">"numberType"</span> <span class="attr">use</span>=<span class="string">"required"</span>/&gt;</span><span class="comment">&lt;!--指定其包含的属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xsd:complexType</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:simpleType</span> <span class="attr">name</span>=<span class="string">"sexType"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsd:restriction</span> <span class="attr">base</span>=<span class="string">"xsd:string"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xsd:enumeration</span> <span class="attr">value</span>=<span class="string">"male"</span>/&gt;</span><span class="comment">&lt;!--指定枚举选项--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xsd:enumeration</span> <span class="attr">value</span>=<span class="string">"female"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">xsd:restriction</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xsd:simpleType</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:simpleType</span> <span class="attr">name</span>=<span class="string">"ageType"</span>&gt;</span><span class="comment">&lt;!--定义ageType类型--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsd:restriction</span> <span class="attr">base</span>=<span class="string">"xsd:integer"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xsd:minInclusive</span> <span class="attr">value</span>=<span class="string">"0"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xsd:maxInclusive</span> <span class="attr">value</span>=<span class="string">"100"</span>/&gt;</span><span class="comment">&lt;!--指定范围--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">xsd:restriction</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xsd:simpleType</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:simpleType</span> <span class="attr">name</span>=<span class="string">"numberType"</span>&gt;</span><span class="comment">&lt;!--定义numberType类型--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsd:restriction</span> <span class="attr">base</span>=<span class="string">"xsd:string"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xsd:pattern</span> <span class="attr">value</span>=<span class="string">"ITCAST_\d&#123;4&#125;"</span>/&gt;</span><span class="comment">&lt;!--正则表达式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">xsd:restriction</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xsd:simpleType</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xsd:schema</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--students.xml--&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">students</span> <span class="attr">xmlns</span>=<span class="string">"http://www.itcast.cn/xml"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.itcast.cn/xml students.xsd"</span> &gt;</span><span class="comment">&lt;!--指定约束文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span> <span class="attr">number</span>=<span class="string">"ITCAST_1001"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>zhangSan<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>20<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sex</span>&gt;</span>male<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span> <span class="attr">number</span>=<span class="string">"ITCAST_1002"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>liSi<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>25<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sex</span>&gt;</span>female<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">students</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="schema名称空间"><a href="#schema名称空间" class="headerlink" title="schema名称空间"></a>schema名称空间</h4><p>名称空间定义：如果一个XML文档中使用多个Schema文件，而这些Schema文件中定义了相同名称的元素时就会出现名字冲突。这就像一个Java文件中使用了import java.util.*和import java.sql.*时，在使用Date类时，那么就不明确Date是哪个包下的Date了。</p><p>总之名称空间就是用来处理元素和属性的名称冲突问题，与Java中的包是同一用途。如果每个元素和属性都有自己的名称空间，那么就不会出现名字冲突问题，就像是每个类都有自己所在的包一样，那么类名就不会出现冲突。</p><h5 id="目标名称空间"><a href="#目标名称空间" class="headerlink" title="目标名称空间"></a>目标名称空间</h5><p>在XSD文件中为定义的元素指定名称，即指定目标名称空间。这需要给<code>&lt;xsd:schema&gt;</code>元素添加<code>targetNamespace</code>属性。</p><p>例如：<code>&lt;xsd:schema targetNamespace=&quot;http://www.itcast.cn/xml&quot;&gt;</code></p><p>名称空间可以是任意字符串，但通常我们会使用公司的域名作为名称空间，这与Java中的包名使用域名的倒序是一样的！千万不要以为这个域名是真实的，它可以是不存在的域名。</p><p>如果每个公司发布的Schema都随意指定名称空间，如a、b之类的，那么很可能会出现名称空间的名字冲突，所以还是使用域名比较安全，因为域名是唯一的。</p><p>当使用了<code>targetNamespace</code>指定目标名称空间后，那么当前XSD文件中定义的元素和属性就在这个名称空间之中了。</p><h5 id="XML指定XSD文件"><a href="#XML指定XSD文件" class="headerlink" title="XML指定XSD文件"></a>XML指定XSD文件</h5><p>在XML文件中需要指定XSD约束文件，这需要使用在根元素中使用<code>schemaLocation</code>属性来指定XSD文件的路径，以及目标名称空间。格式为：<code>schemaLocation=&quot;目标名称空间 XSD文件路径&quot;</code></p><p>例如：<code>&lt;students schemaLocation=&quot;http://www.itcast.cn/xml students.xsd&quot;&gt;</code></p><p><code>schemaLocation</code>是用来指定XSD文件的路径，也就是说为当前XML文档指定约束文件。但它不只要指定XSD文件的位置，还要指定XSD文件的目标名称空间。</p><p>其中<code>http://www.itcast.cn/xml</code>为目标名称空间，<code>students.xsd</code>为XSD文件的位置，它们中间使用空白符（空格或换行）分隔。</p><p>也可以指定多个XSD文件，格式为：</p><p><code>schemaLocation=&quot;目标名称空间1 XSD文件路径1 目标名称空间2 XSD文件路径2&quot;</code></p><p>下面是spring配置文件的例子，它一共指定两个XSD文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">                      http://www.springframework.org/schema/beans/spring-beans-3.0.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">                      http://www.springframework.org/schema/aop </span></span></span><br><span class="line"><span class="tag"><span class="string">                      http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="定义名称空间"><a href="#定义名称空间" class="headerlink" title="定义名称空间"></a>定义名称空间</h5><p>现在我们已经知道一个XML中可以指定多个XSD文件，例如上面Spring的配置文件中就指定了多个XSD文件，那么如果我在<code>&lt;beans&gt;</code>元素中给出一个子元素<code>&lt;bean&gt;</code>，你知道它是哪个名称空间中的么？显然是无法知道的。</p><p>所以只是使用<code>schemaLocation</code>指定XSD是不够的，它只是导入了这个XSD及XSD的名称空间而已。<code>schemaLocation</code>的作用就相当于Java中导入Jar包的作用！最终还是在Java文件中使用import来指定包名的。</p><p><code>xmlns</code>是用来指定名称空间前缀的，所谓前缀就是”简称”，例如中华人民共和国简称中国一样，然后我们在每个元素前面加上前缀，就可以处理名字冲突了。</p><p>格式为：<code>xmln:前缀=&quot;名称空间&quot;</code></p><p>注意，使用<code>xmlns</code>指定的名称空间必须是在<code>schemaLocation</code>中存在的名称空间。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:b</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line">xmlns:aop="http://www.springframework.org/schema/aop"&lt;!--这里指定了两个前缀--&gt;</span><br><span class="line">    xsi:schemaLocation="http://www.springframework.org/schema/beans </span><br><span class="line">                      http://www.springframework.org/schema/beans/spring-beans-3.0.xsd </span><br><span class="line">                      http://www.springframework.org/schema/aop </span><br><span class="line">                      http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">b:bean</span>&gt;</span><span class="tag">&lt;/<span class="name">b:bean</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:scoped-proxy</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="默认名称空间"><a href="#默认名称空间" class="headerlink" title="默认名称空间"></a>默认名称空间</h5><p>在一个XML文件中，可以指定一个名称空间没有前缀，那么在当前XML文档中没有前缀的元素就来自默认名称空间。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span></span></span><br><span class="line">xmlns="http://www.springframework.org/schema/beans"&lt;!--默认名称空间--&gt;</span><br><span class="line">xmlns:aop="http://www.springframework.org/schema/aop"</span><br><span class="line">    xsi:schemaLocation="http://www.springframework.org/schema/beans </span><br><span class="line">                      http://www.springframework.org/schema/beans/spring-beans-3.0.xsd </span><br><span class="line">                      http://www.springframework.org/schema/aop </span><br><span class="line">                      http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="comment">&lt;!--使用默认名称空间--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:scoped-proxy</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="W3C的元素和属性"><a href="#W3C的元素和属性" class="headerlink" title="W3C的元素和属性"></a>W3C的元素和属性</h5><p>如果我们的XML文件中需要使用W3C提供的元素和属性，那么可以不在schemaLocation属性中指定XSD文件的位置，但一定要定义名称空间，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&lt;!--指定名称空间--&gt;</span><br><span class="line">      xsi:schemaLocation="http://www.springframework.org/schema/beans </span><br><span class="line">                      http://www.springframework.org/schema/beans/spring-beans-3.0.xsd </span><br><span class="line">                      http://www.springframework.org/schema/aop </span><br><span class="line">                      http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"&gt;</span><br><span class="line"><span class="comment">&lt;!--这里无需指定--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面定义了一个名称空间，前缀为xsi，名称空间为<code>http://www.w3.org/2001/XMLSchema-instance</code>。这个名称空间无需在<code>schemaLocation</code>中存在。</p><p>你可能已经发现了，<code>schemaLocation</code>这个属性其实是w3c定义的属性，与元素一定，属性也需要指定”出处”，<code>xsi:schemaLocation</code>中的<code>xsi</code>就是名称空间前缀。也就是说，上面我们在没有指定<code>xsi</code>名称空间时，就直接使用<code>schemaLocation</code>是错误的。也就是在上面其他的例子中，我们是没有指明<code>xsi</code>代表什么的，所以就是错误的，因为不存在<code>xsi</code>这个前缀。</p><h3 id="XML解析器"><a href="#XML解析器" class="headerlink" title="XML解析器"></a>XML解析器</h3><h4 id="DOM-and-SAX-简介"><a href="#DOM-and-SAX-简介" class="headerlink" title="DOM and SAX 简介"></a>DOM and SAX 简介</h4><p>定义：XML是保存数据的文件，XML中保存的数据也需要被程序读取然后使用。那么程序使用什么来读取XML文件中的数据呢？XML解析器！例如.properties文件的解析器是Properties类一样！</p><p>XML不只被Java语言使用，还被C++、C#、Javascript等等语言使用，所以解析XML不是一门语言的工作！</p><p>主流的XML解析有两种标准：DOM和SAX。它们是标准，是思想，不是真正的解析器，它们是跨语言的！！！</p><ul><li><p>DOM（Document Object Model）：W3C组织提供的解析XML文档的标准接口；</p></li><li><p>SAX（Simple API for XML）：社区讨论的产物，是一种事实上的标准。</p></li></ul><p>Apache的xerces组件实现了DOM和SAX，所以在我们在Java中解析XML需要使用xerces。所以我们称xerces是DOM、SAX解析器。</p><p><strong>DOM解析原理</strong></p><p>DOM要求解析器把整个XML文档装载到一个Document对象中。即使用DOM解析器解析XML文档的结果就是一个Document对象。</p><p>一个XML文档解析后对应一个Document对象，可以通过Document对象获取根元素，然后在通过根元素获取根元素的子元素…，这说明DOM解析方式保留了元素之间的结构关系！</p><ul><li><p>优点：元素与元素之间的结构关系保留了下来；</p></li><li><p>缺点：如果XML文档过大，那么把整个XML文档装载进内存，可能会出现内存溢出的现象！</p></li></ul><p><strong>SAX解析原理</strong></p><p>DOM解析后的结果是一个Document对象，而SAX解析没有结果！SAX要求在开始解析之前用户提供一个接口的实现对象，然后把接口实现对象传递给SAX解析器，然后在SAX解析器的过程中不断调用实现对象的方法。</p><ul><li><p>DOM是解析时把数据放到了Document对象中，然后用户从Document中获取需要的数据；</p></li><li><p>SAX要求用户参与到解析过程中来，把想要做的事情写到接口实现对象中，然后SAX在解析过程中来调用接口实现对象的方法。</p></li></ul><p>SAX解析器会在解析XML文档的过程中，在发生特定事件时，调用接口中特定的方法。例如在SAX解析到某个元素的开始标签时，输出元素名称！其中解析到开始标签就是特定的事件，而输出元素名称，就是接口中方法的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口中方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startDocument</span><span class="params">()</span></span>;<span class="comment">// 开始解析时调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endDocument</span><span class="params">()</span></span>;<span class="comment">// 结束解析时调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startElement</span><span class="params">(String uri, String localName, String qName, Attibutes atts)</span></span>;<span class="comment">// 遇到元素开始标签调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endElement</span><span class="params">(String uri, String localName, String qName)</span><span class="comment">// 遇到元素结束标签调用</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">characters</span><span class="params">(<span class="keyword">char</span>[] ch, <span class="keyword">int</span> start, <span class="keyword">int</span> length)</span></span>;<span class="comment">// 遇到文本内容调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ignorableWhitespace</span><span class="params">(<span class="keyword">char</span>[] ch, <span class="keyword">int</span> start, <span class="keyword">int</span> length)</span></span>;<span class="comment">// 遇到元素和元素之间空白调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processingInstruction</span><span class="params">(String target, String data)</span></span>;<span class="comment">// 遇到处理指令时调用</span></span><br></pre></td></tr></table></figure><p>接口的实现由我们来完成，然后我们需要把接口实现类对象”交给”SAX解析器，然后让SAX开始解析。SAX会在特定事件发生时，调用接口中的方法，完成我们交给它的任务。</p><ul><li><p>优点：适合解析大XML文件（内存空间占用小），因为是解析一行处理一行，处理完了就不需要在保留数据了；</p></li><li><p>缺点：因为是解析一行处理一行，解析之后数据就丢失了，所以元素与元素之间的结构关系没有保留下来。</p></li></ul><p><strong>JAXP</strong></p><p>JAXP（Java API for XML Processing）是由Java提供的，JAXP是对所有像xerces一样的解析的提供统一接口的API。</p><p>当我们使用JAXP完成解析工作时，还需要为JAXP指定xerces或其他解析器，当需要更换解析器时，无需修改代码，只需要修改配置即可。</p><p>JAXP不是解析器，但使用它可以方便的切换解析器。所以在我们的程序中只会使用JAXP，而不会直接使用Xeces。</p><p><strong>JDOM和DOM4j</strong></p><p>DOM和SAX是跨语言的XML解析准备，在Java中使用并不方便。而JDOM和DOM4j是专门为Java语言提供的解析工具！使用起来很方便，所以真实开发中使用JDOM或DOM4J比较多。</p><p>又因为DOM4J与JDOM比较结果为DOM4j完胜，所以这里只会对DOM4j介绍，而不会介绍JDOM。</p><h4 id="DOM-和-SAX-解析"><a href="#DOM-和-SAX-解析" class="headerlink" title="DOM 和 SAX 解析"></a>DOM 和 SAX 解析</h4><p>DOM中的核心概念就是节点，在XML文档中的元素、属性、文本、处理指令，在DOM中都是节点！ </p><h5 id="JAXP-DOM"><a href="#JAXP-DOM" class="headerlink" title="JAXP-DOM"></a>JAXP-DOM</h5><p>使用DOM解析XML的目标就是获取到Document对象，然后在从Document中获取到需要的数据。Document对象就是XML文档在内存中的样子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取Document对象 三步</span></span><br><span class="line">DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();<span class="comment">// 获取工厂</span></span><br><span class="line">DocumentBuilder builder = factory.newDocumentBuilder();<span class="comment">// 获取解析器</span></span><br><span class="line">Document document = builder.parse(<span class="keyword">new</span> File(<span class="string">"students.xml"</span>));<span class="comment">// 解析xml获得Document</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历Document</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> <span class="keyword">throws</span> SAXException, IOException, ParserConfigurationException </span>&#123;</span><br><span class="line">    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();</span><br><span class="line">    DocumentBuilder builder = factory.newDocumentBuilder();</span><br><span class="line">    Document document = builder.parse(<span class="keyword">new</span> File(<span class="string">"src/students.xml"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取根元素</span></span><br><span class="line">    Element rootEle = document.getDocumentElement();</span><br><span class="line">    <span class="comment">// 获取元素的所有子节点</span></span><br><span class="line">    NodeList nodeList = rootEle.getChildNodes();</span><br><span class="line">    <span class="comment">// 循环遍历所有节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodeList.getLength(); i++) &#123;</span><br><span class="line">        <span class="comment">// 获取其中每个节点</span></span><br><span class="line">        Node node = nodeList.item(i);</span><br><span class="line">        <span class="comment">// 判断节点的类型是否为元素</span></span><br><span class="line">        <span class="keyword">if</span>(node.getNodeType() == Node.ELEMENT_NODE) &#123;</span><br><span class="line">            <span class="comment">// 强转成元素类型</span></span><br><span class="line">            Element stuEle = (Element) node;</span><br><span class="line">            <span class="comment">// 获取元素的名称</span></span><br><span class="line">            String eleName = stuEle.getNodeName();</span><br><span class="line">            <span class="comment">// 获取元素的number属性值</span></span><br><span class="line">            String number = stuEle.getAttribute(<span class="string">"number"</span>);</span><br><span class="line">            <span class="comment">// 获取名为name的子元素，因为返回值为NodeList，</span></span><br><span class="line">            <span class="comment">// 所以需要使用item(0)方法获取第一个name子元素</span></span><br><span class="line">            <span class="comment">// getTextContent()是获取节点的文本内容</span></span><br><span class="line">            String name = stuEle.getElementsByTagName(<span class="string">"name"</span>).item(<span class="number">0</span>).getTextContent();</span><br><span class="line">            String age = stuEle.getElementsByTagName(<span class="string">"age"</span>).item(<span class="number">0</span>).getTextContent();</span><br><span class="line">            String sex = stuEle.getElementsByTagName(<span class="string">"sex"</span>).item(<span class="number">0</span>).getTextContent();</span><br><span class="line"></span><br><span class="line">            System.out.println(eleName + <span class="string">":[number="</span> + number + <span class="string">", name="</span> + name + <span class="string">", age="</span> + age + <span class="string">", sex="</span> + sex + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="JAXP-SAX"><a href="#JAXP-SAX" class="headerlink" title="JAXP-SAX"></a>JAXP-SAX</h5><p>使用SAX解析XML文档需要先给出DefaultHandler的子类，重写其中的方法。然后在使用SAX开始解析时把DefaultHandler子类对象传递给SAX解析器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyContentHandler</span> <span class="keyword">extends</span> <span class="title">DefaultHandler</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startDocument</span><span class="params">()</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"开始解析..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endDocument</span><span class="params">()</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"解析结束..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startElement</span><span class="params">(String uri, String localName, String qName,</span></span></span><br><span class="line"><span class="function"><span class="params">Attributes atts)</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">System.out.println(qName + <span class="string">"元素解析开始"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endElement</span><span class="params">(String uri, String localName, String qName)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">System.out.println(qName + <span class="string">"元素解析结束"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">characters</span><span class="params">(<span class="keyword">char</span>[] ch, <span class="keyword">int</span> start, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">System.out.print(<span class="keyword">new</span> String(ch, start, length).trim());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用SAX解析首先需要获取工厂，再通过工厂获取解析器对象，然后使用解析对象完成解析工作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SAXParserFactory factory = SAXParserFactory.newInstance();</span><br><span class="line">SAXParser parser = factory.newSAXParser();</span><br><span class="line">parser.parse(<span class="keyword">new</span> File(<span class="string">"src/students.xml"</span>), <span class="keyword">new</span> MyContentHandler());</span><br></pre></td></tr></table></figure><h4 id="DOM4j-解析"><a href="#DOM4j-解析" class="headerlink" title="DOM4j 解析"></a>DOM4j 解析</h4><p>DOM4J是针对Java开发人员专门提供的XML文档解析规范，它不同与DOM，但与DOM相似。DOM4J针对Java开发人员而设计，所以对于Java开发人员来说，使用DOM4J要比使用DOM更加方便。</p><p>在DOM4J中，也有Node、Document、Element等接口，结构上与DOM中的接口比较相似。但它们是不同的类：</p><p><img src="https://i.loli.net/2020/06/26/lHTBAeoknaLsbif.jpg" alt="img"></p><p>Node</p><ul><li><p>Attribute：表示属性节点；</p></li><li><p>Branch：表示可以包含子元素的节点：</p><ul><li>Document：表示整个文档；</li><li>Element：表示元素节点；</li></ul></li><li><p>CharacterData：表示文本节点：</p><ul><li>Text：表示文本内容；</li><li>CDATA：表示CDATA段内容；</li><li>Comment：表示注释内容。</li></ul></li></ul><p>再次强调，DOM和DOM4J是不同的，DOM中的Document是org.w3c.Document，而DOM4J中的Document是org.dom4j.Document，它们是不同的类，其他Node、Element也是一样。</p><h5 id="读取、保存、创建Document"><a href="#读取、保存、创建Document" class="headerlink" title="读取、保存、创建Document"></a>读取、保存、创建Document</h5><p>使用dom4j需要导入：</p><ul><li><p>dom4j.jar</p></li><li><p>jaxen.jar</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取</span></span><br><span class="line">SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">Document doc = reader.read(<span class="string">"src/students.xml"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存xml文档</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建格式化器，使用\t缩进，添加换行</span></span><br><span class="line">OutputFormat format = <span class="keyword">new</span> OutputFormat(<span class="string">"\t"</span>, <span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 清空数据中原有的换行</span></span><br><span class="line">format.setTrimText(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 创建XML输出流对象</span></span><br><span class="line">XMLWriter writer = <span class="keyword">new</span> XMLWriter(<span class="keyword">new</span> FileWriter(<span class="string">"src/a.xml"</span>), format);</span><br><span class="line"><span class="comment">// 输出Document</span></span><br><span class="line">writer.write(doc);</span><br><span class="line"><span class="comment">// 关闭流</span></span><br><span class="line">writer.close();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Document</span></span><br><span class="line">Document doc = DocumentHelper.createDocument();</span><br></pre></td></tr></table></figure><p>遍历Document</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> <span class="keyword">throws</span> DocumentException </span>&#123;</span><br><span class="line">    SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">    Document doc = reader.read(<span class="string">"src/students.xml"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取根元素</span></span><br><span class="line">    Element rootEle = doc.getRootElement();</span><br><span class="line">    <span class="comment">// 获取根元素的所有子元素</span></span><br><span class="line">    List&lt;Element&gt; eleList = rootEle.elements();</span><br><span class="line">    <span class="comment">// 遍历元素集合</span></span><br><span class="line">    <span class="keyword">for</span> (Element stuEle : eleList) &#123;</span><br><span class="line">        <span class="comment">// 获取元素名称</span></span><br><span class="line">        String eleName = stuEle.getName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取元素的number属性值</span></span><br><span class="line">        String number = stuEle.attributeValue(<span class="string">"number"</span>);</span><br><span class="line">        <span class="comment">// 获取元素的name子元素内容</span></span><br><span class="line">        String name = stuEle.elementText(<span class="string">"name"</span>);</span><br><span class="line">        <span class="comment">// 获取元素的age子元素内容</span></span><br><span class="line">        String age = stuEle.elementText(<span class="string">"age"</span>);</span><br><span class="line">        <span class="comment">// 获取元素的sex子元素内容</span></span><br><span class="line">        String sex = stuEle.elementText(<span class="string">"sex"</span>);</span><br><span class="line">        System.out.println(eleName + <span class="string">": [number="</span> + number + <span class="string">", name="</span></span><br><span class="line">                           + name + <span class="string">", age="</span> + age + <span class="string">", sex="</span> + sex + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加student元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">Document doc = reader.read(<span class="string">"src/students.xml"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取根元素&lt;students&gt;</span></span><br><span class="line">Element root = doc.getRootElement();</span><br><span class="line"><span class="comment">// 为root添加名为student的子元素，并返回这个新添加的子元素</span></span><br><span class="line">Element stuEle = root.addElement(<span class="string">"student"</span>);</span><br><span class="line"><span class="comment">// 给元素添加属性number，值为123</span></span><br><span class="line">stuEle.addAttribute(<span class="string">"number"</span>, <span class="string">"123"</span>);</span><br><span class="line"><span class="comment">// 添加子元素name，并设置name子元素的文本内容为wangWu</span></span><br><span class="line">stuEle.addElement(<span class="string">"name"</span>).setText(<span class="string">"wangWu"</span>);</span><br><span class="line">stuEle.addElement(<span class="string">"age"</span>).setText(<span class="string">"30"</span>);</span><br><span class="line">stuEle.addElement(<span class="string">"sex"</span>).setText(<span class="string">"male"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建格式化器，使用\t缩进，添加换行</span></span><br><span class="line">OutputFormat format = <span class="keyword">new</span> OutputFormat(<span class="string">"\t"</span>, <span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 清空数据中原有的换行</span></span><br><span class="line">format.setTrimText(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 创建XML输出流对象</span></span><br><span class="line">XMLWriter writer = <span class="keyword">new</span> XMLWriter(<span class="keyword">new</span> FileWriter(<span class="string">"src/a.xml"</span>), format);</span><br><span class="line"><span class="comment">// 输出Document</span></span><br><span class="line">writer.write(doc);</span><br><span class="line"><span class="comment">// 关闭流</span></span><br><span class="line">writer.close();</span><br></pre></td></tr></table></figure><p>查询元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">Document doc = reader.read(<span class="string">"src/students.xml"</span>);</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * selectSingNode()方法的参数是XPath</span></span><br><span class="line"><span class="comment"> * XPath是在XML文档中查找的一门表达式语言</span></span><br><span class="line"><span class="comment"> * "//"表示查找整个XML文档</span></span><br><span class="line"><span class="comment"> * student表示查找名为student的元素</span></span><br><span class="line"><span class="comment"> * []表示条件</span></span><br><span class="line"><span class="comment"> * @number表示number属性</span></span><br><span class="line"><span class="comment"> * @number='ITCAST_1001'表示条件为number属性等于ITCAST_1001</span></span><br><span class="line"><span class="comment"> * selectSingNode()方法在查找到多个满足XPath的元素时，只返回第一个。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Element stuEle1 = (Element)doc.selectSingleNode(<span class="string">"//student[@number='ITCAST_1001']"</span>);</span><br><span class="line"><span class="comment">// 把元素转换成字符串</span></span><br><span class="line">System.out.println(stuEle1.asXML());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找name子元素内容为liSi的student元素</span></span><br><span class="line">Element stuEle2 = (Element) doc.selectSingleNode(<span class="string">"//student[name='liSi']"</span>);</span><br><span class="line">System.out.println(stuEle2.asXML());</span><br></pre></td></tr></table></figure><p>修改元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">Document doc = reader.read(<span class="string">"src/students.xml"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找元素</span></span><br><span class="line">Element stuEle = (Element)doc.selectSingleNode(<span class="string">"//student[@number='ITCAST_1001']"</span>);</span><br><span class="line"><span class="comment">// 修改student元素的name子元素内容为"张三"</span></span><br><span class="line">stuEle.element(<span class="string">"name"</span>).setText(<span class="string">"张三"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建格式化器，使用\t缩进，添加换行</span></span><br><span class="line">OutputFormat format = <span class="keyword">new</span> OutputFormat(<span class="string">"\t"</span>, <span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 清空数据中原有的换行</span></span><br><span class="line">format.setTrimText(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 创建XML输出流对象</span></span><br><span class="line">XMLWriter writer = <span class="keyword">new</span> XMLWriter(<span class="keyword">new</span> FileWriter(<span class="string">"src/a.xml"</span>), format);</span><br><span class="line"><span class="comment">// 输出Document</span></span><br><span class="line">writer.write(doc);</span><br><span class="line"><span class="comment">// 关闭流</span></span><br><span class="line">writer.close();</span><br></pre></td></tr></table></figure><p>删除学生元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">Document doc = reader.read(<span class="string">"src/students.xml"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找元素</span></span><br><span class="line">Element stuEle = (Element)doc.selectSingleNode(<span class="string">"//student[@number='ITCAST_1001']"</span>);</span><br><span class="line"><span class="comment">// 获取父元素来删除元素</span></span><br><span class="line">stuEle.getParent().remove(stuEle);</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建格式化器，使用\t缩进，添加换行</span></span><br><span class="line">OutputFormat format = <span class="keyword">new</span> OutputFormat(<span class="string">"\t"</span>, <span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 清空数据中原有的换行</span></span><br><span class="line">format.setTrimText(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 创建XML输出流对象</span></span><br><span class="line">XMLWriter writer = <span class="keyword">new</span> XMLWriter(<span class="keyword">new</span> FileWriter(<span class="string">"src/a.xml"</span>), format);</span><br><span class="line"><span class="comment">// 输出Document</span></span><br><span class="line">writer.write(doc);</span><br><span class="line"><span class="comment">// 关闭流</span></span><br><span class="line">writer.close();</span><br></pre></td></tr></table></figure><h5 id="DOM4j-API-介绍"><a href="#DOM4j-API-介绍" class="headerlink" title="DOM4j API 介绍"></a>DOM4j API 介绍</h5><p>Node方法：</p><ul><li><p>String asXML()：把当前节点转换成字符串，如果当前Node是Document，那么就会把整个XML文档返回；</p></li><li><p>String getName()：获取当前节点名字；Document的名字就是绑定的XML文档的路径；Element的名字就是元素名称；Attribute的名字就是属性名；</p></li><li><p>Document getDocument()：返回当前节点所在的Document对象；</p></li><li><p>short getNodeType()：获取当前节点的类型；</p></li><li><p>String getNodeTypeName()：获取当前节点的类型名称，例如当前节点是Document的话，那么该方法返回Document；</p></li><li><p>String getStringValue()：获取当前节点的子孙节点中所有文本内容连接成的字符串；</p></li><li><p>String getText()：获取当前节点的文本内容。如果当前节点是Text等文本节点，那么本方法返回文本内容；例如当前节点是Element，那么当前节点的内容不是子元素，而是纯文本内容，那么返回文本内容，否则返回空字符串；</p></li><li><p>void setDocument(Document doc)：给当前节点设置文档元素；</p></li><li><p>void setParent(Element parent)：给当前节点设置父元素；</p></li><li><p>void setText(String text)：给当前节点设置文本内容；</p></li></ul><p>Branch方法：</p><ul><li>void add(Element e)：添加子元素；</li><li>void add(Node node)：添加子节点；</li><li>void add(Comment comment)：添加注释；</li><li>Element addElement(String eleName)：通过名字添加子元素，返回值为子元素对象；</li><li>void clearContent()：清空所有子内容；</li><li>List content()：获取所有子内容，与获取所有子元素的区别是，<name>liSi</name>元素没有子元素，但有子内容；</li><li>Element elementById(String id)：如果元素有名为”ID”的属性，那么可以使用这个方法来查找；</li><li>int indexOf(Node node)：查找子节点在子节点列表中的下标位置；</li><li>Node node(int index)：通过下标获取子节点；</li><li>int nodeCount()：获取子节点的个数；</li><li>Iterator nodeIterator()：获取子节点列表的迭代器对象；</li><li>boolean remove(Node node)：移除指定子节点；</li><li>boolean remove(Commont commont)：移除指定注释；</li><li>boolean remove(Element e)：移除指定子元素；</li><li>void setContent(List content) ：设置子节点内容；</li></ul><p>Document方法：</p><ul><li>Element getRootElement()：获取根元素；</li><li>void setRootElement()：设置根元素；</li><li>String getXmlEncoding()：获取XML文档的编码；</li><li>void setXmlEncoding()：设置XML文档的编码；</li></ul><p>Element方法：</p><ul><li>void add(Attribute attr)：添加属性节点；</li><li>void add(CDATA cdata)：添加CDATA段节点；</li><li>void add(Text Text)：添加Text节点；</li><li>Element addAttribute(String name, String value)：添加属性，返回值为当前元素本身；</li><li>Element addCDATA(String cdata)：添加CDATA段节点；</li><li>Element addComment(String comment)：添加属性节点；</li><li>Element addText(String text)：添加Text节点；</li><li>void appendAttributes(Element e)：把参数元素e的所有属性添加到当前元素中；</li><li>Attribute attribute(int index)：获取指定下标位置上的属性对象；</li><li>Attribute attribute(String name)：通过指定属性名称获取属性对象；</li><li>int attributeCount()：获取属性个数；</li><li>Iterator attributeIterator()：获取当前元素属性集合的迭代器；</li><li>List attributes()：获取当前元素的属性集合；</li><li>String attributeValue(String name)：获取当前元素指定名称的属性值；</li><li>Element createCopy()：clone当前元素对象，但不会copy父元素。也就是说新元素没有父元素，但有子元素；</li><li>Element element(String name)：获取当前元素第一个名称为name的子元素；</li><li>Iterator elementIterator()：获取当前元素的子元素集合的迭代器；</li><li>Iterator elementIterator(String name)：获取当前元素中指定名称的子元素集合的迭代器；</li><li>List elements()：获取当前元素子元素集合；</li><li>List elements(String name)：获取当前元素指定名称的子元素集合；</li><li>String elementText(String name)：获取当前元素指定名称的第一个元素文件内容；</li><li>String elementTextTrime(String name)：同上，只是去除了无用空白；</li><li>boolean isTextOnly()：当前元素是否为纯文本内容元素；</li><li>boolean remove(Attribute attr)：移除属性；</li><li>boolean remove(CDATA cdata)：移除CDATA；</li><li>boolean remove(Text text)：移除Text。</li></ul><p>DocumentHelper静态方法介绍：</p><ul><li>static Document createDocument()：创建Dcoument对象；</li><li>static Element createElement(String name)：创建指定名称的元素对象；</li><li>static Attribute createAttrbute(Element owner, String name, String value)：创建属性对象；</li><li>static Text createText(String text)：创建属性对象；</li><li>static Document parseText(String text)：通过给定的字符串生成Document对象；</li></ul><hr><h2 id="Day-03"><a href="#Day-03" class="headerlink" title="Day 03"></a>Day 03</h2><p><em>27/06/2020</em></p><h4 id="C-S"><a href="#C-S" class="headerlink" title="C/S"></a>C/S</h4><ul><li><p>C/S结构即客户端/服务器（Client/Server），例如QQ；</p></li><li><p>需要编写服务器端程序，以及客户端程序，例如我们安装的就是QQ的客户端程序；</p></li><li><p>缺点：软件更新时需要同时更新客户端和服务器端两端，比较麻烦；</p></li><li><p>优点：安全性比较好。</p></li></ul><h4 id="B-S"><a href="#B-S" class="headerlink" title="B/S"></a>B/S</h4><ul><li>B/S结构即浏览器/服务器（Browser/Server）；</li><li>优点：只需要编写服务器端程序；</li><li>缺点：安全性较差。</li></ul><h3 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h3><p>Tomcat的目录结构</p><ul><li><p>bin：该目录下存放的是二进制可执行文件，如果是安装版，那么这个目录下会有两个exe文件：tomcat6.exe、tomcat6w.exe，前者是在控制台下启动Tomcat，后者是弹出UGI窗口启动Tomcat；如果是解压版，那么会有startup.bat和shutdown.bat文件，startup.bat用来启动Tomcat，但需要先配置JAVA_HOME环境变量才能启动，shutdawn.bat用来停止Tomcat；</p></li><li><p>conf：这是一个非常非常重要的目录，这个目录下有四个最为重要的文件：</p><ul><li>server.xml：配置整个服务器信息。例如修改端口号，添加虚拟主机等；下面会详细介绍这个文件；</li><li>tomcatusers.xml：存储tomcat用户的文件，这里保存的是tomcat的用户名及密码，以及用户的角色信息。可以按着该文件中的注释信息添加tomcat用户，然后就可以在Tomcat主页中进入Tomcat Manager页面了；</li><li>web.xml：部署描述符文件，这个文件中注册了很多MIME类型，即文档类型。这些MIME类型是客户端与服务器之间说明文档类型的，如用户请求一个html网页，那么服务器还会告诉客户端浏览器响应的文档是text/html类型的，这就是一个MIME类型。客户端浏览器通过这个MIME类型就知道如何处理它了。当然是在浏览器中显示这个html文件了。但如果服务器响应的是一个exe文件，那么浏览器就不可能显示它，而是应该弹出下载窗口才对。MIME就是用来说明文档的内容是什么类型的！</li><li>context.xml：对所有应用的统一配置，通常我们不会去配置它。</li></ul></li><li><p>lib：Tomcat的类库，里面是一大堆jar文件。如果需要添加Tomcat依赖的jar文件，可以把它放到这个目录中，当然也可以把应用依赖的jar文件放到这个目录中，这个目录中的jar所有项目都可以共享之，但这样你的应用放到其他Tomcat下时就不能再共享这个目录下的Jar包了，所以建议只把Tomcat需要的Jar包放到这个目录下；</p></li><li><p>logs：这个目录中都是日志文件，记录了Tomcat启动和关闭的信息，如果启动Tomcat时有错误，那么异常也会记录在日志文件中。</p></li><li><p>temp：存放Tomcat的临时文件，这个目录下的东西可以在停止Tomcat后删除！</p></li><li><p>webapps：存放web项目的目录，其中每个文件夹都是一个项目；如果这个目录下已经存在了目录，那么都是tomcat自带的。项目。其中ROOT是一个特殊的项目，在地址栏中没有给出项目目录时，对应的就是ROOT项目。<code>http://localhost:8080/examples</code>，进入示例项目。其中examples就是项目名，即文件夹的名字。</p></li><li><p>work：运行时生成的文件，最终运行的文件都在这里。通过webapps中的项目生成的！可以把这个目录下的内容删除，再次运行时会生再次生成work目录。当客户端用户访问一个JSP文件时，Tomcat会通过JSP生成Java文件，然后再编译Java文件生成class文件，生成的java和class文件都会存放到这个目录下。</p></li><li><p>LICENSE：许可证。</p></li><li><p>NOTICE：说明文件。</p></li></ul><h4 id="Web-应用"><a href="#Web-应用" class="headerlink" title="Web 应用"></a>Web 应用</h4><h5 id="静态应用"><a href="#静态应用" class="headerlink" title="静态应用"></a>静态应用</h5><ul><li>在webapps下创建一个hello目录；</li><li>在webapps\hello\下创建index.html；</li><li>启动tomcat；</li><li>打开浏览器访问<code>http://localhost:8080/hello/index.html</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--index.html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="动态应用"><a href="#动态应用" class="headerlink" title="动态应用"></a>动态应用</h5><ul><li>在webapps下创建hello1目录；</li><li>在webapps\hello1\下创建WEB-INF目录；</li><li>在webapps\hello1\WEB-INF\下创建web.xml；</li><li>在webapps\hello1\下创建index.html。</li><li>打开浏览器访问<code>http://localhost:8080/hello/index.html</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">version</span>=<span class="string">"2.5"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee </span></span></span><br><span class="line"><span class="tag"><span class="string">http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>完整的Web应用还需要在WEB-INF目录下创建：</p><ul><li>classes；</li><li>lib目录；</li></ul><p>webapps</p><p>|- hello</p><p>​    |-index.html</p><p>​    |-WEB-INF</p><p>​        |-web.xml</p><p>​        |-classes</p><p>​        |-lib</p><ul><li>hello：应用目录，hello就是应用的名称；</li><li>index.html：应用资源。应用下可以有多个资源，例如css、js、html、jsp等，也可以把资源放到文件夹中，例如：hello\html\index.html，这时访问URL为：<a href="http://localhost:8080/hello/html/index.html；" target="_blank" rel="noopener">http://localhost:8080/hello/html/index.html；</a></li><li>WEB-INF：这个目录名称必须是大写，这个目录下的东西是无法通过浏览器直接访问的，也就是说放到这里的东西是安全的；</li><li>web.xml：应用程序的部署描述符文件，可以在该文件中对应用进行配置，例如配置应用的首页</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>classes：存放class文件的目录；</p></li><li><p>lib：存放jar包的目录；</p></li></ul><h5 id="配置外部应用"><a href="#配置外部应用" class="headerlink" title="配置外部应用"></a>配置外部应用</h5><p>也可以把应用放到Tomcat之外，这就是外部应用了。例如我们把上面写的hello应用从webapps目录中剪切到C盘下，即C:/hello。现在hello这个Web应用已经不在Tomcat中了，这时我们需要在tomcat中配置外部应用的位置，配置的方式一共有两种：</p><ul><li>conf/server.xml：打开server.xml文件，找到<code>&lt;Host&gt;</code>元素，在其中添加<code>&lt;Context&gt;</code>元素，代码如下：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"localhost"</span> <span class="attr">appBse</span>=<span class="string">"webapps"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">"itcast_hello"</span> <span class="attr">docBse</span>=<span class="string">"C:/hello/"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br></pre></td></tr></table></figure><p>1）path：指定当前应用的名称</p><p>2）docBase：指定应用的物理位置</p><p>3）浏览器访问路径：<code>http://localhost:8080/itcast_hello/index.html</code></p><ul><li>conf/catalana/localhost：在该目录下创建itcast_hello.xml文件，在该文件中编写<code>&lt;Context&gt;</code>元素，代码如下：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">docBase</span>=<span class="string">"C:/hello/"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>1）文件名：指定当前应用的名称；</p><p>2）docBase：指定应用的物理位置；</p><p>3）浏览器访问路径：<code>http://localhost:8080/itcast_hello/index.html</code></p><h5 id="server-xml"><a href="#server-xml" class="headerlink" title="server.xml"></a>server.xml</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Server</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Servier</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Engine</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Host</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Context</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;Server&gt;</code>：根元素，表示整个服务器的配置信息；</li><li><code>&lt;Service&gt;</code>：<code>&lt;Server&gt;</code>的子元素，在<code>&lt;Server&gt;</code>中只能有一个<code>&lt;Service&gt;</code>元素，它表示服务；</li><li><code>&lt;Connector&gt;</code>：<code>&lt;Service&gt;</code>的子元素，在<code>&lt;Service&gt;</code>中可以有N个<code>&lt;Connector&gt;</code>元素，它表示连接。</li><li><code>&lt;Engine&gt;</code>：<code>&lt;Service&gt;</code>的子元素，在<code>&lt;Service&gt;</code>中只能有一<code>&lt;Engine&gt;</code>元素，该元素表示引擎，它是<code>&lt;Service&gt;</code>组件的核心。</li><li><code>&lt;Host&gt;</code>：<code>&lt;Engine&gt;</code>的子元素，在<code>&lt;Engine&gt;</code>中可以有N个<code>&lt;Host&gt;</code>元素，每个<code>&lt;Host&gt;</code>元素表示一个虚拟主机。所谓虚拟主机就像是真的主机一样，每个主机都有自己的主机名和项目目录。例如<code>&lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot;&gt;</code>表示主机名为localhost，这个主机的项目存放在webapps目录中。访问这个项目下的主机时，需要使用localhost主机名，项目都存放在webapps目录下。</li><li><code>&lt;Context&gt;</code>：<code>&lt;Host&gt;</code>元素的子元素，在<code>&lt;Host&gt;</code>中可以有N个<code>&lt;Context&gt;</code>元素，每个<code>&lt;Context&gt;</code>元素表示一个应用。如果应用在<code>&lt;Host&gt;</code>的appBase指定的目录下，那么可以不配置<code>&lt;Context&gt;</code>元素，如果是外部应用，那么就必须配置<code>&lt;Context&gt;</code>。如果要为应用指定资源，也需要配置<code>&lt;Context&gt;</code>元素。</li></ul><p>我们可以把<code>&lt;Server&gt;</code>看作是一个大酒店：</p><ul><li><p><code>&lt;Service&gt;</code>：酒店的服务部门；</p></li><li><p><code>&lt;Connector&gt;</code>：服务员；</p></li><li><p><code>&lt;Engine&gt;</code>：后厨；</p></li><li><p><code>&lt;Host&gt;</code>：后厨中的一个区，例如川菜区是一个<code>&lt;Host&gt;</code>、粤菜区是一个<code>&lt;Host&gt;</code>；</p></li><li><p><code>&lt;Context&gt;</code>：后厨的一个厨师。</p></li></ul><p>用户发出一个请求：<code>http://localhost:8080/hello/index.jsp</code>。发现是http/1.1协议，而且还是8080端口，所以就交给了处理这一请求的”服务员（处理HTTP请求的<code>&lt;Connector&gt;</code>）”，”服务员”再把请求交给了”后厨（<code>&lt;Engine&gt;</code>）”，因为请求是要一盘水煮鱼，所以由”川菜区（<code>&lt;Host&gt;</code>）”负责，因为”大老王师傅<code>&lt;Context&gt;</code>“做水煮鱼最地道，所以由它完成。</p><ul><li><code>&lt;Connector&gt;</code>：关心请求中的http、和8080；</li><li><code>&lt;Host&gt;</code>：关心localhost；</li><li><code>&lt;Context&gt;</code>：关心hello</li></ul><h5 id="映射虚拟主机"><a href="#映射虚拟主机" class="headerlink" title="映射虚拟主机"></a>映射虚拟主机</h5><p>我们的目标是，在浏览器中输出：<code>http://www.itcast.cn</code>就可以访问我们的项目。</p><p>完成这一目标，我们需要做三件事：</p><ul><li><p>修改端口号为80，这一点应该没有问题吧；</p></li><li><p>在本机上可以解析域名为127.0.0.1，这需要修改C:\WINDOWS\system32\drivers\etc\hosts文件，添加对<code>http://www.itcast.cn</code>和127.0.01的绑定关系；</p></li><li><p>在server.xml文件中添加一个<code>&lt;Host&gt;</code>（主机）。</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"www.itcast.cn"</span> <span class="attr">appBase</span>=<span class="string">"F:/itcastapps"</span> <span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>name=&quot;www.itcast.cn&quot;</code>：指定虚拟主机名为<code>www.itcast.cn</code>；</li><li>appBase=”F:/itcastapps”：指定当前虚拟主机的应用程序存放目录为F:/itcastapps。</li><li>在itcastapps目录下创建名为ROOT的应用，因为一个主机只可以有一个名为ROOT的应用，名为ROOT的应用在浏览器中访问是可以不给出应用名称。</li></ul><h3 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h3><p>HTTP（hypertext transport protocol），即超文本传输协议。这个协议详细规定了浏览器和万维网服务器之间互相通信的规则。</p><p>HTTP就是一个通信规则，通信规则规定了客户端发送给服务器的内容格式，也规定了服务器发送给客户端的内容格式。其实我们要学习的就是这个两个格式！客户端发送给服务器的格式叫”请求协议”；服务器发送给客户端的格式叫”响应协议”。  </p><h4 id="URL-和-URI"><a href="#URL-和-URI" class="headerlink" title="URL 和 URI"></a>URL 和 URI</h4><p>URL：统一资源定位符，就是一个网址，例如：<code>http://www.itcast.cn</code>就是一个URL。<code>/hello/index.html</code>也是一个URL，URL必须是一个真实存在的网址。</p><p>URI：统一资源标识符：比URI包含了URL，URI的范围更加宽泛，URI可以是一个不存在的网址。在网络上用来标签资源的都是URI，例如<code>zhangSan@163.com</code>也是URI。</p><h4 id="请求协议"><a href="#请求协议" class="headerlink" title="请求协议"></a>请求协议</h4><p>请求协议的格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">请求首行；  </span><br><span class="line">请求头信息；  </span><br><span class="line">空行；  </span><br><span class="line">请求体。</span><br></pre></td></tr></table></figure><p>浏览器发送给服务器的内容就这个格式的，如果不是这个格式服务器将无法解读！在HTTP协议中，请求有很多请求方法，其中最为常用的就是GET和POST。不同的请求方法之间的区别，后面会一点一点的介绍。</p><h4 id="响应协议"><a href="#响应协议" class="headerlink" title="响应协议"></a>响应协议</h4><p>响应协议的格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">响应首行；</span><br><span class="line">响应头信息；</span><br><span class="line">空行；</span><br><span class="line">响应体。</span><br></pre></td></tr></table></figure><p>响应内容是由服务器发送给浏览器的内容，浏览器会根据响应内容来显示。</p><hr><h2 id="Day-04"><a href="#Day-04" class="headerlink" title="Day 04"></a>Day 04</h2><p><em>28/06/2020</em></p><h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><p>Servlet是JavaWeb的三大组件之一，它属于动态资源。Servlet的作用是处理请求，服务器会把接收到的请求交给Servlet来处理，在Servlet中通常需要：</p><ul><li>接收请求数据；</li><li>处理请求；</li><li>完成响应。</li></ul><p>　　例如客户端发出登录请求，或者输出注册请求，这些请求都应该由Servlet来完成处理！Servlet需要我们自己来编写，每个Servlet必须实现<code>javax.servlet.Servlet</code>接口。</p><h4 id="实现Servlet的方式"><a href="#实现Servlet的方式" class="headerlink" title="实现Servlet的方式"></a>实现Servlet的方式</h4><p>实现Servlet有三种方式：</p><ul><li>实现javax.servlet.Servlet接口；</li><li>继承javax.servlet.GenericServlet类；</li><li>继承javax.servlet.http.HttpServlet类；</li></ul><p>通常我们会去继承HttpServlet类来完成我们的Servlet，但学习Servlet还要从javax.servlet.Servlet接口开始学习。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Servlet.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletInfo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h4><p>开始第一个Servlet应用！首先在webapps目录下创建helloservlet目录，它就是我们的应用目录了，然后在helloservlet目录中创建准备JavaWeb应用所需内容：</p><ul><li><p>创建/helloservlet/WEB-INF目录；</p></li><li><p>创建/helloservlet/WEB-INF/classes目录；</p></li><li><p>创建/helloservlet/WEB-INF/lib目录；</p></li><li><p>创建/helloservlet/WEB-INF/web.xml文件；</p></li></ul><p>接下来我们开始准备完成Servlet，完成Servlet需要分为两步：</p><ul><li><p>编写Servlet类；</p></li><li><p>在web.xml文件中配置Servlet；</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HelloServlet.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getServletInfo</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"hello servlet!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们暂时忽略Servlet中其他四个方法，只关心service()方法，因为它是用来处理请求的方法。我们在该方法内给出一条输出语句！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--web.xml 重要 背--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>cn.itcast.servlet.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/helloworld<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在web.xml中配置Servlet的目的其实只有一个，就是把访问路径与一个Servlet绑定到一起，上面配置是把访问路径：”/helloworld”与”cn.itcast.servlet.HelloServlet”绑定到一起。</p><ul><li><p><code>&lt;servlet&gt;</code>：指定HelloServlet这个Servlet的名称为hello；</p></li><li><p><code>&lt;servlet-mapping&gt;</code>：指定/helloworld访问路径所以访问的Servlet名为hello。</p></li><li><p><code>&lt;servlet&gt;</code>和<code>&lt;servlet-mapping&gt;</code>通过<code>&lt;servlet-name&gt;</code>这个元素关联在一起了！</p></li></ul><p>接下来，我们编译HelloServlet，注意，编译HelloServlet时需要导入servlet-api.jar，因为Servlet.class等类都在servlet-api.jar中。</p><p>javac -classpath F:/tomcat6/lib/servlet-api.jar -d . HelloServlet.java</p><p>然后把HelloServlet.class放到/helloworld/WEB-INF/classes/目录下，然后启动Tomcat，在浏览器中访问：<code>http://localhost:8080/helloservlet/helloworld</code>即可在控制台上看到输出！</p><ul><li>/helloservlet/WEB-INF/classes/cn/itcast/servlet/HelloServlet.class；</li></ul><h3 id="Servlet接口"><a href="#Servlet接口" class="headerlink" title="Servlet接口"></a>Servlet接口</h3><h4 id="Servlet-的生命周期"><a href="#Servlet-的生命周期" class="headerlink" title="Servlet 的生命周期"></a>Servlet 的生命周期</h4><p>所谓xxx的生命周期，就是说xxx的出生、服务，以及死亡。Servlet生命周期也是如此！与Servlet的生命周期相关的方法有：</p><ul><li><p>void init(ServletConfig)；</p></li><li><p>void service(ServletRequest,ServletResponse)；</p></li><li><p>void destroy()；</p><h5 id="init"><a href="#init" class="headerlink" title="init"></a>init</h5></li></ul><p>服务器会在Servlet第一次被访问时创建Servlet，或者是在服务器启动时创建Servlet。如果服务器启动时就创建Servlet，那么还需要在web.xml文件中配置。也就是说默认情况下，Servlet是在第一次被访问时由服务器创建的。</p><p>而且一个Servlet类型，服务器只创建一个实例对象，例如在我们首次访问<code>http://localhost:8080/helloservlet/helloworld</code>时，服务器通过”/helloworld”找到了绑定的Servlet名称为cn.itcast.servlet.HelloServlet，然后服务器查看这个类型的Servlet是否已经创建过，如果没有创建过，那么服务器才会通过反射来创建HelloServlet的实例。当我们再次访问<code>http://localhost:8080/helloservlet/helloworld</code>时，服务器就不会再次创建HelloServlet实例了，而是直接使用上次创建的实例。</p><p>在Servlet被创建后，服务器会马上调用Servlet的<code>void init(ServletConfig)</code>方法。请记住， Servlet出生后马上就会调用<code>init()</code>方法，而且一个Servlet的一生。这个方法只会被调用一次。这好比小孩子出生后马上就要去剪脐带一样，而且剪脐带一生只有一次。</p><p>我们可以把一些对Servlet的初始化工作放到init方法中！</p><h5 id="service"><a href="#service" class="headerlink" title="service"></a>service</h5><p>当服务器每次接收到请求时，都会去调用Servlet的<code>service()</code>方法来处理请求。服务器接收到一次请求，就会调用<code>service()</code>方法一次，所以<code>service()</code>方法是会被调用多次的。正因为如此，所以我们才需要把处理请求的代码写到<code>service()</code>方法中！</p><h5 id="destroy"><a href="#destroy" class="headerlink" title="destroy"></a>destroy</h5><p>Servlet是不会轻易离去的，通常都是在服务器关闭时Servlet才会离去！在服务器被关闭时，服务器会去销毁Servlet，在销毁Servlet之前服务器会先去调用Servlet的<code>destroy()</code>方法，我们可以把Servlet的临终遗言放到<code>destroy()</code>方法中，例如对某些资源的释放等代码放到<code>destroy()</code>方法中。</p><h4 id="Servlet-接口相关类型"><a href="#Servlet-接口相关类型" class="headerlink" title="Servlet 接口相关类型"></a>Servlet 接口相关类型</h4><p>在Servlet接口中还存在三个我们不熟悉的类型：</p><ul><li><p>ServletRequest：<code>service()</code> 方法的参数，它表示请求对象，它封装了所有与请求相关的数据，它是由服务器创建的；</p></li><li><p>ServletResponse：<code>service()</code>方法的参数，它表示响应对象，在<code>service()</code>方法中完成对客户端的响应需要使用这个对象；</p></li><li><p>ServletConfig：<code>init()</code>方法的参数，它表示Servlet配置对象，它对应Servlet的配置信息，那对应web.xml文件中的<code>&lt;servlet&gt;</code>元素。</p></li></ul><h5 id="ServletRequest和ServletResponse"><a href="#ServletRequest和ServletResponse" class="headerlink" title="ServletRequest和ServletResponse"></a>ServletRequest和ServletResponse</h5><p>ServletRequest和ServletResponse是Servlet#<code>service()</code> 方法的两个参数，一个是请求对象，一个是响应对象，可以从ServletRequest对象中获取请求数据，可以使用ServletResponse对象完成响应。你以后会发现，这两个对象就像是一对恩爱的夫妻，永远不分离，总是成对出现。</p><p>ServletRequest和ServletResponse的实例由服务器创建，然后传递给service()方法。如果在service() 方法中希望使用HTTP相关的功能，那么可以把ServletRequest和ServletResponse强转成HttpServletRequest和HttpServletResponse。这也说明我们经常需要在service()方法中对ServletRequest和ServletResponse进行强转，这是很心烦的事情。不过后面会有一个类来帮我们解决这一问题的。</p><p>HttpServletRequest方法：</p><ul><li><p>String getParameter(String paramName)：获取指定请求参数的值；</p></li><li><p>String getMethod()：获取请求方法，例如GET或POST；</p></li><li><p>String getHeader(String name)：获取指定请求头的值；</p></li><li><p>void setCharacterEncoding(String encoding)：设置请求体的编码！因为GET请求没有请求体，所以这个方法只只对POST请求有效。当调用<code>request.setCharacterEncoding(&quot;utf-8&quot;)</code>之后，再通过getParameter()方法获取参数值时，那么参数值都已经通过了转码，即转换成了UTF-8编码。所以，这个方法必须在调用getParameter()方法之前调用！</p></li></ul><p>HttpServletResponse方法：</p><ul><li><p>PrintWriter getWriter()：获取字符响应流，使用该流可以向客户端输出响应信息。例如<code>response.getWriter().print(&quot;&lt;h1&gt;Hello JavaWeb!&lt;/h1&gt;&quot;)</code>；</p></li><li><p>ServletOutputStream getOutputStream()：获取字节响应流，当需要向客户端响应字节数据时，需要使用这个流，例如要向客户端响应图片；</p></li><li><p>void setCharacterEncoding(String encoding)：用来设置字符响应流的编码，例如在调用<code>setCharacterEncoding(&quot;utf-8&quot;)</code>;之后，再<code>response.getWriter()</code>获取字符响应流对象，这时的响应流的编码为utf-8，使用response.getWriter()输出的中文都会转换成utf-8编码后发送给客户端；</p></li><li><p>void setHeader(String name, String value)：向客户端添加响应头信息，例如<code>setHeader(&quot;Refresh&quot;, &quot;3;url=http://www.itcast.cn&quot;)</code>，表示3秒后自动刷新到<code>http://www.itcast.cn</code>；</p></li><li><p>void setContentType(String contentType)：该方法是<code>setHeader(&quot;content-type&quot;, &quot;xxx&quot;)</code>的简便方法，即用来添加名为content-type响应头的方法。content-type响应头用来设置响应数据的MIME类型，例如要向客户端响应jpg的图片，那么可以<code>setContentType(&quot;image/jepg&quot;)</code>，如果响应数据为文本类型，那么还要台同时设置编码，例如<code>setContentType(&quot;text/html;chartset=utf-8&quot;)</code>表示响应数据类型为文本类型中的html类型，并且该方法会调用<code>setCharacterEncoding(&quot;utf-8&quot;)</code>方法；</p></li><li><p>void sendError(int code, String errorMsg)：向客户端发送状态码，以及错误消息。例如给客户端发送404：<code>response(404, &quot;您要查找的资源不存在！&quot;)</code>。</p></li></ul><h5 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a>ServletConfig</h5><p>ServletConfig对象对应web.xml文件中的<code>&lt;servlet&gt;</code>元素。例如你想获取当前Servlet在web.xml文件中的配置名，那么可以使用servletConfig.getServletName()方法获取！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>One<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        cn.itcast.servlet.OneServlet</span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure><p>ServletConfig对象是由服务器创建的，然后传递给Servlet的init()方法，你可以在init()方法中使用它！</p><ul><li><p>String getServletName()：获取Servlet在web.xml文件中的配置名称，即<code>&lt;servlet-name&gt;</code>指定的名称；</p></li><li><p>ServletContext getServletContext()：用来获取ServletContext对象，ServletContext会在后面讲解；</p></li><li><p>String getInitParameter(String name)：用来获取在web.xml中配置的初始化参数，通过参数名来获取参数值；</p></li><li><p>Enumeration getInitParameterNames()：用来获取在web.xml中配置的所有初始化参数名称；</p></li></ul><p>在<code>&lt;servlet&gt;</code>元素中还可以配置初始化参数：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>One<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>cn.itcast.servlet.OneServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>paramName1<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>paramValue1<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>paramName2<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>paramValue2<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在OneServlet中，可以使用ServletConfig对象的getInitParameter()方法来获取初始化参数，例如：</p><p><code>String value1 = servletConfig.getInitParameter(&quot;paramName1&quot;);//获取到paramValue1</code></p><h3 id="GenericServlet"><a href="#GenericServlet" class="headerlink" title="GenericServlet"></a>GenericServlet</h3><p>GenericServlet是Servlet接口的实现类，我们可以通过继承GenericServlet来编写自己的Servlet。下面是GenericServlet类的源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GenericServlet.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span>, <span class="title">ServletConfig</span>,</span></span><br><span class="line"><span class="class">        <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ServletConfig config;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericServlet</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInitParameter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getServletConfig().getInitParameter(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title">getInitParameterNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getServletConfig().getInitParameterNames();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletContext <span class="title">getServletContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getServletConfig().getServletContext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.config = config;</span><br><span class="line">        <span class="keyword">this</span>.init();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        getServletContext().log(getServletName() + <span class="string">": "</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String message, Throwable t)</span> </span>&#123;</span><br><span class="line">        getServletContext().log(getServletName() + <span class="string">": "</span> + message, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> config.getServletName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在GenericServlet中，定义了一个ServletConfig config实例变量，并在init(ServletConfig)方法中把参数ServletConfig赋给了实例变量。然后在该类的很多方法中使用了实例变量config。</p><p>如果子类覆盖了GenericServlet的init(StringConfig)方法，那么this.config=config这一条语句就会被覆盖了，也就是说GenericServlet的实例变量config的值为null，那么所有依赖config的方法都不能使用了。如果真的希望完成一些初始化操作，那么去覆盖GenericServlet提供的init()方法，它是没有参数的init()方法，它会在init(ServletConfig)方法中被调用。</p><p>GenericServlet还实现了ServletConfig接口，所以可以直接调用getInitParameter()、getServletContext()等ServletConfig的方法。</p><h3 id="HttpServlet"><a href="#HttpServlet" class="headerlink" title="HttpServlet"></a>HttpServlet</h3><p>HttpServlet类是GenericServlet的子类，它提供了对HTTP请求的特殊支持，所以通常我们都会通过继承HttpServlet来完成自定义的Servlet。</p><p>HttpServlet类中提供了service(HttpServletRequest,HttpServletResponse)方法，这个方法是HttpServlet自己的方法，不是从Servlet继承来的。在HttpServlet的service(ServletRequest,ServletResponse)方法中会把ServletRequest和ServletResponse强转成HttpServletRequest和HttpServletResponse，然后调用service(HttpServletRequest,HttpServletResponse)方法，这说明子类可以去覆盖service(HttpServletRequest,HttpServletResponse)方法即可，这就不用自己去强转请求和响应对象了。</p><p>其实子类也不用去覆盖service(HttpServletRequest,HttpServletResponse)方法，因为HttpServlet还要做另一步简化操作，下面会介绍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HttpServlet.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServlet</span> <span class="keyword">extends</span> <span class="title">GenericServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        ……</span><br><span class="line">&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        HttpServletRequest  request;</span><br><span class="line">        HttpServletResponse response;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            request = (HttpServletRequest) req;</span><br><span class="line">            response = (HttpServletResponse) res;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"non-HTTP request or response"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        service(request, response);</span><br><span class="line">&#125;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="doGet-和doPost"><a href="#doGet-和doPost" class="headerlink" title="doGet()和doPost()"></a>doGet()和doPost()</h4><p>在HttpServlet的service(HttpServletRequest,HttpServletResponse)方法会去判断当前请求是GET还是POST，如果是GET请求，那么会去调用本类的doGet()方法，如果是POST请求会去调用doPost()方法，这说明我们在子类中去覆盖doGet()或doPost()方法即可。</p><h3 id="Servlet-细节"><a href="#Servlet-细节" class="headerlink" title="Servlet 细节"></a>Servlet 细节</h3><h4 id="Servlet与线程安全"><a href="#Servlet与线程安全" class="headerlink" title="Servlet与线程安全"></a>Servlet与线程安全</h4><p>因为一个类型的Servlet只有一个实例对象，那么就有可能会现时出一个Servlet同时处理多个请求，那么Servlet是否为线程安全的呢？答案是：”不是线程安全的”。这说明Servlet的工作效率很高，但也存在线程安全问题！</p><p>所以我们不应该在Servlet中随意创建成员变量，因为可能会存在一个线程对这个成员变量进行写操作，另一个线程对这个成员变量进行读操作。</p><h4 id="让服务器在启动时就创建Servlet"><a href="#让服务器在启动时就创建Servlet" class="headerlink" title="让服务器在启动时就创建Servlet"></a>让服务器在启动时就创建Servlet</h4><p>默认情况下，服务器会在某个Servlet第一次收到请求时创建它。也可以在web.xml中对Servlet进行配置，使服务器启动时就创建Servlet。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>cn.itcast.servlet.Hello1Servlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>0<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello1<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello2<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>cn.itcast.servlet.Hello2Servlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello2<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello2<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello3<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>cn.itcast.servlet.Hello3Servlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>2<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello3<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello3<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在<code>&lt;servlet&gt;</code>元素中配置<code>&lt;load-on-startup&gt;</code>元素可以让服务器在启动时就创建该Servlet，其中<code>&lt;load-on-startup&gt;</code>元素的值必须是大于等于0的整数，它的使用是服务器启动时创建Servlet的顺序。上例中，根据<code>&lt;load-on-startup&gt;</code>的值可以得知服务器创建Servlet的顺序为Hello1Servlet、Hello2Servlet、Hello3Servlet。</p><h4 id="lt-url-pattern-gt"><a href="#lt-url-pattern-gt" class="headerlink" title="&lt;url-pattern&gt;"></a><code>&lt;url-pattern&gt;</code></h4><p><code>&lt;url-pattern&gt;</code>是<code>&lt;servlet-mapping&gt;</code>的子元素，用来指定Servlet的访问路径，即URL。它必须是以”/“开头！</p><p>1）可以在<code>&lt;servlet-mapping&gt;</code>中给出多个<code>&lt;url-pattern&gt;</code>，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>AServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/AServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/BServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么这说明一个Servlet绑定了两个URL，无论访问/AServlet还是/BServlet，访问的都是AServlet。</p><p>2）还可以在<code>&lt;url-pattern&gt;</code>中使用通配符，所谓通配符就是星号”*“，星号可以匹配任何URL前缀或后缀，使用通配符可以命名一个Servlet绑定一组URL，例如：</p><ul><li><p><code>&lt;url-pattern&gt;/servlet/*&lt;url-patter&gt;</code>：/servlet/a、/servlet/b，都匹配/servlet/*；</p></li><li><p><code>&lt;url-pattern&gt;*.do&lt;/url-pattern&gt;</code>：/abc/def/ghi.do、/a.do，都匹配*.do；</p></li><li><p><code>&lt;url-pattern&gt;/*&lt;url-pattern&gt;</code>：匹配所有URL；</p></li></ul><p>请注意，通配符要么为前缀，要么为后缀，不能出现在URL中间位置，也不能只有通配符。例如：<code>/*.do</code>就是错误的，因为星号出现在URL的中间位置上了。<em>.</em>也是不对的，因为一个URL中最多只能出现一个通配符。</p><p>注意，通配符是一种模糊匹配URL的方式，如果存在更具体的<code>&lt;url-pattern&gt;</code>，那么访问路径会去匹配具体的<code>&lt;url-pattern&gt;</code>。例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>cn.itcast.servlet.Hello1Servlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/servlet/hello1<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello2<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>cn.itcast.servlet.Hello2Servlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello2<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/servlet/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当访问路径为<code>http://localhost:8080/hello/servlet/hello1</code>时，因为访问路径即匹配hello1的<code>&lt;url-pattern&gt;</code>，又匹配hello2的<code>&lt;url-pattern&gt;</code>，但因为hello1的<code>&lt;url-pattern&gt;</code>中没有通配符，所以优先匹配，即设置hello1。</p><h4 id="web-xml文件的继承（了解）"><a href="#web-xml文件的继承（了解）" class="headerlink" title="web.xml文件的继承（了解）"></a>web.xml文件的继承（了解）</h4><p>每个完整的JavaWeb应用中都需要有web.xml，但我们不知道所有的web.xml文件都有一个共同的父文件，它在Tomcat的conf/web.xml路径。</p><h3 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h3><p>服务器会为每个应用创建一个ServletContext对象：</p><ul><li><p>ServletContext对象的创建是在服务器启动时完成的；</p></li><li><p>ServletContext对象的销毁是在服务器关闭时完成的。</p></li></ul><p>ServletContext对象的作用是在整个Web应用的动态资源之间共享数据！例如在AServlet中向ServletContext对象中保存一个值，然后在BServlet中就可以获取这个值，这就是共享数据了。</p><h4 id="获取ServletContext"><a href="#获取ServletContext" class="headerlink" title="获取ServletContext"></a>获取ServletContext</h4><p>在Servlet中获取ServletContext对象：</p><ul><li><p>在void init(ServletConfig config)中：<code>ServletContext context = config.getServletContext();</code>，ServletConfig类的getServletContext()方法可以用来获取ServletContext对象；</p></li><li><p>在GenericeServlet或HttpServlet中获取ServletContext对象：</p></li><li><p>GenericServlet类有getServletContext()方法，所以可以直接使用this.getServletContext()来获取；</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> </span>&#123;</span><br><span class="line">        ServletContext context = config.getServletContext();</span><br><span class="line">    &#125;</span><br><span class="line">…</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">        ServletContext context = <span class="keyword">this</span>.getServletContext();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="域对象的功能"><a href="#域对象的功能" class="headerlink" title="域对象的功能"></a>域对象的功能</h4><p>ServletContext是JavaWeb四大域对象之一：</p><ul><li><p>PageContext；</p></li><li><p>ServletRequest；</p></li><li><p>HttpSession；</p></li><li><p>ServletContext；</p></li></ul><p>所有域对象都有存取数据的功能，因为域对象内部有一个Map，用来存储数据，下面是ServletContext对象用来操作数据的方法：</p><ul><li><p>void setAttribute(String name, Object value)：用来存储一个对象，也可以称之为存储一个域属性，例如：servletContext.setAttribute(“xxx”, “XXX”)，在ServletContext中保存了一个域属性，域属性名称为xxx，域属性的值为XXX。请注意，如果多次调用该方法，并且使用相同的name，那么会覆盖上一次的值，这一特性与Map相同；</p></li><li><p>Object getAttribute(String name)：用来获取ServletContext中的数据，当前在获取之前需要先去存储才行，例如：String value = (String)servletContext.getAttribute(“xxx”);，获取名为xxx的域属性；</p></li><li><p>void removeAttribute(String name)：用来移除ServletContext中的域属性，如果参数name指定的域属性不存在，那么本方法什么都不做；</p></li><li><p>Enumeration getAttributeNames()：获取所有域属性的名称；</p></li></ul><h4 id="获取应用初始化参数"><a href="#获取应用初始化参数" class="headerlink" title="获取应用初始化参数"></a>获取应用初始化参数</h4><p>还可以使用ServletContext来获取在web.xml文件中配置的应用初始化参数！注意，应用初始化参数与Servlet初始化参数不同：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>paramName1<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>paramValue1<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>paramName2<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>paramValue2<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ServletContext context = <span class="keyword">this</span>.getServletContext();</span><br><span class="line">String value1 = context.getInitParameter(<span class="string">"paramName1"</span>);</span><br><span class="line">String value2 = context.getInitParameter(<span class="string">"paramName2"</span>);</span><br><span class="line">System.out.println(value1 + <span class="string">", "</span> + value2);</span><br><span class="line"></span><br><span class="line">Enumeration names = context.getInitParameterNames();</span><br><span class="line"><span class="keyword">while</span>(names.hasMoreElements()) &#123;</span><br><span class="line">    System.out.println(names.nextElement());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取资源相关方法"><a href="#获取资源相关方法" class="headerlink" title="获取资源相关方法"></a>获取资源相关方法</h4><p><img src="https://i.loli.net/2020/06/28/pL6JzPvrkig4COR.png" alt></p><h5 id="获取真实路径"><a href="#获取真实路径" class="headerlink" title="获取真实路径"></a>获取真实路径</h5><p>还可以使用ServletContext对象来获取Web应用下的资源，例如在hello应用的根目录下创建a.txt文件，现在想在Servlet中获取这个资源，就可以使用ServletContext来获取。</p><ul><li><p>获取a.txt的真实路径：String realPath = servletContext.getRealPath(“/a.txt”)，realPath的值为a.txt文件的绝对路径：F:\tomcat6\webapps\hello\a.txt；</p></li><li><p>获取b.txt的真实路径：String realPath = servletContext.getRealPath(“/WEB-INF/b.txt”)；</p></li></ul><h5 id="获取资源流"><a href="#获取资源流" class="headerlink" title="获取资源流"></a>获取资源流</h5><p>不只可以获取资源的路径，还可以通过ServletContext获取资源流，即把资源以输入流的方式获取：</p><ul><li><p>获取a.txt资源流：InputStream in = servletContext.getResourceAsStream(“/a.txt”)；</p></li><li><p>获取b.txt资源流：InputStream in = servletContext.getResourceAsStream(“/WEB-INF/b.txt”)；</p></li></ul><h5 id="获取指定目录下所有资源路径"><a href="#获取指定目录下所有资源路径" class="headerlink" title="获取指定目录下所有资源路径"></a>获取指定目录下所有资源路径</h5><p>还可以使用ServletContext获取指定目录下所有资源路径，例如获取/WEB-INF下所有资源的路径：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set set = context.getResourcePaths(<span class="string">"/WEB-INF"</span>);</span><br><span class="line">System.out.println(set);</span><br></pre></td></tr></table></figure><h4 id="访问量统计"><a href="#访问量统计" class="headerlink" title="访问量统计"></a>访问量统计</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ServletContext application  = <span class="keyword">this</span>.getServletContext();<span class="comment">// 获取ServletContext对象</span></span><br><span class="line">Integer count = (Integer)application.getAttribute(<span class="string">"count"</span>);<span class="comment">// 获取对象的count属性</span></span><br><span class="line"><span class="keyword">if</span>(count == <span class="keyword">null</span>) &#123;<span class="comment">// 如果不存在 则创建访问量 并置1</span></span><br><span class="line">    count = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line">response.setContentType(<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line">response.getWriter().print(<span class="string">"&lt;h1&gt;本页面一共被访问"</span> + count + <span class="string">"次！&lt;/h1&gt;"</span>);<span class="comment">// 向客户端返访问次数</span></span><br><span class="line">application.setAttribute(<span class="string">"count"</span>, count);<span class="comment">// 保存</span></span><br></pre></td></tr></table></figure><h3 id="获取类路径资源"><a href="#获取类路径资源" class="headerlink" title="获取类路径资源"></a>获取类路径资源</h3><p>这里要讲的是获取类路径下的资源，对于JavaWeb应用而言，就是获取classes目录下的资源。</p><p><img src="https://i.loli.net/2020/06/28/qF9RrU4kuT8ZGCb.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = <span class="keyword">this</span>.getClass().getResourceAsStream(<span class="string">"/xxx.txt"</span>);</span><br><span class="line">System.out.println(IOUtils.toString(in));</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">InputStream in = <span class="keyword">this</span>.getClass().getClassLoader().getResourceAsStream(<span class="string">"xxx.txt"</span>);</span><br><span class="line">System.out.println(IOUtils.toString(in));</span><br></pre></td></tr></table></figure><ul><li><p>Class类的getResourceAsStream(String path)：</p><ul><li>路径以”/“开头，相对classes路径；</li><li>路径不以”/“开头，相对当前class文件所有路径，例如在cn.itcast.servlet.MyServlet中执行，那么相对/classes/cn/itcast/servlet/路径；</li></ul></li><li><p>ClassLoader类的getResourceAsStream(String path)：</p><ul><li>相对classes路径；</li></ul></li></ul><hr><h2 id="Day-05"><a href="#Day-05" class="headerlink" title="Day 05"></a>Day 05</h2><p><em>29/06/2020</em></p><p><img src="https://i.loli.net/2020/06/29/qwGEeM6o1KBzSgk.png" alt="2.png"></p><h3 id="response"><a href="#response" class="headerlink" title="response"></a>response</h3><p>response是Servlet.service方法的一个参数，类型为javax.servlet.http.HttpServletResponse。在客户端发出每个请求时，服务器都会创建一个response对象，并传入给Servlet.service()方法。response对象是用来对客户端进行响应的，这说明在service()方法中使用response对象可以完成对客户端的响应工作。</p><p>response对象的功能分为以下四种：</p><ul><li>设置响应头信息；</li><li>发送状态码；</li><li>设置响应正文；</li><li>重定向；</li></ul><h4 id="响应正文"><a href="#响应正文" class="headerlink" title="响应正文"></a>响应正文</h4><p>response是响应对象，向客户端输出响应正文（响应体）可以使用response的响应流，repsonse一共提供了两个响应流对象：</p><ul><li><p>PrintWriter out = response.getWriter()：获取字符流；</p></li><li><p>ServletOutputStream out = response.getOutputStream()：获取字节流；</p></li></ul><p>当然，如果响应正文内容为字符，那么使用response.getWriter()，如果响应内容是字节，例如下载时，那么可以使用response.getOutputStream()。</p><p>注意，在一个请求中，不能同时使用这两个流！也就是说，要么你使用repsonse.getWriter()，要么使用response.getOutputStream()，但不能同时使用这两个流。不然会抛出<code>IllegalStateException</code>异常。</p><h5 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h5><ul><li>字符编码</li></ul><p>在使用response.getWriter()时需要注意默认字符编码为ISO-8859-1，如果希望设置字符流的字符编码为utf-8，可以使用response.setCharaceterEncoding(“utf-8”)来设置。这样可以保证输出给客户端的字符都是使用UTF-8编码的！</p><p>但客户端浏览器并不知道响应数据是什么编码的！如果希望通知客户端使用UTF-8来解读响应数据，那么还是使用response.setContentType(“text/html;charset=utf-8”)方法比较好，因为这个方法不只会调用response.setCharaceterEncoding(“utf-8”)，还会设置content-type响应头，客户端浏览器会使用content-type头来解读响应数据。</p><ul><li>缓冲区</li></ul><p>response.getWriter()是PrintWriter类型，所以它有缓冲区，缓冲区的默认大小为8KB。也就是说，在响应数据没有输出8KB之前，数据都是存放在缓冲区中，而不会立刻发送到客户端。当Servlet执行结束后，服务器才会去刷新流，使缓冲区中的数据发送到客户端。</p><p>如果希望响应数据马上发送给客户端：</p><ul><li>向流中写入大于8KB的数据；</li><li>调用response.flushBuffer()方法来手动刷新缓冲区；</li></ul><h4 id="设置响应头"><a href="#设置响应头" class="headerlink" title="设置响应头"></a>设置响应头</h4><p>可以使用response对象的setHeader()方法来设置响应头！使用该方法设置的响应头最终会发送给客户端浏览器！</p><ul><li><p>response.setHeader(“content-type”, “text/html;charset=utf-8”)：设置content-type响应头，该头的作用是告诉浏览器响应内容为html类型，编码为utf-8。而且同时会设置response的字符流编码为utf-8，即response.setCharaceterEncoding(“utf-8”)；</p></li><li><p><code>response.setHeader(&quot;Refresh&quot;,&quot;5; URL=http://www.itcast.cn&quot;)</code>：5秒后自动跳转到传智主页。</p></li></ul><h4 id="设置状态码及其他方法"><a href="#设置状态码及其他方法" class="headerlink" title="设置状态码及其他方法"></a>设置状态码及其他方法</h4><ul><li><p>response.setContentType(“text/html;charset=utf-8”)：等同与调用response.setHeader(“content-type”, “text/html;charset=utf-8”)；</p></li><li><p>response.setCharacterEncoding(“utf-8”)：设置字符响应流的字符编码为utf-8； </p></li><li><p>response.setStatus(200)：设置状态码；</p></li><li><p>response.sendError(404, “您要查找的资源不存在”)：当发送错误状态码时，Tomcat会跳转到固定的错误页面去，但可以显示错误信息。</p></li></ul><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>当你访问<code>http://www.sun.com</code>时，你会发现浏览器地址栏中的URL会变成<code>http://www.oracle.com/us/sun/index.html</code>，这就是重定向了。</p><p>重定向是服务器通知浏览器去访问另一个地址，即再发出另一个请求。</p><p>响应码为200表示响应成功，而响应码为302表示重定向。所以完成重定向的第一步就是设置响应码为302。</p><p>因为重定向是通知浏览器再第二个请求，所以浏览器需要知道第二个请求的URL，所以完成重定向的第二步是设置Location头，指定第二个请求的URL地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">response.setStatus(<span class="number">302</span>);</span><br><span class="line">response.setHeader(<span class="string">"Location"</span>, <span class="string">"http://www.itcast.cn"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的作用是：当访问AServlet后，会通知浏览器重定向到传智主页。客户端浏览器解析到响应码为302后，就知道服务器让它重定向，所以它会马上获取响应头Location，然后发出第二个请求。</p><h5 id="更便捷的重定向"><a href="#更便捷的重定向" class="headerlink" title="更便捷的重定向"></a>更便捷的重定向</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">response.sendRedirect(<span class="string">"http://www.itcast.cn"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>response.sendRedirect()方法会设置响应头为302，以设置Location响应头。</p><p>如果要重定向的URL是在同一个服务器内，那么可以使用相对路径，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">response.sendRedirect(<span class="string">"/hello/BServlet"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重定向的URL地址为：<code>http://localhost:8080/hello/BServlet</code></p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ul><li>重定向是两次请求；</li><li>重定向的URL可以是其他应用，不局限于当前应用；</li><li>重定向的响应头为302，并且必须要有Location响应头；</li><li>重定向就不要再使用response.getWriter()或response.getOutputStream()输出数据，不然可能会出现异常；</li></ul><h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><p>request是Servlet.service()方法的一个参数，类型为javax.servlet.http.HttpServletRequest。在客户端发出每个请求时，服务器都会创建一个request对象，并把请求数据封装到request中，然后在调用Servlet.service()方法时传递给service()方法，这说明在service()方法中可以通过request对象来获取请求数据。</p><p>request的功能可以分为以下几种：</p><ul><li><p>封装了请求头数据；</p></li><li><p>封装了请求正文数据，如果是GET请求，那么就没有正文；</p></li><li><p>request是一个域对象，可以把它当成Map来添加获取数据；</p></li><li><p>request提供了请求转发和请求包含功能。</p></li></ul><h4 id="域方法"><a href="#域方法" class="headerlink" title="域方法"></a>域方法</h4><p>request是域对象！在JavaWeb中一共四个域对象，其中ServletContext就是域对象，它在整个应用中只创建一个ServletContext对象。request其中一个，request可以在一个请求中共享数据。</p><p>一个请求会创建一个request对象，如果在一个请求中经历了多个Servlet，那么多个Servlet就可以使用request来共享数据。现在我们还不知道如何在一个请求中经历多个Servlet，后面在学习请求转发和请求包含后就知道了。</p><p>下面是request的域方法：</p><ul><li><p>void setAttribute(String name, Object value)：用来存储一个对象，也可以称之为存储一个域属性，例如：servletContext.setAttribute(“xxx”, “XXX”)，在request中保存了一个域属性，域属性名称为xxx，域属性的值为XXX。请注意，如果多次调用该方法，并且使用相同的name，那么会覆盖上一次的值，这一特性与Map相同；</p></li><li><p>Object getAttribute(String name)：用来获取request中的数据，当前在获取之前需要先去存储才行，例如：String value = (String)request.getAttribute(“xxx”);，获取名为xxx的域属性；</p></li><li><p>void removeAttribute(String name)：用来移除request中的域属性，如果参数name指定的域属性不存在，那么本方法什么都不做；</p></li><li><p>Enumeration getAttributeNames()：获取所有域属性的名称；</p></li></ul><h4 id="request获取请求头数据"><a href="#request获取请求头数据" class="headerlink" title="request获取请求头数据"></a>request获取请求头数据</h4><p>request与请求头相关的方法有：</p><ul><li><p>String getHeader(String name)：获取指定名称的请求头；</p></li><li><p>Enumeration getHeaderNames()：获取所有请求头名称；</p></li><li><p>int getIntHeader(String name)：获取值为int类型的请求头。</p></li></ul><h4 id="request其他方法"><a href="#request其他方法" class="headerlink" title="request其他方法"></a>request其他方法</h4><p>request中还提供了与请求相关的其他方法，有些方法是为了我们更加便捷的方法请求头数据而设计，有些是与请求URL相关的方法。</p><ul><li><p>int getContentLength()：获取请求体的字节数，GET请求没有请求体，没有请求体返回-1；</p></li><li><p>String getContentType()：获取请求类型，如果请求是GET，那么这个方法返回null；如果是POST请求，那么默认为application/x-www-form-urlencoded，表示请求体内容使用了URL编码；</p></li><li><p>String getMethod()：返回请求方法，例如：GET</p></li><li><p>Locale getLocale()：返回当前客户端浏览器的Locale。java.util.Locale表示国家和言语，这个东西在国际化中很有用；</p></li><li><p>String getCharacterEncoding()：获取请求体编码，如果没有setCharacterEncoding()，那么返回null，表示使用ISO-8859-1编码；</p></li><li><p>void setCharacterEncoding(String code)：设置请求编码，只对请求体有效！注意，对于GET而言，没有请求体！！！所以此方法只能对POST请求中的参数有效！</p></li><li><p>String getContextPath()：返回上下文路径，例如：/hello</p></li><li><p>String getQueryString()：返回请求URL中的参数，例如：name=zhangSan</p></li><li><p>String getRequestURI()：返回请求URI路径，例如：/hello/oneServlet</p></li><li><p>StringBuffer getRequestURL()：返回请求URL路径，例如：<a href="http://localhost/hello/oneServlet，即返回除了参数以外的路径信息；" target="_blank" rel="noopener">http://localhost/hello/oneServlet，即返回除了参数以外的路径信息；</a></p></li><li><p>String getServletPath()：返回Servlet路径，例如：/oneServlet</p></li><li><p>String getRemoteAddr()：返回当前客户端的IP地址；</p></li><li><p>String getRemoteHost()：返回当前客户端的主机名，但这个方法的实现还是获取IP地址；</p></li><li><p>String getScheme()：返回请求协议，例如：http；</p></li><li><p>String getServerName()：返回主机名，例如：localhost</p></li><li><p>int getServerPort()：返回服务器端口号，例如：8080</p></li></ul><p><img src="https://i.loli.net/2020/06/29/WPFQOAz9i1ENkKC.png" alt="2.png"></p><p>eg. 可以使用request.getRemoteAddr()方法获取客户端的IP地址，然后判断IP是否为禁用IP。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String ip = request.getRemoteAddr();</span><br><span class="line">System.out.println(ip);</span><br><span class="line"><span class="keyword">if</span>(ip.equals(<span class="string">"127.0.0.1"</span>)) &#123;</span><br><span class="line">    response. getWriter().print(<span class="string">"您的IP已被禁止！"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    response.getWriter().print(<span class="string">"Hello!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="request获取请求参数"><a href="#request获取请求参数" class="headerlink" title="request获取请求参数"></a>request获取请求参数</h4><p>最为常见的客户端传递参数方式有两种：</p><ul><li><p>浏览器地址栏直接输入：一定是GET请求；</p></li><li><p>超链接：一定是GET请求；</p></li><li><p>表单：可以是GET，也可以是POST，这取决与<code>&lt;form&gt;</code>的method属性值；</p></li></ul><p>GET请求和POST请求的区别：</p><ul><li><p>GET请求：</p><ul><li><p>请求参数会在浏览器的地址栏中显示，所以不安全；</p></li><li><p>请求参数长度限制长度在1K之内；</p></li><li><p>GET请求没有请求体，无法通过request.setCharacterEncoding()来设置参数的编码；</p></li></ul></li><li><p>POST请求：</p><ul><li><p>请求参数不会显示浏览器的地址栏，相对安全；</p></li><li><p>请求参数长度没有限制；</p></li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/hello/ParamServlet?p1=v1&amp;p2=v2"</span>&gt;</span>超链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/hello/ParamServlet"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    参数1：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"p1"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    参数2：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"p2"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面是使用request获取请求参数的API：</p><ul><li>String getParameter(String name)：通过指定名称获取参数值；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    String v1 = request.getParameter(<span class="string">"p1"</span>);</span><br><span class="line">    String v2 = request.getParameter(<span class="string">"p2"</span>);</span><br><span class="line">    System.out.println(<span class="string">"p1="</span> + v1);</span><br><span class="line">    System.out.println(<span class="string">"p2="</span> + v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    String v1 = request.getParameter(<span class="string">"p1"</span>);</span><br><span class="line">    String v2 = request.getParameter(<span class="string">"p2"</span>);</span><br><span class="line">    System.out.println(<span class="string">"p1="</span> + v1);</span><br><span class="line">    System.out.println(<span class="string">"p2="</span> + v2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>String[] getParameterValues(String name)：当多个参数名称相同时，可以使用方法来获取；</p></li><li><p>Enumeration getParameterNames()：获取所有参数的名字；</p></li><li><p>Map getParameterMap()：获取所有参数封装到Map中，其中key为参数名，value为参数值，因为一个参数名称可能有多个值，所以参数值是String[]，而不是String。</p></li></ul><h4 id="请求转发与请求包含"><a href="#请求转发与请求包含" class="headerlink" title="请求转发与请求包含"></a>请求转发与请求包含</h4><p>无论是请求转发还是请求包含，都表示由多个Servlet共同来处理一个请求。例如Servlet1来处理请求，然后Servlet1又转发给Servlet2来继续处理这个请求。</p><h5 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h5><p>在AServlet中，把请求转发到BServlet：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"AServlet"</span>);</span><br><span class="line">RequestDispatcher rd = request.getRequestDispatcher(<span class="string">"/BServlet"</span>);</span><br><span class="line">rd.forward(request, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// --------------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"BServlet"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="请求包含"><a href="#请求包含" class="headerlink" title="请求包含"></a>请求包含</h5><p>在AServlet中，把请求包含到BServlet：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"AServlet"</span>);</span><br><span class="line">RequestDispatcher rd = request.getRequestDispatcher(<span class="string">"/BServlet"</span>);</span><br><span class="line">rd.include (request, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"BServlet"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="请求转发与请求包含比较"><a href="#请求转发与请求包含比较" class="headerlink" title="请求转发与请求包含比较"></a>请求转发与请求包含比较</h5><ul><li><p>如果在AServlet中请求转发到BServlet，那么在AServlet中就不允许再输出响应体，即不能再使用response.getWriter()和response.getOutputStream()向客户端输出，这一工作应该由BServlet来完成；如果是使用请求包含，那么没有这个限制；</p></li><li><p>请求转发虽然不能输出响应体，但还是可以设置响应头的，例如：response.setContentType(“text/html;charset=utf-8”);</p></li><li><p>请求包含大多是应用在JSP页面中，完成多页面的合并；</p></li><li><p>请求转发大多是应用在Servlet中，转发目标大多是JSP页面；</p></li></ul><p><img src="https://i.loli.net/2020/06/29/w7TlOmZHXcECJY3.png" alt="2.png"></p><h5 id="请求转发与重定向比较"><a href="#请求转发与重定向比较" class="headerlink" title="请求转发与重定向比较"></a>请求转发与重定向比较</h5><ul><li><p>请求转发是一个请求，而重定向是两个请求；</p></li><li><p>请求转发后浏览器地址栏不会有变化，而重定向会有变化，因为重定向是两个请求；</p></li><li><p>请求转发的目标只能是本应用中的资源，重定向的目标可以是其他应用；</p></li><li><p>请求转发对AServlet和BServlet的请求方法是相同的，即要么都是GET，要么都是POST，因为请求转发是一个请求；</p></li><li><p>重定向的第二个请求一定是GET；</p></li></ul><h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h3><p>与路径相关的操作</p><ul><li><p>超链接</p></li><li><p>表单</p></li><li><p>转发</p></li><li><p>包含</p></li><li><p>重定向</p></li><li><p><code>&lt;url-pattern&gt;</code></p></li><li><p>ServletContext获取资源</p></li><li><p>Class获取资源</p></li><li><p>ClassLoader获取资源</p></li></ul><h4 id="客户端路径"><a href="#客户端路径" class="headerlink" title="客户端路径"></a>客户端路径</h4><p>超链接、表单、重定向都是客户端路径，客户端路径可以分为三种方式：</p><ul><li><p>绝对路径；</p></li><li><p>以”/“开头的相对路径；</p></li><li><p>不以”/“开头的相对路径；</p></li></ul><p>例如：<code>http://localhost:8080/hello1/pages/a.html</code>中的超链接和表单如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">绝对路径：<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://localhost:8080/hello2/index.html"</span>&gt;</span>链接1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">客户端路径：<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/hello3/pages/index.html"</span>&gt;</span>链接2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">相对路径：<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index.html"</span>&gt;</span>链接3<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line">绝对路径：</span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://localhost:8080/hello2/index.html"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"表单1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">客户端路径：</span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/hello2/index.html"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"表单2"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">相对路径：</span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"index.html"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"表单3"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>链接1和表单1：没什么可说的，它使用绝对路径；</p></li><li><p>链接2和表单2：以”/“开头，相对主机，与当前a.html的主机相同，即最终访问的页面为<code>http://localhost:8080/hello2/index.html</code>；</p></li><li><p>链接3和表单3：不以”/“开头，相对当前页面的路径，即a.html所有路径，即最终访问的路径为：<code>http://localhost:8080/hello1/pages/index.html</code>；</p></li></ul><h5 id="建议使用”-“"><a href="#建议使用”-“" class="headerlink" title="建议使用”/“"></a>建议使用”/“</h5><p>强烈建议使用”/“开头的路径，这说明在页面中的超链接和表单都要以”/“开头，后面是当前应用的名称，再是访问路径：</p><p><code>&lt;form action=&quot;/hello/servlet/AServlet&quot;&gt;</code></p><p><code>&lt;/form&gt;</code></p><p><code>&lt;a href=&quot;/hello/b.html&quot;&gt;链接&lt;/a&gt;</code></p><p>其中/hello是当前应用名称，这也说明如果将来修改了应用名称，那么页面中的所有路径也要修改，这一点确实是个问题。这一问题的处理方案会在学习了JSP之后讲解！</p><p>在Servlet中的重定向也建议使用”/“开头。同理，也要给出应用的名称！例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.sendRedirect(<span class="string">"/hello/BServlet"</span>);</span><br></pre></td></tr></table></figure><p>其中/hello是当前应用名，如果将来修改了应用名称，那么也要修改所有重定向的路径，这一问题的处理方案是使用request.getContextPath()来获取应用名称。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.sendRedirect(request.getContextPath() + <span class="string">"/BServlet"</span>);</span><br></pre></td></tr></table></figure><h4 id="服务器端路径"><a href="#服务器端路径" class="headerlink" title="服务器端路径"></a>服务器端路径</h4><p>服务器端路径必须是相对路径，不能是绝对路径。但相对路径有两种形式：</p><ul><li><p>以”/“开头；</p></li><li><p>不以”/“开头；</p></li></ul><p>其中请求转发、请求包含都是服务器端路径，服务器端路径与客户端路径的区别是：</p><ul><li><p>客户端路径以”/“开头：相对当前主机；</p></li><li><p>服务器端路径以”/“开头：相对当前应用；</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eg1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">request.getRequestDispatcher(<span class="string">"/BServlet"</span>).forward(request, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设访问AServlet的路径为：<code>http://localhost:8080/hello/servlet/AServlet</code></p><p>因为路径以”/“开头，所以相对当前应用，即<code>http://localhost:8080/hello/BServlet</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eg2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">request.getRequestDispatcher(<span class="string">"BServlet"</span>).forward(request, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设访问AServlet的路径为：<code>http://localhost:8080/hello/servlet/AServlet</code></p><p>因为路径不以”/“开头，所以相对当前应用，即<code>http://localhost:8080/hello/servlet/BServlet</code>。</p><h4 id="lt-url-pattern-gt-路径"><a href="#lt-url-pattern-gt-路径" class="headerlink" title="&lt;url-pattern&gt;路径"></a><code>&lt;url-pattern&gt;</code>路径</h4><p><code>&lt;url-pattern&gt;</code>必须使用”/“开头，并且相对的是当前应用。</p><h4 id="ServletContext获取资源"><a href="#ServletContext获取资源" class="headerlink" title="ServletContext获取资源"></a>ServletContext获取资源</h4><p>必须是相对路径，可以”/“开头，也可以不使用”/“开头，但无论是否使用”/“开头都是相对当前应用路径。</p><p>例如在AServlet中获取资源，AServlet的路径路径为：<code>http://localhost:8080/hello/servlet/AServlet</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">String path1 = <span class="keyword">this</span>.getServletContext().getRealPath(<span class="string">"a.txt"</span>);</span><br><span class="line">String path2 = <span class="keyword">this</span>.getServletContext().getRealPath(<span class="string">"/a.txt"</span>);</span><br><span class="line">System.out.println(path1);</span><br><span class="line">System.out.println(path2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>path1和path2是相同的结果：<code>http://localhost:8080/hello/a.txt</code></p><h4 id="Class获取资源"><a href="#Class获取资源" class="headerlink" title="Class获取资源"></a>Class获取资源</h4><p>Class获取资源也必须是相对路径，可以”/“开头，也可以不使用”/“开头。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">InputStream in = Demo.class.getResourceAsStream("/a.txt");</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">InputStream in = Demo.class.getResourceAsStream("a.txt");</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中fun1()方法获取资源时以”/“开头，那么相对的是当前类路径，即/hello/WEB-INF/classes/a.txt文件；</p><p>其中fun2()方法获取资源时没有以”/“开头，那么相对当前Demo.class所在路径，因为Demo类在cn.itcast包下，所以资源路径为：/hello/WEB-INF/classes/cn/itcast/a.txt。</p><h4 id="ClassLoader获取资源"><a href="#ClassLoader获取资源" class="headerlink" title="ClassLoader获取资源"></a>ClassLoader获取资源</h4><p>ClassLoader获取资源也必须是相对路径，可以”/“开头，也可以不使用”/“开头。但无论是否以”/“开头，资源都是相对当前类路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">InputStream in = Demo.class.getClassLoader().getResourceAsStream("/a.txt");</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">InputStream in = Demo.class.getClassLoader().getResourceAsStream("a.txt");</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fun1()和fun2()方法的资源都是相对类路径，即classes目录，即/hello/WEB-INF/classes/a.txt</p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><h4 id="请求编码"><a href="#请求编码" class="headerlink" title="请求编码"></a>请求编码</h4><h5 id="直接在地址栏中给出中文"><a href="#直接在地址栏中给出中文" class="headerlink" title="直接在地址栏中给出中文"></a>直接在地址栏中给出中文</h5><p>请求数据是由客户端浏览器发送服务器的，请求数据的编码是由浏览器决定的。例如在浏览器地址栏中给出：<code>http://localhost:8080/hello/AServlet?name=传智</code>，那么其中”传智”是什么编码的呢？不同浏览器使用不同的编码，所以这是不确定的！</p><ul><li><p>IE：使用GB2312；</p></li><li><p>FireFox：使用GB2312；</p></li><li><p>Chrome：使用UTF-8； </p></li></ul><p>通常没有哪个应用要求用户在浏览器地址栏中输入请求数据的，所以大家只需了解一下即可。</p><h5 id="在页面中发出请求"><a href="#在页面中发出请求" class="headerlink" title="在页面中发出请求"></a>在页面中发出请求</h5><p>通常向服务器发送请求数据都需要先请求一个页面，然后用户在页面中输入数据。页面中有超链接和表单，通过超链接和表单就可以向服务器发送数据了。</p><p>因为页面是服务器发送到客户端浏览器的，所以这个页面本身的编码由服务器决定。而用户在页面中输入的数据也是由页面本身的编码决定的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>index.html<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"content-type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/hello/servlet/AServlet"</span>&gt;</span></span><br><span class="line">  名称:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/hello/servlet/AServlet?name=传智"</span>&gt;</span>链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当用户在index.html页面中输入数据时，都是UTF-8列表的。因为这个页面本身就是UTF-8编码的！</p><p><strong>页面的编译就是页面中输入数据的编码。</strong></p><h5 id="GET请求解读编码"><a href="#GET请求解读编码" class="headerlink" title="GET请求解读编码"></a>GET请求解读编码</h5><p>当客户端通过GET请求发送数据给服务器时，使用request.getParameter()获取的数据是被服务器误认为ISO-8859-1编码的，也就是说客户端发送过来的数据无论是UTF-8还是GBK，服务器都认为是ISO-8859-1，这就说明我们需要在使用request.getParameter()获取数据后，再转发成正确的编码。</p><p>例如客户端以UTF-8发送的数据，使用如下转码方式：</p><p>String name = request.getParameter(“name”);</p><p>name = new String(name.getBytes(“iso-8859-1”), “utf-8”);</p><h5 id="POST请求解读编码"><a href="#POST请求解读编码" class="headerlink" title="POST请求解读编码"></a>POST请求解读编码</h5><p>当客户端通过POST请求发送数据给服务器时，可以在使用request.getParameter()获取请求参数之前先通过request.setCharacterEncoding()来指定编码，然后再使用reuqest.getParameter()方法来获取请求参数，那么就是用指定的编码来读取了。</p><p>也就是说，如果是POST请求，服务器可以指定编码！但如果没有指定编码，那么默认还是使用ISO-8859-1来解读。</p><p>request.setCharacterEncoding(“utf-8”);</p><p>String name = request.getParameter(“name”);</p><h4 id="响应编码"><a href="#响应编码" class="headerlink" title="响应编码"></a>响应编码</h4><p>响应：服务器发送给客户端数据！响应是由response对象来完成，如果响应的数据不是字符数据，那么就无需去考虑编码问题。当然，如果响应的数据是字符数据，那么就一定要考虑编码的问题了。</p><p>response.getWriter().print(“传智”);</p><p>上面代码因为没有设置repsonse.getWriter()字符流的编码，所以服务器使用默认的编码（ISO-8859-1）来处理，因为ISO-8859-1不支持中文，所以一定会出现乱码的。</p><p>所以在使用response.getWriter()发送数据之前，一定要设置response.getWriter()的编码，这需要使用response.setCharacterEncoding()方法：</p><p>response.setCharacterEncoding(“utf-8”);</p><p>response.getWriter().print(“传智”);</p><p>上面代码因为在使用response.getWriter()输出之前已经设置了编码，所以输出的数据为utf-8编码。但是，因为没有告诉浏览器使用什么编码来读取响应数据，所以很可能浏览器会出现错误的解读，那么还是会出现乱码的。当然，通常浏览器都支持来设置当前页面的编码，如果用户在看到编码时，去设置浏览器的编码，如果设置的正确那么乱码就会消失。但是我们不能让用户总去自己设置编码，而且应该直接通知浏览器，服务器发送过来的数据是什么编码，这样浏览器就直接使用服务器告诉他的编码来解读！这需要使用content-type响应头。</p><p>response.setContentType(“text/html;charset=utf-8”);</p><p>response.getWriter().print(“传智”);</p><p>上面代码使用setContentType()方法设置了响应头content-type编码为utf-8，这不只是在响应中添加了响应头，还等于调用了一次response.setCharacterEncoding(“utf-8”)，也就是说，通过我们只需要调用一次response.setContentType(“text/html;charset=utf-8”)即可，而无需再去调用response.setCharacterEncoding(“utf-8”)了。</p><p>在静态页面中，使用<code>&lt;meta&gt;</code>来设置content-type响应头，例如：</p><p><code>&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;</code></p><h4 id="URL编码"><a href="#URL编码" class="headerlink" title="URL编码"></a>URL编码</h4><p>通过页面传输数据给服务器时，如果包含了一些特殊字符是无法发送的。这时就需要先把要发送的数据转换成URL编码格式，再发送给服务器。</p><p>其实需要我们自己动手给数据转换成URL编码的只有GET超链接，因为表单发送数据会默认使用URL编码，也就是说，不用我们自己来编码。</p><p>例如：”传智”这两个字通过URL编码后得到的是：”%E4%BC%A0%E6%99%BA”。URL编码是先需要把”传智”转换成字节，例如我们现在使用UTF-8把”传智”转换成字符，得到的结果是：”[-28, -68, -96, -26, -103, -70]”，然后再把所有负数加上256，得到[228, 188, 160, 230, 153, 186]，再把每个int值转换成16进制，得到[E4, BC, A0, E6, 99, BA]，最后再每个16进制的整数前面加上”%”。</p><p>通过URL编码，把”传智”转换成了”%E4%BC%A0%E6%99%BA”，然后发送给服务器！服务器会自动识别出数据是使用URL编码过的，然后会自动把数据转换回来。</p><p>当然，在页面中我们不需要自己去通过上面的过程把”传智”转换成”%E4%BC%A0%E6%99%BA”，而是使用Javascript来完成即可。当后面我们学习了JSP后，就不用再使用Javascript了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">_go</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        location = <span class="string">"/day05_2/AServlet?name="</span> + <span class="built_in">encodeURIComponent</span>(<span class="string">"传智+播客"</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因为URL默认只支持ISO-8859-1，这说明在URL中出现中文和一些特殊字符可能无法发送到服务器。所以我们需要对包含中文或特殊字符的URL进行URL编码。</p><p>服务器会自动识别数据是否使用了URL编码，如果使用了服务器会自动把数据解码，无需我们自己动手解码。</p><p>String s = “传智”;</p><p>s = URLEncoder.encode(s, “utf-8”);// %E4%BC%A0%E6%99%BA</p><p>s = URLDecoderdecode(s, “utf-8”);//传智</p><hr><h2 id="Day-06"><a href="#Day-06" class="headerlink" title="Day 06"></a>Day 06</h2><p><em>30/06/2020</em></p><h3 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h3><p>JSP（Java Server Pages）是JavaWeb服务器端的<strong>动态资源</strong>。它与html页面的作用是相同的，<strong>显示数据和获取数据</strong>。</p><p>JSP = html + Java脚本（代码片段） + JSP动作标签</p><h4 id="JSP语法"><a href="#JSP语法" class="headerlink" title="JSP语法"></a>JSP语法</h4><h5 id="JSP-脚本"><a href="#JSP-脚本" class="headerlink" title="JSP 脚本"></a>JSP 脚本</h5><p>JSP脚本就是Java代码片段，它分为三种：</p><ul><li><p><code>&lt;%...%&gt;</code>：Java语句；</p></li><li><p><code>&lt;%=…%&gt;</code>：Java表达式；</p></li><li><p><code>&lt;%!...%&gt;</code>：Java定义类成员；</p></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> <span class="keyword">import</span>=<span class="string">"java.util.*"</span> pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">&lt;title&gt;JSP演示&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;h1&gt;JSP演示&lt;/h1&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">    <span class="comment">// Java语句</span></span><br><span class="line">    String s1 = <span class="string">"hello jsp"</span>;</span><br><span class="line">    <span class="comment">// 不会输出到客户端，而是在服务器端的控制台打印</span></span><br><span class="line">    System.out.println(s1);</span><br><span class="line">    %&gt;</span><br><span class="line">  &lt;!-- 输出到客户端浏览器上 --&gt;</span><br><span class="line">    输出变量：&lt;%=s1 %&gt;&lt;br/&gt;</span><br><span class="line">    输出<span class="keyword">int</span>类型常量：&lt;%=<span class="number">100</span> %&gt;&lt;br/&gt;</span><br><span class="line">    输出String类型常量：&lt;%=<span class="string">"你好"</span> %&gt;&lt;br/&gt;</span><br><span class="line">    &lt;br/&gt;</span><br><span class="line">    使用表达式输出常量是很傻的一件事，因为可以直接使用html即可，下面是输出上面的常量：&lt;br/&gt;</span><br><span class="line">    <span class="number">100</span>&lt;br/&gt;</span><br><span class="line">    你好   </span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h5 id="内置对象-out"><a href="#内置对象-out" class="headerlink" title="内置对象 out"></a>内置对象 out</h5><p>out对象在JSP页面中无需创建就可以使用，它的作用是用来向客户端输出。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;out.jsp&lt;/h1&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">    <span class="comment">//向客户端输出</span></span><br><span class="line">    out.print(<span class="string">"你好！"</span>);</span><br><span class="line">    </span><br><span class="line">    %&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>其中<code>&lt;%=…%&gt;</code>与<code>out.print()</code>功能是相同的！它们都是向客户端输出，例如：</p><p><code>&lt;%=s1%&gt;</code>等同于<code>&lt;% out.print(s1); %&gt;</code></p><p><code>&lt;%=&quot;hello&quot;%&gt;</code>等同于<code>&lt;% out.print(&quot;hello&quot;); %&gt;</code>，也等同于直接在页面中写hello一样。</p><h5 id="多个-lt-gt-可以通用"><a href="#多个-lt-gt-可以通用" class="headerlink" title="多个&lt;%...%&gt;可以通用"></a>多个<code>&lt;%...%&gt;</code>可以通用</h5><p>在一个JSP中多个&lt;%…%&gt;是相通的。例如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;out.jsp&lt;/h1&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">    String s = <span class="string">"hello"</span>;</span><br><span class="line">    %&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">    out.print(s);</span><br><span class="line">    %&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>循环打印表格：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;表格&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">    &lt;table border=<span class="string">"1"</span> width=<span class="string">"50%"</span>&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;th&gt;序号&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;用户名&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;密码&lt;/th&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &lt;%</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            %&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;&lt;%=i+1 %&gt;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;user&lt;%=i %&gt;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;&lt;%=100 + 1 %&gt;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &lt;%</span><br><span class="line">        &#125;</span><br><span class="line">        %&gt;</span><br><span class="line">    &lt;/table&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h4 id="JSP-原理"><a href="#JSP-原理" class="headerlink" title="JSP 原理"></a>JSP 原理</h4><p>JSP是一种特殊的Servlet，当JSP页面首次被访问时，容器（Tomcat）会先把JSP编译成Servlet，然后再去执行Servlet。所以JSP其实就是一个Servlet！</p><p><img src="https://i.loli.net/2020/06/30/Te17gIh5qb2FHWE.png" alt="2.png"></p><h5 id="JSP真身存放目录"><a href="#JSP真身存放目录" class="headerlink" title="JSP真身存放目录"></a>JSP真身存放目录</h5><p>JSP生成的Servlet存放在${CATALANA}/work目录下，我经常开玩笑的说，它是JSP的”真身”。我们打开看看其中的内容，了解一下JSP的”真身”。</p><p>你会发现，在JSP中的静态信息（例如<code>&lt;html&gt;</code>等）在”真身”中都是使用out.write()完成打印！这些静态信息都是作为字符串输出给了客户端。</p><p>JSP的整篇内容都会放到名为<code>_jspService</code>的方法中！你可能会说<code>&lt;@page&gt;</code>不在”真身”中，<code>&lt;%@page&gt;</code>我们明天再看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">_jspService</span><span class="params">(<span class="keyword">final</span> javax.servlet.http.HttpServletRequest request, </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">final</span> javax.servlet.http.HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException, javax.servlet.ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> javax.servlet.jsp.PageContext pageContext;</span><br><span class="line">    javax.servlet.http.HttpSession session = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> javax.servlet.ServletContext application;</span><br><span class="line">    <span class="keyword">final</span> javax.servlet.ServletConfig config;</span><br><span class="line">    javax.servlet.jsp.JspWriter out = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> java.lang.Object page = <span class="keyword">this</span>;</span><br><span class="line">    javax.servlet.jsp.JspWriter _jspx_out = <span class="keyword">null</span>;</span><br><span class="line">    javax.servlet.jsp.PageContext _jspx_page_context = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">      pageContext = _jspxFactory.getPageContext(<span class="keyword">this</span>, request, response,</span><br><span class="line">      <span class="keyword">null</span>, <span class="keyword">true</span>, <span class="number">8192</span>, <span class="keyword">true</span>);</span><br><span class="line">      _jspx_page_context = pageContext;</span><br><span class="line">      application = pageContext.getServletContext();</span><br><span class="line">      config = pageContext.getServletConfig();</span><br><span class="line">      session = pageContext.getSession();</span><br><span class="line">      out = pageContext.getOut();</span><br><span class="line">      _jspx_out = out;</span><br><span class="line"></span><br><span class="line">…<span class="comment">// JSP页面中的内容都会在这个位置出现！这时上面所说的对象已经创建完了，所以在JSP页面中是可以使用的。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JSP脚本"><a href="#JSP脚本" class="headerlink" title="JSP脚本"></a>JSP脚本</h4><p>JSP脚本一共三种形式：</p><ul><li><p><code>&lt;%...%&gt;</code>：内容会直接放到”真身”中；</p></li><li><p><code>&lt;%=…%&gt;</code>：内容会放到out.print()中，作为out.print()的参数；</p></li><li><p><code>&lt;%!…%&gt;</code>：内容会放到_jspService()方法之外，被类直接包含；</p></li></ul><p>前面已经讲解了<code>&lt;%...%&gt;</code>和<code>&lt;%=…%&gt;</code>，但还没有讲解<code>&lt;%!...%&gt;</code>的作用！</p><p>现在我们已经知道了，JSP其实就是一个类，一个Servlet类。<code>&lt;%!...%&gt;</code>的作用是在类中添加方法或成员的，所以<code>&lt;%!...%&gt;</code>中的内容不会出现在<code>_jspService()</code>中。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;%!</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello JSP!"</span>;</span><br><span class="line">&#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h4 id="JSP注释"><a href="#JSP注释" class="headerlink" title="JSP注释"></a>JSP注释</h4><p>我们现在已经知道JSP是需要先编译成.java，再编译成.class的。其中<code>&lt;%-- ... --%&gt;</code>中的内容在JSP编译成.java时会被忽略的，即JSP注释。</p><p>也可以在JSP页面中使用html注释：<code>&lt;!-- … --&gt;</code>，但这个注释在JSP编译成的.java中是存在的，它不会被忽略，而且会被发送到客户端浏览器。但是在浏览器显示服务器发送过来的html时，因为<code>&lt;!-- … --&gt;</code>是html的注释，所以浏览器是不会显示它的。</p><p><img src="https://i.loli.net/2020/06/30/5Cr37imLUd9pPsl.png" alt="2.png"></p><h3 id="会话跟踪技术"><a href="#会话跟踪技术" class="headerlink" title="会话跟踪技术"></a>会话跟踪技术</h3><h4 id="什么是会话跟踪技术"><a href="#什么是会话跟踪技术" class="headerlink" title="什么是会话跟踪技术"></a>什么是会话跟踪技术</h4><p>我们需要先了解一下什么是会话！可以把会话理解为客户端与服务器之间的一次会晤，在一次会晤中可能会包含多次请求和响应。例如你给10086打个电话，你就是客户端，而10086服务人员就是服务器了。从双方接通电话那一刻起，会话就开始了，到某一方挂断电话表示会话结束。在通话过程中，你会向10086发出多个请求，那么这多个请求都在一个会话中。</p><p>在JavaWeb中，客户向某一服务器发出第一个请求开始，会话就开始了，直到客户关闭了浏览器会话结束。</p><p>在一个会话的多个请求中共享数据，这就是会话跟踪技术。例如在一个会话中的请求如下：</p><ul><li><p>请求银行主页；</p></li><li><p>请求登录（请求参数是用户名和密码）；</p></li><li><p>请求转账（请求参数与转账相关的数据）；</p></li><li><p>请求信誉卡还款（请求参数与还款相关的数据）。</p></li></ul><p>在这上会话中当前用户信息必须在这个会话中共享的，因为登录的是张三，那么在转账和还款时一定是相对张三的转账和还款！这就说明我们必须在一个会话过程中有共享数据的能力。</p><h4 id="会话路径技术使用Cookie或session完成"><a href="#会话路径技术使用Cookie或session完成" class="headerlink" title="会话路径技术使用Cookie或session完成"></a>会话路径技术使用Cookie或session完成</h4><p>我们知道HTTP协议是无状态协议，也就是说每个请求都是独立的！无法记录前一次请求的状态。但HTTP协议中可以使用Cookie来完成会话跟踪！</p><p>在JavaWeb中，使用session来完成会话跟踪，session底层依赖Cookie技术。</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><h4 id="Cookie概述"><a href="#Cookie概述" class="headerlink" title="Cookie概述"></a>Cookie概述</h4><p>Cookie翻译成中文是小甜点，小饼干的意思。在HTTP中它表示服务器送给客户端浏览器的小甜点。其实Cookie就是一个键和一个值构成的，随着服务器端的响应发送给客户端浏览器。然后客户端浏览器会把Cookie保存起来，当下一次再访问服务器时把Cookie再发送给服务器。</p><p><img src="https://i.loli.net/2020/06/30/RhIEKGckm4Zg29a.png" alt="2.png"></p><p>Cookie是由服务器创建，然后通过响应发送给客户端的一个键值对。客户端会保存Cookie，并会标注出Cookie的来源（哪个服务器的Cookie）。当客户端向服务器发出请求时会把所有这个服务器Cookie包含在请求中发送给服务器，这样服务器就可以识别客户端了！</p><h5 id="Cookie规范"><a href="#Cookie规范" class="headerlink" title="Cookie规范"></a>Cookie规范</h5><ul><li><p>Cookie大小上限为4KB；</p></li><li><p>一个服务器最多在客户端浏览器上保存20个Cookie；</p></li><li><p>一个浏览器最多保存300个Cookie；</p></li></ul><p>上面的数据只是HTTP的Cookie规范，但在浏览器大战的今天，一些浏览器为了打败对手，为了展现自己的能力起见，可能对Cookie规范”扩展”了一些，例如每个Cookie的大小为8KB，最多可保存500个Cookie等！但也不会出现把你硬盘占满的可能！</p><p>注意，不同浏览器之间是不共享Cookie的。也就是说在你使用IE访问服务器时，服务器会把Cookie发给IE，然后由IE保存起来，当你在使用FireFox访问服务器时，不可能把IE保存的Cookie发送给服务器。</p><h5 id="Cookie与HTTP头"><a href="#Cookie与HTTP头" class="headerlink" title="Cookie与HTTP头"></a>Cookie与HTTP头</h5><p>Cookie是通过HTTP请求和响应头在客户端和服务器端传递的：</p><ul><li>Cookie：请求头，客户端发送给服务器端；<ul><li>格式：Cookie: a=A; b=B; c=C。即多个Cookie用分号离开；</li></ul></li><li>Set-Cookie：响应头，服务器端发送给客户端；<ul><li>一个Cookie对应一个Set-Cookie：</li><li>Set-Cookie: a=A</li><li>Set-Cookie: b=B</li><li>Set-Cookie: c=C</li></ul></li></ul><h5 id="Cookie的覆盖"><a href="#Cookie的覆盖" class="headerlink" title="Cookie的覆盖"></a>Cookie的覆盖</h5><p>如果服务器端发送重复的Cookie那么会覆盖原有的Cookie，例如客户端的第一个请求服务器端发送的Cookie是：Set-Cookie: a=A；第二请求服务器端发送的是：Set-Cookie: a=AA，那么客户端只留下一个Cookie，即：a=AA。</p><h5 id="Cookie第一例"><a href="#Cookie第一例" class="headerlink" title="Cookie第一例"></a>Cookie第一例</h5><p>我们这个案例是，客户端访问AServlet，AServlet在响应中添加Cookie，浏览器会自动保存Cookie。然后客户端访问BServlet，这时浏览器会自动在请求中带上Cookie，BServlet获取请求中的Cookie打印出来。</p><p><img src="https://i.loli.net/2020/06/30/TDbBVqmEUscFHMj.png" alt="2.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AServlet.java</span></span><br><span class="line"><span class="keyword">package</span> cn.itcast.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Cookie;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给客户端发送Cookie</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">response.setContentType(<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line"></span><br><span class="line">String id = UUID.randomUUID().toString();<span class="comment">//生成一个随机字符串</span></span><br><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"id"</span>, id);<span class="comment">//创建Cookie对象，指定名字和值</span></span><br><span class="line">response.addCookie(cookie);<span class="comment">//在响应中添加Cookie对象</span></span><br><span class="line">response.getWriter().print(<span class="string">"已经给你发送了ID"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BServlet.java</span></span><br><span class="line"><span class="keyword">package</span> cn.itcast.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Cookie;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取客户端请求中的Cookie</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">response.setContentType(<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line"></span><br><span class="line">Cookie[] cs = request.getCookies();<span class="comment">//获取请求中的Cookie</span></span><br><span class="line"><span class="keyword">if</span>(cs != <span class="keyword">null</span>) &#123;<span class="comment">//如果请求中存在Cookie</span></span><br><span class="line"><span class="keyword">for</span>(Cookie c : cs) &#123;<span class="comment">//遍历所有Cookie</span></span><br><span class="line"><span class="keyword">if</span>(c.getName().equals(<span class="string">"id"</span>)) &#123;<span class="comment">//获取Cookie名字，如果Cookie名字是id</span></span><br><span class="line">response.getWriter().print(<span class="string">"您的ID是："</span> + c.getValue());<span class="comment">//打印Cookie值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Cookie-生命"><a href="#Cookie-生命" class="headerlink" title="Cookie 生命"></a>Cookie 生命</h4><h5 id="什么是Cookie的生命"><a href="#什么是Cookie的生命" class="headerlink" title="什么是Cookie的生命"></a>什么是Cookie的生命</h5><p>Cookie不只是有name和value，Cookie还有生命。所谓生命就是Cookie在客户端的有效时间，可以通过setMaxAge(int)来设置Cookie的有效时间。</p><ul><li><p>cookie.setMaxAge(-1)：cookie的maxAge属性的默认值就是-1，表示只在浏览器内存中存活。一旦关闭浏览器窗口，那么cookie就会消失。</p></li><li><p>cookie.setMaxAge(60*60)：表示cookie对象可存活1小时。当生命大于0时，浏览器会把Cookie保存到硬盘上，就算关闭浏览器，就算重启客户端电脑，cookie也会存活1小时；</p></li><li><p>cookie.setMaxAge(0)：cookie生命等于0是一个特殊的值，它表示cookie被作废！也就是说，如果原来浏览器已经保存了这个Cookie，那么可以通过Cookie的setMaxAge(0)来删除这个Cookie。无论是在浏览器内存中，还是在客户端硬盘上都会删除这个Cookie。 </p></li></ul><h5 id="案例：显示上次访问时间"><a href="#案例：显示上次访问时间" class="headerlink" title="案例：显示上次访问时间"></a>案例：显示上次访问时间</h5><ul><li><p>创建Cookie，名为lasttime，值为当前时间，添加到response中；</p></li><li><p>在AServlet中获取请求中名为lasttime的Cookie；</p></li><li><p>如果不存在输出”您是第一次访问本站”，如果存在输出”您上一次访问本站的时间是xxx”；</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AServlet.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    response.setContentType(<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line"></span><br><span class="line">    Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"lasttime"</span>, <span class="keyword">new</span> Date().toString());<span class="comment">// 这里可能会出现小bug</span></span><br><span class="line">    cookie.setMaxAge(<span class="number">60</span> * <span class="number">60</span>);</span><br><span class="line">    response.addCookie(cookie);</span><br><span class="line"></span><br><span class="line">    Cookie[] cs = request.getCookies();</span><br><span class="line">    String s = <span class="string">"您是首次访问本站！"</span>;</span><br><span class="line">    <span class="keyword">if</span>(cs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(Cookie c : cs) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c.getName().equals(<span class="string">"lasttime"</span>)) &#123;</span><br><span class="line">                s = <span class="string">"您上次的访问时间是："</span> + c.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    response.getWriter().print(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Cookie的path"><a href="#Cookie的path" class="headerlink" title="Cookie的path"></a>Cookie的path</h4><h5 id="什么是Cookie的路径"><a href="#什么是Cookie的路径" class="headerlink" title="什么是Cookie的路径"></a>什么是Cookie的路径</h5><p>现在有WEB应用A，向客户端发送了10个Cookie，这就说明客户端无论访问应用A的哪个Servlet都会把这10个Cookie包含在请求中！但是也许只有AServlet需要读取请求中的Cookie，而其他Servlet根本就不会获取请求中的Cookie。这说明客户端浏览器有时发送这些Cookie是多余的！</p><p>可以通过设置Cookie的path来指定浏览器，在访问什么样的路径时，包含什么样的Cookie。</p><h5 id="Cookie路径与请求路径的关系"><a href="#Cookie路径与请求路径的关系" class="headerlink" title="Cookie路径与请求路径的关系"></a>Cookie路径与请求路径的关系</h5><p>下面我们来看看Cookie路径的作用：</p><p>下面是客户端浏览器保存的3个Cookie的路径：</p><p>a:　/cookietest；</p><p>b:　/cookietest/servlet；</p><p>c:　/cookietest/jsp；</p><p>下面是浏览器请求的URL：</p><p>A:　<code>http://localhost:8080/cookietest/AServlet</code>；</p><p>B:　<code>http://localhost:8080/cookietest/servlet/BServlet</code>；</p><p>C:　<code>http://localhost:8080/cookietest/jsp/CServlet</code>；</p><ul><li><p>请求A时，会在请求中包含a；</p></li><li><p>请求B时，会在请求中包含a、b；</p></li><li><p>请求C时，会在请求中包含a、c；</p></li></ul><p>也就是说，请求路径如果包含了Cookie路径，那么会在请求中包含这个Cookie，否则不会请求中不会包含这个Cookie。</p><ul><li><p>A请求的URL包含了”/cookietest”，所以会在请求中包含路径为”/cookietest”的Cookie；</p></li><li><p>B请求的URL包含了”/cookietest”，以及”/cookietest/servlet”，所以请求中包含路径为”/cookietest”和”/cookietest/servlet”两个Cookie；</p></li><li><p>B请求的URL包含了”/cookietest”，以及”/cookietest/jsp”，所以请求中包含路径为”/cookietest”和”/cookietest/jsp”两个Cookie；</p></li></ul><h5 id="设置Cookie的路径"><a href="#设置Cookie的路径" class="headerlink" title="设置Cookie的路径"></a>设置Cookie的路径</h5><p>设置Cookie的路径需要使用setPath()方法，例如：</p><p>cookie.setPath(“/cookietest/servlet”);</p><p>如果没有设置Cookie的路径，那么Cookie路径的默认值当前访问资源所在路径，例如：</p><ul><li><p>访问<code>http://localhost:8080/cookietest/AServlet</code>时添加的Cookie默认路径为/cookietest；</p></li><li><p>访问<code>http://localhost:8080/cookietest/servlet/BServlet</code>时添加的Cookie默认路径为/cookietest/servlet；</p></li><li><p>访问<code>http://localhost:8080/cookietest/jsp/BServlet</code>时添加的Cookie默认路径为/cookietest/jsp；</p></li></ul><h4 id="Cookie的domain"><a href="#Cookie的domain" class="headerlink" title="Cookie的domain"></a>Cookie的domain</h4><p>Cookie的domain属性可以让网站中二级域共享Cookie，次要！</p><p>百度你是了解的对吧！</p><p><code>http://www.baidu.com</code></p><p><code>http://zhidao.baidu.com</code></p><p><code>http://news.baidu.com</code></p><p><code>http://tieba.baidu.com</code></p><p>现在我希望在这些主机之间共享Cookie（例如在<code>www.baidu.com</code>中响应的cookie，可以在<code>news.baidu.com</code>请求中包含）。很明显，现在不是路径的问题了，而是主机的问题，即域名的问题。处理这一问题其实很简单，只需要下面两步：</p><ul><li><p>设置Cookie的path为”/“：c.setPath(“/“)；</p></li><li><p>设置Cookie的domain为”.baidu.com”：c.setDomain(“.baidu.com”)。</p></li></ul><p>当domain为”.baidu.com”时，无论前缀是什么，都会共享Cookie的。但是现在我们需要设置两个虚拟主机：<code>www.baidu.com</code>和<code>news.baidu.com</code>。</p><p>第一步：设置windows的DNS路径解析</p><p>找到C:\WINDOWS\system32\drivers\etc\hosts文件，添加如下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1       localhost</span><br><span class="line">127.0.0.1       www.baidu.com</span><br><span class="line">127.0.0.1       news.baidu.com</span><br></pre></td></tr></table></figure><p>第二步：设置Tomcat虚拟主机</p><p>找到server.xml文件，添加<code>&lt;Host&gt;</code>元素，内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"www.baidu.com"</span>  <span class="attr">appBase</span>=<span class="string">"F:\webapps\www"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlValidation</span>=<span class="string">"false"</span> <span class="attr">xmlNamespaceAware</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"news.baidu.com"</span>  <span class="attr">appBase</span>=<span class="string">"F:\webapps\news"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlValidation</span>=<span class="string">"false"</span> <span class="attr">xmlNamespaceAware</span>=<span class="string">"false"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>第三步：创建A项目，创建AServlet，设置Cookie。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Cookie[] cs = request.getCookies();</span><br><span class="line"><span class="keyword">if</span>(cs != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(Cookie c : cs) &#123;</span><br><span class="line">        String s = c.getName() + <span class="string">": "</span> + c.getValue() + <span class="string">"&lt;br/&gt;"</span>;</span><br><span class="line">        response.getWriter().print(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把B项目的WebRoot目录复制到F:\webapps\news目录下，并把WebRoot目录的名字修改为ROOT。</p><p>第五步：访问<code>www.baidu.com\AServlet</code>，然后再访问<code>news.baidu.com\BServlet</code>。</p><h4 id="Cookie保存中文"><a href="#Cookie保存中文" class="headerlink" title="Cookie保存中文"></a>Cookie保存中文</h4><p>Cookie的name和value都不能使用中文，如果希望在Cookie中使用中文，那么需要先对中文进行URL编码，然后把编码后的字符串放到Cookie中。</p><p>向客户端响应中添加Cookie</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String name = URLEncoder.encode(<span class="string">"姓名"</span>, <span class="string">"UTF-8"</span>);</span><br><span class="line">String value = URLEncoder.encode(<span class="string">"张三"</span>, <span class="string">"UTF-8"</span>);</span><br><span class="line">Cookie c = <span class="keyword">new</span> Cookie(name, value);</span><br><span class="line">c.setMaxAge(<span class="number">3600</span>);</span><br><span class="line">response.addCookie(c);</span><br></pre></td></tr></table></figure><p>从客户端请求中获取Cookie</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line">Cookie[] cs = request.getCookies();</span><br><span class="line"><span class="keyword">if</span>(cs != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(Cookie c : cs) &#123;</span><br><span class="line">        String name = URLDecoder.decode(c.getName(), <span class="string">"UTF-8"</span>);</span><br><span class="line">        String value = URLDecoder.decode(c.getValue(), <span class="string">"UTF-8"</span>);</span><br><span class="line">        String s = name + <span class="string">": "</span> + value + <span class="string">"&lt;br/&gt;"</span>;</span><br><span class="line">        response.getWriter().print(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="显示曾经浏览过的商品"><a href="#显示曾经浏览过的商品" class="headerlink" title="显示曾经浏览过的商品"></a>显示曾经浏览过的商品</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--index.jsp--%&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;商品列表&lt;/h1&gt;</span><br><span class="line">    &lt;a href="/day06_3/GoodServlet?name=ThinkPad"&gt;ThinkPad&lt;/a&gt;&lt;br/&gt;</span><br><span class="line">    &lt;a href="/day06_3/GoodServlet?name=Lenovo"&gt;Lenovo&lt;/a&gt;&lt;br/&gt;</span><br><span class="line">    &lt;a href="/day06_3/GoodServlet?name=Apple"&gt;Apple&lt;/a&gt;&lt;br/&gt;</span><br><span class="line">    &lt;a href="/day06_3/GoodServlet?name=HP"&gt;HP&lt;/a&gt;&lt;br/&gt;</span><br><span class="line">    &lt;a href="/day06_3/GoodServlet?name=SONY"&gt;SONY&lt;/a&gt;&lt;br/&gt;</span><br><span class="line">    &lt;a href="/day06_3/GoodServlet?name=ACER"&gt;ACER&lt;/a&gt;&lt;br/&gt;</span><br><span class="line">    &lt;a href="/day06_3/GoodServlet?name=DELL"&gt;DELL&lt;/a&gt;&lt;br/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;hr/&gt;</span><br><span class="line">    您浏览过的商品：</span><br><span class="line">    &lt;%</span><br><span class="line">    Cookie[] cs = request.getCookies();</span><br><span class="line">    <span class="keyword">if</span>(cs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(Cookie c : cs) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c.getName().equals(<span class="string">"goods"</span>)) &#123;</span><br><span class="line">                out.print(c.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    %&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GoodServlet</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">String goodName = request.getParameter(<span class="string">"name"</span>);</span><br><span class="line">String goods = CookieUtils.getCookValue(request, <span class="string">"goods"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(goods != <span class="keyword">null</span>) &#123;</span><br><span class="line">String[] arr = goods.split(<span class="string">", "</span>);</span><br><span class="line">Set&lt;String&gt; goodSet = <span class="keyword">new</span> LinkedHashSet(Arrays.asList(arr));</span><br><span class="line">goodSet.add(goodName);</span><br><span class="line">goods = goodSet.toString();</span><br><span class="line">goods = goods.substring(<span class="number">1</span>, goods.length() - <span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">goods = goodName;</span><br><span class="line">&#125;</span><br><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"goods"</span>, goods);</span><br><span class="line">cookie.setMaxAge(<span class="number">1</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>);</span><br><span class="line">response.addCookie(cookie);</span><br><span class="line"></span><br><span class="line">response.sendRedirect(<span class="string">"/day06_3/index.jsp"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CookieUtils</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CookieUtils</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCookValue</span><span class="params">(HttpServletRequest request, String name)</span> </span>&#123;</span><br><span class="line">Cookie[] cs = request.getCookies();</span><br><span class="line"><span class="keyword">if</span>(cs == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(Cookie c : cs) &#123;</span><br><span class="line"><span class="keyword">if</span>(c.getName().equals(name)) &#123;</span><br><span class="line"><span class="keyword">return</span> c.getValue();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HttpSession"><a href="#HttpSession" class="headerlink" title="HttpSession"></a>HttpSession</h3><h4 id="HttpSession概述"><a href="#HttpSession概述" class="headerlink" title="HttpSession概述"></a>HttpSession概述</h4><p>javax.servlet.http.HttpSession接口表示一个会话，我们可以把一个会话内需要共享的数据保存到HttpSession对象中！</p><h5 id="获取HttpSession对象"><a href="#获取HttpSession对象" class="headerlink" title="获取HttpSession对象"></a>获取HttpSession对象</h5><ul><li><p>HttpSession request.getSesssion()：如果当前会话已经有了session对象那么直接返回，如果当前会话还不存在会话，那么创建session并返回；</p></li><li><p>HttpSession request.getSession(boolean)：当参数为true时，与requeset.getSession()相同。如果参数为false，那么如果当前会话中存在session则返回，不存在返回null；</p></li></ul><h5 id="HttpSession是域对象"><a href="#HttpSession是域对象" class="headerlink" title="HttpSession是域对象"></a>HttpSession是域对象</h5><p>我们已经学习过HttpServletRequest、ServletContext，它们都是域对象，现在我们又学习了一个HttpSession，它也是域对象。它们三个是Servlet中可以使用的域对象，而JSP中可以多使用一个域对象，明天我们再讲解JSP的第四个域对象。</p><ul><li><p>HttpServletRequest：一个请求创建一个request对象，所以在同一个请求中可以共享request，例如一个请求从AServlet转发到BServlet，那么AServlet和BServlet可以共享request域中的数据；</p></li><li><p>ServletContext：一个应用只创建一个ServletContext对象，所以在ServletContext中的数据可以在整个应用中共享，只要不启动服务器，那么ServletContext中的数据就可以共享；</p></li><li><p>HttpSession：一个会话创建一个HttpSession对象，同一会话中的多个请求中可以共享session中的数据；</p></li></ul><p>下面是session的域方法：</p><ul><li><p>void setAttribute(String name, Object value)：用来存储一个对象，也可以称之为存储一个域属性，例如：session.setAttribute(“xxx”, “XXX”)，在session中保存了一个域属性，域属性名称为xxx，域属性的值为XXX。请注意，如果多次调用该方法，并且使用相同的name，那么会覆盖上一次的值，这一特性与Map相同；</p></li><li><p>Object getAttribute(String name)：用来获取session中的数据，当前在获取之前需要先去存储才行，例如：String value = (String) session.getAttribute(“xxx”);，获取名为xxx的域属性；</p></li><li><p>void removeAttribute(String name)：用来移除HttpSession中的域属性，如果参数name指定的域属性不存在，那么本方法什么都不做；</p></li><li><p>Enumeration getAttributeNames()：获取所有域属性的名称；</p></li></ul><h4 id="登录案例"><a href="#登录案例" class="headerlink" title="登录案例"></a>登录案例</h4><p>需要的页面：</p><ul><li><p>login.jsp：登录页面，提供登录表单；</p></li><li><p>index1.jsp：主页，显示当前用户名称，如果没有登录，显示您还没登录；</p></li><li><p>index2.jsp：主页，显示当前用户名称，如果没有登录，显示您还没登录；</p></li></ul><p>Servlet：</p><ul><li>LoginServlet：在login.jsp页面提交表单时，请求本Servlet。在本Servlet中获取用户名、密码进行校验，如果用户名、密码错误，显示”用户名或密码错误”，如果正确保存用户名session中，然后重定向到index1.jsp；</li></ul><p>当用户没有登录时访问index1.jsp或index2.jsp，显示”您还没有登录”。如果用户在login.jsp登录成功后到达index1.jsp页面会显示当前用户名，而且不用再次登录去访问index2.jsp也会显示用户名。因为多次请求在一个会话范围，index1.jsp和index2.jsp都会到session中获取用户名，session对象在一个会话中是相同的，所以都可以获取到用户名！</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--login.jsp--%&gt;</span><br><span class="line">&lt;%@ page language=<span class="string">"java"</span> <span class="keyword">import</span>=<span class="string">"java.util.*"</span> pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;login.jsp&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;h1&gt;login.jsp&lt;/h1&gt;</span><br><span class="line">    &lt;hr/&gt;</span><br><span class="line">    &lt;form action=<span class="string">"/day06_4/LoginServlet"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">    用户名：&lt;input type=<span class="string">"text"</span> name=<span class="string">"username"</span> /&gt;&lt;br/&gt;</span><br><span class="line">        &lt;input type=<span class="string">"submit"</span> value=<span class="string">"Submit"</span>/&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--index1.jsp--%&gt;</span><br><span class="line">&lt;%@ page language=<span class="string">"java"</span> <span class="keyword">import</span>=<span class="string">"java.util.*"</span> pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;index1.jsp&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;body&gt;</span><br><span class="line">&lt;h1&gt;index1.jsp&lt;/h1&gt;</span><br><span class="line">&lt;%</span><br><span class="line">String username = (String)session.getAttribute(<span class="string">"username"</span>);</span><br><span class="line"><span class="keyword">if</span>(username == <span class="keyword">null</span>) &#123;</span><br><span class="line">out.print(<span class="string">"您还没有登录！"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">out.print(<span class="string">"用户名："</span> + username);</span><br><span class="line">&#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;hr/&gt;</span><br><span class="line">&lt;a href="/day06_4/index2.jsp"&gt;index2&lt;/a&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--index2.jsp--%&gt;</span><br><span class="line">&lt;%@ page language=<span class="string">"java"</span> <span class="keyword">import</span>=<span class="string">"java.util.*"</span> pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;index2.jsp&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;body&gt;</span><br><span class="line">&lt;h1&gt;index2.jsp&lt;/h1&gt;</span><br><span class="line">&lt;%</span><br><span class="line">String username = (String)session.getAttribute(<span class="string">"username"</span>);</span><br><span class="line"><span class="keyword">if</span>(username == <span class="keyword">null</span>) &#123;</span><br><span class="line">out.print(<span class="string">"您还没有登录！"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">out.print(<span class="string">"用户名："</span> + username);</span><br><span class="line">&#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;hr/&gt;</span><br><span class="line">&lt;a href="/day06_4/index1.jsp"&gt;index1&lt;/a&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LoginServlet</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">request.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line">response.setContentType(<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line"></span><br><span class="line">String username = request.getParameter(<span class="string">"username"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(username.equalsIgnoreCase(<span class="string">"itcast"</span>)) &#123;</span><br><span class="line">response.getWriter().print(<span class="string">"用户名或密码错误！"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">HttpSession session = request.getSession();</span><br><span class="line">session.setAttribute(<span class="string">"username"</span>, username);</span><br><span class="line">response.sendRedirect(<span class="string">"/day06_4/index1.jsp"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="session的实现原理"><a href="#session的实现原理" class="headerlink" title="session的实现原理"></a>session的实现原理</h4><p>session底层是依赖Cookie的！我们来理解一下session的原理吧！</p><p>当我首次去银行时，因为还没有账号，所以需要开一个账号，我获得的是银行卡，而银行这边的数据库中留下了我的账号，我的钱是保存在银行的账号中，而我带走的是我的卡号。</p><p>当我再次去银行时，只需要带上我的卡，而无需再次开一个账号了。只要带上我的卡，那么我在银行操作的一定是我的账号！</p><p>当首次使用session时，服务器端要创建session，session是保存在服务器端，而给客户端的session的id（一个cookie中保存了sessionId）。客户端带走的是sessionId，而数据是保存在session中。</p><p>当客户端再次访问服务器时，在请求中会带上sessionId，而服务器会通过sessionId找到对应的session，而无需再创建新的session。</p><p><img src="https://i.loli.net/2020/06/30/TN62RhXb5WA8auw.png" alt="2.png"></p><h4 id="session与浏览器"><a href="#session与浏览器" class="headerlink" title="session与浏览器"></a>session与浏览器</h4><p>session保存在服务器，而sessionId通过Cookie发送给客户端，但这个Cookie的生命为-1，即只在浏览器内存中存在，也就是说如果用户关闭了浏览器，那么这个Cookie就丢失了。</p><p>当用户再次打开浏览器访问服务器时，就不会有sessionId发送给服务器，那么服务器会认为你没有session，所以服务器会创建一个session，并在响应中把sessionId中到Cookie中发送给客户端。　　　　　</p><p>你可能会说，那原来的session对象会怎样？当一个session长时间没人使用的话，服务器会把session删除了！这个时长在Tomcat中配置是30分钟，可以在${CATALANA}/conf/web.xml找到这个配置，当然你也可以在自己的web.xml中覆盖这个配置！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>session失效时间也说明一个问题！如果你打开网站的一个页面开始长时间不动，超出了30分钟后，再去点击链接或提交表单时你会发现，你的session已经丢失了！</p><h4 id="session其他常用API"><a href="#session其他常用API" class="headerlink" title="session其他常用API"></a>session其他常用API</h4><ul><li><p>String getId()：获取sessionId；</p></li><li><p>int getMaxInactiveInterval()：获取session可以的最大不活动时间（秒），默认为30分钟。当session在30分钟内没有使用，那么Tomcat会在session池中移除这个session；</p></li><li><p>void setMaxInactiveInterval(int interval)：设置session允许的最大不活动时间（秒），如果设置为1秒，那么只要session在1秒内不被使用，那么session就会被移除；</p></li><li><p>long getCreationTime()：返回session的创建时间，返回值为当前时间的毫秒值；</p></li><li><p>long getLastAccessedTime()：返回session的最后活动时间，返回值为当前时间的毫秒值；</p></li><li><p>void invalidate()：让session失效！调用这个方法会被session失效，当session失效后，客户端再次请求，服务器会给客户端创建一个新的session，并在响应中给客户端新session的sessionId；</p></li><li><p>boolean isNew()：查看session是否为新。当客户端第一次请求时，服务器为客户端创建session，但这时服务器还没有响应客户端，也就是还没有把sessionId响应给客户端时，这时session的状态为新。</p></li></ul><h4 id="URL重写"><a href="#URL重写" class="headerlink" title="URL重写"></a>URL重写</h4><p>我们知道session依赖Cookie，那么session为什么依赖Cookie呢？因为服务器需要在每次请求中获取sessionId，然后找到客户端的session对象。那么如果客户端浏览器关闭了Cookie呢？那么session是不是就会不存在了呢？</p><p>其实还有一种方法让服务器收到的每个请求中都带有sessioinId，那就是URL重写！在每个页面中的每个链接和表单中都添加名为jSessionId的参数，值为当前sessionid。当用户点击链接或提交表单时也服务器可以通过获取jSessionId这个参数来得到客户端的sessionId，找到sessoin对象。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--index.jsp--%&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;URL重写&lt;/h1&gt;</span><br><span class="line">    &lt;a href='/day06_5/index.jsp;jsessionid=&lt;%=session.getId() %&gt;' &gt;主页&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">    &lt;form action=<span class="string">'/day06_5/index.jsp;jsessionid=&lt;%=session.getId() %&gt;'</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">        &lt;input type=<span class="string">"submit"</span> value=<span class="string">"提交"</span>/&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>也可以使用response.encodeURL()对每个请求的URL处理，这个方法会自动追加jsessionid参数，与上面我们手动添加是一样的效果。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href='&lt;%=response.encodeURL("/day06_5/index.jsp") %&gt;' &gt;主页&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;form action=<span class="string">'&lt;%=response.encodeURL("/day06_5/index.jsp") %&gt;'</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"submit"</span> value=<span class="string">"提交"</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>　使用response.encodeURL()更加”智能”，它会判断客户端浏览器是否禁用了Cookie，如果禁用了，那么这个方法在URL后面追加jsessionid，否则不会追加。</p><h3 id="案例：一次性图片验证码"><a href="#案例：一次性图片验证码" class="headerlink" title="案例：一次性图片验证码"></a>案例：一次性图片验证码</h3><h4 id="验证码有啥用"><a href="#验证码有啥用" class="headerlink" title="验证码有啥用"></a>验证码有啥用</h4><p>在我们注册时，如果没有验证码的话，我们可以使用URLConnection来写一段代码发出注册请求。甚至可以使用while(true)来注册！那么服务器就废了！</p><p>验证码可以去识别发出请求的是人还是程序！当然，如果聪明的程序可以去分析验证码图片！但分析图片也不是一件容易的事，因为一般验证码图片都会带有干扰线，人都看不清，那么程序一定分析不出来。</p><h4 id="VerifyCode类"><a href="#VerifyCode类" class="headerlink" title="VerifyCode类"></a>VerifyCode类</h4><p>现在我们已经有了cn.itcast.utils.VerifyCode类，这个类可以生成验证码图片！下面来看一个小例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建验证码类</span></span><br><span class="line">    VerifyCode vc = <span class="keyword">new</span> VerifyCode();</span><br><span class="line">    <span class="comment">// 获取随机图片</span></span><br><span class="line">    BufferedImage image = vc.getImage();</span><br><span class="line">    <span class="comment">// 获取刚刚生成的随机图片上的文本</span></span><br><span class="line">    String text = vc.getText();</span><br><span class="line">    System.out.println(text);</span><br><span class="line">    <span class="comment">// 保存图片</span></span><br><span class="line">    FileOutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">"F:/xxx.jpg"</span>);</span><br><span class="line">    VerifyCode.output(image, out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在页面中显示动态图片"><a href="#在页面中显示动态图片" class="headerlink" title="在页面中显示动态图片"></a>在页面中显示动态图片</h4><p>我们需要写一个VerifyCodeServlet，在这个Servlet中我们生成动态图片，然后它图片写入到response.getOutputStream()流中！然后让页面的<img>元素指定这个VerifyCodServlet即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// VerifyCodeServlet</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VerifyCodeServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">VerifyCode vc = <span class="keyword">new</span> VerifyCode();</span><br><span class="line">BufferedImage image = vc.getImage();</span><br><span class="line">String text = vc.getText();</span><br><span class="line">System.out.println(<span class="string">"text:"</span> + text);</span><br><span class="line">VerifyCode.output(image, response.getOutputStream());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--index.jsp--%&gt;</span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="function">function <span class="title">_change</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> imgEle = document.getElementById(<span class="string">"vCode"</span>);</span><br><span class="line">        imgEle.src = <span class="string">"/day06_6/VerifyCodeServlet?"</span> + <span class="keyword">new</span> Date().getTime();</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">...  </span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;验证码&lt;/h1&gt;</span><br><span class="line">    &lt;img id=<span class="string">"vCode"</span> src=<span class="string">"/day06_6/VerifyCodeServlet"</span>/&gt;</span><br><span class="line">    &lt;a href="javascript:_change()"&gt;看不清，换一张&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h4 id="在注册页面中使用验证码"><a href="#在注册页面中使用验证码" class="headerlink" title="在注册页面中使用验证码"></a>在注册页面中使用验证码</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">"/day06_6/RegistServlet"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">    用户名：&lt;input type=<span class="string">"text"</span> name=<span class="string">"username"</span>/&gt;&lt;br/&gt;</span><br><span class="line">    验证码：&lt;input type=<span class="string">"text"</span> name=<span class="string">"code"</span> size=<span class="string">"3"</span>/&gt;</span><br><span class="line">    &lt;img id=<span class="string">"vCode"</span> src=<span class="string">"/day06_6/VerifyCodeServlet"</span>/&gt;</span><br><span class="line">    &lt;a href="javascript:_change()"&gt;看不清，换一张&lt;/a&gt;</span><br><span class="line">    &lt;br/&gt;</span><br><span class="line">    &lt;input type=<span class="string">"submit"</span> value=<span class="string">"Submit"</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><h4 id="RegistServlet"><a href="#RegistServlet" class="headerlink" title="RegistServlet"></a>RegistServlet</h4><p>修改VerifyCodeServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VerifyCodeServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">VerifyCode vc = <span class="keyword">new</span> VerifyCode();</span><br><span class="line">BufferedImage image = vc.getImage();</span><br><span class="line">request.getSession().setAttribute(<span class="string">"vCode"</span>, vc.getText());</span><br><span class="line">VerifyCode.output(image, response.getOutputStream());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">// RegisterServlet</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegistServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">request.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line">response.setContentType(<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line"></span><br><span class="line">String username = request.getParameter(<span class="string">"username"</span>);</span><br><span class="line">String vCode = request.getParameter(<span class="string">"code"</span>); </span><br><span class="line"></span><br><span class="line">String sessionVerifyCode = (String)request.getSession().getAttribute(<span class="string">"vCode"</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(vCode.equalsIgnoreCase(sessionVerifyCode) ) &#123;</span><br><span class="line">response.getWriter().print(username + <span class="string">", 恭喜！注册成功！"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">response.getWriter().print(<span class="string">"验证码错误！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结验证码案例"><a href="#总结验证码案例" class="headerlink" title="总结验证码案例"></a>总结验证码案例</h4><ul><li><p>VerifyCodeServlet：</p><ul><li><p>生成验证码：VerifyCode vc = new VerifyCode(); BufferedImage image = vc.getImage()；</p></li><li><p>在session中保存验证码文本：request.getSession.getAttribute(“vCode”, vc.getText())；</p></li><li><p>把验证码输出到页面：VerifyCode.output(image, response.getOutputStream)；</p></li></ul></li><li><p>regist.jsp：</p><ul><li><p>表单中包含username和code字段；</p></li><li><p>在表单中给出<img>指向VerifyCodeServlet，用来在页面中显示验证码图片；</p></li><li><p>提供”看不清，换一张”链接，指向_change()函数；</p></li><li><p>提交到RegistServlet；</p></li></ul></li><li><p>RegistServlet：</p><ul><li>获取表单中的username和code；</li></ul></li><li><p>获取session中的vCode；</p><ul><li>比较code和vCode是否相同；</li></ul></li><li><p>相同说明用户输入的验证码正确，否则输入验证码错误。</p></li></ul><hr><h2 id="Day-07"><a href="#Day-07" class="headerlink" title="Day 07"></a>Day 07</h2><p><em>01/07/2020</em></p><h3 id="JSP-指令"><a href="#JSP-指令" class="headerlink" title="JSP 指令"></a>JSP 指令</h3><p>JSP指令的格式：<code>&lt;%@指令名 attr1=&quot;&quot; attr2=&quot;&quot; %&gt;</code>，一般都会把JSP指令放到JSP文件的最上方，但这不是必须的。</p><p>JSP中有三大指令：page、include、taglib，最为常用，也最为复杂的就是page指令了。</p><h4 id="page-指令"><a href="#page-指令" class="headerlink" title="page 指令"></a>page 指令</h4><p>page指令是最为常用的指定，也是属性最多的属性！</p><p>page指令没有必须属性，都是可选属性。例如&lt;%@page %&gt;，没有给出任何属性也是可以的！</p><p>在JSP页面中，任何指令都可以重复出现！</p><p><code>&lt;%@ page language=&quot;java&quot;%&gt;</code></p><p><code>&lt;%@ page import=&quot;java.util.*&quot;%&gt;</code></p><p><code>&lt;%@ page pageEncoding=&quot;utf-8&quot;%&gt;</code></p><p>这也是可以的！</p><h5 id="page指令的pageEncoding和contentType（重点）"><a href="#page指令的pageEncoding和contentType（重点）" class="headerlink" title="page指令的pageEncoding和contentType（重点）"></a>page指令的pageEncoding和contentType（重点）</h5><p>pageEncoding指定当前JSP页面的编码！这个编码是给服务器看的，服务器需要知道当前JSP使用的编码，不然服务器无法正确把JSP编译成java文件。所以这个编码只需要与真实的页面编码一致即可！在MyEclipse中，在JSP文件上点击右键，选择属性就可以看到当前JSP页面的编码了。</p><p>contentType属性与response.setContentType()方法的作用相同！它会完成两项工作，一是设置响应字符流的编码，二是设置content-type响应头。例如：<code>&lt;%@ contentType=&quot;text/html;charset=utf-8&quot;%&gt;</code>，它会使”真身”中出现response.setContentType(“text/html;charset=utf-8”)。</p><p>无论是page指令的pageEncoding还是contentType，它们的默认值都是ISO-8859-1，我们知道ISO-8859-1是无法显示中文的，所以JSP页面中存在中文的话，一定要设置这两个属性。</p><p>其实pageEncoding和contentType这两个属性的关系很”暧昧”：</p><ul><li><p>当设置了pageEncoding，而没设置contentType时： contentType的默认值为pageEncoding；</p></li><li><p>当设置了contentType，而没设置pageEncoding时： pageEncoding的默认值与contentType；</p></li></ul><p><strong>也就是说，当pageEncoding和contentType只出现一个时，那么另一个的值与出现的值相同。如果两个都不出现，那么两个属性的值都是ISO-8859-1。所以通过我们至少设置它们两个其中一个！</strong></p><h5 id="page指令的import属性"><a href="#page指令的import属性" class="headerlink" title="page指令的import属性"></a>page指令的import属性</h5><p>import是page指令中一个很特别的属性！</p><p>import属性值对应”真身”中的import语句。</p><p>import属性值可以使逗号：<code>&lt;%@page import=&quot;java.net.*,java.util.*,java.sql.*&quot;%&gt;</code></p><p>import属性是唯一可以重复出现的属性：</p><p><code>&lt;%@page import=&quot;java.util.*&quot; import=&quot;java.net.*&quot; import=&quot;java.sql.*&quot;%&gt;</code></p><p>但是，我们一般会使用多个page指令来导入多个包：</p><p><code>&lt;%@ page import=&quot;java.util.*&quot;%&gt;</code></p><p><code>&lt;%@ page import=&quot;java.net.*&quot;%&gt;</code></p><p><code>&lt;%@ page import=&quot;java.text.*&quot;%&gt;</code></p><h5 id="page指令的errorPage和isErrorPage"><a href="#page指令的errorPage和isErrorPage" class="headerlink" title="page指令的errorPage和isErrorPage"></a>page指令的errorPage和isErrorPage</h5><p>我们知道，在一个JSP页面出错后，Tomcat会响应给用户错误信息（500页面）！如果你不希望Tomcat给用户输出错误信息，那么可以使用page指令的errorPage来指定错误页！也就是自定义错误页面，例如：<code>&lt;%@page errorPage=&quot;xxx.jsp&quot;%&gt;</code>。这时，在当前JSP页面出现错误时，会请求转发到xxx.jsp页面。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--a.jsp--%&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.util.*"</span> pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br><span class="line">&lt;%@ page  errorPage=<span class="string">"b.jsp"</span> %&gt;</span><br><span class="line">&lt;%</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">true</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"哈哈~"</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--b.jsp--%&gt;</span><br><span class="line">&lt;%@ page pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">   &lt;h1&gt;出错啦！&lt;/h1&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>在上面代码中，a.jsp抛出异常后，会请求转发到b.jsp。在浏览器的地址栏中还是a.jsp，因为是请求转发！</p><p>而且客户端浏览器收到的响应码为200，表示请求成功！如果希望客户端得到500，那么需要指定b.jsp为错误页面。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> <span class="keyword">import</span>=<span class="string">"java.util.*"</span> pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br><span class="line">&lt;%@ page  isErrorPage=<span class="string">"true"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">   &lt;h1&gt;出错啦！&lt;/h1&gt;</span><br><span class="line">&lt;%=exception.getMessage() %&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>注意，当isErrorPage为true时，说明当前JSP为错误页面，即专门处理错误的页面。那么这个页面中就可以使用一个内置对象exception了。其他页面是不能使用这个内置对象的！</p><p>温馨提示：<em>IE会在状态码为500时，并且响应正文的长度小于等于512B时不给予显示！而是显示”网站无法显示该页面”字样。这时你只需要添加一些响应内容即可，例如上例中的b.jsp中我给出一些内容，IE就可以正常显示了！</em></p><h6 id="web-xml中配置错误页面"><a href="#web-xml中配置错误页面" class="headerlink" title="web.xml中配置错误页面"></a>web.xml中配置错误页面</h6><p>不只可以通过JSP的page指令来配置错误页面，还可以在web.xml文件中指定错误页面。这种方式其实与page指令无关，但想来想去还是在这个位置来说明比较合适！</p><p>web.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">error-code</span>&gt;</span>404<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/error404.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">error-code</span>&gt;</span>500<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/error500.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exception-type</span>&gt;</span>java.lang.RuntimeException<span class="tag">&lt;/<span class="name">exception-type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/error.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;error-page&gt;</code>有两种使用方式：</p><ul><li><p><code>&lt;error-code&gt;</code>和<code>&lt;location&gt;</code>子元素；</p></li><li><p><code>&lt;exception-type&gt;</code>和<code>&lt;location&gt;</code>子元素；</p><p>其中<code>&lt;error-code&gt;</code>是指定响应码；<code>&lt;location&gt;</code>指定转发的页面；<code>&lt;exception-type&gt;</code>是指定抛出的异常类型。</p></li><li><p>当出现404时，会跳转到error404.jsp页面；</p></li><li><p>当出现RuntimeException异常时，会跳转到error.jsp页面；</p></li><li><p>当出现非RuntimeException的异常时，会跳转到error500.jsp页面。</p></li></ul><p>这种方式会在控制台看到异常信息！而使用page指令时不会在控制台打印异常信息。</p><h5 id="page指令的authFlush和buffer"><a href="#page指令的authFlush和buffer" class="headerlink" title="page指令的authFlush和buffer"></a>page指令的authFlush和buffer</h5><p>buffer表示当前JSP的输出流（out隐藏对象）的缓冲区大小，默认为8kb。</p><p>authFlush表示在out对象的缓冲区满时如何处理！当authFlush为true时，表示缓冲区满时把缓冲区数据输出到客户端；当authFlush为false时，表示缓冲区满时，抛出异常。authFlush的默认值为true。</p><p>这两个属性一般我们也不会去特意设置，都是保留默认值！</p><h5 id="page指令的isELIgnored"><a href="#page指令的isELIgnored" class="headerlink" title="page指令的isELIgnored"></a>page指令的isELIgnored</h5><p>后面我们会讲解EL表达式语言，page指令的isELIgnored属性表示当前JSP页面是否忽略EL表达式，默认值为false，表示不忽略（即支持）。</p><h5 id="page指令的其他属性"><a href="#page指令的其他属性" class="headerlink" title="page指令的其他属性"></a>page指令的其他属性</h5><ul><li><p>language：只能是Java，这个属性可以看出JSP最初设计时的野心！希望JSP可以转换成其他语言！但是，到现在JSP也只能转换成Java代码；</p></li><li><p>info：JSP说明性信息；</p></li><li><p>isThreadSafe：默认为false，为true时，JSP生成的Servlet会去实现一个过时的标记接口SingleThreadModel，这时JSP就只能处理单线程的访问；</p></li><li><p>session：默认为true，表示当前JSP页面可以使用session对象，如果为false表示当前JSP页面不能使用session对象；</p></li><li><p>extends：指定当前JSP页面生成的Servlet的父类；</p></li></ul><h5 id="lt-jsp-config-gt-（了解）"><a href="#lt-jsp-config-gt-（了解）" class="headerlink" title="&lt;jsp-config&gt;（了解）"></a><code>&lt;jsp-config&gt;</code>（了解）</h5><p>在web.xml页面中配置<code>&lt;jsp-config&gt;</code>也可以完成很多page指定的功能！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">jsp-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jsp-property-group</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span><span class="comment">&lt;!--对所有jsp进行配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-ignored</span>&gt;</span>true<span class="tag">&lt;/<span class="name">el-ignored</span>&gt;</span><span class="comment">&lt;!--忽略EL表达式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">page-encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">page-encoding</span>&gt;</span><span class="comment">&lt;!--指定页面编码为utf-8--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scripting-invalid</span>&gt;</span>true<span class="tag">&lt;/<span class="name">scripting-invalid</span>&gt;</span><span class="comment">&lt;!--禁用Java脚本！如果在JSP页面中使用了Java脚本就会抛出异常。--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">jsp-property-group</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">jsp-config</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="include指令"><a href="#include指令" class="headerlink" title="include指令"></a>include指令</h4><p>include指令表示静态包含！即目的是把多个JSP合并成一个JSP文件！</p><p>include指令只有一个属性：file，指定要包含的页面，例如：<code>&lt;%@include file=&quot;b.jsp&quot;%&gt;</code>。</p><p>静态包含：当hel.jsp页面包含了lo.jsp页面后，在编译hel.jsp页面时，需要把hel.jsp和lo.jsp页面合并成一个文件，然后再编译成Servlet（Java文件）。</p><p><img src="https://i.loli.net/2020/07/01/pOWiNGAd3E9mQVS.png" alt="2.png"></p><p>很明显，在ol.jsp中在使用username变量，而这个变量在hel.jsp中定义的，所以只有这两个JSP文件合并后才能使用。通过include指定完成对它们的合并！</p><h4 id="taglib指令"><a href="#taglib指令" class="headerlink" title="taglib指令"></a>taglib指令</h4><p>这个指令需要在学习了自定义标签后才会使用，现在只能做了了解而已！</p><p>在JSP页面中使用第三方的标签库时，需要使用taglib指令来”导包”。例如：</p><p><code>&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;</code></p><p>其中prefix表示标签的前缀，这个名称可以随便起。uri是由第三方标签库定义的，所以你需要知道第三方定义的uri。</p><h3 id="JSP-九大内置对象"><a href="#JSP-九大内置对象" class="headerlink" title="JSP 九大内置对象"></a>JSP 九大内置对象</h3><h4 id="什么是JSP九大内置对象"><a href="#什么是JSP九大内置对象" class="headerlink" title="什么是JSP九大内置对象"></a>什么是JSP九大内置对象</h4><p>在JSP中无需创建就可以使用的9个对象，它们是：</p><ul><li><p>out（JspWriter）：等同与response.getWriter()，用来向客户端发送文本数据；</p></li><li><p>config（ServletConfig）：对应”真身”中的ServletConfig；</p></li><li><p>page（当前JSP的真身类型）：当前JSP页面的”this”，即当前对象；</p></li><li><p>pageContext（PageContext）：页面上下文对象，它是最后一个没讲的域对象；</p></li><li><p>exception（Throwable）：只有在错误页面中可以使用这个对象；</p></li><li><p>request（HttpServletRequest）：即HttpServletRequest类的对象；</p></li><li><p>response（HttpServletResponse）：即HttpServletResponse类的对象；</p></li><li><p>application（ServletContext）：即ServletContext类的对象；</p></li><li><p>session（HttpSession）：即HttpSession类的对象，不是每个JSP页面中都可以使用，如果在某个JSP页面中设置<code>&lt;%@page session=&quot;false&quot;%&gt;</code>，说明这个页面不能使用session。</p></li></ul><p>在这9个对象中有很多是极少会被使用的，例如：config、page、exception基本不会使用。</p><p>在这9个对象中有两个对象不是每个JSP页面都可以使用的：exception、session。</p><p>在这9个对象中有很多前面已经学过的对象：out、request、response、application、session、config。</p><h4 id="通过”真身”来对照JSP"><a href="#通过”真身”来对照JSP" class="headerlink" title="通过”真身”来对照JSP"></a>通过”真身”来对照JSP</h4><p>我们知道JSP页面的内容出现在”真身”的<code>_jspService()方法</code>中，而在<code>_jspService()</code>方法开头部分已经创建了9大内置对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">_jspService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    PageContext pageContext = <span class="keyword">null</span>;</span><br><span class="line">    HttpSession session = <span class="keyword">null</span>;</span><br><span class="line">    ServletContext application = <span class="keyword">null</span>;</span><br><span class="line">    ServletConfig config = <span class="keyword">null</span>;</span><br><span class="line">    JspWriter out = <span class="keyword">null</span>;</span><br><span class="line">    Object page = <span class="keyword">this</span>;</span><br><span class="line">    JspWriter _jspx_out = <span class="keyword">null</span>;</span><br><span class="line">    PageContext _jspx_page_context = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">      pageContext = _jspxFactory.getPageContext(<span class="keyword">this</span>, request, response,</span><br><span class="line">      <span class="keyword">null</span>, <span class="keyword">true</span>, <span class="number">8192</span>, <span class="keyword">true</span>);</span><br><span class="line">      _jspx_page_context = pageContext;</span><br><span class="line">      application = pageContext.getServletContext();</span><br><span class="line">      config = pageContext.getServletConfig();</span><br><span class="line">      session = pageContext.getSession();</span><br><span class="line">      out = pageContext.getOut();</span><br><span class="line">      _jspx_out = out;</span><br><span class="line"></span><br><span class="line">　　　　<span class="comment">// 从这里开始，才是JSP页面的内容</span></span><br><span class="line">   &#125;…</span><br></pre></td></tr></table></figure><h4 id="pageContext对象"><a href="#pageContext对象" class="headerlink" title="pageContext对象"></a>pageContext对象</h4><p>在JavaWeb中一共四个域对象，其中Servlet中可以使用的是request、session、application三个对象，而在JSP中可以使用pageContext、request、session、application四个域对象。</p><p>pageContext 对象是PageContext类型，它的主要功能有：</p><ul><li><p>域对象功能；</p></li><li><p>代理其它域对象功能；</p></li><li><p>获取其他内置对象；</p></li></ul><h5 id="域对象功能"><a href="#域对象功能" class="headerlink" title="域对象功能"></a>域对象功能</h5><p>pageContext也是域对象，它的范围是当前页面。它的范围也是四个域对象中最小的！</p><ul><li><p>void setAttribute(String name, Object value)；</p></li><li><p>Object getAttrbiute(String name, Object value)；</p></li><li><p>void removeAttribute(String name, Object value)；</p></li></ul><h5 id="代理其它域对象功能"><a href="#代理其它域对象功能" class="headerlink" title="代理其它域对象功能"></a>代理其它域对象功能</h5><p>还可以使用pageContext来代理其它3个域对象的功能，也就是说可以使用pageContext向request、session、application对象中存取数据，例如：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pageContext.setAttribute(<span class="string">"x"</span>, <span class="string">"X"</span>); <span class="comment">// 向pageContext中存储数据</span></span><br><span class="line">pageContext.setAttribute(<span class="string">"x"</span>, <span class="string">"XX"</span>, PageContext.REQUEST_SCOPE); <span class="comment">// 向request中存储数据</span></span><br><span class="line">pageContext.setAttribute(<span class="string">"x"</span>, <span class="string">"XXX"</span>, PageContext.SESSION_SCOPE); <span class="comment">// 向session中存储数据</span></span><br><span class="line">pageContext.setAttribute(<span class="string">"x"</span>, <span class="string">"XXXX"</span>, PageContext.APPLICATION_SCOPE); <span class="comment">// 向application中存储数据</span></span><br></pre></td></tr></table></figure><ul><li><p>void setAttribute(String name, Object value, int scope)：在指定范围中添加数据；</p></li><li><p>Object getAttribute(String name, int scope)：获取指定范围的数据；</p></li><li><p>void removeAttribute(String name, int scope)：移除指定范围的数据；</p></li><li><p>Object findAttribute(String name)：依次在page、request、session、application范围查找名称为name的数据，如果找到就停止查找。这说明在这个范围内有相同名称的数据，那么page范围的优先级最高！</p></li></ul><h5 id="获取其他内置对象"><a href="#获取其他内置对象" class="headerlink" title="获取其他内置对象"></a>获取其他内置对象</h5><p>一个pageContext对象等于所有内置对象，即1个当9个。这是因为可以使用pageContext对象获取其它8个内置对象：</p><ul><li><p>JspWriter getOut()：获取out内置对象；</p></li><li><p>ServletConfig getServletConfig()：获取config内置对象；</p></li><li><p>Object getPage()：获取page内置对象；</p></li><li><p>ServletRequest getRequest()：获取request内置对象；</p></li><li><p>ServletResponse getResponse()：获取response内置对象；</p></li><li><p>HttpSession getSession()：获取session内置对象；</p></li><li><p>ServletContext getServletContext()：获取application内置对象；</p></li><li><p>Exception getException()：获取exception内置对象；</p></li></ul><h3 id="JSP-动作标签"><a href="#JSP-动作标签" class="headerlink" title="JSP 动作标签"></a>JSP 动作标签</h3><h4 id="JSP动作标签概述"><a href="#JSP动作标签概述" class="headerlink" title="JSP动作标签概述"></a>JSP动作标签概述</h4><p>动作标签的作用是用来简化Java脚本的！</p><p>JSP动作标签是JavaWeb内置的动作标签，它们是已经定义好的动作标签，我们可以拿来直接使用。</p><p>如果JSP动作标签不够用时，还可以使用自定义标签（今天不讲）。JavaWeb一共提供了20个JSP动作标签，但有很多基本没有用，这里只介绍一些有坐标的动作标签。</p><p>JSP动作标签的格式：<code>&lt;jsp:标签名 …&gt;</code></p><h4 id="lt-jsp-include-gt"><a href="#lt-jsp-include-gt" class="headerlink" title="&lt;jsp:include&gt;"></a><code>&lt;jsp:include&gt;</code></h4><p><code>&lt;jsp:include&gt;</code>标签的作用是用来包含其它JSP页面的！你可能会说，前面已经学习了include指令了，它们是否相同呢？虽然它们都是用来包含其它JSP页面的，但它们的实现的级别是不同的！</p><p>include指令是在编译级别完成的包含，即把当前JSP和被包含的JSP合并成一个JSP，然后再编译成一个Servlet。</p><p>include动作标签是在运行级别完成的包含，即当前JSP和被包含的JSP都会各自生成Servlet，然后在执行当前JSP的Servlet时完成包含另一个JSP的Servlet。它与RequestDispatcher的include()方法是相同的！</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--hel.jsp--%&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;hel.jsp&lt;/h1&gt;</span><br><span class="line">    &lt;jsp:include page=<span class="string">"lo.jsp"</span> /&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--lo.jsp--%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">out.println(<span class="string">"&lt;h1&gt;lo.jsp&lt;/h1&gt;"</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/07/01/Oi2EqIUWygDaHVT.png" alt="2.png"></p><p>其实<code>&lt;jsp:include&gt;</code>在”真身”中不过是一句方法调用，即调用另一个Servlet而已。</p><h4 id="lt-jsp-forward-gt"><a href="#lt-jsp-forward-gt" class="headerlink" title="&lt;jsp:forward&gt;"></a><code>&lt;jsp:forward&gt;</code></h4><p>forward标签的作用是请求转发！forward标签的作用与RequestDispatcher#forward()方法相同。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--hel.jsp--%&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;</span><br><span class="line">        hel.jsp</span><br><span class="line">    &lt;/h1&gt;</span><br><span class="line">    &lt;jsp:forward page=<span class="string">"lo.jsp"</span>/&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--lo.jsp--%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">out.println(<span class="string">"&lt;h1&gt;lo.jsp&lt;/h1&gt;"</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>注意，最后客户端只能看到lo.jsp的输出，而看不到hel.jsp的内容。也就是说在hel.jsp中的<code>&lt;h1&gt;hel.jsp&lt;/h1&gt;</code>是不会发送到客户端的。<code>&lt;jsp:forward&gt;</code>的作用是”别再显示我，去显示它吧！”。</p><h4 id="lt-jsp-param-gt"><a href="#lt-jsp-param-gt" class="headerlink" title="&lt;jsp:param&gt;"></a><code>&lt;jsp:param&gt;</code></h4><p>还可以在<code>&lt;jsp:include&gt;</code>和<code>&lt;jsp:forward&gt;</code>标签中使用<code>&lt;jsp:param&gt;</code>子标签，它是用来传递参数的。下面用<code>&lt;jsp:include&gt;</code>来举例说明<code>&lt;jsp:param&gt;</code>的使用。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> <span class="keyword">import</span>=<span class="string">"java.util.*"</span> pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;a.jsp&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;h1&gt;a.jsp&lt;/h1&gt;</span><br><span class="line">    &lt;hr/&gt;</span><br><span class="line">&lt;jsp:include page=<span class="string">"/b.jsp"</span>&gt;</span><br><span class="line">&lt;jsp:param value=<span class="string">"zhangSan"</span> name=<span class="string">"username"</span>/&gt; &lt;%--传参--%&gt;</span><br><span class="line">&lt;/jsp:include&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> <span class="keyword">import</span>=<span class="string">"java.util.*"</span> pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;b.jsp&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;h1&gt;b.jsp&lt;/h1&gt;</span><br><span class="line">    &lt;hr/&gt;</span><br><span class="line">&lt;%</span><br><span class="line">String username = request.getParameter(<span class="string">"username"</span>); </span><br><span class="line">out.print(<span class="string">"你好："</span> + username);</span><br><span class="line">%&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h3><h4 id="JavaBean概述"><a href="#JavaBean概述" class="headerlink" title="JavaBean概述"></a>JavaBean概述</h4><h5 id="什么是JavaBean"><a href="#什么是JavaBean" class="headerlink" title="什么是JavaBean"></a>什么是JavaBean</h5><p>JavaBean是一种规范，也就是对类的要求。它要求Java类的成员变量提供getter/setter方法，这样的成员变量被称之为JavaBean属性。</p><p>JavaBean还要求类必须提供仅有的无参构造器，例如：public User() {…}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> username;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.username = username;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> password;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.password = password;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="JavaBean属性"><a href="#JavaBean属性" class="headerlink" title="JavaBean属性"></a>JavaBean属性</h5><p>JavaBean属性是具有getter/setter方法的成员变量。</p><ul><li><p>也可以只提供getter方法，这样的属性叫只读属性；</p></li><li><p>也可以只提供setter方法，这样的属性叫只写属性；</p></li><li><p>如果属性类型为boolean类型，那么读方法的格式可以是get或is。例如名为abc的boolean类型的属性，它的读方法可以是getAbc()，也可以是isAbc()；</p></li></ul><p>JavaBean属性名要求：前两个字母要么都大写，要么都小写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String iD;<span class="comment">// wrong</span></span><br><span class="line"><span class="keyword">private</span> String ID;</span><br><span class="line"><span class="keyword">private</span> String qQ;<span class="comment">// wrong</span></span><br><span class="line"><span class="keyword">private</span> String QQ;</span><br><span class="line">    <span class="comment">// …</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JavaBean可能存在属性，但不存在这个成员变量，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"zhangSan"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中User类有一个名为username的只读属性！但User类并没有username这个成员变量！</p><p>还可以更变态一点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String hello;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> hello;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.hello = username;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中User类中有一个名为username的属性，它是可读可写的属性！而Use类的成员变量名为hello！也就是说JavaBean的属性名取决于方法名称，而不是成员变量的名称。但通常没有人做这么变态的事情。</p><h4 id="内省（了解）"><a href="#内省（了解）" class="headerlink" title="内省（了解）"></a>内省（了解）</h4><p>内省的目标是得到JavaBean属性的读、写方法的反射对象，通过反射对JavaBean属性进行操作的一组API。例如User类有名为username的JavaBean属性，通过两个Method对象（一个是getUsenrmae()，一个是setUsername()）来操作User对象。</p><p>如果你还不能理解内省是什么，那么我们通过一个问题来了解内省的作用。现在我们有一个Map，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">map.put(<span class="string">"username"</span>, <span class="string">"admin"</span>);</span><br><span class="line">map.put(<span class="string">"password"</span>, <span class="string">"admin123"</span>);</span><br><span class="line"><span class="comment">// ----------------------------------------------------</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.username = username;</span><br><span class="line"><span class="keyword">this</span>.password = password;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> username;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.username = username;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> password;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.password = password;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"User [username="</span> + username + <span class="string">", password="</span> + password + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在需要把map的数据封装到一个User对象中！User类有两个JavaBean属性，一个叫username，另一个叫password。</p><p>你可能想到的是反射，通过map的key来查找User类的Field！这么做是没有问题的，但我们要知道类的成员变量是私有的，虽然也可以通过反射去访问类的私有的成员变量，但我们也要清楚反射访问私有的东西是有”危险”的，所以还是建议通过getUsername和setUsername来访问JavaBean属性。</p><h5 id="内省之获取BeanInfo"><a href="#内省之获取BeanInfo" class="headerlink" title="内省之获取BeanInfo"></a>内省之获取BeanInfo</h5><p>我们这里不想去对JavaBean规范做过多的介绍，所以也就不在多介绍BeanInfo的”出身”了。你只需要知道如何得到它，以及BeanInfo有什么。</p><p>通过java.beans.Introspector的getBeanInfo()方法来获取java.beans.BeanInfo实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BeanInfo beanInfo = Introspector.getBeanInfo(User<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><h5 id="得到所有属性描述符（PropertyDescriptor）"><a href="#得到所有属性描述符（PropertyDescriptor）" class="headerlink" title="得到所有属性描述符（PropertyDescriptor）"></a>得到所有属性描述符（PropertyDescriptor）</h5><p>通过BeanInfo可以得到这个类的所有JavaBean属性的PropertyDescriptor对象。然后就可以通过PropertyDescriptor对象得到这个属性的getter/setter方法的Method对象了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PropertyDescriptor[] pds = beanInfo.getPropertyDescriptors();</span><br></pre></td></tr></table></figure><p>每个PropertyDescriptor对象对应一个JavaBean属性：</p><ul><li><p>String getName()：获取JavaBean属性名称；</p></li><li><p>Method getReadMethod：获取属性的读方法；</p></li><li><p>Method getWriteMethod：获取属性的写方法。</p></li></ul><h5 id="完成Map数据封装到User对象中"><a href="#完成Map数据封装到User对象中" class="headerlink" title="完成Map数据封装到User对象中"></a>完成Map数据封装到User对象中</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">    map.put(<span class="string">"username"</span>, <span class="string">"admin"</span>);</span><br><span class="line">    map.put(<span class="string">"password"</span>, <span class="string">"admin123"</span>);</span><br><span class="line"></span><br><span class="line">    BeanInfo beanInfo = Introspector.getBeanInfo(User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    PropertyDescriptor[] pds = beanInfo.getPropertyDescriptors();</span><br><span class="line"></span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    <span class="keyword">for</span>(PropertyDescriptor pd : pds) &#123;</span><br><span class="line">        String name = pd.getName();</span><br><span class="line">        String value = map.get(name);</span><br><span class="line">        <span class="keyword">if</span>(value != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Method writeMethod = pd.getWriteMethod();</span><br><span class="line">            writeMethod.invoke(user, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="commons-beanutils"><a href="#commons-beanutils" class="headerlink" title="commons-beanutils"></a>commons-beanutils</h4><p>提到内省，不能不提commons-beanutils这个工具。它底层使用了内省，对内省进行了大量的简化！</p><p>使用beanutils需要的jar包：</p><ul><li><p>commons-beanutils.jar；</p></li><li><p>commons-logging.jar；</p></li></ul><h5 id="设置JavaBean属性"><a href="#设置JavaBean属性" class="headerlink" title="设置JavaBean属性"></a>设置JavaBean属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line"></span><br><span class="line">BeanUtils.setProperty(user, <span class="string">"username"</span>, <span class="string">"admin"</span>);</span><br><span class="line">BeanUtils.setProperty(user, <span class="string">"password"</span>, <span class="string">"admin123"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(user);</span><br></pre></td></tr></table></figure><h5 id="获取JavaBean属性"><a href="#获取JavaBean属性" class="headerlink" title="获取JavaBean属性"></a>获取JavaBean属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User(<span class="string">"admin"</span>, <span class="string">"admin123"</span>);</span><br><span class="line"></span><br><span class="line">String username = BeanUtils.getProperty(user, <span class="string">"username"</span>);</span><br><span class="line">String password = BeanUtils.getProperty(user, <span class="string">"password"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"username="</span> + username + <span class="string">", password="</span> + password);</span><br></pre></td></tr></table></figure><h5 id="封装Map数据到JavaBean对象中"><a href="#封装Map数据到JavaBean对象中" class="headerlink" title="封装Map数据到JavaBean对象中"></a>封装Map数据到JavaBean对象中</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">map.put(<span class="string">"username"</span>, <span class="string">"admin"</span>);</span><br><span class="line">map.put(<span class="string">"password"</span>, <span class="string">"admin123"</span>);</span><br><span class="line"></span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line"></span><br><span class="line">BeanUtils.populate(user, map);</span><br><span class="line"></span><br><span class="line">System.out.println(user);</span><br></pre></td></tr></table></figure><h4 id="JSP与JavaBean相关的动作标签"><a href="#JSP与JavaBean相关的动作标签" class="headerlink" title="JSP与JavaBean相关的动作标签"></a>JSP与JavaBean相关的动作标签</h4><p>在JSP中与JavaBean相关的标签有：</p><ul><li><p><code>&lt;jsp:useBean&gt;</code>：创建JavaBean对象；</p></li><li><p><code>&lt;jsp:setProperty&gt;</code>：设置JavaBean属性；</p></li><li><p><code>&lt;jsp:getProperty&gt;</code>：获取JavaBean属性；</p></li></ul><p>我们需要先创建一个JavaBean类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User.java</span></span><br><span class="line"><span class="keyword">package</span> tt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.username = username;</span><br><span class="line"><span class="keyword">this</span>.password = password;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> username;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.username = username;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> password;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.password = password;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"User [username="</span> + username + <span class="string">", password="</span> + password + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="lt-jsp-useBean-gt"><a href="#lt-jsp-useBean-gt" class="headerlink" title="&lt;jsp:useBean&gt;"></a><code>&lt;jsp:useBean&gt;</code></h5><p><code>&lt;jsp:useBean&gt;</code>标签的作用是创建JavaBean对象：</p><ul><li><p>在当前JSP页面创建JavaBean对象；</p></li><li><p>把创建的JavaBean对象保存到域对象中；</p></li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:useBean id=<span class="string">"user1"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"tt.User"</span> /&gt;</span><br></pre></td></tr></table></figure><p>上面代码表示在当前JSP页面中创建User类型的对象，并且把它保存到page域中了。下面我们把<code>&lt;jsp:useBean&gt;</code>标签翻译成Java代码：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">tt.User user1 = <span class="keyword">new</span> tt.User();</span><br><span class="line">pageContext.setAttribute(<span class="string">"user1"</span>, user1);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>这说明我们可以在JSP页面中完成下面的操作：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:useBean id=<span class="string">"user1"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"tt.User"</span> /&gt;</span><br><span class="line">&lt;%=user1 %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">out.println(pageContext.getAttribute(<span class="string">"user1"</span>));</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;jsp:useBean&gt;</code>标签默认是把JavaBean对象保存到page域，还可以通过scope标签属性来指定保存的范围：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:useBean id=<span class="string">"user1"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"tt.User"</span> scope=<span class="string">"page"</span>/&gt;</span><br><span class="line">&lt;jsp:useBean id=<span class="string">"user2"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"tt.User"</span> scope=<span class="string">"request"</span>/&gt;</span><br><span class="line">&lt;jsp:useBean id=<span class="string">"user3"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"tt.User"</span> scope=<span class="string">"session"</span>/&gt;</span><br><span class="line">&lt;jsp:useBean id=<span class="string">"user4"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"tt.User"</span> scope=<span class="string">"applicatioin"</span>/&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;jsp:useBean&gt;</code>标签其实不一定会创建对象！！！其实它会先在指定范围中查找这个对象，如果对象不存在才会创建，我们需要重新对它进行翻译：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:useBean id=<span class="string">"user4"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"tt.User"</span> scope=<span class="string">"applicatioin"</span>/&gt;</span><br></pre></td></tr></table></figure><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">tt.User user4 = (tt.User)application.getAttribute(<span class="string">"user4"</span>);</span><br><span class="line"><span class="keyword">if</span>(user4 == <span class="keyword">null</span>) &#123;</span><br><span class="line">user4 = <span class="keyword">new</span> tt.User();</span><br><span class="line">application.setAttribute(<span class="string">"user4"</span>, user4);</span><br><span class="line">&#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h5 id="lt-jsp-setProperty-gt-和-lt-jsp-getProperty-gt"><a href="#lt-jsp-setProperty-gt-和-lt-jsp-getProperty-gt" class="headerlink" title="&lt;jsp:setProperty&gt;和&lt;jsp:getProperty&gt;"></a><code>&lt;jsp:setProperty&gt;</code>和<code>&lt;jsp:getProperty&gt;</code></h5><p><code>&lt;jsp:setProperty&gt;</code>标签的作用是给JavaBean设置属性值，而<code>&lt;jsp:getProperty&gt;</code>是用来获取属性值。在使用它们之前需要先创建JavaBean：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:useBean id=<span class="string">"user1"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"tt.User"</span> /&gt;</span><br><span class="line">&lt;jsp:setProperty property=<span class="string">"username"</span> name=<span class="string">"user1"</span> value=<span class="string">"admin"</span>/&gt;</span><br><span class="line">&lt;jsp:setProperty property=<span class="string">"password"</span> name=<span class="string">"user1"</span> value=<span class="string">"admin123"</span>/&gt;</span><br><span class="line"></span><br><span class="line">用户名：&lt;jsp:getProperty property=<span class="string">"username"</span> name=<span class="string">"user1"</span>/&gt;&lt;br/&gt;</span><br><span class="line">密　码：&lt;jsp:getProperty property=<span class="string">"password"</span> name=<span class="string">"user1"</span>/&gt;&lt;br/&gt;</span><br></pre></td></tr></table></figure><h3 id="EL（表达式语言）"><a href="#EL（表达式语言）" class="headerlink" title="EL（表达式语言）"></a>EL（表达式语言）</h3><h4 id="EL概述"><a href="#EL概述" class="headerlink" title="EL概述"></a>EL概述</h4><h5 id="EL的作用"><a href="#EL的作用" class="headerlink" title="EL的作用"></a>EL的作用</h5><p>JSP2.0要把html和css分离、要把html和javascript分离、要把Java脚本替换成标签。标签的好处是非Java人员都可以使用。</p><p>JSP2.0 – 纯标签页面，即：不包含&lt;% … %&gt;、&lt;%! … %&gt;，以及&lt;%= … %&gt;</p><p>EL（Expression Language）是一门表达式语言，它对应&lt;%=…%&gt;。我们知道在JSP中，表达式会被输出，所以EL表达式也会被输出。</p><h5 id="EL的格式"><a href="#EL的格式" class="headerlink" title="EL的格式"></a>EL的格式</h5><p>格式：${…}</p><p>例如：${1 + 2}</p><h5 id="关闭EL"><a href="#关闭EL" class="headerlink" title="关闭EL"></a>关闭EL</h5><p>如果希望整个JSP忽略EL表达式，需要在page指令中指定isELIgnored=”true”。</p><p>如果希望忽略某个EL表达式，可以在EL表达式之前添加”&quot;，例如：<code>\${1 + 2}</code>。</p><h5 id="EL运算符"><a href="#EL运算符" class="headerlink" title="EL运算符"></a>EL运算符</h5><table><thead><tr><th align="center">运算符</th><th align="center">说明</th><th align="center">范例</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center"><code>+</code></td><td align="center">加</td><td align="center"><code>${17+5}</code></td><td align="center">22</td></tr><tr><td align="center"><code>-</code></td><td align="center">减</td><td align="center"><code>${17-5}</code></td><td align="center">12</td></tr><tr><td align="center"><code>*</code></td><td align="center">乘</td><td align="center"><code>${17*5}</code></td><td align="center">85</td></tr><tr><td align="center"><code>/</code>或div</td><td align="center">除</td><td align="center"><code>${17/5}或${17 div 5}</code></td><td align="center">3</td></tr><tr><td align="center"><code>%</code>或mod</td><td align="center">取余</td><td align="center"><code>${17%5}或${17 mod 5}</code></td><td align="center">2</td></tr><tr><td align="center"><code>==</code>或eq</td><td align="center">等于</td><td align="center"><code>${5==5}或${5 eq 5}</code></td><td align="center">true</td></tr><tr><td align="center"><code>!=</code>或ne</td><td align="center">不等于</td><td align="center"><code>${5!=5}或${5 ne 5}</code></td><td align="center">false</td></tr><tr><td align="center"><code>&lt;</code>或lt</td><td align="center">小于</td><td align="center"><code>${3&lt;5}或${3 lt 5}</code></td><td align="center">true</td></tr><tr><td align="center"><code>&gt;</code>或gt</td><td align="center">大于</td><td align="center"><code>${3&gt;5}或${3 gt 5}</code></td><td align="center">false</td></tr><tr><td align="center"><code>&lt;=</code>或le</td><td align="center">小于等于</td><td align="center"><code>${3&lt;=5}或${3 le 5}</code></td><td align="center">true</td></tr><tr><td align="center"><code>&gt;=</code>或ge</td><td align="center">大于等于</td><td align="center"><code>${3&gt;=5}或${3 ge 5}</code></td><td align="center">false</td></tr><tr><td align="center">&amp;&amp;或and</td><td align="center">并且</td><td align="center"><code>${true&amp;&amp;false}或${true and false}</code></td><td align="center">false</td></tr><tr><td align="center">!或not</td><td align="center">非</td><td align="center"><code>${!true}或${not true}</code></td><td align="center">false</td></tr><tr><td align="center">||或or</td><td align="center">或者</td><td align="center">`  ${true</td><td align="center"></td></tr><tr><td align="center">empty</td><td align="center">是否为空</td><td align="center"><code>${empty &quot;&quot;}</code>，可以判断字符串、数据、集合的长度是否为0，为0返回true。empty还可以与not或!一起使用。<code>${not empty &quot;&quot;}</code></td><td align="center">true</td></tr></tbody></table><h5 id="EL不显示null"><a href="#EL不显示null" class="headerlink" title="EL不显示null"></a>EL不显示null</h5><p>当EL表达式的值为null时，会在页面上显示空白，即什么都不显示。</p><h4 id="EL表达式格式"><a href="#EL表达式格式" class="headerlink" title="EL表达式格式"></a>EL表达式格式</h4><p>先来了解一下EL表达式的格式！现在还不能演示它，因为需要学习了EL11个内置对象后才方便显示它。</p><ul><li><p>操作List和数组：<code>${list[0]}</code>、<code>${arr[0]}</code>；</p></li><li><p>操作bean的属性：<code>${person.name}</code>、<code>${person[&#39;name&#39;]}</code>，对应<code>person.getName()</code>方法；</p></li><li><p>操作Map的值：<code>${map.key}</code>、<code>${map[&#39;key&#39;]}</code>，对应<code>map.get(key)</code>。</p></li></ul><h4 id="EL内置对象"><a href="#EL内置对象" class="headerlink" title="EL内置对象"></a>EL内置对象</h4><p>EL一共11个内置对象，无需创建即可以使用。这11个内置对象中有10个是Map类型的，最后一个是pageContext对象。</p><ul><li><p>pageScope</p></li><li><p>requestScope</p></li><li><p>sessionScope</p></li><li><p>applicationScope</p></li><li><p>param；</p></li><li><p>paramValues；</p></li><li><p>header；</p></li><li><p>headerValues；</p></li><li><p>initParam；</p></li><li><p>cookie；</p></li><li><p>pageContext；</p></li></ul><h5 id="域相关内置对象（重点）"><a href="#域相关内置对象（重点）" class="headerlink" title="域相关内置对象（重点）"></a>域相关内置对象（重点）</h5><p>域内置对象一共有四个：</p><ul><li><p>pageScope：<code>${pageScope.name}</code>等同与<code>pageContext.getAttribute(&quot;name&quot;);</code></p></li><li><p>requestScope：<code>${requestScope.name}</code>等同与<code>request.getAttribute(&quot;name&quot;);</code></p></li><li><p>sessionScoep：<code>${sessionScope.name}</code>等同与<code>session.getAttribute(&quot;name&quot;);</code></p></li><li><p>applicationScope：<code>${applicationScope.name}</code>等同与<code>application.getAttribute(&quot;name&quot;);</code></p></li></ul><p>如果在域中保存的是JavaBean对象，那么可以使用EL来访问JavaBean属性。因为EL只做读取操作，所以JavaBean一定要提供get方法，而set方法没有要求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">private</span> String sex;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%pageContext.setAttribute(<span class="string">"p1"</span>, <span class="keyword">new</span> Person(<span class="string">"zhk"</span>, <span class="number">19</span>, <span class="string">"male"</span>));%&gt;</span><br><span class="line">$&#123;pageScope.p1.name&#125;&lt;br/&gt;</span><br><span class="line">$&#123;pageScope.p1.age&#125;&lt;br/&gt;</span><br><span class="line">$&#123;pageScope.p1.sex&#125;&lt;br/&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/07/01/jDHpKeVcbIhOwRy.png" alt="2.png"></p><p>全域查找：${person}表示依次在pageScope、requesScopet、sessionScope、appliationScope四个域中查找名字为person的属性。</p><h5 id="请求参数相关内置对象"><a href="#请求参数相关内置对象" class="headerlink" title="请求参数相关内置对象"></a>请求参数相关内置对象</h5><p>param和paramValues这两个内置对象是用来获取请求参数的。</p><ul><li>param：Map&lt;String,String&gt;类型，param对象可以用来获取参数，与request.getParameter()方法相同。</li></ul><p><img src="https://i.loli.net/2020/07/01/DP9KeVXEvQUcJ7M.png" alt="2.png"></p><p>注意，在使用EL获取参数时，如果参数不存在，返回的是空字符串，而不是null。这一点与使用request.getParameter()方法是不同的。</p><ul><li>paramValues：paramValues是Map&lt;String, String[]&gt;类型，当一个参数名，对应多个参数值时可以使用它。</li></ul><h5 id="请求头相关内置对象"><a href="#请求头相关内置对象" class="headerlink" title="请求头相关内置对象"></a>请求头相关内置对象</h5><p>header和headerValues是与请求头相关的内置对象：</p><ul><li><p>header： Map&lt;String,String&gt;类型，用来获取请求头。</p></li><li><p>headerValues：headerValues是Map&lt;String,String[]&gt;类型。当一个请求头名称，对应多个值时，使用该对象，这里就不在赘述。</p></li></ul><h5 id="应用初始化参数相关内置对象"><a href="#应用初始化参数相关内置对象" class="headerlink" title="应用初始化参数相关内置对象"></a>应用初始化参数相关内置对象</h5><ul><li>initParam：initParam是Map&lt;String,String&gt;类型。它对应web.xml文件中的<code>&lt;context-param&gt;</code>参数。</li></ul><p><img src="https://i.loli.net/2020/07/01/HLTiF51eXWyPnrl.png" alt="2.png"></p><h5 id="Cookie相关内置对象"><a href="#Cookie相关内置对象" class="headerlink" title="Cookie相关内置对象"></a>Cookie相关内置对象</h5><ul><li>cookie：cookie是Map&lt;String,Cookie&gt;类型，其中key是Cookie的名字，而值是Cookie对象本身。</li></ul><p><img src="https://i.loli.net/2020/07/01/jNO1Iy69mvubBMT.png" alt="2.png"></p><h5 id="pageContext对象-1"><a href="#pageContext对象-1" class="headerlink" title="pageContext对象"></a>pageContext对象</h5><p>pageContext：pageContext是PageContext类型！可以使用pageContext对象调用getXXX()方法，例如pageContext.getRequest()，可以${pageContext.request}。也就是读取JavaBean属性！！！</p><table><thead><tr><th align="left">EL表达式</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">${pageContext.request.queryString}</td><td align="left">pageContext.getRequest().getQueryString();</td></tr><tr><td align="left">${pageContext.request.requestURL}</td><td align="left">pageContext.getRequest().getRequestURL();</td></tr><tr><td align="left">${pageContext.request.contextPath}</td><td align="left">pageContext.getRequest().getContextPath();</td></tr><tr><td align="left">${pageContext.request.method}</td><td align="left">pageContext.getRequest().getMethod();</td></tr><tr><td align="left">${pageContext.request.protocol}</td><td align="left">pageContext.getRequest().getProtocol();</td></tr><tr><td align="left">${pageContext.request.remoteUser}</td><td align="left">pageContext.getRequest().getRemoteUser();</td></tr><tr><td align="left">${pageContext.request.remoteAddr}</td><td align="left">pageContext.getRequest().getRemoteAddr();</td></tr><tr><td align="left">${pageContext.session.new}</td><td align="left">pageContext.getSession().isNew();</td></tr><tr><td align="left">${pageContext.session.id}</td><td align="left">pageContext.getSession().getId();</td></tr><tr><td align="left">${pageContext.servletContext.serverInfo}</td><td align="left">pageContext.getServletContext().getServerInfo();</td></tr></tbody></table><h3 id="EL函数库"><a href="#EL函数库" class="headerlink" title="EL函数库"></a>EL函数库</h3><h4 id="什么EL函数库"><a href="#什么EL函数库" class="headerlink" title="什么EL函数库"></a>什么EL函数库</h4><p>EL函数库是由第三方对EL的扩展，我们现在学习的EL函数库是由JSTL添加的。JSTL明天再学！</p><p>EL函数库就是定义一些有返回值的静态方法。然后通过EL语言来调用它们！当然，不只是JSTL可以定义EL函数库，我们也可以自定义EL函数库。</p><p>EL函数库中包含了很多对字符串的操作方法，以及对集合对象的操作。例如：<code>${fn:length(“abc”)}</code>会输出3，即字符串的长度。</p><h4 id="导入函数库"><a href="#导入函数库" class="headerlink" title="导入函数库"></a>导入函数库</h4><p>因为是第三方的东西，所以需要导入。导入需要使用taglib指令！</p><p><code>&lt;%@ taglib prefix=&quot;fn&quot; uri=&quot;http://java.sun.com/jsp/jstl/functions&quot; %&gt;</code></p><h4 id="EL函数库介绍"><a href="#EL函数库介绍" class="headerlink" title="EL函数库介绍"></a>EL函数库介绍</h4><ul><li>String toUpperCase(String input)：</li><li>String toLowerCase(String input)：</li><li>int indexOf(String input, String substring)：</li><li>boolean contains(String input, String substring)：</li><li>boolean containsIgnoreCase(String input, String substring)：</li><li>boolean startsWith(String input, String substring)：</li><li>boolean endsWith(String input, String substring)：</li><li>String substring(String input, int beginIndex, int endIndex)：</li><li>String substringAfter(String input, String substring)：</li><li>substringBefore(String input, String substring)：</li><li>String escapeXml(String input)：</li><li>String trim(String input)：</li><li>String replace(String input, String substringBefore, String substringAfter)：</li><li>String[] split(String input, String delimiters)：</li><li>int length(Object obj)：</li><li>String join(String array[], String separator)：</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;%<span class="meta">@taglib</span> prefix=<span class="string">"fn"</span> uri=<span class="string">"http://java.sun.com/jsp/jstl/functions"</span> %&gt;</span><br><span class="line">…</span><br><span class="line">String[] strs = &#123;<span class="string">"a"</span>, <span class="string">"b"</span>,<span class="string">"c"</span>&#125;;</span><br><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">"a"</span>);</span><br><span class="line">pageContext.setAttribute(<span class="string">"arr"</span>, strs);</span><br><span class="line">pageContext.setAttribute(<span class="string">"list"</span>, list);</span><br><span class="line">%&gt;</span><br><span class="line">$&#123;fn:length(arr) &#125;&lt;br/&gt;&lt;!--<span class="number">3</span>--&gt;</span><br><span class="line">$&#123;fn:length(list) &#125;&lt;br/&gt;&lt;!--<span class="number">1</span>--&gt;</span><br><span class="line">$&#123;fn:toLowerCase(<span class="string">"Hello"</span>) &#125;&lt;br/&gt; &lt;!-- hello --&gt;</span><br><span class="line">$&#123;fn:toUpperCase(<span class="string">"Hello"</span>) &#125;&lt;br/&gt; &lt;!-- HELLO --&gt;</span><br><span class="line">$&#123;fn:contains(<span class="string">"abc"</span>, <span class="string">"a"</span>)&#125;&lt;br/&gt;&lt;!-- <span class="keyword">true</span> --&gt;</span><br><span class="line">$&#123;fn:containsIgnoreCase(<span class="string">"abc"</span>, <span class="string">"Ab"</span>)&#125;&lt;br/&gt;&lt;!-- <span class="keyword">true</span> --&gt;</span><br><span class="line">$&#123;fn:contains(arr, <span class="string">"a"</span>)&#125;&lt;br/&gt;&lt;!-- <span class="keyword">true</span> --&gt;</span><br><span class="line">$&#123;fn:containsIgnoreCase(list, <span class="string">"A"</span>)&#125;&lt;br/&gt;&lt;!-- <span class="keyword">true</span> --&gt;</span><br><span class="line">$&#123;fn:endsWith(<span class="string">"Hello.java"</span>, <span class="string">".java"</span>)&#125;&lt;br/&gt;&lt;!-- <span class="keyword">true</span> --&gt;</span><br><span class="line">$&#123;fn:startsWith(<span class="string">"Hello.java"</span>, <span class="string">"Hell"</span>)&#125;&lt;br/&gt;&lt;!-- <span class="keyword">true</span> --&gt;</span><br><span class="line">$&#123;fn:indexOf(<span class="string">"Hello-World"</span>, <span class="string">"-"</span>)&#125;&lt;br/&gt;&lt;!-- <span class="number">5</span> --&gt;</span><br><span class="line">$&#123;fn:join(arr, <span class="string">";"</span>)&#125;&lt;br/&gt;&lt;!-- a;b;c --&gt;</span><br><span class="line">$&#123;fn:replace(<span class="string">"Hello-World"</span>, <span class="string">"-"</span>, <span class="string">"+"</span>)&#125;&lt;br/&gt;&lt;!-- Hello+World --&gt;</span><br><span class="line">$&#123;fn:join(fn:split(<span class="string">"a;b;c;"</span>, <span class="string">";"</span>), <span class="string">"-"</span>)&#125;&lt;br/&gt;&lt;!-- a-b-c --&gt;</span><br><span class="line"></span><br><span class="line">$&#123;fn:substring(<span class="string">"0123456789"</span>, <span class="number">6</span>, <span class="number">9</span>)&#125;&lt;br/&gt;&lt;!-- <span class="number">678</span> --&gt;</span><br><span class="line">$&#123;fn:substring(<span class="string">"0123456789"</span>, <span class="number">5</span>, -<span class="number">1</span>)&#125;&lt;br/&gt;&lt;!-- <span class="number">56789</span> --&gt;</span><br><span class="line">$&#123;fn:substringAfter(<span class="string">"Hello-World"</span>, <span class="string">"-"</span>)&#125;&lt;br/&gt;&lt;!-- World --&gt;</span><br><span class="line">$&#123;fn:substringBefore(<span class="string">"Hello-World"</span>, <span class="string">"-"</span>)&#125;&lt;br/&gt;&lt;!-- Hello --&gt;</span><br><span class="line">$&#123;fn:trim(<span class="string">"     a b c     "</span>)&#125;&lt;br/&gt;&lt;!-- a b c --&gt;</span><br><span class="line">$&#123;fn:escapeXml("&lt;html&gt;&lt;/html&gt;")&#125;&lt;br/&gt; &lt;!-- &lt;html&gt;&lt;/html&gt; --&gt;</span><br></pre></td></tr></table></figure><h4 id="自定义EL函数库"><a href="#自定义EL函数库" class="headerlink" title="自定义EL函数库"></a>自定义EL函数库</h4><ul><li><p>写一个类，写一个有返回值的静态方法；</p></li><li><p>编写itcast.tld文件，可以参数fn.tld文件来写，把itcast.tld文件放到/WEB-INF目录下；</p></li><li><p>在页面中添加taglib指令，导入自定义标签库。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ItcastFuncations.java</span></span><br><span class="line"><span class="keyword">package</span> cn.itcast.el.funcations;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItcastFuncations</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"自定义EL函数库测试"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>itcast.tld（放到classes下）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">taglib</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">version</span>=<span class="string">"2.0"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="tag">&lt;<span class="name">tlib-version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">tlib-version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">short-name</span>&gt;</span>itcast<span class="tag">&lt;/<span class="name">short-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">uri</span>&gt;</span>http://www.itcast.cn/jsp/functions<span class="tag">&lt;/<span class="name">uri</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">function</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>test<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">function-class</span>&gt;</span>cn.itcast.el.funcations.ItcastFuncations<span class="tag">&lt;/<span class="name">function-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">function-signature</span>&gt;</span>String test()<span class="tag">&lt;/<span class="name">function-signature</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">taglib</span>&gt;</span></span><br></pre></td></tr></table></figure><p>index.jsp</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> <span class="keyword">import</span>=<span class="string">"java.util.*"</span> pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br><span class="line">&lt;%@ taglib prefix=<span class="string">"itcast"</span> uri=<span class="string">"/WEB-INF/itcast.tld"</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt; </span><br><span class="line">  &lt;h1&gt;$&#123;itcast:test() &#125;&lt;/h1&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="Day-08"><a href="#Day-08" class="headerlink" title="Day 08"></a>Day 08</h2><p><em>02/07/2020</em></p><h3 id="JSTL-标签库"><a href="#JSTL-标签库" class="headerlink" title="JSTL 标签库"></a>JSTL 标签库</h3><h4 id="什么是JSTL"><a href="#什么是JSTL" class="headerlink" title="什么是JSTL"></a>什么是JSTL</h4><p>JSTL是apache对EL表达式的扩展（也就是说JSTL依赖EL），JSTL是标签语言！JSTL标签使用以来非常方便，它与JSP动作标签一定，只不过它不是JSP内置的标签，需要我们自己导包，以及指定标签库而已！</p><p>如果你使用MyEclipse开发JavaWeb，那么在把项目发布到Tomcat时，你会发现，MyEclipse会在lib目录下存放jstl的Jar包！如果你没有使用MyEclipse开发那么需要自己来导入这个JSTL的Jar包：jstl-1.2.jar。</p><h4 id="JSTL标签库"><a href="#JSTL标签库" class="headerlink" title="JSTL标签库"></a>JSTL标签库</h4><p>JSTL一共包含四大标签库：</p><ul><li><p>core：核心标签库，我们学习的重点；</p></li><li><p>fmt：格式化标签库，只需要学习两个标签即可；</p></li><li><p>sql：数据库标签库，不需要学习了，它过时了；</p></li><li><p>xml：xml标签库，不需要学习了，它过时了。</p></li></ul><h4 id="使用taglib指令导入标签库"><a href="#使用taglib指令导入标签库" class="headerlink" title="使用taglib指令导入标签库"></a>使用taglib指令导入标签库</h4><p>除了JSP动作标签外，使用其他第三方的标签库都需要：</p><ul><li><p>导包；</p></li><li><p>在使用标签的JSP页面中使用taglib指令导入标签库；</p></li></ul><p>下面是导入JSTL的core标签库：</p><p><code>&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;</code> <strong>这里的/jsp需要注意*</strong></p><ul><li><p><code>prefix=&quot;c&quot;</code>：指定标签库的前缀，这个前缀可以随便给值，但大家都会在使用core标签库时指定前缀为c；</p></li><li><p><code>uri=&quot;http://java.sun.com/jstl/core&quot;</code>：指定标签库的uri，它不一定是真实存在的网址，但它可以让JSP找到标签库的描述文件；</p></li></ul><h4 id="core标签库常用标签"><a href="#core标签库常用标签" class="headerlink" title="core标签库常用标签"></a>core标签库常用标签</h4><h5 id="out和set"><a href="#out和set" class="headerlink" title="out和set"></a>out和set</h5><p>out</p><table><thead><tr><th><code>&lt;c:out value=”aaa”/&gt;</code></th><th>输出aaa字符串常量</th></tr></thead><tbody><tr><td><code>&lt;c:out value=”${aaa}”/&gt;</code></td><td>与${aaa}相同</td></tr><tr><td><code>&lt;c:out value=”${aaa}” default=”xxx”/&gt;</code></td><td>当${aaa}不存在时，输出xxx字符串</td></tr><tr><td><code>&lt;%</code><br><code>request.setAttribute(&quot;a&quot;,&quot;&lt;script&gt;alert(&#39;hello&#39;);&lt;/script&gt;&quot;);</code><br><code>%&gt;</code> <br><code>&lt;c:out value=&quot;${a }&quot;  default=&quot;xxx&quot; escapeXml=&quot;false&quot; /&gt;</code></td><td>当escapeXml为false，不会转换“&lt;”、“&gt;”。这可能会受到JavaScript攻击。</td></tr></tbody></table><p>set</p><table><thead><tr><th><code>&lt;c:set var=”a” value=”hello”/&gt;</code></th><th>在pageContext中添加name为a，value为hello的数据。</th></tr></thead><tbody><tr><td><code>&lt;c:set var=”a” value=”hello” scope=”session”/&gt;</code></td><td>在session中添加name为a，value为hello的数据。</td></tr></tbody></table><h5 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h5><table><thead><tr><th><code>&lt;%</code><br><code>pageContext.setAttribute(&quot;a&quot;,  &quot;pageContext&quot;);</code><br><code>request.setAttribute(&quot;a&quot;,  &quot;session&quot;);</code><br><code>session.setAttribute(&quot;a&quot;,  &quot;session&quot;);</code><br><code>application.setAttribute(&quot;a&quot;,  &quot;application&quot;);</code><br><code>%&gt;</code><br><code>&lt;c:remove  var=&quot;a&quot;/&gt;</code><br><code>&lt;c:out  value=&quot;${a }&quot; default=&quot;none&quot;/&gt;</code></th><th>删除所有域中name为a的数据！</th></tr></thead><tbody><tr><td><code>&lt;c:remove var=&quot;a&quot; scope=”page”/&gt;</code></td><td>删除pageContext中name为a的数据！</td></tr></tbody></table><h5 id="url"><a href="#url" class="headerlink" title="url"></a>url</h5><p>url标签会在需要URL重写时添加sessionId。</p><table><thead><tr><th><code>&lt;c:url value=&quot;/&quot;/&gt;</code></th><th>输出上下文路径：/day08_01/</th></tr></thead><tbody><tr><td><code>&lt;c:url value=&quot;/&quot;  var=&quot;a&quot; scope=&quot;request&quot;/&gt;</code></td><td>把本该输出的结果赋给变量a。范围为request</td></tr><tr><td><code>&lt;c:url value=&quot;/AServlet&quot;/&gt;</code></td><td>输出：/day08_01/AServlet</td></tr><tr><td><code>&lt;c:url value=&quot;/AServlet&quot;&gt;</code><br>  <code>&lt;c:param name=&quot;username&quot;  value=&quot;abc&quot;/&gt;</code><br>  <code>&lt;c:param name=&quot;password&quot;  value=&quot;123&quot;/&gt;</code><br>  <code>&lt;/c:url&gt;</code></td><td>输出：/day08_01/AServlet?username=abc&amp;password=123  如果参数中包含中文，那么会自动使用URL编码！</td></tr></tbody></table><h5 id="if"><a href="#if" class="headerlink" title="if"></a>if</h5><p>if标签的test属性必须是一个boolean类型的值，如果test的值为true，那么执行if标签的内容，否则不执行。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:set <span class="keyword">var</span>=<span class="string">"a"</span> value=<span class="string">"hello"</span>/&gt;</span><br><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">"$&#123;not empty a &#125;"</span>&gt;</span><br><span class="line">&lt;c:out value=<span class="string">"$&#123;a &#125;"</span>/&gt;</span><br><span class="line">&lt;/c:if&gt;</span><br></pre></td></tr></table></figure><h5 id="choose"><a href="#choose" class="headerlink" title="choose"></a>choose</h5><p>choose标签对应Java中的if/else if/else结构。when标签的test为true时，会执行这个when的内容。当所有when标签的test都为false时，才会执行otherwise标签的内容。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:set <span class="keyword">var</span>=<span class="string">"score"</span> value=<span class="string">"$&#123;param.score &#125;"</span>/&gt;</span><br><span class="line">&lt;c:choose&gt;</span><br><span class="line">&lt;c:when test="$&#123;score &gt; 100 || score &lt; 0&#125;"&gt;错误的分数：$&#123;score &#125;&lt;/c:when&gt;</span><br><span class="line">&lt;c:when test="$&#123;score &gt;= 90 &#125;"&gt;A级&lt;/c:when&gt;</span><br><span class="line">&lt;c:when test="$&#123;score &gt;= 80 &#125;"&gt;B级&lt;/c:when&gt;</span><br><span class="line">&lt;c:when test="$&#123;score &gt;= 70 &#125;"&gt;C级&lt;/c:when&gt;</span><br><span class="line">&lt;c:when test="$&#123;score &gt;= 60 &#125;"&gt;D级&lt;/c:when&gt;</span><br><span class="line">&lt;c:otherwise&gt;E级&lt;/c:otherwise&gt;</span><br><span class="line">&lt;/c:choose&gt;</span><br></pre></td></tr></table></figure><h5 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h5><p>forEach当前就是循环标签了，forEach标签有多种两种使用方式：</p><ul><li><p>使用循环变量，指定开始和结束值，类似for(int i = 1; i &lt;= 10; i++) {}；</p></li><li><p>循环遍历集合，类似for(Object o : 集合)；</p></li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:set <span class="keyword">var</span>=<span class="string">"sum"</span> value=<span class="string">"0"</span> /&gt; </span><br><span class="line">&lt;c:forEach <span class="keyword">var</span>=<span class="string">"i"</span> begin=<span class="string">"1"</span> end=<span class="string">"10"</span> step=<span class="string">"2"</span>&gt; &lt;%--这里默认步长为<span class="number">1</span> 可设置为<span class="number">2</span>--%&gt;</span><br><span class="line">&lt;c:set <span class="keyword">var</span>=<span class="string">"sum"</span> value=<span class="string">"$&#123;sum + i&#125;"</span> /&gt; </span><br><span class="line">&lt;/c:forEach&gt;</span><br><span class="line">&lt;c:out value=<span class="string">"sum = $&#123;sum &#125;"</span>/&gt;</span><br></pre></td></tr></table></figure><p>遍历集合和数组</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">String[] names = &#123;<span class="string">"zhangSan"</span>, <span class="string">"liSi"</span>, <span class="string">"wangWu"</span>, <span class="string">"zhaoLiu"</span>&#125;;</span><br><span class="line">pageContext.setAttribute(<span class="string">"ns"</span>, names);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;c:forEach <span class="keyword">var</span>=<span class="string">"item"</span> items=<span class="string">"$&#123;ns &#125;"</span>&gt;</span><br><span class="line">&lt;c:out value=<span class="string">"name: $&#123;item &#125;"</span>/&gt;&lt;br/&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure><p>遍历list</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">names.add(<span class="string">"zhangSan"</span>);</span><br><span class="line">names.add(<span class="string">"liSi"</span>);</span><br><span class="line">names.add(<span class="string">"wangWu"</span>);</span><br><span class="line">names.add(<span class="string">"zhaoLiu"</span>);</span><br><span class="line">pageContext.setAttribute(<span class="string">"ns"</span>, names);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;c:forEach <span class="keyword">var</span>=<span class="string">"item"</span> items=<span class="string">"$&#123;ns &#125;"</span>&gt;</span><br><span class="line">&lt;c:out value=<span class="string">"name: $&#123;item &#125;"</span>/&gt;&lt;br/&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure><p>遍历map</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">Map&lt;String,String&gt; stu = <span class="keyword">new</span> LinkedHashMap&lt;String,String&gt;();</span><br><span class="line">stu.put(<span class="string">"number"</span>, <span class="string">"N_1001"</span>);</span><br><span class="line">stu.put(<span class="string">"name"</span>, <span class="string">"zhangSan"</span>);</span><br><span class="line">stu.put(<span class="string">"age"</span>, <span class="string">"23"</span>);</span><br><span class="line">stu.put(<span class="string">"sex"</span>, <span class="string">"male"</span>);</span><br><span class="line">pageContext.setAttribute(<span class="string">"stu"</span>, stu);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;c:forEach <span class="keyword">var</span>=<span class="string">"item"</span> items=<span class="string">"$&#123;stu &#125;"</span>&gt;</span><br><span class="line">&lt;c:out value=<span class="string">"$&#123;item.key &#125;: $&#123;item.value &#125;"</span>/&gt;&lt;br/&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure><p>forEach标签还有一个属性：varStatus，这个属性用来指定接收“循环状态”的变量名，例如：<code>&lt;forEach varStatus=”vs” …/&gt;</code>，这时就可以使用vs这个变量来获取循环的状态了。</p><ul><li><p>count：int类型，当前以遍历元素的个数；</p></li><li><p>index：int类型，当前元素的下标；</p></li><li><p>first：boolean类型，是否为第一个元素；</p></li><li><p>last：boolean类型，是否为最后一个元素；</p></li><li><p>current：Object类型，表示当前项目。</p></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:forEach <span class="keyword">var</span>=<span class="string">"item"</span> items=<span class="string">"$&#123;ns &#125;"</span> varStatus=<span class="string">"vs"</span>&gt;</span><br><span class="line">&lt;c:if test="$&#123;vs.first &#125;"&gt;第一行：&lt;/c:if&gt;</span><br><span class="line">&lt;c:if test="$&#123;vs.last &#125;"&gt;最后一行：&lt;/c:if&gt;</span><br><span class="line">&lt;c:out value=<span class="string">"第$&#123;vs.count &#125;行: "</span>/&gt;</span><br><span class="line">&lt;c:out value=<span class="string">"[$&#123;vs.index &#125;]: "</span>/&gt;</span><br><span class="line">&lt;c:out value=<span class="string">"name: $&#123;vs.current &#125;"</span>/&gt;&lt;br/&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure><h4 id="fmt标签库常用标签"><a href="#fmt标签库常用标签" class="headerlink" title="fmt标签库常用标签"></a>fmt标签库常用标签</h4><p>fmt标签库是用来格式化输出的，通常需要格式化的有时间和数字。</p><p>格式化时间：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">"fmt"</span> uri=<span class="string">"http://java.sun.com/jsp/jstl/fmt"</span> %&gt;</span><br><span class="line">......</span><br><span class="line">&lt;%</span><br><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">pageContext.setAttribute(<span class="string">"d"</span>, date);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;fmt:formatDate value=<span class="string">"$&#123;d &#125;"</span> pattern=<span class="string">"yyyy-MM-dd HH:mm:ss"</span>/&gt;</span><br></pre></td></tr></table></figure><p>格式化数字：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line"><span class="keyword">double</span> d1 = <span class="number">3.5</span>;</span><br><span class="line"><span class="keyword">double</span> d2 = <span class="number">4.4</span>; </span><br><span class="line">pageContext.setAttribute(<span class="string">"d1"</span>, d1);</span><br><span class="line">pageContext.setAttribute(<span class="string">"d2"</span>, d2);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;fmt:formatNumber value=<span class="string">"$&#123;d1 &#125;"</span> pattern=<span class="string">"0.00"</span>/&gt;&lt;br/&gt;</span><br><span class="line">&lt;fmt:formatNumber value=<span class="string">"$&#123;d2 &#125;"</span> pattern=<span class="string">"#.##"</span>/&gt;</span><br></pre></td></tr></table></figure><h3 id="自定义标签"><a href="#自定义标签" class="headerlink" title="自定义标签"></a>自定义标签</h3><h4 id="自定义标签概述"><a href="#自定义标签概述" class="headerlink" title="自定义标签概述"></a>自定义标签概述</h4><h5 id="自定义标签的步骤"><a href="#自定义标签的步骤" class="headerlink" title="自定义标签的步骤"></a>自定义标签的步骤</h5><p>其实我们在JSP页面中使用标签就等于调用某个对象的某个方法一样，例如：&lt;c:if test=””&gt;，这就是在调用对象的方法一样。自定义标签其实就是自定义类一样！</p><ul><li><p>定义标签处理类：必须是Tag或SimpleTag的实现类；</p></li><li><p>编写标签库描述符文件（TLD）；</p></li></ul><p>SimpleTag接口是JSP2.0中新给出的接口，用来简化自定义标签，所以现在我们基本上都是使用SimpleTag。</p><p>Tag是老的，传统的自定义标签时使用的接口，现在不建议使用它了。</p><h5 id="SimpleTag接口介绍"><a href="#SimpleTag接口介绍" class="headerlink" title="SimpleTag接口介绍"></a>SimpleTag接口介绍</h5><p>SimpleTag接口内容如下：</p><ul><li><p>void doTag()：标签执行方法；</p></li><li><p>JspTag getParent()：获取父标签；</p></li><li><p>void setParent(JspTag parent)：设置父标签</p></li><li><p>void setJspContext(JspContext context)：设置PageContext</p></li><li><p>void setJspBody(JspFragment jspBody)：设置标签体对象；</p></li></ul><p>请记住，万物皆对象！在JSP页面中的标签也是对象！你可以通过查看JSP的“真身”清楚的知道，所有标签都会变成对象的方法调用。标签对应的类我们称之为“标签处理类”！</p><p>标签的生命周期：</p><ol><li><p>当容器（Tomcat）第一次执行到某个标签时，会创建标签处理类的实例；</p></li><li><p>然后调用setJspContext(JspContext)方法，把当前JSP页面的pageContext对象传递给这个方法；</p></li><li><p>如果当前标签有父标签，那么使用父标签的标签处理类对象调用setParent(JspTag)方法；</p></li><li><p>如果标签有标签体，那么把标签体转换成JspFragment对象，然后调用setJspBody()方法；</p></li><li><p>每次执行标签时，都调用doTag()方法，它是标签处理方法。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HelloTag.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloTag</span> <span class="keyword">implements</span> <span class="title">SimpleTag</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> JspTag parent;</span><br><span class="line"><span class="keyword">private</span> PageContext pageContext;</span><br><span class="line"><span class="keyword">private</span> JspFragment jspBody;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTag</span><span class="params">()</span> <span class="keyword">throws</span> JspException, IOException </span>&#123;</span><br><span class="line">pageContext.getOut().print(<span class="string">"Hello Tag!!!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParent</span><span class="params">(JspTag parent)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.parent = parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> JspTag <span class="title">getParent</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setJspContext</span><span class="params">(JspContext pc)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.pageContext = (PageContext) pc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setJspBody</span><span class="params">(JspFragment jspBody)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.jspBody = jspBody;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="标签库描述文件（TLD）"><a href="#标签库描述文件（TLD）" class="headerlink" title="标签库描述文件（TLD）"></a>标签库描述文件（TLD）</h5><p>标签库描述文件是用来描述当前标签库中的标签的！标签库描述文件的扩展名为tld，你可以把它放到WEB-INF下，这样就不会被客户端直接访问到了。</p><p>hello.tld</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">taglib</span> <span class="attr">version</span>=<span class="string">"2.0"</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xml</span>=<span class="string">"http://www.w3.org/XML/1998/namespace"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee </span></span></span><br><span class="line"><span class="tag"><span class="string">http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd "</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">tlib-version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">tlib-version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">short-name</span>&gt;</span>itcast<span class="tag">&lt;/<span class="name">short-name</span>&gt;</span> <span class="comment">&lt;!--简称--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uri</span>&gt;</span>http://www.itcast.cn/tags<span class="tag">&lt;/<span class="name">uri</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tag</span>&gt;</span><span class="comment">&lt;!--一个tag代表一个标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tag-class</span>&gt;</span>cn.itcast.tag.HelloTag<span class="tag">&lt;/<span class="name">tag-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body-content</span>&gt;</span>empty<span class="tag">&lt;/<span class="name">body-content</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tag</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">taglib</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="使用标签"><a href="#使用标签" class="headerlink" title="使用标签"></a>使用标签</h5><p>在页面中使用标签分为两步：</p><ul><li><p>使用taglib导入标签库；</p></li><li><p>使用标签；</p></li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">"it"</span> uri=<span class="string">"/WEB-INF/hello.tld"</span> %&gt;</span><br><span class="line">......</span><br><span class="line">&lt;it:hello/&gt;</span><br></pre></td></tr></table></figure><h4 id="自定义标签进阶"><a href="#自定义标签进阶" class="headerlink" title="自定义标签进阶"></a>自定义标签进阶</h4><h5 id="继承SimpleTagSupport"><a href="#继承SimpleTagSupport" class="headerlink" title="继承SimpleTagSupport"></a>继承SimpleTagSupport</h5><p>继承SimpleTagSuppport要比实现SimpleTag接口方便太多了，现在你只需要重写doTag()方法，其他方法都已经被SimpleTagSuppport完成了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloTag</span> <span class="keyword">extends</span> <span class="title">SimpleTagSupport</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTag</span><span class="params">()</span> <span class="keyword">throws</span> JspException, IOException </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.getJspContext().getOut().write(<span class="string">"&lt;p&gt;Hello SimpleTag!&lt;/p&gt;"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="有标签体的标签"><a href="#有标签体的标签" class="headerlink" title="有标签体的标签"></a>有标签体的标签</h5><p>我们先来看看标签体内容的可选值：</p><p><code>&lt;body-content&gt;</code>元素的可选值有：</p><ul><li><p>empty：无标签体。</p></li><li><p>JSP：传统标签支持它，SimpleTag已经不再支持使用<code>&lt;body-content&gt;JSP&lt;/body-content&gt;</code>。标签体内容可以是任何东西：EL、JSTL、&lt;%=%&gt;、&lt;%%&gt;，以及html； </p></li><li><p>scriptless：标签体内容不能是Java脚本，但可以是EL、JSTL等。在SimpleTag中，如果需要有标签体，那么就使用该选项；</p></li><li><p>tagdependent：标签体内容不做运算，由标签处理类自行处理，无论标签体内容是EL、JSP、JSTL，都不会做运算。<strong>这个选项几乎没有人会使用！</strong></p></li></ul><p>自定义有标签体的标签需要：</p><ul><li><p>获取标签体对象：JspFragment jspBody = getJspBody();；</p></li><li><p>把标签体内容输出到页面：jspBody.invoke(null)；</p></li><li><p>tld中指定标签内容类型：scriptless。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloTag</span> <span class="keyword">extends</span> <span class="title">SimpleTagSupport</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTag</span><span class="params">()</span> <span class="keyword">throws</span> JspException, IOException </span>&#123;</span><br><span class="line">PageContext pc = (PageContext) <span class="keyword">this</span>.getJspContext();</span><br><span class="line">HttpServletRequest req = (HttpServletRequest) pc.getRequest();</span><br><span class="line">String s = req.getParameter(<span class="string">"exec"</span>);</span><br><span class="line"><span class="keyword">if</span>(s != <span class="keyword">null</span> &amp;&amp; s.endsWith(<span class="string">"true"</span>)) &#123;</span><br><span class="line">JspFragment body = <span class="keyword">this</span>.getJspBody(); <span class="comment">// 获取标签体对象</span></span><br><span class="line">body.invoke(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tag</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tag-class</span>&gt;</span>cn.itcast.tags.HelloTag<span class="tag">&lt;/<span class="name">tag-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body-content</span>&gt;</span>scriptless<span class="tag">&lt;/<span class="name">body-content</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tag</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;itcast:hello&gt;</span><br><span class="line">    &lt;h1&gt;哈哈哈~&lt;/h1&gt;</span><br><span class="line">&lt;/itcast:hello&gt;</span><br></pre></td></tr></table></figure><h5 id="不执行标签下面的页面内容"><a href="#不执行标签下面的页面内容" class="headerlink" title="不执行标签下面的页面内容"></a>不执行标签下面的页面内容</h5><p>如果希望在执行了自定义标签后，不再执行JSP页面下面的东西，那么就需要在doTag()方法中使用SkipPageException。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SkipTag</span> <span class="keyword">extends</span> <span class="title">SimpleTagSupport</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTag</span><span class="params">()</span> <span class="keyword">throws</span> JspException, IOException </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.getJspContext().getOut().print(<span class="string">"&lt;h1&gt;只能看到我！&lt;/h1&gt;"</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> SkipPageException();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tag</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>skip<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tag-class</span>&gt;</span>cn.itcast.tags.SkipTag<span class="tag">&lt;/<span class="name">tag-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body-content</span>&gt;</span>empty<span class="tag">&lt;/<span class="name">body-content</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tag</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;itcast:skip/&gt;</span><br><span class="line">&lt;h1&gt;看不见我！&lt;/h1&gt;</span><br></pre></td></tr></table></figure><h5 id="带有属性的标签"><a href="#带有属性的标签" class="headerlink" title="带有属性的标签"></a>带有属性的标签</h5><p>一般标签都会带有属性，例如<code>&lt;c:if test=””&gt;</code>，其中test就是一个boolean类型的属性。完成带有属性的标签需要：</p><ul><li><p>在处理类中给出JavaBean属性（提供get/set方法）；</p></li><li><p>在TLD中部属相关属性。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IfTag</span> <span class="keyword">extends</span> <span class="title">SimpleTagSupport</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> test;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> test;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTest</span><span class="params">(<span class="keyword">boolean</span> test)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.test = test;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTag</span><span class="params">()</span> <span class="keyword">throws</span> JspException, IOException </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(test) &#123;</span><br><span class="line"><span class="keyword">this</span>.getJspBody().invoke(<span class="keyword">null</span>); <span class="comment">// 执行标签内容</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tag</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>if<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">tag-class</span>&gt;</span>cn.itcast.tag.IfTag<span class="tag">&lt;/<span class="name">tag-class</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">body-content</span>&gt;</span>scriptless<span class="tag">&lt;/<span class="name">body-content</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attribute</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>test<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">required</span>&gt;</span>true<span class="tag">&lt;/<span class="name">required</span>&gt;</span><span class="comment">&lt;!--属性必须--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rtexprvalue</span>&gt;</span>true<span class="tag">&lt;/<span class="name">rtexprvalue</span>&gt;</span><span class="comment">&lt;!--可为EL或JSTL 否则只为常量--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">attribute</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">tag</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">pageContext.setAttribute(<span class="string">"one"</span>, <span class="keyword">true</span>);</span><br><span class="line">pageContext.setAttribute(<span class="string">"two"</span>, <span class="keyword">false</span>);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;it:if test="$&#123;one &#125;"&gt;xixi&lt;/it:if&gt;</span><br><span class="line">&lt;it:if test="$&#123;two &#125;"&gt;haha&lt;/it:if&gt;</span><br><span class="line">&lt;it:if test="true"&gt;hehe&lt;/it:if&gt;</span><br></pre></td></tr></table></figure><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><h4 id="MVC设计模式"><a href="#MVC设计模式" class="headerlink" title="MVC设计模式"></a>MVC设计模式</h4><p><img src="https://i.loli.net/2020/07/02/tCNjacl82GwU5v6.png" alt="2.png"></p><p>MVC模式（Model-View-Controller）是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。</p><p>MVC模式最早为Trygve Reenskaug)提出，为施乐帕罗奥多研究中心（Xerox PARC）的Smalltalk语言发明的一种软件设计模式。</p><p>MVC可对程序的后期维护和扩展提供了方便，并且使程序某些部分的重用提供了方便。而且MVC也使程序简化，更加直观。</p><ul><li><p>控制器Controller：对请求进行处理，负责请求转发；</p></li><li><p>视图View：界面设计人员进行图形界面设计；</p></li><li><p>模型Model：程序编写程序应用的功能（实现算法等等）、数据库管理；</p></li></ul><p>注意，MVC不是Java的东西，几乎现在所有B/S结构的软件都采用了MVC设计模式。但是要注意，MVC在B/S结构软件并没有完全实现，例如在我们今后的B/S软件中并不会有事件驱动！</p><h4 id="JavaWeb与MVC"><a href="#JavaWeb与MVC" class="headerlink" title="JavaWeb与MVC"></a>JavaWeb与MVC</h4><p>JavaWeb的经历了JSP Model1、JSP Model1二代、JSP Model2三个时期。</p><h5 id="JSP-Model1第一代"><a href="#JSP-Model1第一代" class="headerlink" title="JSP Model1第一代"></a>JSP Model1第一代</h5><p>JSP Model1是JavaWeb早期的模型，它适合小型Web项目，开发成本低！Model1第一代时期，服务器端只有JSP页面，所有的操作都在JSP页面中，连访问数据库的API也在JSP页面中完成。也就是说，所有的东西都耦合在一起，对后期的维护和扩展极为不利。</p><h5 id="JSP-Model1第二代"><a href="#JSP-Model1第二代" class="headerlink" title="JSP Model1第二代"></a>JSP Model1第二代</h5><p>JSP Model1第二代有所改进，把业务逻辑的内容放到了JavaBean中，而JSP页面负责显示以及请求调度的工作。虽然第二代比第一代好了些，但还让JSP做了过多的工作，JSP中把视图工作和请求调度（控制器）的工作耦合在一起了。</p><h5 id="JSP-Model2"><a href="#JSP-Model2" class="headerlink" title="JSP Model2"></a>JSP Model2</h5><p>JSP Model2模式已经可以清晰的看到MVC完整的结构了。</p><ul><li><p>JSP：视图层，用来与用户打交道。负责接收用来的数据，以及显示数据给用户；</p></li><li><p>Servlet：控制层，负责找到合适的模型对象来处理业务逻辑，转发到合适的视图；</p></li><li><p>JavaBean：模型层，完成具体的业务工作，例如：开启、转账等。</p></li></ul><p><img src="https://i.loli.net/2020/07/02/rW3h8gzknvsJeU1.png" alt="2.png"></p><p>JSP Model2适合多人合作开发大型的Web项目，各司其职，互不干涉，有利于开发中的分工，有利于组件的重用。但是，Web项目的开发难度加大，同时对开发人员的技术要求也提高了。</p><h3 id="JavaWeb三层框架"><a href="#JavaWeb三层框架" class="headerlink" title="JavaWeb三层框架"></a>JavaWeb三层框架</h3><p>我们常说的三层框架是由JavaWeb提出的，也就是说这是JavaWeb独有的！</p><p>所谓三层是表述层（WEB层）、业务逻辑层（Business Logic），以及数据访问层（Data Access）。</p><ul><li><p>WEB（表述）层：包含JSP和Servlet等与WEB相关的内容；</p></li><li><p>业务逻辑层：业务层中不包含JavaWeb API，它只关心业务逻辑，它对应功能；</p></li><li><p>数据访问层：封装了对数据库的访问细节；</p></li></ul><p>注意，在业务层中不能出现JavaWeb API，例如request、response等。也就是说，业务层代码是可重用的，甚至可以应用到非Web环境中。业务层的每个方法可以理解成一个万能，例如转账业务方法。业务层依赖数据层，而Web层依赖业务层！</p><p><img src="https://i.loli.net/2020/07/02/47i2GSkRPLAW3YB.png" alt="2.png"></p><hr><h2 id="Day-09"><a href="#Day-09" class="headerlink" title="Day 09"></a>Day 09</h2><p><em>03/07/2020</em></p><h3 id="案例-用户注册登录"><a href="#案例-用户注册登录" class="headerlink" title="案例 用户注册登录"></a>案例 用户注册登录</h3><p>要求：3层框架，使用验证码</p><h4 id="功能分析"><a href="#功能分析" class="headerlink" title="功能分析"></a>功能分析</h4><ul><li><p>注册</p></li><li><p>登录</p></li></ul><h5 id="JSP页面"><a href="#JSP页面" class="headerlink" title="JSP页面"></a>JSP页面</h5><ul><li><p>regist.jsp</p><ul><li>注册表单：用户输入注册信息；</li><li>回显错误信息：当注册失败时，显示错误信息；</li></ul></li><li><p>login.jsp</p><ul><li>登录表单：用户输入登录信息；</li><li>回显错误信息：当登录失败时，显示错误信息；</li></ul></li><li><p>index.jsp</p><ul><li>用户已登录：显示当前用户名，以及“退出”链接；</li><li>用户未登录：显示“您还没有登录”；</li></ul></li></ul><h5 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h5><p>User：</p><ul><li><p>String username；</p></li><li><p>String password；</p></li></ul><h5 id="Servlet-1"><a href="#Servlet-1" class="headerlink" title="Servlet"></a>Servlet</h5><ul><li><p>VerifyCodeServlet</p><ul><li>生成验证码；</li><li>在session中保存验证码文本；</li><li>把图片输出到页面</li></ul></li><li><p>RegistServlet</p><ul><li><p>获取用户名、密码，封装到User对象中；</p></li><li><p>获取验证码、获取确认密码；</p></li><li><p>校验用户名、密码、验证码不能为空，校验失败，向request中保存错误信息，转发回regist.jsp显示错误信息；</p></li><li><p>比较两次输入的错误是否一致，如果不一致，向request中保存错误信息，转发回regist.jsp显示错误信息；</p></li><li><p>获取session中的验证码，与表单输入的验证码比较，如果不一致，向request中保存错误信息，转发回regist.jsp显示错误信息；</p></li><li><p>使用UserService的regist()方法完成注册，如果注册失败，向request中保存错误信息，转发回regist.jsp显示错误信息，如果注册成功，转发到login.jsp页面，表示注册成功；</p></li></ul></li><li><p>LoginServlet</p><ul><li><p>获取用户名、密码、验证码；</p></li><li><p>校验用户名、密码、验证码是否为空，校验失败，向request中保存错误信息，转发回login.jsp显示错误信息；</p></li><li><p>获取session中的验证码，与表单中的验证码比较，如果不同，向request中保存错误信息，转发回login.jsp显示错误信息；</p></li><li><p>删除session中的验证码；</p></li><li><p>通过UserService的login()方法完成登录，如果抛出异常，获取异常信息，保存到request中，转发到login.jsp显示错误信息；</p></li><li><p>向session中保存当前用户对象；</p></li><li><p>转发到index.jsp页面，表示登录成功！</p></li></ul></li><li><p>QuitServlet</p><ul><li><p>获取session，销毁之；</p></li><li><p>重定向到index.jsp；</p></li></ul></li></ul><h5 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h5><p>UserException：为UserService使用的异常类；</p><p>UserService：</p><ul><li><p>void regist(User user)：</p><ul><li><p>使用UserDao的findByUsername()方法查询名为user.getUsername()的用户，如果用户存在，说明用户名已经被注册，抛出异常；</p></li><li><p>使用UserDao的add(User)方法保存用户信息；</p></li></ul></li><li><p>User login(String username, String password)：</p><ul><li><p>使用UserDao的findByUsername()方法查询名为user.getUsername()的用户，如果用户不存在，说明用户名错误，抛出异常；</p></li><li><p>如果查询到了User，那么比较参数password与user.getPassword()是否相等，如果不等，说明密码错误，抛出异常；</p></li><li><p>如果一致，表示登录成功，返回User对象；</p></li></ul></li></ul><h5 id="DAO"><a href="#DAO" class="headerlink" title="DAO"></a>DAO</h5><p>UserDao：</p><ul><li><p>void add(User)：</p><ul><li><p>创建SAXReader对象，获取Document对象，再获取根元素；</p></li><li><p>给root元素添加子元素；</p></li><li><p>给子元素设置username属性，值为user.getUsername()；</p></li><li><p>给子元素设置password属性，值为user.getPassword()；</p></li><li><p>创建OutputFormat对象，指定缩进为“\t”，指定添加换行；</p></li><li><p>设置OutputFormat清空原有空白；</p></li><li><p>使用FileWrtier和OutputFormat创建XMLWriter对象；</p></li><li><p>使用XMLWriter对象的write()保存Document；</p></li><li><p>关闭XMLWriter对象；</p></li></ul></li><li><p>User findByUsername(String username)：</p><ul><li><p>创建SAXReader对象，获取Document对象；</p></li><li><p>使用Xpath（//user[username=’xxx’]）来查询元素；</p></li><li><p>如果元素没有查询到，返回null；</p></li><li><p>如果元素查询到了，那么创建User对象；</p></li><li><p>把元素的username属性赋给User的username属性；</p></li><li><p>把元素的password属性赋给User的password属性；</p></li><li><p>返回user对象；</p></li></ul></li></ul><h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><h5 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h5><ul><li><p>用户在浏览器地址栏中请求regist.jsp；</p></li><li><p>服务器发送html给浏览器；</p></li><li><p>浏览器收到html，开始解析，并显示；</p></li><li><p>解析到<code>&lt;img&gt;</code>时，请求VerifyCodeServlet；</p></li><li><p>VerifyCodeServlet生成验证码图片，保存验证码文本，把图片响应给浏览器；</p></li><li><p>浏览器显示在页面中显示图片。</p></li></ul><p><img src="https://i.loli.net/2020/07/03/YzSxaTW74DgGftM.png" alt="2.png"></p><p><img src="https://i.loli.net/2020/07/03/DTSVv3xPeZFXInH.png" alt="2.png"></p><h5 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h5><p>省略。。。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>login.jsp</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;登录&lt;/h1&gt;</span><br><span class="line">    &lt;hr/&gt;</span><br><span class="line">    &lt;p style="font-weight: 900; color: red;"&gt;$&#123;msg &#125;&lt;/p&gt;</span><br><span class="line">    &lt;form action=<span class="string">"&lt;c:url value='/LoginServlet'/&gt;"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">        用户名：&lt;input type=<span class="string">"text"</span> name=<span class="string">"username"</span> value=<span class="string">"$&#123;user.username &#125;"</span> /&gt;&lt;br/&gt;</span><br><span class="line">        密　码：&lt;input type=<span class="string">"password"</span> name=<span class="string">"password"</span>/&gt;&lt;br/&gt;</span><br><span class="line">        验证码：&lt;input type=<span class="string">"text"</span> name=<span class="string">"loginCode"</span> size=<span class="string">"2"</span>/&gt;</span><br><span class="line">        &lt;img id=<span class="string">"vCode"</span> src=<span class="string">"&lt;c:url value='/VerifyCodeServlet?name=loginCode'/&gt;"</span> border=<span class="string">"2"</span>/&gt;</span><br><span class="line">        &lt;a href="javascript:_change()" style="font-size: 12;"&gt;看不清，换一张&lt;/a&gt;&lt;br/&gt;</span><br><span class="line">        &lt;input type=<span class="string">"submit"</span> value=<span class="string">"登录"</span>/&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;!-------------------------------------------&gt;</span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="function">function <span class="title">_change</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> img = document.getElementById(<span class="string">"vCode"</span>);</span><br><span class="line">        img.src = <span class="string">"&lt;c:url value='/VerifyCodeServlet?name=loginCode&amp;'/&gt;"</span> + <span class="keyword">new</span> Date().getTime();</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>regist.jsp</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;注册&lt;/h1&gt;</span><br><span class="line">    &lt;hr/&gt;</span><br><span class="line">    &lt;p style="font-weight: 900; color: red;"&gt;$&#123;msg &#125;&lt;/p&gt;</span><br><span class="line">    &lt;form action=<span class="string">"&lt;c:url value='/RegistServlet'/&gt;"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">        用户名：&lt;input type=<span class="string">"text"</span> name=<span class="string">"username"</span> value=<span class="string">"$&#123;user.username &#125;"</span> /&gt;&lt;br/&gt;</span><br><span class="line">        密　码：&lt;input type=<span class="string">"password"</span> name=<span class="string">"password"</span>/&gt;&lt;br/&gt;</span><br><span class="line">        确认密码：&lt;input type=<span class="string">"password"</span> name=<span class="string">"repassword"</span>/&gt;&lt;br/&gt;</span><br><span class="line">        验证码：&lt;input type=<span class="string">"text"</span> name=<span class="string">"registCode"</span> size=<span class="string">"2"</span>/&gt;</span><br><span class="line">        &lt;img id=<span class="string">"vCode"</span> src=<span class="string">"&lt;c:url value='/VerifyCodeServlet?name=registCode'/&gt;"</span> border=<span class="string">"2"</span>/&gt;</span><br><span class="line">        &lt;a href="javascript:_change()" style="font-size: 12;"&gt;看不清，换一张&lt;/a&gt;&lt;br/&gt;</span><br><span class="line">        &lt;input type=<span class="string">"submit"</span> value=<span class="string">"注册"</span>/&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;!----------------------------------------------------------------------&gt;</span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="function">function <span class="title">_change</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> img = document.getElementById(<span class="string">"vCode"</span>);</span><br><span class="line">        img.src = <span class="string">"&lt;c:url value='/VerifyCodeServlet?name=registCode&amp;'/&gt;"</span> + <span class="keyword">new</span> Date().getTime();</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>index.jsp</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;主页&lt;/h1&gt;</span><br><span class="line">    &lt;hr/&gt;</span><br><span class="line">    &lt;c:choose&gt;</span><br><span class="line">        &lt;c:when test=<span class="string">"$&#123;empty sessionScope.user &#125;"</span>&gt;</span><br><span class="line">            您还没有登录</span><br><span class="line">        &lt;/c:when&gt;</span><br><span class="line">        &lt;c:otherwise&gt;</span><br><span class="line">            用户名：$&#123;sessionScope.user.username &#125;</span><br><span class="line">            &lt;a href="&lt;c:url value='/QuitServlet'/&gt;"&gt;退出&lt;/a&gt;</span><br><span class="line">        &lt;/c:otherwise&gt;</span><br><span class="line">    &lt;/c:choose&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// VerifyCodeServlet.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VerifyCodeServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String name = request.getParameter(<span class="string">"name"</span>);</span><br><span class="line"></span><br><span class="line">        VerifyCode vc = <span class="keyword">new</span> VerifyCode();<span class="comment">//创建验证码类</span></span><br><span class="line">        BufferedImage image  = vc.getImage();<span class="comment">//创建验证码图片</span></span><br><span class="line">        request.getSession().setAttribute(name, vc.getText());<span class="comment">//获取验证码文本</span></span><br><span class="line">        System.out.println(vc.getText());</span><br><span class="line">        VerifyCode.output(image, response.getOutputStream());<span class="comment">//输出图片到页面</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RegistServlet.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegistServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">request.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line">response.setContentType(<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line"></span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">BeanUtils.populate(user, request.getParameterMap());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">&#125;</span><br><span class="line">String loginCode = request.getParameter(<span class="string">"registCode"</span>);</span><br><span class="line">String repassword = request.getParameter(<span class="string">"repassword"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(user.getUsername() == <span class="keyword">null</span> || user.getUsername().trim().isEmpty()) &#123;</span><br><span class="line">request.setAttribute(<span class="string">"msg"</span>, <span class="string">"用户名不能为空!"</span>);</span><br><span class="line">request.setAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">request.getRequestDispatcher(<span class="string">"/regist.jsp"</span>).forward(request, response);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(user.getPassword() == <span class="keyword">null</span> || user.getPassword().trim().isEmpty()) &#123;</span><br><span class="line">request.setAttribute(<span class="string">"msg"</span>, <span class="string">"密码不能为空!"</span>);</span><br><span class="line">request.setAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">request.getRequestDispatcher(<span class="string">"/regist.jsp"</span>).forward(request, response);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!user.getPassword().equals(repassword)) &#123;</span><br><span class="line">request.setAttribute(<span class="string">"msg"</span>, <span class="string">"两次输入不一致！"</span>);</span><br><span class="line">request.setAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">request.getRequestDispatcher(<span class="string">"/regist.jsp"</span>).forward(request, response);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(loginCode == <span class="keyword">null</span> || loginCode.trim().isEmpty()) &#123;</span><br><span class="line">request.setAttribute(<span class="string">"msg"</span>, <span class="string">"验证码不能为空！"</span>);</span><br><span class="line">request.setAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">request.getRequestDispatcher(<span class="string">"/regist.jsp"</span>).forward(request, response);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String vCode = (String)request.getSession().getAttribute(<span class="string">"registCode"</span>);</span><br><span class="line">request.getSession().removeAttribute(<span class="string">"registCode"</span>);</span><br><span class="line"><span class="keyword">if</span>(!vCode.equalsIgnoreCase(loginCode)) &#123;</span><br><span class="line">request.setAttribute(<span class="string">"msg"</span>, <span class="string">"验证码错误！"</span>);</span><br><span class="line">request.setAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">request.getRequestDispatcher(<span class="string">"/regist.jsp"</span>).forward(request, response);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UserService userService = <span class="keyword">new</span> UserService();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">userService.regist(user);</span><br><span class="line">request.getRequestDispatcher(<span class="string">"/login.jsp"</span>).forward(request, response);</span><br><span class="line">&#125; <span class="keyword">catch</span> (UserException e) &#123;</span><br><span class="line">request.setAttribute(<span class="string">"msg"</span>, e.getMessage());</span><br><span class="line">request.setAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">request.getRequestDispatcher(<span class="string">"/regist.jsp"</span>).forward(request, response);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LoginServlet.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">request.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line">response.setContentType(<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line"></span><br><span class="line">String username = request.getParameter(<span class="string">"username"</span>);</span><br><span class="line">String password = request.getParameter(<span class="string">"password"</span>);</span><br><span class="line">String loginCode = request.getParameter(<span class="string">"loginCode"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(username == <span class="keyword">null</span> || username.trim().isEmpty()) &#123;</span><br><span class="line">request.setAttribute(<span class="string">"msg"</span>, <span class="string">"用户名不能为空!"</span>);</span><br><span class="line">request.setAttribute(<span class="string">"username"</span>, username);</span><br><span class="line">request.getRequestDispatcher(<span class="string">"/login.jsp"</span>).forward(request, response);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(password == <span class="keyword">null</span> || password.trim().isEmpty()) &#123;</span><br><span class="line">request.setAttribute(<span class="string">"msg"</span>, <span class="string">"密码不能为空!"</span>);</span><br><span class="line">request.setAttribute(<span class="string">"username"</span>, username);</span><br><span class="line">request.getRequestDispatcher(<span class="string">"/login.jsp"</span>).forward(request, response);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(loginCode == <span class="keyword">null</span> || loginCode.trim().isEmpty()) &#123;</span><br><span class="line">request.setAttribute(<span class="string">"msg"</span>, <span class="string">"验证码不能为空！"</span>);</span><br><span class="line">request.setAttribute(<span class="string">"username"</span>, username);</span><br><span class="line">request.getRequestDispatcher(<span class="string">"/login.jsp"</span>).forward(request, response);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String vCode = (String)request.getSession().getAttribute(<span class="string">"loginCode"</span>);</span><br><span class="line">request.getSession().removeAttribute(<span class="string">"loginCode"</span>);</span><br><span class="line"><span class="keyword">if</span>(!vCode.equalsIgnoreCase(loginCode)) &#123;</span><br><span class="line">request.setAttribute(<span class="string">"msg"</span>, <span class="string">"验证码错误！"</span>);</span><br><span class="line">request.setAttribute(<span class="string">"username"</span>, username);</span><br><span class="line">request.getRequestDispatcher(<span class="string">"/login.jsp"</span>).forward(request, response);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UserService userService = <span class="keyword">new</span> UserService();</span><br><span class="line">User user;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">user = userService.login(username, password);</span><br><span class="line">&#125; <span class="keyword">catch</span> (UserException e) &#123;</span><br><span class="line">request.setAttribute(<span class="string">"msg"</span>, e.getMessage());</span><br><span class="line">request.setAttribute(<span class="string">"username"</span>, username);</span><br><span class="line">request.getRequestDispatcher(<span class="string">"/login.jsp"</span>).forward(request, response);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">request.getSession().setAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">request.getRequestDispatcher(<span class="string">"/index.jsp"</span>).forward(request, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QuitServlet.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuitServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"><span class="comment">// 使session失效</span></span><br><span class="line">request.getSession().invalidate();</span><br><span class="line">response.sendRedirect(request.getContextPath() + <span class="string">"/index.jsp"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UserException.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UserException</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UserException</span><span class="params">(String message, Throwable cause)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(message, cause);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UserException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UserException</span><span class="params">(Throwable cause)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(cause);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UserService.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> UserDao userDao = <span class="keyword">new</span> UserDao();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">login</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> UserException </span>&#123;</span><br><span class="line">User user = userDao.findByUsername(username);</span><br><span class="line"><span class="keyword">if</span>(user == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UserException(<span class="string">"用户名错误！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!user.getPassword().equals(password)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UserException(<span class="string">"密码错误！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">regist</span><span class="params">(User user)</span> <span class="keyword">throws</span> UserException </span>&#123;</span><br><span class="line">User _user = userDao.findByUsername(user.getUsername());</span><br><span class="line"><span class="keyword">if</span>(_user != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UserException(<span class="string">"用户名已注册！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">userDao.add(user);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UserDao.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String path;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UserDao</span><span class="params">()</span> </span>&#123;</span><br><span class="line">path = <span class="keyword">this</span>.getClass().getResource(<span class="string">"/users.xml"</span>).getPath();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">Document doc = reader.read(path);</span><br><span class="line"></span><br><span class="line">Element root = doc.getRootElement();</span><br><span class="line">Element userEle = root.addElement(<span class="string">"user"</span>);</span><br><span class="line">userEle.addAttribute(<span class="string">"username"</span>, user.getUsername());</span><br><span class="line">userEle.addAttribute(<span class="string">"password"</span>, user.getPassword());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建格式化器，使用\t缩进，添加换行</span></span><br><span class="line">OutputFormat format = <span class="keyword">new</span> OutputFormat(<span class="string">"\t"</span>, <span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 清空数据中原有的换行</span></span><br><span class="line">format.setTrimText(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 创建XML输出流对象</span></span><br><span class="line">XMLWriter writer = <span class="keyword">new</span> XMLWriter(<span class="keyword">new</span> FileWriter(path), format);</span><br><span class="line"><span class="comment">// 输出Document</span></span><br><span class="line">writer.write(doc);</span><br><span class="line"><span class="comment">// 关闭流</span></span><br><span class="line">writer.close();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">findByUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">Document doc = reader.read(path);</span><br><span class="line">Element ele = (Element) doc.selectSingleNode(<span class="string">"//user[@username='"</span> + username + <span class="string">"']"</span>);</span><br><span class="line"><span class="keyword">if</span>(ele == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">user.setUsername(ele.attributeValue(<span class="string">"username"</span>));</span><br><span class="line">user.setPassword(ele.attributeValue(<span class="string">"password"</span>));</span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>在这里呢小结一下，对于之前这么多天的学习，对JavaWeb有了一个初步的了解，例如Servlet、Tomcat、jsp、xml等相关都有了一定的认识，但是还不够深入，对于某些基础的东西还不够了解，所以在这里这个部分的学习就先告一段落了，之后的学习则是从b站上进行更基础更细节的学习了，整理的东西也不会太多了。在那上面学习完成之后，还会在这里继续之前没完成的数据库部分，因为本人已经在大学中学习了数据库这门课了，所以对于这部分之后的内容就先不做延申了，之后会来补上。</p><p>b站的学习相关博文则会在本博客新开一篇来更新。</p>]]></content>
      
      
      <categories>
          
          <category> 学习篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自学总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法记录</title>
      <link href="/2020/05/27/%C2%96%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/05/27/%C2%96%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p><em>20/05/27</em></p><h2 id="LeetCode-974"><a href="#LeetCode-974" class="headerlink" title="LeetCode 974"></a>LeetCode 974</h2><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个整数数组 <code>A</code>，返回其中元素之和可被 <code>K</code> 整除的（连续、非空）子数组的数目。</p><h4 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h4><p>前缀和</p><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：A = [4,5,0,-2,-3,1], K = 5</span><br><span class="line">输出：7</span><br><span class="line">解释：</span><br><span class="line">有 7 个子数组满足其元素之和可被 K = 5 整除：</span><br><span class="line">[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]</span><br></pre></td></tr></table></figure><a id="more"></a><h5 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h5><ul><li><p>1 &lt;= A.length &lt;= 30000</p></li><li><p>-10000 &lt;= A[i] &lt;= 10000</p></li><li><p>2 &lt;= K &lt;= 10000</p></li></ul><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>首先肯定先暴力想一波，直接两层for循环，sum保存和，然后依次模K进行判断。但是时间复杂度肯定O(N^2)，看范围肯定是过不了了，然后再想想其他办法。分析题目，对于子数组求和的问题，肯定先前缀和一波，前缀和存在数组P[]中，注意P[0]=0初始化别忘了(后面会有坑)，即前0个元素和为0。然后再解析题目，要求元素之和能被K整除，即(P[j]-P[i])%K==0，到这里还是没有什么突破口，因为这样还是得遍历，时间复杂度肯定上去了。所以就很关键的数学定理出现了，<strong>同余定理</strong>。即保证P[i]%K==P[j]%K就肯定能保证(P[j]-P[i])%K==0了。接下来就是遍历了，计算每个P[i]%K的值，然后相同的值之间肯定存在子数组符合条件。如果存在多个相同的值，那就可以组合出很多情况，比如如果存在四个P[i]%K的值相同，那肯定就存在6种组合方式组成的子数组，这肯定不难相到排列组合问题。然后就针对这个进行下一步优化，因为要求相同的值的个数，所以可以用Map实现，遍历P数组，P[i]%K的值以及该值的出现次数存入Map中，然后最后遍历Map的value，进行相应的排列组合运算再相加就解决了。</p><p>需要注意的地方就是，如果我们最开始没有初始化的话，如果遇到P[i]%K==0的时候，该子数组肯定是满足的，不需要另一个P[j]与其配对，如果没有这个初始化的0，我们算法在统计的时候就会少，这个bug还很难找到。如果不太理解，可以看这个例子：[2,2,1] K=5，我们按照算法来，没有初始化，P数组就为[2,4,5]，然后依次%K，得到[2,4,0]，然后放入Map中，每个都是1，即最后得到结果为0，但实际上的结果应该是1，子数组[2,2,1]是满足的，所以这就是需要初始化的原因了。还有需要注意的地方就是P[i]是会出现负数的情况的，所以在%K的时候应该加上一部分值使其为正值再取模。</p><h5 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h5><p>可以用数组代替Map来提高效率降低空间利用率，即因为%K的结果就在0-K-1之间，则可以设定数组times[MAX]，初始化为0，MAX取K值，然后每次得到P[i]%K时，就times[P[i]%K]++即可，这样就免去了Map的复杂操作，但是空间复杂度就会高一些，后面的遍历也是一样的道理了。</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraysDivByK</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">30005</span>];</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        p[<span class="number">0</span>]=<span class="number">0</span>; <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.length;i++)&#123;</span><br><span class="line">            sum+=A[i];</span><br><span class="line">            p[i+<span class="number">1</span>]=sum;</span><br><span class="line">        &#125;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.length+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = (p[i]+<span class="number">15000</span>*K)%K;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(temp)) map.put(temp,map.get(temp)+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> map.put(temp,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v:map.values())&#123;</span><br><span class="line">            sum+=v*(v-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-1"><a href="#LeetCode-1" class="headerlink" title="LeetCode 1"></a>LeetCode 1</h2><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><h5 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h5><p>简单题，就不放代码了，就是依次存入hash表中，也就是存入Map中，value作为键，下标作为值，然后再进行遍历并判断即可。写到这里肯定会问如果有重复的value怎么办，如果重复，那肯定要么这个value的是target的1/2，要么不是组成target的一部分，因为题目保证只有一个解。所以我们考虑这个value的是target的1/2的情况，那hash表内就只存了一个value及其下标，但其实并不影响，因为当遍历到没有存进Map的那个value对应的nums[i]时，进行判断，如果成功就输出当前元素的下标和对应存进Map那个value的下标即可，也同样可以完成题目要求，并不影响。</p><h2 id="LeetCode-2"><a href="#LeetCode-2" class="headerlink" title="LeetCode 2"></a>LeetCode 2</h2><h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 = 807</span><br></pre></td></tr></table></figure><h5 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h5><p>首先，第一个思路肯定是每一位挨着挨着求和存数组，然后再把数组每一个元素乘以10相应的幂再相加，就得到了最终需要的数字sum，再把这个数每一位放在另一个链表上，就ok了。这样肯定能做，但需要注意的是sum的范围，可能是很大很大的，所以这里是第一个可以进行改进的地方，我们可以不对其求和，每次得到两个链表某一位上相加得到的数后，直接对其进行处理，即放在链表上。比如num[cnt]+=l1.val+l2.val，然后判断num[cnt]是否&gt;=10，如果&gt;=10，则num[cnt+1]=1；这也是为什么前面使用+=的原因了。这样得到num[cnt]后，再通过new ListNode(num[cnt]%10)来构建当前数的链表。细心的朋友应该发现了，其实根本不必使用num数组，直接用num就可以了，只需要添加一句else num=0，这样就形成了第二个优化。</p><p>需要注意的地方就是，l1和l2可能不一样长，所以需要补0.还有就是特殊情况的处理，可能l1和l2的最后一位进位了，同时又退出了循环，所以需要判断一下。</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        ListNode l3 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode temp = l3;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="keyword">null</span>||l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1==<span class="keyword">null</span>) l1=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(l2==<span class="keyword">null</span>) l2=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            num+=(l1.val+l2.val);</span><br><span class="line">            temp.next = <span class="keyword">new</span> ListNode(num%<span class="number">10</span>);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">            <span class="keyword">if</span>(num&gt;=<span class="number">10</span>) num=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> num=<span class="number">0</span>; </span><br><span class="line">            l1=l1.next;</span><br><span class="line">            l2=l2.next;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">1</span>) temp.next=<span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> l3.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>20/05/30</em></p><h2 id="LeetCode-84"><a href="#LeetCode-84" class="headerlink" title="LeetCode 84"></a>LeetCode 84</h2><h5 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><h5 id="类别-1"><a href="#类别-1" class="headerlink" title="类别"></a>类别</h5><p>单调栈</p><h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,1,5,6,2,3]</span><br><span class="line">输出: 10</span><br></pre></td></tr></table></figure><h5 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h5><p>首先可以想到暴力算法，即固定每个柱子高度，然后枚举矩形的宽度。这样时间复杂度就O(N^2)，肯定不是我们所希望的。然后我们考虑优化，因为要找最大的面积，而且柱子的高度是有高有低的，我们可以想到单调栈来完成，如果对单调栈没什么了解的，可以看看这道题后面的一个小题，帮助理解单调栈的用法和好处。然后言归正传，我们就考虑维护一个单调栈，如果遇到比当前栈顶的柱子更高的柱子，就将该柱子入栈，如果遇到了比当前栈顶矮的柱子，那就出栈，直到遇到比当前柱子矮的栈顶，然后再将该柱子入栈，同时在其他柱子出栈的时候需要注意更新相应的最大矩形面积，这里是比较难理解的。比如，当前柱子比栈顶矮，然后需要出栈，然后因为出栈的这个柱子是栈中柱子最高的，所以以这个柱子为顶的矩形面积可以求出，并比较更新相应的最大矩形面积。用一句能够帮助理解的话就是<strong>每个柱子出栈的时候，我们都已经计算了以它为顶的矩形的面积的最大值，并对最后结果进行了更新</strong>，即不会导致出栈后得到的面积不是最大面积。可以通过看代码来帮助理解。</p><p>需要注意的地方是，我们在具体实现的时候，需要在高度数组最后插入一个高度为0或者-1的元素，保证栈中所有元素都能出栈。还有我们栈中保存的实质是柱子对应的下标。然后因为需要对给的高度数组进行操作，我们采用c++来描述。</p><h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">height</span>.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; index;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">height</span>.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(index.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">height</span>[index.back()] &gt;= <span class="built_in">height</span>[i]) &#123;</span><br><span class="line">                <span class="keyword">int</span> h = <span class="built_in">height</span>[index.back()];</span><br><span class="line">                index.pop_back();</span><br><span class="line">                <span class="keyword">int</span> sidx = index.<span class="built_in">size</span>() &gt; <span class="number">0</span> ? index.back() : <span class="number">-1</span>;</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, h * (i-sidx<span class="number">-1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            index.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>帮助理解单调栈，[click here][<a href="https://zhuanlan.zhihu.com/p/26465701]" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26465701]</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>期末题解（部分）</title>
      <link href="/2019/12/22/%E6%9C%9F%E6%9C%AB%E9%A2%98%E8%A7%A3_%E9%83%A8%E5%88%86/"/>
      <url>/2019/12/22/%E6%9C%9F%E6%9C%AB%E9%A2%98%E8%A7%A3_%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>在这里给大家提供9道题的题解，都是比较容易想到的题(其他题也不会啊)，希望有需要的人能够从中得到一些启发。可能有些会存在一些小错误因为是我自己通过记忆来描述的，希望理解。</p><a id="more"></a><h2 id="第一次算法期末考试"><a href="#第一次算法期末考试" class="headerlink" title="第一次算法期末考试"></a>第一次算法期末考试</h2><h2 id="A-水二分查找"><a href="#A-水二分查找" class="headerlink" title="A 水二分查找"></a>A 水二分查找</h2><p>输入:多组输入、n、n个数(按顺序排好的)、q、m(q次查询，看n个数中是否存在与m相同的数)</p><p>输出:存在输出Yes，不存在输出No，对于每个q输出q行</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这n个数的数据范围应该是在10<sup>6</sup>内的，所以可以很自然的想到直接用桶装即可解决，而不需要二分查找，具体二分查找这里就不给代码了，因为后面第二次的A题会给出的。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000005</span>],num[<span class="number">1000005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,q,m;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))&#123;</span><br><span class="line">        <span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="keyword">sizeof</span>(num));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">            num[a[i]]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line">        <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">            <span class="keyword">if</span>(num[m]) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-KMP"><a href="#B-KMP" class="headerlink" title="B KMP"></a>B KMP</h2><p>输入:多组输入、两个字符串s、t</p><p>输出:t在s中出现的所有位置，用空格隔开、输出t对应得next数组</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>显然是直接套用KMP即可，因为要输出所有位置，所以需要把判断条件放在while循环内部，具体可以看代码就很清楚了。next数组则一样非常简单即可求出。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 1000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> next[MAX];</span><br><span class="line"><span class="keyword">char</span> s[MAX],t[MAX];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getnext</span><span class="params">(<span class="keyword">int</span> next[],<span class="keyword">char</span> *t)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j=<span class="number">0</span>,k=<span class="number">-1</span>;</span><br><span class="line">next[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> lent=<span class="built_in">strlen</span>(t);</span><br><span class="line"><span class="keyword">while</span>(j&lt;lent)&#123;</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">-1</span>||t[j]==t[k])&#123;</span><br><span class="line">j++;</span><br><span class="line">k++;</span><br><span class="line">next[j]=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> k=next[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="keyword">char</span> *s,<span class="keyword">char</span> *t)</span></span>&#123;</span><br><span class="line">getnext(next,t);</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> lens=<span class="built_in">strlen</span>(s),lent=<span class="built_in">strlen</span>(t);</span><br><span class="line"><span class="keyword">while</span>(i&lt;lens)&#123;</span><br><span class="line"><span class="keyword">while</span>(j!=<span class="number">-1</span>&amp;&amp;t[j]!=s[i])&#123;</span><br><span class="line">j=next[j];</span><br><span class="line">&#125;</span><br><span class="line">i++;j++;</span><br><span class="line"><span class="keyword">if</span>(j==lent)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i-j+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,s,t))&#123;</span><br><span class="line"><span class="built_in">memset</span>(next,<span class="number">0</span>,<span class="keyword">sizeof</span>(next));</span><br><span class="line">KMP(s,t);</span><br><span class="line"><span class="keyword">int</span> lent=<span class="built_in">strlen</span>(t);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lent;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,next[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-线段"><a href="#C-线段" class="headerlink" title="C 线段"></a>C 线段</h2><p>这道题具体的输入输出不太记得了，大致意思应该是输入n条线段的左右坐标(在数轴上)，然后判断最多有多少条线段满足不和别的线段相交并输出最多的数量，并且端点重合可以认为不相交。</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>因为有助教给的提示，这道题就很简单了，就是对这些线段的右端点进行排序，然后通过贪心来从左到右遍历即可。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>可能输入输出有些问题，大家能明白大体就行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100005</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">&#125;a[MAX];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">void</span> <span class="keyword">const</span> *a,<span class="keyword">void</span> <span class="keyword">const</span> *b)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">c</span>,<span class="title">d</span>;</span></span><br><span class="line">    c=*(struct node*)a;</span><br><span class="line">    d=*(struct node*)b;</span><br><span class="line">    <span class="keyword">if</span>(c.r!=d.r) <span class="keyword">return</span> c.r-d.r;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> c.l-d.l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,ans=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a[i].l,&amp;a[i].r);</span><br><span class="line">    &#125;</span><br><span class="line">    qsort(a,n,<span class="keyword">sizeof</span>(struct node),cmp);</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i].l&gt;=a[k].r)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            k=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-字符串"><a href="#D-字符串" class="headerlink" title="D 字符串"></a>D 字符串</h2><p>输入:串t、q、q个串s。然后对t、s进行比较，规则如下</p><ul><li>s和t长度相同，若s和t完全相同，输出myw，否则输出friend</li><li>s比t长度大，若t是s的子串，输出teacher，否则输出senior</li><li>s比t长度小，若s是t的子串，输出child，否则输出dd</li></ul><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>很简单的KMP，直接套板子即可，注意长度相同的时候不需要用KMP，直接strcmp就可</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> next[MAX];</span><br><span class="line"><span class="keyword">char</span> s[MAX],t[MAX];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getnext</span><span class="params">(<span class="keyword">int</span> next[],<span class="keyword">char</span> *t)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j=<span class="number">0</span>,k=<span class="number">-1</span>;</span><br><span class="line">next[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> lent=<span class="built_in">strlen</span>(t);</span><br><span class="line"><span class="keyword">while</span>(j&lt;lent)&#123;</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">-1</span>||t[j]==t[k])&#123;</span><br><span class="line">j++;</span><br><span class="line">k++;</span><br><span class="line">next[j]=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> k=next[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="keyword">char</span> *s,<span class="keyword">char</span> *t)</span></span>&#123;</span><br><span class="line">getnext(next,t);</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> lens=<span class="built_in">strlen</span>(s),lent=<span class="built_in">strlen</span>(t);</span><br><span class="line"><span class="keyword">while</span>(i&lt;lens&amp;&amp;j&lt;lent)&#123;</span><br><span class="line"><span class="keyword">if</span>(j==<span class="number">-1</span>||t[j]==s[i])&#123;</span><br><span class="line">i++;j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> j=next[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(j&gt;=lent) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,t);</span><br><span class="line"><span class="keyword">int</span> q;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line"><span class="keyword">while</span>(q--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line"><span class="keyword">int</span> lens=<span class="built_in">strlen</span>(s),lent=<span class="built_in">strlen</span>(t);</span><br><span class="line"><span class="keyword">if</span>(lent==lens)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(s,t)==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"myw\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"friend\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(lens&gt;lent)&#123;</span><br><span class="line"><span class="built_in">memset</span>(next,<span class="number">0</span>,<span class="keyword">sizeof</span>(next));</span><br><span class="line"><span class="keyword">if</span>(KMP(s,t)==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"teacher\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"senior\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(next,<span class="number">0</span>,<span class="keyword">sizeof</span>(next));</span><br><span class="line"><span class="keyword">if</span>(KMP(t,s)==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"child\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"dd\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G-圆"><a href="#G-圆" class="headerlink" title="G 圆"></a>G 圆</h2><p>这道题考试中因为时间问题没能做出来，所以代码的正确性也不确定，有错误希望大家指出来。</p><p>输入:圆心坐标、半径以及两个点的坐标</p><p>输出:两点最近且不穿过圆的距离</p><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>首先肯定是两点连线不与圆相交就直接算两点距离，这个怎么判断呢，也不难，圆心到直线的距离与半径比较即可，但是这个距离怎么算比较方便呢，可以通过叉积先算出这两点与圆心围成的三角形面积再除以两点的距离来算得，这样比较好写。然后如果两点连线与圆相交的话，这样怎么算最近距离呢，很容易可以想到是和切线相关，即两点分别对圆作切线然后取两距离较近的切点，两切点之间的弧长加上这两个切点到其原来两个点的距离之和即为所要求的距离了。即下图的线段AA’加上线段BB’加上弧A’B’即可。</p><p><img src="https://raw.githubusercontent.com/DbettKK/pictures/master/1.jpg" alt></p><p>然后是算AA’和BB’的问题了，很显然直接用勾股定理还是很容易算出来的，即AO和BO都很容易得到，用勾股定理就能得到AA’和BB’了。最后就是算弧A’B’的问题了，想算弧，显然先算角，即算图中对应得θ角，我的想法是先通过余弦定理算出α角然后知道角AOA’的余弦值，通过数学库的acos即可得到AOA’角，然后同理对于BOB’角，然后用α角减去这两个角就得到了θ角，然后通过周长和θ角求得弧长。</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><p>这里就给出一些函数，具体代码就不给了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">2.0</span>*<span class="built_in">asin</span>(<span class="number">1.0</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(<span class="built_in">point</span> p1,<span class="built_in">point</span> p2)</span></span>&#123;<span class="comment">//求直线两点距离的平方</span></span><br><span class="line">    <span class="keyword">return</span> ((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">xmult</span><span class="params">(<span class="built_in">point</span> p1,<span class="built_in">point</span> p2,<span class="built_in">point</span> p0)</span></span>&#123;<span class="comment">//叉积</span></span><br><span class="line"><span class="keyword">return</span> (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">area</span><span class="params">(<span class="built_in">point</span> p1,<span class="built_in">point</span> p2,<span class="built_in">point</span> p3)</span></span>&#123;<span class="comment">//三角形面积</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(xmult(p1,p2,p3))/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">alpha</span><span class="params">(<span class="built_in">point</span> p1,<span class="built_in">point</span> p2,<span class="built_in">point</span> p0)</span></span>&#123;<span class="comment">//算α角,余弦定理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">acos</span>((dis(p1,p0)+dis(p2,p0)-dis(p1,p2))/</span><br><span class="line">                (<span class="number">2</span>*<span class="built_in">sqrt</span>(dis(p1,p0))*<span class="built_in">sqrt</span>(dis(p2,p0))));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*剩下的运算就是直接调用函数就可完成，这里举一个判断</span></span><br><span class="line"><span class="comment">两点相连的直线是否与圆相交的例子即可，其他不再赘述。*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isx</span><span class="params">(<span class="built_in">point</span> p1,<span class="built_in">point</span> p2,<span class="built_in">point</span> p0,<span class="keyword">double</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="number">2</span>*area(p1,p2,p0))/<span class="built_in">sqrt</span>(dis(p1,p2)))&gt;r;</span><br><span class="line">&#125;<span class="comment">//为true则说明不相交。</span></span><br></pre></td></tr></table></figure><h2 id="第二次算法期末考试"><a href="#第二次算法期末考试" class="headerlink" title="第二次算法期末考试"></a>第二次算法期末考试</h2><h2 id="A-真二分查找"><a href="#A-真二分查找" class="headerlink" title="A 真二分查找"></a>A 真二分查找</h2><p>输入输出和上文的A大致一样，这里就不再赘述</p><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>由于a[i]数据范围到了10<sup>9</sup>，所以没法投机取巧用桶装了，老老实实写二分，由于这次还要输出第一次出现的位置，因此找到一个位置后还应该向前排查是否存在相同的。其他还是比较好写了。</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100005</span>]=&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,m,q;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line"><span class="keyword">while</span>(q--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>,r=n<span class="number">-1</span>,mid,ans=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(m==a[mid])&#123;</span><br><span class="line">ans=mid;</span><br><span class="line"><span class="keyword">int</span> tmp=mid;</span><br><span class="line"><span class="keyword">if</span>(a[tmp<span class="number">-1</span>]==m)&#123;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">tmp--;</span><br><span class="line">&#125;<span class="keyword">while</span>(a[tmp]==m);</span><br><span class="line">ans=tmp+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(m&gt;a[mid]) l=mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ans!=<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"Yes %d\n"</span>,ans+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>题目名字忘了，这道题很简单，就是一个优先队列的问题。代码也不给了真的很简单。需要注意的就是优先队列默认是从大到小的，这里需要让它从小到大，即用greater对应得那个初始化定义即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br></pre></td></tr></table></figure><h2 id="C-三角形"><a href="#C-三角形" class="headerlink" title="C 三角形"></a>C 三角形</h2><p>输入:n、n个数、m、l、r(m次查询)</p><p>输出:每次查询是否存在可以构成三角形的三个数，存在输出Yes，否则输出No</p><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><p>虽然到最后也没能看懂助教的提示，只混了0.5分，但是后来一想还是觉得自己很脑残。。。</p><p>不说废话了，首先肯定暴力是很好想到的，即对[l,r]区间进行排序然后遍历找是否存在i使得a[i]+a[i+1]&gt;a[i+2]即可，存在就break输出Yes，遍历完都没找到就输出No，但是这样明显也会超时没因为排序复杂度是O(nlogn)，那助教给的提示有什么用呢，显然对于斐波拉契数列，a[i]+a[i+1]是等于a[i+2]的，即是三角形存在的最差情况，即这个数列永远不可能存在三个数组成三角形，但是这个数列在i&gt;50后会爆int，由于我们的数据是在int范围内的，所以这个数列在i&gt;50后是肯定存在三个数能组成三角形的，因为a[50]+a[51]肯定比任何其他int内的数都大，所以肯定存在了。斐波拉契这个最坏情况在i&gt;50后都一定存在三个数能组成三角形了，那对于一个普通的序列，那就更是这样了，所以对于所有r-l&gt;=50的查询我们就直接认为它一定存在三个数能组成三角形了，&lt;50的情况则用暴力即可，时间复杂度也不可能会超了。</p><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100005</span>],tmp[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,l,r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        tmp[i]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line">        <span class="keyword">if</span>((r-l)&gt;=<span class="number">50</span>) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">std</span>::sort(tmp+l,tmp+r+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r<span class="number">-2</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(tmp[i]+tmp[i+<span class="number">1</span>]&gt;tmp[i+<span class="number">2</span>])&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag) <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++) tmp[i]=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-k进制a-b"><a href="#E-k进制a-b" class="headerlink" title="E k进制a*b"></a>E k进制a*b</h2><p>输入:t组数据，k、a、b</p><p>输出:每组数据输出k进制的a*b的结果</p><h3 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h3><p>一看数据是10<sup>5</sup>，肯定不是普通的乘法模拟了，直接就是FFT，套板子即可，k进制的问题就直接在最后还原的时候处理即可，很简单。不过y1s1，板子真的要敲很久。。。</p><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000005</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi=<span class="number">3.1415926535</span>;</span><br><span class="line"><span class="keyword">char</span> s1[N&gt;&gt;<span class="number">1</span>],s2[N&gt;&gt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">double</span> rea[N],ina[N],reb[N],inb[N];</span><br><span class="line"><span class="keyword">int</span> ans[N&gt;&gt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">double</span> *x,<span class="keyword">double</span> *y)</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> t=*x;</span><br><span class="line">*x=*y;</span><br><span class="line">*y=t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Rev</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">ans&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">ans|=(x&amp;<span class="number">1</span>);</span><br><span class="line">x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(<span class="keyword">double</span> *reA,<span class="keyword">double</span> *inA,<span class="keyword">int</span> n,<span class="keyword">bool</span> flag)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> s;</span><br><span class="line"><span class="keyword">double</span> lgn=<span class="built_in">log</span>((<span class="keyword">double</span>)n)/<span class="built_in">log</span>((<span class="keyword">double</span>)<span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j=Rev(i,lgn);</span><br><span class="line"><span class="keyword">if</span>(j&gt;i)&#123;</span><br><span class="line">Swap(&amp;reA[i],&amp;reA[j]);</span><br><span class="line">Swap(&amp;inA[i],&amp;inA[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(s=<span class="number">1</span>;s&lt;=lgn;s++)&#123;</span><br><span class="line"><span class="keyword">int</span> m=(<span class="number">1</span>&lt;&lt;s);</span><br><span class="line"><span class="keyword">double</span> reWm=<span class="built_in">cos</span>(<span class="number">2</span>*pi/m),inWm=<span class="built_in">sin</span>(<span class="number">2</span>*pi/m);</span><br><span class="line"><span class="keyword">if</span>(flag) inWm=-inWm;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;n;k+=m)&#123;</span><br><span class="line"><span class="keyword">double</span> reW=<span class="number">1.0</span>,inW=<span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;m/<span class="number">2</span>;j++)&#123;</span><br><span class="line"><span class="keyword">int</span> tag=k+j+m/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">double</span> reT=reW*reA[tag]-inW*inA[tag];</span><br><span class="line"><span class="keyword">double</span> inT=reW*inA[tag]+inW*reA[tag];</span><br><span class="line"><span class="keyword">double</span> reU=reA[k+j],inU=inA[k+j];</span><br><span class="line">reA[k+j]=reU+reT;</span><br><span class="line">inA[k+j]=inU+inT;</span><br><span class="line">reA[tag]=reU-reT;</span><br><span class="line">inA[tag]=inU-inT;</span><br><span class="line"><span class="keyword">double</span> <span class="keyword">rew_t</span>=reW*reWm-inW*inWm;</span><br><span class="line"><span class="keyword">double</span> <span class="keyword">inw_t</span>=reW*inWm+inW*reWm;</span><br><span class="line">reW=<span class="keyword">rew_t</span>;</span><br><span class="line">inW=<span class="keyword">inw_t</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag)&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">reA[i]/=n;</span><br><span class="line">inA[i]/=n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t,k;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,s1,s2);</span><br><span class="line"><span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="keyword">sizeof</span>(ans));</span><br><span class="line"><span class="built_in">memset</span>(rea,<span class="number">0</span>,<span class="keyword">sizeof</span>(rea));</span><br><span class="line"><span class="built_in">memset</span>(reb,<span class="number">0</span>,<span class="keyword">sizeof</span>(reb));</span><br><span class="line"><span class="built_in">memset</span>(ina,<span class="number">0</span>,<span class="keyword">sizeof</span>(ina));</span><br><span class="line"><span class="built_in">memset</span>(inb,<span class="number">0</span>,<span class="keyword">sizeof</span>(inb));</span><br><span class="line"><span class="keyword">int</span> i,lent,len=<span class="number">1</span>,len1,len2;</span><br><span class="line">len1=<span class="built_in">strlen</span>(s1),len2=<span class="built_in">strlen</span>(s2);</span><br><span class="line">lent=(len1&gt;len2?len1:len2);</span><br><span class="line"><span class="keyword">while</span>(len&lt;lent) len&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">len&lt;&lt;=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;len1) rea[i]=(<span class="keyword">double</span>)s1[len1-i<span class="number">-1</span>]-<span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">if</span>(i&lt;len2) reb[i]=(<span class="keyword">double</span>)s2[len2-i<span class="number">-1</span>]-<span class="string">'0'</span>;</span><br><span class="line">ina[i]=inb[i]=<span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line">FFT(rea,ina,len,<span class="number">0</span>);</span><br><span class="line">FFT(reb,inb,len,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line"><span class="keyword">double</span> rec=rea[i]*reb[i]-ina[i]*inb[i];</span><br><span class="line"><span class="keyword">double</span> inc=rea[i]*inb[i]+ina[i]*reb[i];</span><br><span class="line">rea[i]=rec;ina[i]=inc;</span><br><span class="line">&#125;</span><br><span class="line">FFT(rea,ina,len,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">ans[i]=(<span class="keyword">int</span>)(rea[i]+<span class="number">0.4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">ans[i+<span class="number">1</span>]+=ans[i]/k;</span><br><span class="line">ans[i]%=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> len_ans=len1+len2+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(ans[len_ans]==<span class="number">0</span>&amp;&amp;len_ans&gt;<span class="number">0</span>) len_ans--;</span><br><span class="line"><span class="keyword">for</span>(i=len_ans;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,ans[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong><em>上述所有如有谬误请一定指出，以便快速修改防止误导他人。</em></strong></p>]]></content>
      
      
      <categories>
          
          <category> 综合题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解篇-C6</title>
      <link href="/2019/11/30/%E9%A2%98%E8%A7%A3%E7%AF%87-C6/"/>
      <url>/2019/11/30/%E9%A2%98%E8%A7%A3%E7%AF%87-C6/</url>
      
        <content type="html"><![CDATA[<p><em>本文图片可能有时加载不出来，主要github不支持数学公式，我就只能放图，但是github的图片也功能经常出现问题，所以大家体谅一下</em></p><a id="more"></a><h2 id="A-A-B"><a href="#A-A-B" class="headerlink" title="A-A*B"></a>A-A*B</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>计算A*B</p><p>时间限制：1000ms  内存限制：65536KB</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>多组数据输入</p><p>两行两个大整数A和B，A和B保证小于等于50000位。</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>每组数据输出一行，A*B的值</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12345678987654321 98765432123456789</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1219326320073159566072245112635269</span><br></pre></td></tr></table></figure><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>可能有负数哦</p><hr><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先如果大家有上课听讲了一丢丢并且下课很认真找过板子的话，肯定还是很容易找到FFT的板子的，这样就只用改负号了，如果没有并且想看下分析的可以往下阅读，当然可以直接看代码快乐AC。</p><p>首先我们如果用普通乘法采用竖式计算的方法的话时间复杂度为O(n<sup>2</sup>)，肯定是过不了的，所以我们采用FFT算法的话，我们可以降到O(nlogn)的复杂度，就可以随意过了。步入正题，说清楚这个板子不太容易。首先是多项式的两种表示方法——系数表示和点值表示。首先我们常见的多项式都是这样的A=a<sub>0</sub>+a<sub>1</sub>x+a<sub>2</sub>x<sup>2</sup>+……+a<sub>n-1</sub>x<sup>n-1</sup>，然后系数表示法就是用一个n维向量来表示A={a<sub>0</sub>,a<sub>1</sub>,…a<sub>n-1</sub>}，这样肯定能一一对应的表示多项式；然后是点值表示法，我们只用确定n个点x<sub>i</sub>和其对应的A，就肯定可以反推出A的多项式表达，所以点值表示法就是由n个点组成的{(0,A(0)),(1,A(1)),…,(n-1,A(n-1))}，这n个点可以随机取，并且该表示肯定也可以一一对应的表示多项式的，然后我们表示出A和B之后想要求出C，那C的点值表达肯定就是从A和B中取2n个点乘起来，然后也能得到点值表达，但是时间复杂度为O(n<sup>2</sup>)这样肯定不行。我们下面要做的就是把多项式从系数表达转换为点值表达，然后再转换回去，这些过程的时间复杂度都是低于O(nlogn)的。</p><p>然后我们就说一下复数的知识，首先任何复数z都能表示成为一个向量z=r(cosθ+isinθ)，其中r为z的模长，θ为向量与x轴的夹角，称为幅角。根据欧拉公式：e<sup>iθ</sup>=cosθ+isinθ，所以z=r*e<sup>iθ</sup>，所以可以推出(cosθ+isinθ)<sup>α</sup>=(cosαθ+isinαθ) ，这就是棣莫弗公式。然后是在方程x<sup>n</sup>=1中，满足这个方程的解一共有n个，这n个解构成了1的n次单位根。并且这n个根中至少存在一个根w<sub>n</sub>使得w<sub>n</sub>的1~n次方刚好就对应这些n次单位根，这样的w<sub>n</sub>就称为本原根，即这些n次单位根可以表示为w<sub>n</sub><sup>0</sup>,w<sub>n</sub><sup>1</sup>,w<sub>n</sub><sup>2</sup>,…,w<sub>n</sub><sup>n-1</sup>，并且这些数的n次方都为1，因此由棣莫弗公式我们可以得到一个通用(本原根可能不止一个)本原根w<sub>n</sub>= cos(2π/n)+i*sin(2π/n)。</p><p>然后介绍DFT(离散傅里叶变换)，我们之前所说的点值表示中x<sub>i</sub>的选取是随机的。而DFT的奇妙则是n个点取的就是上文所说的n次单位根。我们的A(x)可以表示为A(x)= ∑<sub>j</sub><sup>n−1</sup>(a<sub>j</sub>∗x<sup>j</sup>)(j从0开始)，然后x取n个单位根，即表示为y<sub>k</sub>=A(w<sub>n</sub><sup>k</sup>)=∑<sub>j</sub><sup>n−1</sup>(a<sub>j</sub>*(w<sub>n</sub><sup>k</sup>)<sup>j</sup>)(j从0开始，0&lt;=k&lt;=n-1)，这个数用y表示的话就是y={y<sub>0</sub>,y<sub>1</sub>,y<sub>2</sub>, … ,y<sub>n-1</sub>}。所以我们完成了从系数表示到点值表示转化的过程，只是这里的时间复杂度太高，我们不能采用。</p><p>然后我们再说FFT(快速傅里叶变换)，FFT本质也是把多项式的系数表达转换为点值表达，只不过时间复杂度更低。首先构造两个式子(A右上角那个0和1不是指数的意思，只是一个标号)：</p><ul><li><p>A<sup>0</sup>(x)=a<sub>0</sub>+a<sub>2</sub>x+a<sub>4</sub>x<sup>2</sup>+…+a<sub>n-2</sub>x<sup>n/2-1</sup></p></li><li><p>A<sup>1</sup>(x)=a<sub>1</sub>+a<sub>3</sub>x+a<sub>5</sub>x<sup>2</sup>+…+a<sub>n-1</sub>x<sup>n/2-1</sup></p></li></ul><p>能够知道的是A(x)=A<sup>0</sup>(x<sup>2</sup>)+x*A<sup>1</sup>(x<sup>2</sup>)，所以DFT问题就转化为了A<sup>0</sup>和A<sup>1</sup>在(w<sub>n</sub><sup>0</sup>)<sup>2</sup>,(w<sub>n</sub><sup>1</sup>)<sup>2</sup>,(w<sub>n</sub><sup>2</sup>)<sup>2</sup>,…,(w<sub>n</sub><sup>n-1</sup>)<sup>2</sup>这些点上的求值问题，这样一直分裂下去，就是分治的思想就能解决问题了，并且时间复杂度在O(nlogn)内。</p><p>然后是如何递归的问题，虽然已经找到了分治的方法，但是转化后的问题并不相同，而是多了一个平方。我们的处理方法还是借用棣莫弗公式，转化后即得到w<sub>αn</sub><sup>αk</sup>=w<sub>n</sub><sup>k</sup>，所以问题里的(w<sub>n</sub><sup>0</sup>)<sup>2</sup>,(w<sub>n</sub><sup>1</sup>)<sup>2</sup>,(w<sub>n</sub><sup>2</sup>)<sup>2</sup>,…,(w<sub>n</sub><sup>n-1</sup>)<sup>2</sup>就转化为了w<sub>n/2</sub><sup>0</sup>,w<sub>n/2</sub><sup>1</sup>,w<sub>n/2</sub><sup>2</sup>,…,w<sub>n/2</sub><sup>n-1</sup>，所以只要每次处理子问题的时候替换一下本原根，就让子问题和原问题完全一样了。由于在口头上说不是那么容易理解，下面举一个n=4的例子：</p><p>y<sub>0</sub>=A(w<sub>4</sub><sup>0</sup>)=A<sup>0</sup>((w<sub>4</sub><sup>0</sup>)<sup>2</sup>)+w<sub>4</sub><sup>0</sup>*A<sup>1</sup>((w<sub>4</sub><sup>0</sup>)<sup>2</sup>)，y<sub>1</sub>=A(w<sub>4</sub><sup>1</sup>)=A<sup>0</sup>((w<sub>4</sub><sup>1</sup>)<sup>2</sup>)+w<sub>4</sub><sup>1</sup>*A<sup>1</sup>((w<sub>4</sub><sup>1</sup>)<sup>2</sup>)；</p><p>y<sub>2</sub>=A(w<sub>4</sub><sup>2</sup>)=A<sup>0</sup>((w<sub>4</sub><sup>2</sup>)<sup>2</sup>)+w<sub>4</sub><sup>2</sup>*A<sup>1</sup>((w<sub>4</sub><sup>2</sup>)<sup>2</sup>)，y<sub>3</sub>=A(w<sub>4</sub><sup>3</sup>)=A<sup>0</sup>((w<sub>4</sub><sup>3</sup>)<sup>2</sup>)+w<sub>4</sub><sup>3</sup>*A<sup>1</sup>((w<sub>4</sub><sup>3</sup>)<sup>2</sup>)；</p><p>根据上文提到的借用棣莫弗公式从而转换的方法，从而得到：</p><p>y<sub>0</sub>=A(w<sub>4</sub><sup>0</sup>)=A<sup>0</sup>(w<sub>2</sub><sup>0</sup>)+w<sub>4</sub><sup>0</sup>*A<sup>1</sup>(w<sub>2</sub><sup>0</sup>)，y<sub>1</sub>=A(w<sub>4</sub><sup>1</sup>)=A<sup>0</sup>(w<sub>2</sub><sup>1</sup>)+w<sub>4</sub><sup>1</sup>*A<sup>1</sup>(w<sub>2</sub><sup>1</sup>)；</p><p>y<sub>2</sub>=A(w<sub>4</sub><sup>2</sup>)=A<sup>0</sup>(w<sub>2</sub><sup>2</sup>)+w<sub>4</sub><sup>2</sup>*A<sup>1</sup>(w<sub>2</sub><sup>2</sup>)，y<sub>3</sub>=A(w<sub>4</sub><sup>3</sup>)=A<sup>0</sup>(w<sub>2</sub><sup>3</sup>)+w<sub>4</sub><sup>3</sup>*A<sup>1</sup>(w<sub>2</sub><sup>3</sup>)；</p><p>再经过一些简单的公式变换(w<sub>n</sub><sup>k+n/2</sup>=w<sub>n</sub><sup>k</sup>*w<sub>n</sub><sup>n/2</sup>=-w<sub>n</sub><sup>k</sup>(可以想想为何是-1)和w<sub>n</sub><sup>k+n</sup>=w<sub>n</sub><sup>k</sup>*w<sub>n</sub><sup>n</sup>=w<sub>n</sub><sup>k</sup>)，得到</p><p>y<sub>0</sub>=A(w<sub>4</sub><sup>0</sup>)=A<sup>0</sup>(w<sub>2</sub><sup>0</sup>)+w<sub>4</sub><sup>0</sup>*A<sup>1</sup>(w<sub>2</sub><sup>0</sup>)，y<sub>1</sub>=A(w<sub>4</sub><sup>1</sup>)=A<sup>0</sup>(w<sub>2</sub><sup>1</sup>)+w<sub>4</sub><sup>1</sup>*A<sup>1</sup>(w<sub>2</sub><sup>1</sup>)；</p><p>y<sub>2</sub>=A(w<sub>4</sub><sup>2</sup>)=A<sup>0</sup>(w<sub>2</sub><sup>0</sup>)-w<sub>4</sub><sup>0</sup>*A<sup>1</sup>(w<sub>2</sub><sup>0</sup>)，y<sub>3</sub>=A(w<sub>4</sub><sup>3</sup>)=A<sup>0</sup>(w<sub>2</sub><sup>1</sup>)-w<sub>4</sub><sup>1</sup>*A<sup>1</sup>(w<sub>2</sub><sup>1</sup>)；</p><p>然后这样就能很简单快速的得出y的点值表达{y<sub>0</sub>,y<sub>1</sub>,y<sub>2</sub>, … ,y<sub>n-1</sub>}啦，时间也是O(nlogn)。</p><p>但是我们求出了所需要得结果C多项式的点值表达后，怎么算出C的系数表达呢。我们先构造一个范德蒙矩阵V(有w的那个矩阵)如下</p><p><img src="https://raw.githubusercontent.com/DbettKK/pictures/master/blog2/%E9%A2%98%E8%A7%A3C6-1.jpg" alt></p><p>这里我们可以记作y=V*a，同时观察这个V其中的元素，对于第k行第j列的元素，它的值为w<sub>n</sub><sup>kj</sup>。我们FFT所求即求出了V，我们现在要把点值表达变回系数表达，也就是FFT的逆过程。对于这个也就是求a，转换一下上方的式子就是a=V<sup>-1</sup>*y，而对于V<sup>-1</sup>这个矩阵来说，它第j行第k列的元素，则是w<sub>n</sub><sup>-kj</sup>/n(这里就不证明了，大家可以自己查阅)。</p><p>然后我们再考虑I<sub>n</sub>=V*V<sup>-1</sup>这个矩阵，考虑该矩阵中第j行第j’列的元素：</p><p><img src="https://raw.githubusercontent.com/DbettKK/pictures/master/blog2/%E9%A2%98%E8%A7%A3C6-2.jpg" alt></p><p>然后我们还需要一个引理：对任意大于等于1的整数n和不能被n整除的非负整数k，有：(证明也在下方)</p><p><img src="https://raw.githubusercontent.com/DbettKK/pictures/master/blog2/%E9%A2%98%E8%A7%A3C6-3.jpg" alt></p><p>也就是一个等比数列求和的过程，然后我们就能发现上面考虑的I<sub>n</sub>矩阵中的j行j‘列元素在j!=j’的时候为0，相等的时候为1。所以我们就能根据a=V<sup>-1</sup>*y得到以下式子：(下方也放上上文求出的y的式子)</p><p><img src="https://raw.githubusercontent.com/DbettKK/pictures/master/blog2/%E9%A2%98%E8%A7%A3C6-4.jpg" alt></p><p>所以我们在计算逆FFT时，就把a和y的位置互换，再用w<sub>n</sub><sup>-1</sup>代替w<sub>n</sub><sup>1</sup>，并把结果除以n就可以了。时间复杂度也是一样的，通过FFT和逆FFT的运用就能把 次数界为 n 的多项式在其系数表示与点值表示之间来回进行转换。 从而算出大数乘法了。</p><hr><p>好了上面就是纯数学的推导部分，阅读起来应该不是很难(毕竟我这个cj都能理解)，然后再讲讲怎么具体应用于大数乘法。其实也很简单，首先运用FFT将A和B的系数表示转换为点值表示，然后将他们相乘得到C的点值表示，最后通过逆FFT将C转换为系数表示，输出答案就okkk了。然后先放代码吧。</p><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 150010</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.141592653</span>;</span><br><span class="line"><span class="keyword">char</span> s1[N&gt;&gt;<span class="number">1</span>], s2[N&gt;&gt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">double</span> rea[N], ina[N], reb[N], inb[N];</span><br><span class="line"><span class="keyword">int</span> ans[N&gt;&gt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">double</span> *x, <span class="keyword">double</span> *y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> t = *x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Rev</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        ans&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        ans |= (x &amp; <span class="number">1</span>);</span><br><span class="line">        x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;<span class="comment">//二进制的反转x-&gt;ans</span></span><br><span class="line"><span class="comment">//作用就是把这n个数分成我们想要的lgn个部分，且每个部分仅有两个待处理的，然后再处理</span></span><br><span class="line"><span class="comment">//不太明白的可以看看网上关于FFT中的二进制的翻转问题的博客啥的</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(<span class="keyword">double</span> *reA, <span class="keyword">double</span> *inA, <span class="keyword">int</span> n, <span class="keyword">bool</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">double</span> lgn = <span class="built_in">log</span>((<span class="keyword">double</span>)n) / <span class="built_in">log</span>((<span class="keyword">double</span>)<span class="number">2</span>);<span class="comment">//定义log(2)(n),也就是代表分裂次数</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = Rev(i, lgn);</span><br><span class="line">        <span class="keyword">if</span>(j &gt; i)&#123;</span><br><span class="line">            Swap(&amp;reA[i], &amp;reA[j]);</span><br><span class="line">            Swap(&amp;inA[i], &amp;inA[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(s = <span class="number">1</span>; s &lt;= lgn; s++)&#123;<span class="comment">//共进行lgn次</span></span><br><span class="line">        <span class="keyword">int</span> m = (<span class="number">1</span>&lt;&lt;s);</span><br><span class="line">        <span class="keyword">double</span> reWm = <span class="built_in">cos</span>(<span class="number">2</span>*pi/m), inWm = <span class="built_in">sin</span>(<span class="number">2</span>*pi/m);<span class="comment">//本原根</span></span><br><span class="line">        <span class="keyword">if</span>(flag) inWm = -inWm;<span class="comment">//对C来说就要转换为负的</span></span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; n; k += m)&#123;</span><br><span class="line">            <span class="keyword">double</span> reW = <span class="number">1.0</span>, inW = <span class="number">0.0</span>;</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; m / <span class="number">2</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tag = k+j+m/<span class="number">2</span>;<span class="comment">//可以对照上文的公式看</span></span><br><span class="line">                <span class="keyword">double</span> reT = reW * reA[tag] - inW * inA[tag];</span><br><span class="line">                <span class="keyword">double</span> inT = reW * inA[tag] + inW * reA[tag];</span><br><span class="line">                <span class="keyword">double</span> reU = reA[k+j], inU = inA[k+j];</span><br><span class="line">                reA[k+j] = reU + reT;</span><br><span class="line">                inA[k+j] = inU + inT;</span><br><span class="line">                reA[tag] = reU - reT;</span><br><span class="line">                inA[tag] = inU - inT;</span><br><span class="line">                <span class="keyword">double</span> <span class="keyword">rew_t</span> = reW * reWm - inW * inWm; </span><br><span class="line">                <span class="keyword">double</span> <span class="keyword">inw_t</span> = reW * inWm + inW * reWm; <span class="comment">//这里实现迭代</span></span><br><span class="line">                reW = <span class="keyword">rew_t</span>;</span><br><span class="line">                inW = <span class="keyword">inw_t</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;<span class="comment">//对C来说需要除以n</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            reA[i] /= n;</span><br><span class="line">            inA[i] /= n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    <span class="comment">//freopen("in.txt","r",stdin);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, s1, s2))&#123; </span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(ans, <span class="number">0</span> , <span class="keyword">sizeof</span>(ans));</span><br><span class="line">        <span class="built_in">memset</span>(rea, <span class="number">0</span> , <span class="keyword">sizeof</span>(rea));</span><br><span class="line">        <span class="built_in">memset</span>(ina, <span class="number">0</span> , <span class="keyword">sizeof</span>(ina));</span><br><span class="line">        <span class="built_in">memset</span>(reb, <span class="number">0</span> , <span class="keyword">sizeof</span>(reb));</span><br><span class="line">        <span class="built_in">memset</span>(inb, <span class="number">0</span> , <span class="keyword">sizeof</span>(inb));<span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">int</span> i, lent, len = <span class="number">1</span>, len1, len2;</span><br><span class="line">        len1 = <span class="built_in">strlen</span>(s1);</span><br><span class="line">        len2 = <span class="built_in">strlen</span>(s2);</span><br><span class="line">        <span class="keyword">if</span>(s1[<span class="number">0</span>]==<span class="string">'-'</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len1;i++)&#123;</span><br><span class="line">        s1[i]=s1[i+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">len1--;</span><br><span class="line">flag^=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(s2[<span class="number">0</span>]==<span class="string">'-'</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len2;i++)&#123;</span><br><span class="line">        s2[i]=s2[i+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">len2--;</span><br><span class="line">flag^=<span class="number">1</span>;</span><br><span class="line">&#125;<span class="comment">//符号的判断</span></span><br><span class="line">        lent = (len1 &gt; len2 ? len1 : len2);</span><br><span class="line">        <span class="keyword">while</span>(len &lt; lent) len &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        len &lt;&lt;= <span class="number">1</span>;<span class="comment">// 保证长度为2的幂次，才能逐渐二分</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; len1) rea[i] = (<span class="keyword">double</span>)s1[len1-i<span class="number">-1</span>] - <span class="string">'0'</span>;<span class="comment">//将数组s1反转，并保存为double</span></span><br><span class="line">            <span class="keyword">if</span>(i &lt; len2) reb[i] = (<span class="keyword">double</span>)s2[len2-i<span class="number">-1</span>] - <span class="string">'0'</span>;<span class="comment">//将数组s2反转，并保存为double</span></span><br><span class="line">            ina[i] = inb[i] = <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        FFT(rea, ina, len, <span class="number">0</span>);<span class="comment">//对A进行FFT</span></span><br><span class="line">        FFT(reb, inb, len, <span class="number">0</span>);<span class="comment">//对B进行FFT</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">double</span> rec = rea[i] * reb[i] - ina[i] * inb[i];</span><br><span class="line">            <span class="keyword">double</span> inc = rea[i] * inb[i] + ina[i] * reb[i];</span><br><span class="line">            rea[i] = rec; ina[i] = inc;</span><br><span class="line">        &#125;<span class="comment">//获得C的点值表达</span></span><br><span class="line">        FFT(rea, ina, len, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            ans[i] = (<span class="keyword">int</span>)(rea[i] + <span class="number">0.4</span>);<span class="comment">//舍入</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            ans[i+<span class="number">1</span>] += ans[i] / <span class="number">10</span>;</span><br><span class="line">            ans[i] %= <span class="number">10</span>;</span><br><span class="line">        &#125;<span class="comment">//消除进位</span></span><br><span class="line">        <span class="keyword">int</span> len_ans = len1 + len2 + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(ans[len_ans] == <span class="number">0</span> &amp;&amp; len_ans &gt; <span class="number">0</span>) len_ans--;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="built_in">printf</span>(<span class="string">"-"</span>);</span><br><span class="line">        <span class="keyword">for</span>(i = len_ans; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上文的代码我几乎都标注了，应该能够比较容易的看懂了</p><p>如有谬误，请一定指出，本人争取马上修改，勿误导他人。</p><hr><h2 id="B-定向越野"><a href="#B-定向越野" class="headerlink" title="B-定向越野"></a>B-定向越野</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>为了锻炼身体，某楠参加了一个定向越野比赛，定向越野是利用地图和指北针导航的一项竞技运动，通常由起点出发，在多个点标处打卡，再返回终点。但是非酋某楠的指北针居然是坏的，所以只能靠记住来时的方向和各个点的坐标来判断下一步。现在希望你能够帮忙判断下一步是左转还是右转。对于每次转弯输出一个字符，左转输出’L’，右转输出’R’，直走不输出。</p><p>时间限制：1000ms，内存限制：65536KB</p><h3 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h3><p>多组数据输入</p><p>每组数据第一行一个数n，n表示按顺序经历的点的数量，包括起点、各个点标以及终点。1&lt;n&lt;10000</p><p>接下来n行每行两个整数为点的坐标，均在INT范围内。</p><h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><p>每组数据一行，每次转弯的方向’L’或’R’，中间用空格分隔</p><h3 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> 5 </span><br><span class="line"> 0 0</span><br><span class="line">-1 1</span><br><span class="line"> 0 1</span><br><span class="line">-1 2</span><br><span class="line"> 0 3</span><br></pre></td></tr></table></figure><h3 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R L R</span><br></pre></td></tr></table></figure><hr><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>很明显的一道计算几何题，用叉积判断方向就可，需要注意的是如果走直线是不输出的。还有一个就是可能long long会超，如果先算乘法再算减法的话(就是把叉积的式子展开了分别算)，就需要用double来存，如果是先减再乘，longlong就能随意过了。</p><h3 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> x[<span class="number">10005</span>],y[<span class="number">10005</span>];</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x[i],&amp;y[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(((<span class="keyword">long</span> <span class="keyword">long</span>)(x[i]-x[i<span class="number">-1</span>])*(y[i+<span class="number">1</span>]-y[i])-(<span class="keyword">long</span> <span class="keyword">long</span>)(x[i+<span class="number">1</span>]-x[i])*(y[i]-y[i<span class="number">-1</span>]))&gt;<span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"L "</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(((<span class="keyword">long</span> <span class="keyword">long</span>)(x[i]-x[i<span class="number">-1</span>])*(y[i+<span class="number">1</span>]-y[i])-(<span class="keyword">long</span> <span class="keyword">long</span>)(x[i+<span class="number">1</span>]-x[i])*(y[i]-y[i<span class="number">-1</span>]))&lt;<span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"R "</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如有谬误，请一定指出，本人争取马上修改，勿误导他人。</p><hr><h2 id="C-危机合约"><a href="#C-危机合约" class="headerlink" title="C-危机合约"></a>C-危机合约</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>一天起床，你突然发现自己成为了整合运动的一员，作为火刀哥的手下前去探路。由于危机合约的特殊性，博士只能布置没有阻挡数的干员，每路过一个干员就会受到一次他的攻击，你的目的就是在不被干掉的情况下，从位于最左第一列某点的红色出生点走到位于最右某点的蓝色目的地。作为一个普通宿主士兵，你只能走向右上，右，右下三个格子。</p><p>时间限制：1000ms，内存限制：65536KB</p><h3 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h3><p>第一行n和m，表示地图有n行m列 (n,m&lt;100)</p><p>第二行h，a和b，h表示你现有的血量，红色出生点在第0列a行，蓝色目的地在第m+1列b行(1&lt;=a,b&lt;=n)</p><p>接下来n行，每行m列，其中’*’表示这个点不能走，数字表示这个点上干员对你的伤害，范围0到9</p><h3 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h3><p>如果能够活着走到目的地，则输出剩余血量</p><p>如果已经死亡，则输出”doctor win”</p><h3 id="输入样例-2"><a href="#输入样例-2" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3 5</span><br><span class="line">20 1 3</span><br><span class="line">0 1 2 * 4</span><br><span class="line">2 3 * 3 5</span><br><span class="line">6 1 2 * 4</span><br></pre></td></tr></table></figure><h3 id="输出样例-2"><a href="#输出样例-2" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><hr><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>首先应该能看出这是一道dp的题目，所以就先分析怎么样dp吧。首先本人先想到的是对当前的血量进行dp(好像和大部分盆友想法不太一样)，<code>dp[i][j]</code>即代表在i行j列处的血量，并且还没有扣除当前应该扣除的血量，即已经走到了i行j列，只是还没扣血(不太理解的可以从代码来理解)，这样dp的好处呢就是不用管*格是否走不走得到，反正就往下走，走到*后再往下走就直接把血扣到负数即可。然后转移方程呢，就是走到当前格子的血量等于前一列那三个格子中剩余血量减去需要扣除的血量后最大的。如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j]=tmax(dp[i<span class="number">-1</span>][j<span class="number">-1</span>]-<span class="built_in">map</span>[i<span class="number">-1</span>][j<span class="number">-1</span>],dp[i][j<span class="number">-1</span>]-<span class="built_in">map</span>[i][j<span class="number">-1</span>],dp[i+<span class="number">1</span>][j<span class="number">-1</span>]-<span class="built_in">map</span>[i+<span class="number">1</span>][j<span class="number">-1</span>])<span class="comment">//tmax指三者中的最大值</span></span><br></pre></td></tr></table></figure><p>一些需要注意的地方呢就是，首先初始化的问题，*的格子赋值为inf，dp的初始值赋值为-inf，map的初始值赋值为inf，因为要保证第一步走的时候的正确性，然后还要比所给的图多赋值一圈，才能保证在边缘的时候不会走错，然后a点的初始化就是<code>dp[a][0]=h,map[a][0]=-inf</code>，因为赋值都是inf和-inf并且还存在减法，数据的要求也是10<sup>9</sup>，所以把dp和map设置成long long比较安全。最后还有一个很坑的就是读入的问题了，scanf和getchar真的有毒，因为<code>\r\n</code>等诸多问题，所以还是建议用cin比较好。最后我在代码里也加一个其他dp的方法也能ac。</p><h3 id="AC代码-2"><a href="#AC代码-2" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 2147483647 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll dp[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="function">ll <span class="title">dmax</span><span class="params">(ll a,ll b,ll c)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a&gt;=b&amp;&amp;a&gt;=c) <span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">if</span>(b&gt;=a&amp;&amp;b&gt;=c) <span class="keyword">return</span> b;</span><br><span class="line"><span class="keyword">if</span>(c&gt;=a&amp;&amp;c&gt;=b) <span class="keyword">return</span> c;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line">ll <span class="built_in">map</span>[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">int</span> h,a,b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;h,&amp;a,&amp;b);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n+<span class="number">1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m+<span class="number">1</span>;j++)&#123;</span><br><span class="line">dp[i][j]=-inf;</span><br><span class="line"><span class="built_in">map</span>[i][j]=inf;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dp[a][<span class="number">0</span>]=h;</span><br><span class="line"><span class="built_in">map</span>[a][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;c;</span><br><span class="line"><span class="keyword">if</span>(c!=<span class="string">'*'</span>) <span class="built_in">map</span>[i][j]=c-<span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">map</span>[i][j]=inf;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m+<span class="number">1</span>;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">dp[i][j]=dmax(dp[i<span class="number">-1</span>][j<span class="number">-1</span>]-<span class="built_in">map</span>[i<span class="number">-1</span>][j<span class="number">-1</span>],dp[i][j<span class="number">-1</span>]-<span class="built_in">map</span>[i][j<span class="number">-1</span>],dp[i+<span class="number">1</span>][j<span class="number">-1</span>]-<span class="built_in">map</span>[i+<span class="number">1</span>][j<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/*for(int j=1;j&lt;=m+1;j++)&#123;</span></span><br><span class="line"><span class="comment">for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">dp[i][j]=dmin(dp[i-1][j-1],dp[i][j-1],dp[i+1][j-1])+map[i][j];</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">    <span class="comment">//这个dp对应的就是减少的生命值，初始化就是反的，并且最后的输出和判断doctor win也有点区别，还有就是求的是最小值，其实两个dp实际上是一样的</span></span><br><span class="line"><span class="keyword">if</span>(dp[b][m+<span class="number">1</span>]&lt;=<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"doctor win"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld"</span>,dp[b][m+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如有谬误，请一定指出，本人争取马上修改，勿误导他人。</p><hr><h2 id="D-不NAN的过河"><a href="#D-不NAN的过河" class="headerlink" title="D-不NAN的过河"></a>D-不NAN的过河</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>某楠也要过Zexal过的那条河，通过借助河中间的石砖过到河对岸去，这些石砖以直线排列。河的长度为L，当某楠走到或跨过坐标为L的点时，就算到达了河对岸。但是强迫症的某楠最多只能跨m次，请你计算某楠过河最长的一步最少是多少。注意从岸边迈向石头和从石头迈向岸边也算1步。</p><p>时间限制：1000ms，内存限制：65536KB</p><h3 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h3><p>多组数据输入</p><p>每组数据第一行有3个正整数L，n，m，L表示河的宽度，n表示有n个石砖，m表示某楠最多只能跨m步。(1≤L≤10<sup>9</sup>,1≤n≤10<sup>5</sup>,1≤m≤10<sup>5</sup>)</p><p>第二行有n个不同的正整数分别表示这n个石砖在数轴上的位置（所有相邻的整数之间用一个空格隔开。</p><h3 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h3><p>每组数据输出一个整数，表示某楠迈的最长一步的最小距离。</p><h3 id="输入样例-3"><a href="#输入样例-3" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 2 3</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure><h3 id="输出样例-3"><a href="#输出样例-3" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><hr><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>首先看问题他要求最长一步的最小距离，肯定需要去判断，遍历判断肯定时间不太行，O(n<sup>2</sup>)肯定超了，所以我们就采用二分来枚举即可，时间是绰绰有余的。然后是怎么判断的问题了，便于理解，我们把a[0]设为0，a[n+1]设为L，然后判断的问题，肯定要让每一步跨的最大，所以就是贪心的思想。在遇到一步跨不到的石砖时才记录步数，然后将开始的地方置为当前石砖的前一块也就是<code>a[i-1]</code>，这样需要考虑的就是如果一步跨过了岸边，那它也会将开始的地方置为a[n]，所以最后一步就没有算上，所以我们cnt初始值设为1而不是0。还有一个很重要的就是，他没有说石砖是有序的，所以最开始需要排个序才行(这个bug太恶心)。</p><h3 id="AC代码-3"><a href="#AC代码-3" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,l,mid;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">void</span> <span class="keyword">const</span> *a,<span class="keyword">void</span> <span class="keyword">const</span> *b)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> c,d;</span><br><span class="line">c=*(<span class="keyword">int</span> *)a;</span><br><span class="line">d=*(<span class="keyword">int</span> *)b;</span><br><span class="line"><span class="keyword">return</span> c-d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">1</span>,pre=a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n+<span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]-pre&gt;mid) &#123;</span><br><span class="line">pre=a[i<span class="number">-1</span>];</span><br><span class="line">cnt++;</span><br><span class="line"><span class="keyword">if</span>(a[i]-pre&gt;mid)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cnt&lt;=m) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;l,&amp;n,&amp;m)) &#123;</span><br><span class="line">a[<span class="number">0</span>]=<span class="number">0</span>,a[n+<span class="number">1</span>]=l;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">&#125; </span><br><span class="line">qsort(a,n+<span class="number">2</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>),cmp);</span><br><span class="line"><span class="keyword">int</span> left=<span class="number">0</span>,right=l,ans;</span><br><span class="line"><span class="keyword">while</span>(left&lt;=right) &#123;</span><br><span class="line">mid=(left+right)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(check()) ans=mid,right=mid<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如有谬误，请一定指出，本人争取马上修改，勿误导他人。</p><hr><h2 id="E-线段交点"><a href="#E-线段交点" class="headerlink" title="E-线段交点"></a>E-线段交点</h2><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p>有两条线段，求线段的交点。</p><p>时间限制：1000ms  内存限制：65536KB</p><h3 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h3><p>多组输入数据</p><p>每组数据两行</p><p>每行两个整数x，y，分别表示一条线段的x坐标，y坐标(−100≤x,y≤100)</p><h3 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h3><p>每组数据输出一行，两个数表示交点的坐标，中间用空格隔开。如果没有交点，或者线段重合，输出<code>none</code></p><h3 id="输入样例-4"><a href="#输入样例-4" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 0 1 1</span><br><span class="line">1 0 0 1 </span><br><span class="line">0 0 2 2</span><br><span class="line">1 1 3 3</span><br></pre></td></tr></table></figure><h3 id="输出样例-4"><a href="#输出样例-4" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0.50 0.50</span><br><span class="line">none</span><br></pre></td></tr></table></figure><hr><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>首先这道题就是一道数学题感觉，需要考虑的情况很多，考虑完全就能过了。步入正题，我们两条直线先设置为AB，CD，交点为O，叉积用cross()表示。首先肯定是判断能否相交，因为我们是根据叉积来判断的，所以相交的情况也会比较多一些。首先先看正常的相交，也就是相交点不在端点处。对应的条件就是cross(AC,AB)和cross(AD,AB)异号并且cross(CA,CD)和cross(CB,CD)异号即可。然后是AB端点和CD重合的情况，对应的条件就是cross(AC,AB)和cross(AD,AB)异号并且cross(CA,CD)和cross(CB,CD)积为0，当然还有相反的情况(CD端点和AB重合，条件就不说了)，然后是重合和平行的情况，即叉积cross(AB,CD)为0，这里面也有一种相交的情况即诸如这种A-&gt;B(C)-&gt;D情况，怎么讨论这种情况呢，如果AB的两个端点均在CD线段上，这肯定是重合，那这个情况怎么判断呢，我用的方法比较笨(应该会有更简便的方法的)，通过AC斜率和AD斜率相等并且A的x、y坐标在C和D的x、y坐标中间，对B也一样，然后就是这种重合情况。然后在这种情况之外如果存在一组端点(A和C及其他情况)重合的情况，则是相交了，这种情况的判断方法我用的也比较笨，即通过判断A是否和C或者D重合，以及B是否和C或者D重合，然后如果重合就说明相交了，并且在这里需要输出，因为正常算交点的方法没法算这种情况，这里输出应该比较容易，存在重合就直接输出坐标就好了。然后其他的情况都是none即可。这就是所有的情况了。前面几种都比较好实现，最后一个情况会麻烦一些(也可能是我的方法比较笨)。</p><p>然后再说一下怎么算交点的问题了。就是通过算出两个三角形ACD,BCD的面积，然后根据其比值求出AO比AB，然后求出向量OA，然后用A的坐标加上OA向量即得到O的坐标了，比较容易理解。</p><h3 id="AC代码-4"><a href="#AC代码-4" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="keyword">double</span> x,y;</span><br><span class="line">Point(<span class="keyword">double</span> x=<span class="number">0</span>, <span class="keyword">double</span> y=<span class="number">0</span>):x(x),y(y) &#123;&#125;</span><br><span class="line">Point <span class="keyword">operator</span> + (Point p)&#123;</span><br><span class="line"><span class="keyword">return</span> Point(x+p.x,y+p.y);<span class="comment">//重定义加法，点的加法即坐标相加，也可能是点和向量相加 </span></span><br><span class="line">&#125;</span><br><span class="line">Point <span class="keyword">operator</span> - (Point p)&#123;</span><br><span class="line"><span class="keyword">return</span> Point(x-p.x,y-p.y);<span class="comment">//重定义减法，点的减法即坐标相减 </span></span><br><span class="line">&#125;</span><br><span class="line">Point <span class="keyword">operator</span> * (<span class="keyword">double</span> a)&#123;</span><br><span class="line"><span class="keyword">return</span> Point(a*x,a*y);<span class="comment">//重定义乘法，点乘常数即以坐标乘常数 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">typedef</span> Point Vector;<span class="comment">//因为向量Vector也能用X,Y表示</span></span><br><span class="line"><span class="keyword">int</span> flag; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment</span>&#123;</span> <span class="comment">//Segment 线段</span></span><br><span class="line">Point p1,p2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cross</span><span class="params">(Vector a, Vector b)</span> </span>&#123;<span class="comment">//向量的外积 </span></span><br><span class="line"><span class="keyword">return</span> a.x*b.y - a.y*b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">crossx</span><span class="params">(Point p1,Point p2,Point q1,Point q2)</span></span>&#123;<span class="comment">//也是外积不过是具体的点之间的 </span></span><br><span class="line"><span class="keyword">return</span> (p1.x-p2.x)*(q1.y-q2.y)-(p1.y-p2.y)*(q1.x-q2.x);<span class="comment">//p1p2 x q1q2 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">issame</span><span class="params">(Point P1,Point P2,Point Q1,Point Q2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>((P1.x==Q1.x&amp;&amp;P1.y==Q1.y)&amp;&amp;(!(P2.x==Q2.x&amp;&amp;P2.y==Q2.y))) &#123; <span class="comment">//P1=Q1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lf %lf\n"</span>,P1.x,P1.y);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>((!(P1.x==Q1.x&amp;&amp;P1.y==Q1.y))&amp;&amp;(P2.x==Q2.x&amp;&amp;P2.y==Q2.y)) &#123; <span class="comment">//P2=Q2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lf %lf\n"</span>,P2.x,P2.y);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>((P2.x==Q1.x&amp;&amp;P2.y==Q1.y)&amp;&amp;(!(P1.x==Q2.x&amp;&amp;P1.y==Q2.y))) &#123; <span class="comment">//P2=Q1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lf %lf\n"</span>,P2.x,P2.y);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>((!(P2.x==Q1.x&amp;&amp;P2.y==Q1.y))&amp;&amp;(P1.x==Q2.x&amp;&amp;P1.y==Q2.y)) &#123; <span class="comment">//P1=Q2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lf %lf\n"</span>,P1.x,P1.y);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isch</span><span class="params">(Point P1,Point P2,Point Q1,Point Q2)</span></span>&#123; </span><br><span class="line"><span class="keyword">if</span>(<span class="comment">//存在两个端点均与另一线段重合</span></span><br><span class="line">((P2.y-Q1.y)*(Q1.x-P1.x)==(Q1.y-P1.y)*(P2.x-Q1.x)&amp;&amp;(((P1.x&lt;=Q1.x)&amp;&amp;(P2.x&gt;=Q1.x))||((P1.x&gt;=Q1.x)&amp;&amp;(P2.x&lt;=Q1.x)))&amp;&amp;(((P1.y&lt;=Q1.y)&amp;&amp;(P2.y&gt;=Q1.y))||((P1.y&gt;=Q1.y)&amp;&amp;(P2.y&lt;=Q1.y)))&amp;&amp;</span><br><span class="line">(P2.y-Q2.y)*(Q2.x-P1.x)==(Q2.y-P1.y)*(P2.x-Q2.x)&amp;&amp;(((P1.x&lt;=Q2.x)&amp;&amp;(P2.x&gt;=Q2.x))||((P1.x&gt;=Q2.x)&amp;&amp;(P2.x&lt;=Q2.x)))&amp;&amp;(((P1.y&lt;=Q2.y)&amp;&amp;(P2.y&gt;=Q2.y))||((P1.y&gt;=Q2.y)&amp;&amp;(P2.y&lt;=Q2.y))))||</span><br><span class="line">((Q2.y-P1.y)*(P1.x-Q1.x)==(P1.y-Q1.y)*(Q2.x-P1.x)&amp;&amp;(((Q1.x&lt;=P1.x)&amp;&amp;(Q2.x&gt;=P1.x))||((Q1.x&gt;=P1.x)&amp;&amp;(Q2.x&lt;=P1.x)))&amp;&amp;(((Q1.y&lt;=P1.y)&amp;&amp;(Q2.y&gt;=P1.y))||((Q1.y&gt;=P1.y)&amp;&amp;(Q2.y&lt;=P1.y)))&amp;&amp;</span><br><span class="line">(Q2.y-P2.y)*(P2.x-Q1.x)==(P2.y-Q1.y)*(Q2.x-P2.x)&amp;&amp;(((Q1.x&lt;=P2.x)&amp;&amp;(Q2.x&gt;=P2.x))||((Q1.x&gt;=P2.x)&amp;&amp;(Q2.x&lt;=P2.x)))&amp;&amp;(((Q1.y&lt;=P2.y)&amp;&amp;(Q2.y&gt;=P2.y))||((Q1.y&gt;=P2.y)&amp;&amp;(Q2.y&lt;=P2.y))))</span><br><span class="line">)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(Point p1,Point p2,Point q1,Point q2)</span></span>&#123;<span class="comment">//判断是否相交 </span></span><br><span class="line"><span class="keyword">if</span>(crossx(p1,q1,p1,p2)*crossx(p1,q2,p1,p2)&lt;<span class="number">0</span>&amp;&amp;crossx(q1,p1,q1,q2)*crossx(q1,p2,q1,q2)&lt;<span class="number">0</span>) </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//正常相交 </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>((crossx(p1,q1,p1,p2)*crossx(p1,q2,p1,p2)&lt;<span class="number">0</span>&amp;&amp;crossx(q1,p1,q1,q2)*crossx(q1,p2,q1,q2)==<span class="number">0</span>)||</span><br><span class="line">(crossx(p1,q1,p1,p2)*crossx(p1,q2,p1,p2)==<span class="number">0</span>&amp;&amp;crossx(q1,p1,q1,q2)*crossx(q1,p2,q1,q2)&lt;<span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//存在一端点在另一条线段上而不是端点处的相交 </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(crossx(p1,q1,p1,p2)*crossx(p1,q2,p1,p2)==<span class="number">0</span>&amp;&amp;crossx(q1,p1,q1,q2)*crossx(q1,p2,q1,q2)==<span class="number">0</span>)&#123;<span class="comment">//共线 </span></span><br><span class="line"><span class="keyword">if</span>(isch(p1,p2,q1,q2)) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(issame(p1,p2,q1,q2))&#123;<span class="comment">//存在一组端点重合 </span></span><br><span class="line">flag=<span class="number">1</span>;<span class="comment">//不是正常相交，需要自己算，之后就不算 </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Point <span class="title">getCrossPoint</span><span class="params">(Segment s1,Segment s2)</span></span>&#123;</span><br><span class="line">Vector base;<span class="comment">//向量</span></span><br><span class="line">base=s2.p2-s2.p1; </span><br><span class="line"><span class="keyword">double</span> d1=<span class="built_in">fabs</span>(cross(base,s1.p1-s2.p1));</span><br><span class="line"><span class="keyword">double</span> d2=<span class="built_in">fabs</span>(cross(base,s1.p2-s2.p1));<span class="comment">//算三角形面积，只是没有除以2 </span></span><br><span class="line"><span class="keyword">double</span> t=d1/(d1+d2);<span class="comment">//面积之比等于线段之比，可理解为t=AO/(AO+BO) </span></span><br><span class="line"><span class="keyword">return</span> s1.p1+(s1.p2-s1.p1)*t;<span class="comment">//通过A点坐标加上向量OA然后求得O点坐标 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Segment s1,s2;</span><br><span class="line">Point p;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf%lf"</span>,&amp;s1.p1.x,&amp;s1.p1.y,&amp;s1.p2.x,&amp;s1.p2.y)) &#123;</span><br><span class="line">flag=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf%lf"</span>,&amp;s2.p1.x,&amp;s2.p1.y,&amp;s2.p2.x,&amp;s2.p2.y);</span><br><span class="line"><span class="keyword">if</span>(!judge(s1.p1,s1.p2,s2.p1,s2.p2)) <span class="built_in">printf</span>(<span class="string">"none\n"</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">p=getCrossPoint(s1,s2);<span class="comment">//交点坐标 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lf %lf\n"</span>,p.x,p.y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如有谬误，请一定指出，本人争取马上修改，勿误导他人。</p><hr><h2 id="F-直线"><a href="#F-直线" class="headerlink" title="F-直线"></a>F-直线</h2><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><p>二维平面上有n个黑点m个白点，现在请问是否存在一条直线使得所有的黑点白点分别在直线两侧（黑点都在一侧，白点都在另一侧）。</p><p>时间限制：1000ms  内存限制：65536KB</p><h3 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h3><p>对于每组数据：</p><p>第一行两个正整数n、m。(1≤n,m≤100)</p><p>接下来n行，每行两个正整数x,y，表示一个黑点的xy坐标(1≤x,y≤1000)</p><p>接下来m行，每行两个正整数x,y，表示一个白点的xy坐标(1≤x,y≤1000)</p><h3 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h3><p>每组数据输出一行，存在输出<code>YES</code>，否则输出<code>NO</code></p><h3 id="输入样例-5"><a href="#输入样例-5" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">100 700</span><br><span class="line">200 200</span><br><span class="line">600 600</span><br><span class="line">500 100</span><br><span class="line">500 300</span><br><span class="line">800 500</span><br><span class="line">3 3</span><br><span class="line">100 300</span><br><span class="line">400 600</span><br><span class="line">400 100</span><br><span class="line">600 400</span><br><span class="line">500 900</span><br><span class="line">300 300</span><br></pre></td></tr></table></figure><h3 id="输出样例-5"><a href="#输出样例-5" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><hr><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>从题目来看可以比较容易可以看出是一道凸包的题目，即黑色点的凸包和白色点的凸包是否存在交点，存在，则不存在题中所说的直线，反之亦然。重点就是如何判断凸包是否相交呢。凸包相交也就分为两种情况，一种是一个凸包的点是否被另一凸包包含，包含并且不是全部的点被包含(需要特判一下)则肯定相交，第二种是两个凸包的边是否相交(比如两个三角形组成六芒星的图，点都不互相包含，但是凸包相交)。需要注意的就是，是否凸包被完全包含，以及凸包的点在另一个凸包的边的上。具体的怎么判断算法我就不多介绍了(有板子就好了)，大家可以看AC代码(网上找的板子)自己理解一下，我能看懂的地方都给大家标注了，但是很多具体的算法(比如判断边相交)我也没怎么详细看懂(不好意思，能力有限)。</p><h3 id="AC代码-5"><a href="#AC代码-5" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    Point(<span class="keyword">double</span> x = <span class="number">0</span>, <span class="keyword">double</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">    Point <span class="keyword">operator</span>+(Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(a.x + x, a.y + y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>-(Point a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x - a.x, y - a.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == a.x)</span><br><span class="line">            <span class="keyword">return</span> y &lt; a.y;</span><br><span class="line">        <span class="keyword">return</span> x &lt; a.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Point &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(x - a.x) &lt; eps &amp;&amp; <span class="built_in">fabs</span>(y - a.y) &lt; eps)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(x * x + y * y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cross</span><span class="params">(Vector a, Vector b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x * b.y - a.y * b.x;</span><br><span class="line">&#125;<span class="comment">//叉积</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dot</span><span class="params">(Vector a, Vector b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x * b.x + a.y * b.y;</span><br><span class="line">&#125;<span class="comment">//点积</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isclock</span><span class="params">(Point p0, Point p1, Point p2)</span> </span>&#123;</span><br><span class="line">    Vector a = p1 - p0;</span><br><span class="line">    Vector b = p2 - p0;</span><br><span class="line">    <span class="keyword">if</span> (cross(a, b) &lt; -eps)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;<span class="comment">//判断平行也就是夹角很小很小</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getDistance</span><span class="params">(Point a, Point b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(a.x - b.x, <span class="number">2</span>) + <span class="built_in">pow</span>(a.y - b.y, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;Point&gt; Polygon;</span><br><span class="line"><span class="function">Polygon <span class="title">Andrew</span><span class="params">(Polygon s)</span></span>&#123;</span><br><span class="line">    Polygon u,l;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">size</span>()&lt;<span class="number">3</span>) <span class="keyword">return</span> s;</span><br><span class="line">    sort(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());<span class="comment">//根据x坐标排序 </span></span><br><span class="line">    u.push_back(s[<span class="number">0</span>]);</span><br><span class="line">    u.push_back(s[<span class="number">1</span>]);</span><br><span class="line">    l.push_back(s[s.<span class="built_in">size</span>()<span class="number">-1</span>]);</span><br><span class="line">    l.push_back(s[s.<span class="built_in">size</span>()<span class="number">-2</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;s.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n=u.<span class="built_in">size</span>();n&gt;=<span class="number">2</span>&amp;&amp;!isclock(u[n<span class="number">-2</span>],u[n<span class="number">-1</span>],s[i]);--n)&#123;</span><br><span class="line">            u.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        u.push_back(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">3</span> ; i &gt;= <span class="number">0</span> ; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n = l.<span class="built_in">size</span>() ; n &gt;=<span class="number">2</span> &amp;&amp; !isclock(l[n<span class="number">-2</span>],l[n<span class="number">-1</span>],s[i]); --n) &#123;</span><br><span class="line">            l.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        l.push_back(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; u.<span class="built_in">size</span>() - <span class="number">1</span> ; i++) l.push_back(u[i]);</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(<span class="keyword">double</span> x)</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(x) &lt;= eps)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断点在线段上</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">OnSegment</span><span class="params">(Point p, Point a1, Point a2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dcmp(cross(a1 - p, a2 - p)) == <span class="number">0</span> &amp;&amp; dcmp(dot(a1 - p, a2 - p)) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断线段相交</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Intersection</span><span class="params">(Point a1, Point a2, Point b1, Point b2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> c1 = cross(a2 - a1, b1 - a1), c2 = cross(a2 - a1, b2 - a1),</span><br><span class="line">            c3 = cross(b2 - b1, a1 - b1), c4 = cross(b2 - b1, a2 - b1);</span><br><span class="line">    <span class="keyword">return</span> dcmp(c1) * dcmp(c2) &lt; <span class="number">0</span> &amp;&amp; dcmp(c3) * dcmp(c4) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断点在凸包内</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPointInPolygon</span><span class="params">(Point p, <span class="built_in">vector</span>&lt;Point&gt; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> wn = <span class="number">0</span>, cc = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cc; i++) &#123;</span><br><span class="line">        Point p1 = s[i];</span><br><span class="line">        Point p2 = s[(i + <span class="number">1</span>) % cc];</span><br><span class="line">        <span class="keyword">if</span> (p1 == p || p2 == p || OnSegment(p, p1, p2)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = dcmp(cross(p2 - p1, p - p1));</span><br><span class="line">        <span class="keyword">int</span> d1 = dcmp(p1.y - p.y);</span><br><span class="line">        <span class="keyword">int</span> d2 = dcmp(p2.y - p.y);</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; d1 &lt;= <span class="number">0</span> &amp;&amp; d2 &gt; <span class="number">0</span>) wn++;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">0</span> &amp;&amp; d2 &lt;= <span class="number">0</span> &amp;&amp; d1 &gt; <span class="number">0</span>) wn--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wn != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(Polygon s1, Polygon s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c1 = s1.<span class="built_in">size</span>(), c2 = s2.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c1; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isPointInPolygon(s1[i], s2)) &#123;<span class="comment">//点是否包含</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c2; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isPointInPolygon(s2[i], s1)) &#123;<span class="comment">//同上</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c1; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c2; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Intersection(s1[i], s1[(i + <span class="number">1</span>) % c1], s2[j], s2[(j + <span class="number">1</span>) % c2])) &#123;<span class="comment">//线段相交判断</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>&amp;&amp;m==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        Polygon s1,s2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">double</span> x1, x2;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>,&amp;x1,&amp;x2);</span><br><span class="line">            s1.push_back(Point(x1, x2));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">            <span class="keyword">double</span> x1, x2;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>,&amp;x1,&amp;x2);</span><br><span class="line">            s2.push_back(Point(x1,x2));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s1.<span class="built_in">size</span>()) s1=Andrew(s1);</span><br><span class="line">        <span class="keyword">if</span>(s2.<span class="built_in">size</span>()) s2=Andrew(s2);</span><br><span class="line">        solve(s1,s2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如有谬误，请一定指出，本人争取马上修改，勿误导他人。</p><hr><h2 id="G-逆序对"><a href="#G-逆序对" class="headerlink" title="G-逆序对"></a>G-逆序对</h2><h3 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h3><p>逆序对的定义：在一个序列a中，如果i&lt;j且 a<sub>i</sub>&gt;a<sub>j</sub> 那么a<sub>i</sub>a<sub>j</sub>就是一个逆序对。</p><p>问相距最远的逆序对的距离（j-i）。如果没有逆序对，输出0。</p><p>时间限制：1000ms  内存限制：65536KB</p><h3 id="输入-6"><a href="#输入-6" class="headerlink" title="输入"></a>输入</h3><p>第一行一个数n，表示序列的长度。(1≤n≤10<sup>5</sup>)</p><p>接下来一行，n个整数，保证在int范围内</p><h3 id="输出-6"><a href="#输出-6" class="headerlink" title="输出"></a>输出</h3><p>一行一个数，表示最远逆序对的距离</p><h3 id="输入样例-6"><a href="#输入样例-6" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">4 3 5 1</span><br></pre></td></tr></table></figure><h3 id="输出样例-6"><a href="#输出样例-6" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><hr><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><p>拿到这道题目能想到的第一个方法肯定就是暴力遍历，但是上机的时候粗略一看O(n<sup>2</sup>)会超就被我***的果断放弃了。。其实好像用不到O(n<sup>2</sup>)。步入正题，肯定是对每一个元素，找到其最远逆序对然后和max比较即可，最后输出max。但是怎么找最快呢，如果直接一步一步从前往后找，每一步还需要比较找出最大的，肯定就差不多O(n<sup>2</sup>)了，肯定过不了，但我们能发现的是，因为是找最远的，所以直接从后往前找，找到了一个就直接break就好了，因为求的是最远距离而不是差值，这样一来时间复杂度就比较乐观了。放上代码</p><h3 id="AC代码-6"><a href="#AC代码-6" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">int</span> distance;</span><br><span class="line">&#125;a[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i].num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">max</span>=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=n<span class="number">-1</span>;j&gt;=i+<span class="number">1</span>;j--)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[j].num&lt;a[i].num)&#123;</span><br><span class="line">a[i].distance=j-i;</span><br><span class="line"><span class="keyword">break</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a[i].distance&gt;<span class="built_in">max</span>) <span class="built_in">max</span>=a[i].distance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,<span class="built_in">max</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如有谬误，请一定指出，本人争取马上修改，勿误导他人。</p>]]></content>
      
      
      <categories>
          
          <category> 综合题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建图方法总结</title>
      <link href="/2019/11/25/%E5%BB%BA%E5%9B%BE%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2019/11/25/%E5%BB%BA%E5%9B%BE%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文呢主要想为大家介绍一些常用的建图方法及数据结构，因为大家平时都直接套板子，可能会有一些模糊的地方，希望本文的介绍对大家图论的学习有所帮助。</p><a id="more"></a><h2 id="建图"><a href="#建图" class="headerlink" title="建图"></a>建图</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>邻接矩阵可以说是最简单最容易理解的建图方法了，简要说就是用一个二维数组存边，下标代表顶点编号。比如<code>map[i][j]</code>即代表顶点i和顶点j之间存在一条边，边的权值为<code>map[i][j]</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max ...</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[<span class="built_in">max</span>][<span class="built_in">max</span>];</span><br></pre></td></tr></table></figure><p>这样无论是遍历或者是存边的时候都非常的方便和容易理解。下面用松弛举个遍历的例子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存图</span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> u,v,w;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">    <span class="built_in">map</span>[u][v]=w;</span><br><span class="line">    <span class="built_in">map</span>[v][u]=<span class="number">0</span>;<span class="comment">//有向图(无向图为w)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">int</span> tmp;<span class="comment">//源点</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="comment">//遍历目标顶点</span></span><br><span class="line">    <span class="keyword">if</span>(dis[i]&gt;dis[tmp]+<span class="built_in">map</span>[tmp][i])<span class="comment">//松弛</span></span><br><span class="line">        dis[i]=dis[tmp]+<span class="built_in">map</span>[tmp][i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也有不可避免的缺点，就是空间占用太大。比如一共10000个点100000条边的时候，就无法用矩阵简单的存储了。只能用其他方法。</p><h3 id="邻接表-链式前向星"><a href="#邻接表-链式前向星" class="headerlink" title="邻接表(链式前向星)"></a>邻接表(链式前向星)</h3><p>链式前向星可以说是一种非常优质的存图结构了，不管是占用内存方面还是遍历方面或者是存边都非常的简单，但有个问题就是不是那么容易理解(反正本人凭自己可能十天八天都不一定弄得明白，还是网上看看博客才懂)。但弄懂了还是很简单的，先放代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max ...</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;e[<span class="built_in">max</span>*<span class="built_in">max</span>];<span class="comment">//max*max代表边总数，实际可能没这么多。</span></span><br><span class="line"><span class="keyword">int</span> head[<span class="built_in">max</span>],e_num=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    e[e_num].to=v;</span><br><span class="line">    e[e_num].weight=w;</span><br><span class="line">    e[e_num].next=head[u];</span><br><span class="line">    head[u]=e_num;</span><br><span class="line">    e_num++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    addedge(u,v,w);</span><br><span class="line">    addedge(v,u,<span class="number">0</span>);<span class="comment">//无向图为w</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//还要初始化head数组全为-1</span></span><br></pre></td></tr></table></figure><p>上面给大家列出了链式前向星的基本结构以及加边的函数，方便下文阐述。首先拿到这个结构体可能第一次接触的时候有点懵(我第一次直接放弃)，首先<code>to</code>就是指该边指向的顶点，<code>weight</code>就是代表权值了也可以代表容量，然后最神奇的就是<code>next</code>，这个则代表和这条边来自同样起始顶点的下一条边的编号(因为这个结构体数组的下标就是代表边的编号)，然后是<code>head[max]</code>，这个数组存的是边的编号，什么编号呢，以该数组下标为起始顶点的边的编号(该数组的下标即为起始顶点的编号)，并且如果从该起始顶点出发的有多条边，那则代表最后添加进head数组的那条边的编号(好像有点绕)，最后<code>e_num</code>代表的是边的编号也就是<code>e[]</code>的下标。如果没怎么搞明白，不要紧，我们再看看这个加边函数应该就比较清楚了。</p><p>首先<code>e_num</code>从0开始，加入第一条边，存其指向的顶点和权值就不多说了，这个比较好理解；然后是<code>e[e_num].next=head[u]</code>，根据我们上文介绍的概念来理解就是，<code>e[e_num].next</code>表示这条边对应的起始顶点的下一条边的编号，等于<code>head[u]</code>，也就等于head数组的初始值-1，因为现在图里只有一条边，所以不存在其他边的情况，所以-1则代表无边。现在图里就一条边，我们假设为顶点1到顶点2有一条边。如下(别忘了同时也相当于加了一条从2-&gt;1的权值为0的边，<code>e_num</code>现在为2)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//边 1-&gt;2</span></span><br><span class="line"><span class="comment">//对应的数组及代码如下</span></span><br><span class="line">e[<span class="number">0</span>].next=head[<span class="number">1</span>];<span class="comment">//head[1]=-1;</span></span><br><span class="line">head[<span class="number">1</span>]=<span class="number">0</span>;<span class="comment">//e_num=0;</span></span><br><span class="line"><span class="comment">//相反的边 2-&gt;1 只是权值为0</span></span><br><span class="line">e[<span class="number">1</span>].next=head[<span class="number">2</span>];<span class="comment">//head[2]=-1</span></span><br><span class="line">head[<span class="number">2</span>]=<span class="number">1</span>;<span class="comment">//e_num=1;</span></span><br></pre></td></tr></table></figure><p>然后我们假设再加入一条从1到3的一条边，代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//边 1-&gt;3</span></span><br><span class="line">e[<span class="number">2</span>].next=head[<span class="number">1</span>];<span class="comment">//此时head[1]=0</span></span><br><span class="line">head[<span class="number">1</span>]=<span class="number">2</span>;<span class="comment">//e_num=2;</span></span><br><span class="line"><span class="comment">//相反的边</span></span><br><span class="line">e[<span class="number">3</span>].next=head[<span class="number">3</span>];<span class="comment">//head[3]=-1;</span></span><br><span class="line">head[<span class="number">3</span>]=<span class="number">3</span>;<span class="comment">//e_num=3;</span></span><br></pre></td></tr></table></figure><p>然后我们再来分析一下，我们先不看那两条相反的边，只看<code>1-&gt;2</code>和<code>1-&gt;3</code>这两边。现在<code>head[1]</code>里存的就是边的编号2，也就是最后加进来的起始顶点为1的边<code>1-&gt;3</code>。这个点应该清楚了吧。然后是<code>e[2].next</code>这个指的是<code>1-&gt;2</code>这条边的编号0，也就是和<code>1-&gt;3</code>这条边有相同起始顶点下一条边的编号，也就是<code>1-&gt;2</code>这条边的编号，所以是0。然后这些应该清楚了，那为什么要这样设置呢，下面代码则是遍历时的代码，还是举松弛的例子，看完大家应该就理解为什么要这样设置了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> s;<span class="comment">//源点</span></span><br><span class="line"><span class="keyword">for</span>(i=head[s];~i;i=e[i].next)&#123;</span><br><span class="line">    <span class="keyword">int</span> v=e[i].to;</span><br><span class="line">    <span class="keyword">if</span>(dis[v]&gt;dis[s]+e[i].weight)</span><br><span class="line">        dis[v]=dis[s]+e[i].weight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我来解释一下这段代码，首先这段代码实现的功能就是对以s源点为起点的所有边进行松弛操作。首先是循环的代码，<code>i</code>就是代表边的编号，初始值就为以s为起点的最后加入head数组的边的编号，<code>~i</code>的意思就是<code>i!=-1</code>了(因为head的初始值我们设为-1)，然后<code>i=e[i].next</code>就代表和当前边具有相同顶点的下一条边的编号了，这样就能遍历以s为起点的所有的边了。然后是<code>v</code>，就是代表当前边的终止顶点，也就是<code>s-&gt;v</code>并且编号为<code>i</code>，所以松弛操作就很好理解了，这个循环也就是几乎所有链式前向星实现遍历的循环了。</p><p>最后再补充一下为什么有向图要存反向边了，这是为了在解决最大流问题的时候的方便，残余网络等等都需要反向边的参与，这样设置反向边的好处也是很大的，因为就是和其本身这条边编号<code>+1</code>或者准确说是<code>^1</code>就能得到其反向边了。(比如上面例子的边<code>1-&gt;2</code>编号为0，<code>2-&gt;1</code>编号为1，也就是0^1，对<code>1-&gt;3</code>也是同样)所以就很方便。</p><p>总结一下就是链式前向星的优势很大，完全不用担心空间的浪费问题，并且其和用单纯的链表存图是异曲同工的，我在这里就不再赘述，缺点就是不那么容易理解，希望大家都能熟练掌握。</p><h3 id="vector实现邻接表"><a href="#vector实现邻接表" class="headerlink" title="vector实现邻接表"></a>vector实现邻接表</h3><p>用vector实现邻接表就比较简单易懂了，直接放代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max ...</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;struct node&gt; G[<span class="built_in">max</span>];<span class="comment">//下标为出发点</span></span><br><span class="line"><span class="comment">//vector&lt;pair&lt;int,int&gt; &gt; G[max];</span></span><br></pre></td></tr></table></figure><p>数据结构还是非常的简单易懂的，就是邻接表最朴素的方式，当然熟练后直接使用pair即可，下面放上存边的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">e</span>;</span><span class="comment">//临时</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">e.v=v,e.w=w;</span><br><span class="line">G[u].push_back(e);<span class="comment">//和二维数组相似</span></span><br><span class="line"><span class="comment">//G[u].push_back(&#123;v,w&#125;);</span></span><br></pre></td></tr></table></figure><p>遍历就和二维数组几乎类似了。上代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">e</span>;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=G[i].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">        e=G[i][j];</span><br><span class="line">        <span class="comment">//e.v,e.w</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点也是有的，比如存在相同边的时候，判断是否重复就比较麻烦了。</p><hr><hr>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解篇-C5</title>
      <link href="/2019/11/23/%E9%A2%98%E8%A7%A3%E7%AF%87-C5/"/>
      <url>/2019/11/23/%E9%A2%98%E8%A7%A3%E7%AF%87-C5/</url>
      
        <content type="html"><![CDATA[<h2 id="A-毛毛虫"><a href="#A-毛毛虫" class="headerlink" title="A-毛毛虫"></a>A-毛毛虫</h2><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>草丛中有两只毛毛虫。他们想穿过草丛里的杀虫剂到达对方的身边。而草丛里的杀虫剂形成了nn个两两无公共点的圆。注意这些杀虫剂只存在于圆的边界上，且杀虫剂宽度非常非常细。毛毛虫一开始不在任何圆的边界上。</p><p>毛毛虫穿过杀虫剂就要受到一次伤害。请问一只毛毛虫到达另一只的身边，最少需要受到几次伤害？</p><p> 时间限制：1000ms  内存限制：65536KB </p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>第一个数为数据组数T，每组数据输入5行，T≤10。</p><p>第一行包含一个整数 n，n≤50。</p><p>第二行包含 n 个整数 x<sub>i</sub>，表示 n 个圆的圆心的横坐标。</p><p>第三行包含 n 个整数 y<sub>i</sub> ，表示 n 个圆的圆心的纵坐标。</p><p>第四行包含 n 个整数 r<sub>i</sub> ，表示 n 个圆的半径。</p><p>最后一行包含四个整数 x1,y1,x2,y2，表示两只毛毛虫位置的横纵坐标。</p><p>所有坐标、半径的绝对值不超过10001000。</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>对于每组数据，输出一行，毛毛虫受到伤害的次数。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">0 -6 6</span><br><span class="line">0 1 6</span><br><span class="line">2 2 2</span><br><span class="line">-5 1 5 1</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><hr><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>刚开始拿到这道题很容易被文字数量和一大堆的输入数据唬住(本人就是)，其实仔细分析会发现其实并不难(Moggin：这是学长出给初中生的题)。</p><p>言归正传，这道题就是一个点和圆的相对位置关系的题，很简单，两条毛毛虫都在某一圆内或者都不在某一圆内对毛毛虫的伤害为0，所以只用考虑包含一条毛毛虫同时不包含另一毛毛虫的圆的数量即可。</p><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> x[<span class="number">55</span>]=&#123;&#125;,y[<span class="number">55</span>]=&#123;&#125;,r[<span class="number">55</span>]=&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(((x1-x[i])*(x1-x[i])+(y1-y[i])*(y1-y[i]))&lt;=r[i]*r[i])&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> T,n,i;</span><br><span class="line"><span class="keyword">int</span> x1,y1,x2,y2;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;y[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;r[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(judge(x1,y1,i)&amp;&amp;!judge(x2,y2,i))&#123;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!judge(x1,y1,i)&amp;&amp;judge(x2,y2,i))&#123;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="B-图1"><a href="#B-图1" class="headerlink" title="B-图1"></a>B-图1</h2><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p>一个无向图，<code>N</code>个点编号<code>1~N</code>。<code>M</code>条边，每条边有一个权值<code>c</code>。</p><p>对于一个点集<code>A</code>，这个点集的权值<code>S</code>定义为S<sub>A</sub>=max(c<sub>ij</sub>)，其中i∈A∧j∈A∧i≠j。</p><p>现在将N个点分割为两个点集A、B，请问max(S<sub>A</sub>,S<sub>B</sub>)的最小值</p><p> 时间限制：1000ms  内存限制：65536KB </p><h3 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h3><p>第一行两个正整数N、M。(2≤N≤20000,1≤M≤100000)</p><p>接下来M行，每行三个整数a,b,c，表示ab之间有一条权值为c的边（1≤a,b≤N,1≤c≤10<sup>9</sup>）</p><h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><p>一行一个数</p><h3 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">4 6</span><br><span class="line">1 4 2534</span><br><span class="line">2 3 3512</span><br><span class="line">1 2 28351</span><br><span class="line">1 3 6618</span><br><span class="line">2 4 1805</span><br><span class="line">3 4 12884</span><br></pre></td></tr></table></figure><h3 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3512</span><br></pre></td></tr></table></figure><hr><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>首先分析题目，白话重新描述一下就是，给图顶点染色，只染两种颜色，然后将同色中权值最大的边最小化，求最小值。这样看来显然就是二分图了(对本人可能不那么显然)，对需要求出来的边进行枚举，将比其权值小的边删去后，剩余的边能否构成二分图，能构成，说明该边满足条件，然后再枚举比该边小的，再判断，直到最后不能构成二分图，则找到了答案。那通过什么方法枚举呢，当然可以挨着挨着枚举，时间复杂度也上去了，由于需要枚举的边是可以从大到小枚举过来的，所以我们可以直接采用二分来求就好了，这样时间复杂度就很低了。然后的问题就是判断能否构成二分图的问题了。我们直接采用比较简单的DFS染色即可。这样就能求出答案了。</p><p>注意：一些需要注意的细节在这里说明一下。首先是二分最开始的值的设置，由于给的权值范围都是10<sup>9</sup>了，所以我们的初始值应该达到long long才行(测试了一下，需要10<sup>11</sup>才能AC)。其次呢就是存图的问题，10000的顶点数，邻接矩阵存肯定爆内存了。所以采用链式前向星来存比较好。还有就是不是一开始就存图，是把边先枚举，比该边大的边才放进图里(连边)，所以最开始存顶点和边的信息需要一个结构体。最后就是染色的问题了，大家可以看了代码再看我马上要说的，就是vis[]数组的作用，因为判断了一个顶点后，和它相连的所有点都已经被染色了，如果再次访问这些点的话，就会出现错误，所以需要判断一下，让已经被染色的不再需要判断，因为无论这个点其所连的边有没有构成二分图，与其相连的所有点就相当于也已经全部判断了一遍了，所以不需要再判断一遍，也能节省一些时间。</p><h3 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max 300005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line">&#125; ver[<span class="built_in">max</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> v;</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line"><span class="keyword">int</span> next;</span><br><span class="line">&#125; e[<span class="built_in">max</span>];</span><br><span class="line"><span class="keyword">int</span> head[<span class="built_in">max</span>],e_num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,S,T;</span><br><span class="line">ll mid;</span><br><span class="line"><span class="keyword">int</span> color[<span class="built_in">max</span>],vis[<span class="built_in">max</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">e[e_num].v=v;</span><br><span class="line">e[e_num].c=c;</span><br><span class="line">e[e_num].next=head[u];</span><br><span class="line">head[u]=e_num;</span><br><span class="line">e_num++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">add(u,v,c);</span><br><span class="line">add(v,u,c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vis[u]=<span class="number">1</span>;</span><br><span class="line">    color[u]=c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];~i;i=e[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j=e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(!color[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!dfs(j, <span class="number">3</span>-c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(color[j]==c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line"><span class="built_in">memset</span>(color,<span class="number">0</span>,<span class="keyword">sizeof</span>(color));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(ver[i].c&gt;mid) insert(ver[i].a,ver[i].b,ver[i].c);<span class="comment">//如果大则连边</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line"><span class="keyword">if</span>(!dfs(i,<span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;ver[i].a,&amp;ver[i].b,&amp;ver[i].c);</span><br><span class="line">&#125;</span><br><span class="line">ll l=<span class="number">0</span>,r=<span class="number">1e14</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">mid=((l+r)&gt;&gt;<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(check()) ans=mid,r=mid<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要看类似题目可以看看这道： <a href="https://www.nowcoder.com/questionTerminal/e5e5e74a65c34d588421944029306e2e" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/e5e5e74a65c34d588421944029306e2e</a> (CodeForces 85E)</p><hr><h2 id="C-图2"><a href="#C-图2" class="headerlink" title="C-图2"></a>C-图2</h2><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><p>一个有向图，<code>N</code>个点编号<code>1~N</code>。<code>M</code>条边，每条边有一个权值<code>c</code>。</p><p>点<code>i</code>、<code>j</code>之间的最短路长度定义为 S<sub>ij</sub>。如果i、j不连通，则S<sub>ij</sub>=−1</p><p>输出所有使得S<sub>ij</sub>最大的i和j</p><p>时间限制：1000ms  内存限制：65536KB</p><h3 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h3><p>第一行一个整数t表示数据组数(t≤50)</p><p>对于每组数据：</p><p>第一行两个正整数N、M。(2≤N≤200,1≤M≤1000)</p><p>接下来M行，每行三个整数a,b,c，表示ab之间有一条权值为c的边（1≤a,b≤N,1≤c≤10<sup>3</sup>）</p><h3 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h3><p>输出所有使得S<sub>ij</sub>最大的i、j，每一对i、j输出一行，用空格隔开，按i的大小由小到大输出，i相同时按j的大小由小到大输出，</p><h3 id="输入样例-2"><a href="#输入样例-2" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">2 1</span><br><span class="line">1 2 3</span><br><span class="line">3 3</span><br><span class="line">1 2 2</span><br><span class="line">2 3 3</span><br><span class="line">3 1 5</span><br></pre></td></tr></table></figure><h3 id="输出样例-2"><a href="#输出样例-2" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2</span><br><span class="line">2 1</span><br></pre></td></tr></table></figure><hr><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>首先看题目可以确定是最短路径题目，接下来就是选算法的问题了(Dijkstra、spfa、Floyd)，显然这里要求所有顶点之间的最短路径，如果选择spfa和Dijkstra则需要求n次再来遍历判断，显然太麻烦了，所以我们显然选择Floyd即可(后文我也会附上Dijkstra的代码)。</p><p>本题需要注意的一些地方：首先是排序，读清楚题，怎么排序，再写cmp函数。其次就是每组数据的最大S<sub>ij</sub>不唯一，本人是采用循环找到前n个相同的最大值，再来输出，当然会有更好的方法。然后就是因为图权值最初设置为inf，因为又是要计算最大边，所以再Floyd算完之后，需要把仍然是inf的边置为-1，不影响后面的排序。最后呢就是注意Floyd算完之后需要存到另一个结构体数组里再进行排序会比较方便。</p><h3 id="AC代码-Floyd"><a href="#AC代码-Floyd" class="headerlink" title="AC代码(Floyd)"></a>AC代码(Floyd)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 1000000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max 205</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> i,j,c;</span><br><span class="line">&#125;ans[<span class="number">40005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">void</span> <span class="keyword">const</span> *a,<span class="keyword">void</span> <span class="keyword">const</span> *b)</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">c</span>,<span class="title">d</span>;</span></span><br><span class="line">c=*(struct node*)a;</span><br><span class="line">d=*(struct node*)b;</span><br><span class="line"><span class="keyword">if</span>(c.c!=d.c) <span class="keyword">return</span> d.c-c.c;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(c.i!=d.i) <span class="keyword">return</span> c.i-d.i;</span><br><span class="line"><span class="keyword">return</span> c.j-d.j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> e[<span class="built_in">max</span>][<span class="built_in">max</span>];</span><br><span class="line"><span class="keyword">int</span> t,n,m,M,cnt;</span><br><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">M=<span class="number">-2147483647</span>;</span><br><span class="line"><span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="keyword">sizeof</span>(ans));</span><br><span class="line">cnt=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i==j) e[i][j]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> e[i][j]=inf;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">e[a][b]=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=n; k++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line"><span class="keyword">if</span>(e[i][j]&gt;e[i][k]+e[k][j])</span><br><span class="line">e[i][j]=e[i][k]+e[k][j];<span class="comment">// Floyd</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(e[i][j]==inf) e[i][j]=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">ans[cnt].c=e[i][j];</span><br><span class="line">ans[cnt].i=i;</span><br><span class="line">ans[cnt].j=j;</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">qsort(ans,cnt,<span class="keyword">sizeof</span>(struct node),cmp);</span><br><span class="line"><span class="keyword">int</span> tmp=ans[<span class="number">0</span>].c,eid=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(ans[i].c==tmp) eid++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=eid;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,ans[i].i,ans[i].j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AC代码-Dijkstra"><a href="#AC代码-Dijkstra" class="headerlink" title="AC代码(Dijkstra)"></a>AC代码(Dijkstra)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max 2000</span></span><br><span class="line"><span class="keyword">int</span> INFINITY=<span class="number">1000000000</span>;</span><br><span class="line"><span class="keyword">int</span> MAX=<span class="number">-2147483647</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> i,j,c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">ans</span>[40005];</span></span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>,n,m;</span><br><span class="line"><span class="keyword">int</span> sweight[<span class="built_in">max</span>]=&#123;&#125;,<span class="built_in">map</span>[<span class="built_in">max</span>][<span class="built_in">max</span>],spath[<span class="built_in">max</span>],e[<span class="built_in">max</span>][<span class="built_in">max</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i==j) <span class="built_in">map</span>[i][j]=e[i][j]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">map</span>[i][j]=e[i][j]=INFINITY;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">void</span> <span class="keyword">const</span> *a,<span class="keyword">void</span> <span class="keyword">const</span> *b)</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">c</span>,<span class="title">d</span>;</span></span><br><span class="line">c=*(struct node*)a;</span><br><span class="line">d=*(struct node*)b;</span><br><span class="line"><span class="keyword">if</span>(c.c!=d.c) <span class="keyword">return</span> d.c-c.c;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(c.i!=d.i) <span class="keyword">return</span> c.i-d.i;</span><br><span class="line"><span class="keyword">return</span> c.j-d.j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> v0)</span></span>&#123;</span><br><span class="line">MAX=<span class="number">-2147483647</span>;</span><br><span class="line"><span class="keyword">int</span> i,j,v,minweight;</span><br><span class="line"><span class="keyword">char</span> wfound[<span class="built_in">max</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">sweight[i]=<span class="built_in">map</span>[v0][i];</span><br><span class="line">spath[i]=v0;</span><br><span class="line">&#125;</span><br><span class="line">sweight[v0]=<span class="number">0</span>;</span><br><span class="line">wfound[v0]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">minweight=INFINITY;</span><br><span class="line"><span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line"><span class="keyword">if</span> (!wfound[j]&amp;&amp;(sweight[j]&lt;minweight))&#123;</span><br><span class="line">v=j;</span><br><span class="line">minweight=sweight[j];</span><br><span class="line">&#125;</span><br><span class="line">wfound[v]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span> (!wfound[j]&amp;&amp;(minweight+<span class="built_in">map</span>[v][j]&lt;sweight[j]))&#123;</span><br><span class="line">sweight[j]=minweight+<span class="built_in">map</span>[v][j];</span><br><span class="line">spath[j]=v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">e[v0][i]=sweight[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">int</span> tmp,eid;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line"><span class="keyword">while</span>(T--) &#123;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="keyword">sizeof</span>(ans));</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line"><span class="built_in">map</span>[a][b]=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">Dijkstra(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(e[i][j]==INFINITY) e[i][j]=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">ans[cnt].c=e[i][j];</span><br><span class="line">ans[cnt].i=i;</span><br><span class="line">ans[cnt].j=j;</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">qsort(ans,cnt,<span class="keyword">sizeof</span>(struct node),cmp);</span><br><span class="line">tmp=ans[<span class="number">0</span>].c,eid=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(ans[i].c==tmp) eid++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=eid; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,ans[i].i,ans[i].j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dijkstra即多了几步，总体思想是不变的。</p><hr><h2 id="D-图3"><a href="#D-图3" class="headerlink" title="D-图3"></a>D-图3</h2><h3 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h3><p>一个无向图，<code>N</code>个点编号<code>1~N</code>。<code>M</code>条边，每条边有一个权值<code>c</code>。</p><p>问对于每条边，最少删除多少条边后，可以使得存在一个最小生成树包含这条边。</p><p>时间限制：1000ms  内存限制：65536KB</p><h3 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h3><p>第一行两个正整数N、M。(2≤N,M≤100)</p><p>接下来M行，每行三个整数a、b、c，表示ab之间存在一条权值为c的边。（1≤a,b≤N，1≤c≤500）</p><h3 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h3><p>输出一行M个数，数之间用空格隔开</p><h3 id="输入样例-3"><a href="#输入样例-3" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2 1</span><br><span class="line">3 1 2</span><br><span class="line">3 2 3</span><br></pre></td></tr></table></figure><h3 id="输出样例-3"><a href="#输出样例-3" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0 1</span><br></pre></td></tr></table></figure><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>首先分析题，要使最小生成树包含这条边。我们现在一直求最小生成树的方法也就两种，Kruskal和Prim算法。我们这道题显然就从Kruskal法来考虑比较方便(可能不是那么显然，先这样想)。Kruskal算法是通过先对边权值通过排序，从权值最小的边开始遍历每一条边，如果加入该边后，生成树仍然满足树的条件的话，则该边加入，如果构成了回路即不满足树的条件，则不增加该边，继续遍历。那对于本题呢，假设某边要存在一个最小生成树包含该边，按照Kruskal算法的过程，在枚举到该边之前，该边没有连通，即先枚举比该边权值小的所有边，然后再枚举该边，那要怎样保证该边一定在生成树里呢，即要保证该边加入后不形成回路，怎么保证呢，因为生成树的不唯一性，那就是要让该边的两个顶点(u,v)不连通，即u、v与其余所有比该边权值小的边的顶点组成一个图(容量为1，保证双向，因为仅求边的数量)，让u和v为源点和汇点，让u和v之间不连通即可，没有连通即割开，即求割，但是要保证删除的边最少，所以就是求最小割了，所以就是算最大流了，所以直接套板子就okk了。</p><p>需要注意的地方：首先，仍然一开始不建图，仅用一结构体存起来，等排完序后遍历时再存图，存图的时候也不要忘了把边的编号存起来，输出的时候需要用。然后是对每条边算了一遍最大流后，要把原图重新初始化一遍，以便存下一个图。之后是，有可能对某一条边来说，存在很多权值相等的边，权值相等的边是不能加入到图里的，但是排序对于权值相同的边并不敏感，所以需要自己判断一下，把权值相同的边先略去后，再建图。最后用数组存结果输出即可。</p><h3 id="AC代码-2"><a href="#AC代码-2" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max 10005</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> a,b,c,num;</span><br><span class="line">&#125;p[<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a&lt;b) <span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> v;</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line"><span class="keyword">int</span> next;</span><br><span class="line">&#125;e[<span class="built_in">max</span>];</span><br><span class="line"><span class="keyword">int</span> head[<span class="built_in">max</span>],e_num=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,S,T;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a,<span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">c</span>,<span class="title">d</span>;</span></span><br><span class="line">c=*(struct node*)a;</span><br><span class="line">d=*(struct node*)b;</span><br><span class="line"><span class="keyword">return</span> c.c-d.c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">e_num++;</span><br><span class="line">e[e_num].v=v;</span><br><span class="line">e[e_num].c=c;</span><br><span class="line">e[e_num].next=head[u];</span><br><span class="line">head[u]=e_num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">add(u,v,c);</span><br><span class="line">add(v,u,c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> depth[<span class="built_in">max</span>];<span class="comment">// 层次网络 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;<span class="comment">//定义一个bfs寻找分层图时的队列</span></span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) q.pop();</span><br><span class="line">    <span class="built_in">memset</span>(depth,<span class="number">-1</span>,<span class="keyword">sizeof</span>(depth));</span><br><span class="line">    depth[S]=<span class="number">0</span>;<span class="comment">//源点深度为0</span></span><br><span class="line">    q.push(S);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=e[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=e[i].v;</span><br><span class="line">            <span class="keyword">if</span>(e[i].c&gt;<span class="number">0</span>&amp;&amp;depth[v]==<span class="number">-1</span>)&#123;</span><br><span class="line">                q.push(v);</span><br><span class="line">                depth[v]=depth[u]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (depth[T]!=<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> flow)</span></span>&#123;        <span class="comment">//flow表示当前搜索分支的流量上限</span></span><br><span class="line">    <span class="keyword">if</span>(u==T)&#123;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=e[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(e[i].c&gt;<span class="number">0</span>&amp;&amp;depth[u]+<span class="number">1</span>==depth[v])&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=dfs(v,<span class="built_in">min</span>(flow,e[i].c));    <span class="comment">// 递归计算顶点 v，用 c(u, v) 来更新当前流量上限</span></span><br><span class="line">            flow-=tmp;</span><br><span class="line">            e[i].c-=tmp;</span><br><span class="line">            res+=tmp;</span><br><span class="line">            e[i^<span class="number">1</span>].c+=tmp;      <span class="comment">// 修改反向弧的容量</span></span><br><span class="line">            <span class="keyword">if</span>(flow==<span class="number">0</span>)&#123;        <span class="comment">// 流量达到上限，不必继续搜索了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(res==<span class="number">0</span>)&#123;     <span class="comment">// 当前没有经过顶点 u 的可行流，不再搜索顶点 u</span></span><br><span class="line">        depth[u]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">()</span></span>&#123;        <span class="comment">// 函数返回值就是最大流的结果</span></span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(bfs())&#123;</span><br><span class="line">        res+=dfs(S,INF);    <span class="comment">// 初始流量上限为 INF</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">505</span>]=&#123;&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);<span class="comment">//m为边</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;p[i].a,&amp;p[i].b,&amp;p[i].c);</span><br><span class="line">        p[i].num=i;</span><br><span class="line">    &#125;</span><br><span class="line">    qsort(p,m,<span class="keyword">sizeof</span>(struct node),cmp);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="built_in">memset</span>(e,<span class="number">0</span>,<span class="keyword">sizeof</span>(e));</span><br><span class="line">    e_num=<span class="number">-1</span>;</span><br><span class="line">    S=p[i].a,T=p[i].b;</span><br><span class="line">    <span class="keyword">for</span>(j=i;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[j].c==p[i].c) <span class="keyword">continue</span>;</span><br><span class="line">    insert(p[j].a,p[j].b,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">ans[p[i].num]=dinic();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,ans[i]);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="E-棋盘"><a href="#E-棋盘" class="headerlink" title="E-棋盘"></a>E-棋盘</h2><h3 id="题面-3"><a href="#题面-3" class="headerlink" title="题面"></a>题面</h3><p>一个<code>N</code>行，<code>M</code>列的棋盘。棋盘每个格子都是边长为1的正方形。</p><p>现在要在棋盘上放一些1×2大小的骨牌。骨牌的边线与格子重合（必须占2个格子），任意两个骨牌不能重叠。</p><p>但是棋盘上的一些格子已经被占用，请问最多可以放多少个骨牌。</p><p>时间限制：1000ms  内存限制：65536KB</p><h3 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h3><p>第一行三个正整数N、M、q。(2≤N,M≤100,0≤q≤1000)</p><p>接下来q行，每行两个整数a,b,表示第a行第b列的格子被占用（1≤a,b≤N）</p><h3 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h3><p>输出一行</p><h3 id="输入样例-4"><a href="#输入样例-4" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8 8 0</span><br></pre></td></tr></table></figure><h3 id="输出样例-4"><a href="#输出样例-4" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">32</span><br></pre></td></tr></table></figure><hr><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>首先我们看题，格子里放骨牌，<code>1*2</code>的骨牌，有些格子被占用，问最多的放法。可能刚看到这道题没什么思路，但我们可以从这个<code>1*2</code>看出一些东西，可以想到就是两个相邻的格子可以放一个骨牌，我们就可以看作一个格子和其所有相邻的格子之间存在一条边，容量为inf，并且该格子连接源点，容量为1，与其相邻的格子连接汇点，容量也为1，这样从源点到汇点的最大流即可以放的骨牌的方法数了。我们举一个例子：一个十字格子(5个格子)，把中间的格子连接源点，则其四周的格子都要连接汇点，那么此时的最大流显然就是1了，也就是方法数为1，同理就可以扩张为整个棋盘了。将所有i+j为奇数(i为行j为列)的点连源点，偶数连汇点相邻的连边，容量就不再赘述，然后求最大流即可。</p><p>需要注意的地方：首先就是存边，单纯的邻接矩阵肯定不行。然后就是那些被占用的点，用一个二维数组存行和列然后作为标记数组，标记的不存入图内即可。最后就是其实该题和练习赛A题几乎一样，并且更简单(想到方法的前提下)</p><h3 id="AC代码-3"><a href="#AC代码-3" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max 1000000</span></span><br><span class="line"><span class="keyword">int</span> num[<span class="number">1005</span>][<span class="number">1005</span>]=&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a&lt;b) <span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> v;</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line"><span class="keyword">int</span> next;</span><br><span class="line">&#125;e[<span class="built_in">max</span>];</span><br><span class="line"><span class="keyword">int</span> head[<span class="built_in">max</span>],e_num=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,S,T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">e_num++;</span><br><span class="line">e[e_num].v=v;</span><br><span class="line">e[e_num].c=c;</span><br><span class="line">e[e_num].next=head[u];</span><br><span class="line">head[u]=e_num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">add(u,v,c);</span><br><span class="line">add(v,u,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> depth[<span class="built_in">max</span>];<span class="comment">// 层次网络 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;<span class="comment">//定义一个bfs寻找分层图时的队列</span></span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) q.pop();</span><br><span class="line">    <span class="built_in">memset</span>(depth,<span class="number">-1</span>,<span class="keyword">sizeof</span>(depth));</span><br><span class="line">    depth[S]=<span class="number">0</span>;<span class="comment">//源点深度为0</span></span><br><span class="line">    q.push(S);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=e[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=e[i].v;</span><br><span class="line">            <span class="keyword">if</span>(e[i].c&gt;<span class="number">0</span>&amp;&amp;depth[v]==<span class="number">-1</span>)&#123;</span><br><span class="line">                q.push(v);</span><br><span class="line">                depth[v]=depth[u]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (depth[T]!=<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> flow)</span></span>&#123;        <span class="comment">//flow表示当前搜索分支的流量上限</span></span><br><span class="line">    <span class="keyword">if</span>(u==T)&#123;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=e[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(e[i].c&gt;<span class="number">0</span>&amp;&amp;depth[u]+<span class="number">1</span>==depth[v])&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=dfs(v,<span class="built_in">min</span>(flow,e[i].c));    <span class="comment">// 递归计算顶点 v，用 c(u, v) 来更新当前流量上限</span></span><br><span class="line">            flow-=tmp;</span><br><span class="line">            e[i].c-=tmp;</span><br><span class="line">            res+=tmp;</span><br><span class="line">            e[i^<span class="number">1</span>].c+=tmp;      <span class="comment">// 修改反向弧的容量</span></span><br><span class="line">            <span class="keyword">if</span>(flow==<span class="number">0</span>)&#123;        <span class="comment">// 流量达到上限，不必继续搜索了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(res==<span class="number">0</span>)&#123;     <span class="comment">// 当前没有经过顶点 u 的可行流，不再搜索顶点 u</span></span><br><span class="line">        depth[u]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">()</span></span>&#123;        <span class="comment">// 函数返回值就是最大流的结果</span></span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(bfs())&#123;</span><br><span class="line">        res+=dfs(S,INF);    <span class="comment">// 初始流量上限为 INF</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a,b,sum=<span class="number">0</span>,eid=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i,q;</span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line">    S=<span class="number">0</span>,T=n*m+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">num[a][b]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">        eid++;</span><br><span class="line">        <span class="keyword">if</span>(!num[i][j])&#123;</span><br><span class="line">        <span class="keyword">if</span>((i+j)%<span class="number">2</span>)&#123;</span><br><span class="line">insert(S,eid,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(j&lt;m) insert(eid,eid+<span class="number">1</span>,INF);</span><br><span class="line"><span class="keyword">if</span>(j&gt;<span class="number">1</span>) insert(eid,eid<span class="number">-1</span>,INF);</span><br><span class="line"><span class="keyword">if</span>(i&lt;n) insert(eid,eid+m,INF);</span><br><span class="line"><span class="keyword">if</span>(i&gt;<span class="number">1</span>) insert(eid,eid-m,INF);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">insert(eid,T,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,dinic());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="F-垃圾粉碎机"><a href="#F-垃圾粉碎机" class="headerlink" title="F-垃圾粉碎机"></a>F-垃圾粉碎机</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>垃圾分类快来了，垃圾场主某楠希望赶在垃圾分类之前将厂里的垃圾全部粉碎填埋。为此场长专门去租了n台垃圾粉碎机，每种垃圾粉碎机都有一个最长使用时间ti，在这段时间里总共可以处理mi吨垃圾,可以在任意时间使用任意时长，但是用完就不能再用。由于场里太穷，同一时间只能运行一台垃圾粉碎机，现在想问在垃圾分类来临之前，最多能粉碎多少垃圾。为了简化计算，所有时间单位以小时计算。</p><p> 时间限制：1000ms  内存限制：65536KB </p><h3 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h3><p>前两个数为垃圾粉碎机的个数N和距离垃圾分类来临时间T小时</p><p>接下来N行每行2个整数，对应的ti和mi</p><p>所有数字均不大于1e5</p><h3 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h3><p>输出一行，能处理的垃圾最大重量，保留2位小数，单位为吨</p><h3 id="输入样例-5"><a href="#输入样例-5" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><h3 id="输出样例-5"><a href="#输出样例-5" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.00</span><br></pre></td></tr></table></figure><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>读题就能看出这是一道非常明显的分数背包题，就直接贪心算法就可解决了，根据m<sub>i</sub>/t<sub>i</sub>的商进行排序即可，然后遍历输出搞定。</p><p>如果对其他背包问题还有问题的朋友可以查看本人的另一篇博文: <a href="https://dbettkk.github.io/2019/11/11/动态规划-DP-——背包问题/#more" target="_blank" rel="noopener">https://dbettkk.github.io/2019/11/11/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-DP-%E2%80%94%E2%80%94%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/#more</a> </p><h3 id="AC代码-4"><a href="#AC代码-4" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max 100005</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">double</span> t;</span><br><span class="line"><span class="keyword">double</span> m;</span><br><span class="line"><span class="keyword">double</span> a;</span><br><span class="line">&#125;dp[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">void</span> <span class="keyword">const</span> *a,<span class="keyword">void</span> <span class="keyword">const</span> *b)</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">c</span>,<span class="title">d</span>;</span></span><br><span class="line">c=*(struct node*)a;</span><br><span class="line">d=*(struct node*)b;</span><br><span class="line"><span class="keyword">return</span> c.a&lt;d.a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,T,i;</span><br><span class="line"><span class="keyword">double</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;T);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>,&amp;dp[i].t,&amp;dp[i].m);</span><br><span class="line">dp[i].a=dp[i].m/dp[i].t;</span><br><span class="line">&#125;</span><br><span class="line">qsort(dp,n,<span class="keyword">sizeof</span>(struct node),cmp);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(dp[i].t&lt;=T)&#123;</span><br><span class="line">ans+=dp[i].m;</span><br><span class="line">T-=dp[i].t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">ans+=T*dp[i].a;</span><br><span class="line">T=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.2lf"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="G-小面包"><a href="#G-小面包" class="headerlink" title="G-小面包"></a>G-小面包</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>又要发小面包了。这次我们有许多<code>3*6</code>的小面包和<code>6*6</code>的方糕，以及一个<code>6*N</code>的长方形盒子，强迫症的某楠一定要把它们整齐的装到盒子里，并且要尽量装满。请问有多少总不同装法？</p><p> 时间限制：1000ms  内存限制：65536KB </p><h3 id="输入-6"><a href="#输入-6" class="headerlink" title="输入"></a>输入</h3><p>多组数据输入。 每组一个3的倍数N（0&lt;=N&lt;=750）</p><h3 id="输出-6"><a href="#输出-6" class="headerlink" title="输出"></a>输出</h3><p>对于每组数据，输出一行，为最终计算对1000007取模得到的结果。</p><h3 id="输入样例-6"><a href="#输入样例-6" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">6</span><br></pre></td></tr></table></figure><h3 id="输出样例-6"><a href="#输出样例-6" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h3><p>输入为3时，只能放入一块小面包。</p><p>输入为6时，有三种情况：</p><p>（1）竖着放两块小面包</p><p>（2）横着放两块小面包</p><p>（3）放一块方糕</p><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><p>首先因为输入的n是3的倍数，所以我们可以将问题简化为<code>2*n</code>的盒子装<code>1*2</code>和<code>2*2</code>的方糕的问题。然后我们开始寻找递推关系。假设<code>n</code>对应有<code>f(n)</code>种装法，那么如果我们首先装<code>1*2</code>的空间，那就相当于只能装<code>1*2</code>的方糕，那么对应就是解决<code>f(n-1)</code>的问题，那如果我们先装<code>2*2</code>的空间，那么可以有两种装法，两个<code>1*2</code>的方糕横着摆放和一个<code>2*2</code>的方糕(有朋友可能会问为什么两个<code>1*2</code>的方糕竖着摆放的情况不算，因为这种情况实际上是属于我们前面提到的先装<code>1*2</code>的空间的情况，如果这里再算一遍就重复了)，所以就相当于解决<code>2*f(n-2)</code>的问题即可。然后如果是装<code>3*2</code>的空间，那么不就是等效于<code>1*(2*2)</code>的情况和<code>2*(1*2)</code>的情况吗，所以我们就找到递推关系了，如下：</p><ul><li>f(n)=f(n-1)+2*f(n-2)</li></ul><p>当然大家也可先推一推前面几种情况然后找规律也是可以解决的，只是这个找规律比较靠运气。</p><h3 id="AC代码-5"><a href="#AC代码-5" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,a[<span class="number">755</span>];</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)) &#123;</span><br><span class="line">a[<span class="number">1</span>]=<span class="number">1</span>,a[<span class="number">0</span>]=<span class="number">1</span>,a[<span class="number">2</span>]=<span class="number">3</span>,a[<span class="number">3</span>]=<span class="number">5</span>,a[<span class="number">4</span>]=<span class="number">11</span>;<span class="comment">// 这是推出的前几种情况，实际不需要这么多</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n/<span class="number">3</span>; i++) &#123;</span><br><span class="line">a[i]=(a[i<span class="number">-1</span>]+<span class="number">2</span>*a[i<span class="number">-2</span>])%<span class="number">1000007</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,(a[n/<span class="number">3</span>])%<span class="number">1000007</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="H-点线面"><a href="#H-点线面" class="headerlink" title="H-点线面"></a>H-点线面</h2><h3 id="题面-4"><a href="#题面-4" class="headerlink" title="题面"></a>题面</h3><p>二维平面上有n个点。现在用一根（毛）线将这些点围起来，问线的最小长度和围起来的面积。</p><p> 时间限制：1000ms  内存限制：65536KB</p><h3 id="输入-7"><a href="#输入-7" class="headerlink" title="输入"></a>输入</h3><p>第一行一个正整数N。(2≤N≤100000)</p><p>接下来N行，每行两个整数a，b，表示一个点的坐标。（−10<sup>6</sup>≤a,b≤10<sup>6</sup>）</p><h3 id="输出-7"><a href="#输出-7" class="headerlink" title="输出"></a>输出</h3><p>输出一行一个数，保留两位小数。</p><h3 id="输入样例-7"><a href="#输入样例-7" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">0 0</span><br><span class="line">0 4</span><br><span class="line">3 0</span><br><span class="line">1 1</span><br></pre></td></tr></table></figure><h3 id="输出样例-7"><a href="#输出样例-7" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12.00 6.00</span><br></pre></td></tr></table></figure><h3 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h3><p>刚上了计算几何，应该都能看出这就一道凸包板子题。当然如果有和我一样没有很认真听的可以看下我下方的分析。</p><p>凸包怎么实现呢，首先确定平面中最下方的点，这个点肯定是在凸包内的，然后再以这个点为基点对其余所有点进行极角排序，即将其余点与该点进行连线后，对连线与x轴的夹角进行排序。排了序后，将夹角最小的点入栈，然后遍历所有其他点，若此点在栈顶的点的左边(实际是栈顶两个点连线的左边)，则压栈，若在右边(同理)，则将栈顶出栈然后把此点压栈，遍历结束后，栈中的点即为凸包上的点。还有就是如何判断在点的左边还是右边的问题了，用叉积即可。比如，<code>a(x1,y1)</code>和<code>b(x2,y2)</code>和<code>c(x3,y3)</code>，判断c相对于ab的位置，那就是相当于判断<code>x1*y2+x2*y3+x3*y1</code>和<code>x1*y3+x2*y1+x3*y2</code> 的大小即可。求出栈后，周长直接遍历算即可，面积则遍历求叉积相加即可(别忘除以2)。</p><p>参考： <a href="https://www.cnblogs.com/Gaxc/p/9610900.html" target="_blank" rel="noopener">https://www.cnblogs.com/Gaxc/p/9610900.html</a> </p><h3 id="AC代码-6"><a href="#AC代码-6" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">double</span> x,y;</span><br><span class="line">&#125; a[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> n,p,st[<span class="number">100005</span>],top;</span><br><span class="line"><span class="keyword">double</span> ans,miny=<span class="number">2e9</span>,minx=<span class="number">2e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(node b,node c)</span> </span>&#123; <span class="comment">//极角排序</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>((b.y-miny)*(c.x-minx)-(c.y-miny)*(b.x-minx))&lt;=<span class="number">1e-8</span>) <span class="keyword">return</span> <span class="built_in">fabs</span>(minx-b.x)&lt;<span class="built_in">fabs</span>(minx-c.x);</span><br><span class="line"><span class="keyword">return</span> (b.y-miny)*(c.x-minx)&lt;(c.y-miny)*(b.x-minx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span> </span>&#123; <span class="comment">//叉积判断</span></span><br><span class="line"><span class="keyword">return</span> ((a[b].x*a[c].y)+(a[c].x*a[d].y)+(a[d].x*a[b].y)-(a[b].x*a[d].y)-(a[c].x*a[b].y)-(a[d].x*a[c].y))&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dist</span><span class="params">(<span class="keyword">double</span> x1,<span class="keyword">double</span> y1,<span class="keyword">double</span> x2,<span class="keyword">double</span> y2)</span> </span>&#123; <span class="comment">//计算两点间的距离</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sqrt</span>((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">rint i;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=n; ++i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>,&amp;a[i].x,&amp;a[i].y);</span><br><span class="line"><span class="keyword">if</span> (a[i].y&lt;miny) &#123; <span class="comment">//寻找最下方的点</span></span><br><span class="line">miny=a[i].y;</span><br><span class="line">minx=a[i].x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp); <span class="comment">//极角排序</span></span><br><span class="line">st[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">st[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">top=<span class="number">2</span>; <span class="comment">//将两个点加入栈中</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">3</span>; i&lt;=n; ++i) &#123; <span class="comment">//扫描</span></span><br><span class="line"><span class="keyword">while</span> (!check(st[top<span class="number">-1</span>],st[top],i)) top--;</span><br><span class="line">st[++top]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">2</span>; i&lt;=top; ++i) <span class="comment">//计算答案</span></span><br><span class="line">ans+=dist(a[st[i<span class="number">-1</span>]].x,a[st[i<span class="number">-1</span>]].y,a[st[i]].x,a[st[i]].y);</span><br><span class="line">ans+=dist(a[st[top]].x,a[st[top]].y,a[<span class="number">1</span>].x,a[st[<span class="number">1</span>]].y);</span><br><span class="line"><span class="keyword">double</span> area=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;top;i++)&#123;</span><br><span class="line">area+=(a[st[i]].x*a[st[i+<span class="number">1</span>]].y-a[st[i+<span class="number">1</span>]].x*a[st[i]].y);</span><br><span class="line">&#125; </span><br><span class="line">area+=(a[st[top]].x*a[st[<span class="number">1</span>]].y-a[st[<span class="number">1</span>]].x*a[st[top]].y);</span><br><span class="line">area/=<span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.2lf %.2lf"</span>,ans,area);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h2><p><a href="https://accoding.cn/index" target="_blank" rel="noopener">北航OJ</a></p><hr><hr>]]></content>
      
      
      <categories>
          
          <category> 综合题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>约瑟夫环</title>
      <link href="/2019/11/17/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/"/>
      <url>/2019/11/17/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>主要是之前一直不知道约瑟夫环的dp解法，这里和大家分享一下。本文用三种方法给大家呈现本题。</p><a id="more"></a><h2 id="最后一条毛毛虫"><a href="#最后一条毛毛虫" class="headerlink" title="最后一条毛毛虫"></a>最后一条毛毛虫</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>小D的花园里养了 n 条毛毛虫，每条毛毛虫都有自己独有的编号（从 1 到 n ）。</p><p>一开始，所有的毛毛虫都开开心心地生活在花园里，享受着食物和阳光。</p><p>直到某一天，额……它们知道自己肯定会被吃掉，所以就开始玩一个游戏，来决定被吃的顺序。游戏的方法是这样的：</p><p>所有毛毛虫按照编号顺序从 11 到 n 顺时针围成一个环，然后从 1 号毛毛虫开始顺时针依次报数，报到数字 m 的毛毛虫就出环被吃，下一条毛毛虫继续从 1 开始顺时针报数……直到所有毛毛虫都出环被吃。</p><p>那么，最后一条被吃的毛毛虫的编号是多少呢？</p><p> 时间限制：1000ms，内存限制：65536KB</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>两个正整数 n,m ，意义如题所示。</p><p>输入数据保证： 1≤n,m≤3000。</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>一个正整数，代表最后一条被吃的毛毛虫的编号。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 3</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h3><p>毛毛虫被吃的顺序依次为：3、1、5、2、4 。</p><h3 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h3><p><a href="accoding.cn">北航OJ</a></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>(1) 首先很显然最简单的约瑟夫环问题，肯定用最容易理解的方法就是循环链表了。通过指针遍历、删除来完成每次的报数和出局环节，最后只剩一条毛毛虫时，就结束就可以了。虽然非常容易理解，但是代码比较长，时间花费也比较高(和后面介绍的方法相比)，但本题的限制还是可以随便AC的。代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">p</span>,*<span class="title">r</span>,*<span class="title">head</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">head=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        r=(struct node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct node));</span><br><span class="line">        r-&gt;num=i;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="literal">NULL</span>)</span><br><span class="line">            head=p=r;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            p-&gt;next=r;          </span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next=head;</span><br><span class="line">    r=p;</span><br><span class="line">    p=head;</span><br><span class="line">   <span class="keyword">while</span>(p-&gt;next!=p)&#123;</span><br><span class="line">         <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m<span class="number">-1</span>;i++)&#123;</span><br><span class="line">               r=p;</span><br><span class="line">               p=p-&gt;next;</span><br><span class="line">          &#125;</span><br><span class="line">          r-&gt;next=p-&gt;next;</span><br><span class="line">          <span class="built_in">free</span>(p);</span><br><span class="line">          p=r-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d"</span>, p-&gt;num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">insert(n,m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2) 第二第三种方法本质一样，只是实现方式有所区别。都是通过数学方法进行一些推导得到的。首先我们假设编号从0开始，最后求出的答案再加1就好了，所以可以知道在第一次中，肯定是叫到(m-1)%n的会出局，那么第一次出局的下一个肯定就是m%n了，如果把他当作0号，那剩下的n-1个人又组成了一个新的约瑟夫环，此时出局的就是(m-1)%(n-1)，但是因为现在的0号并不是0号，而是m%n号，所以我们得到的胜利者还要加回去，也就是((m-1)%(n-1)+m%n)%n，如果我们把第n-1次胜利者看作f(n-1)的话，那第n次的胜利者肯定就是(f(n-1)+m%n)%n，那对于第三次开始叫号也就是同样的道理，胜利者编号就为((f(n-2)+m%(n-1))%(n-1)+m%n)%n，可以看出是有规律的，我们用式子写出来就是f(n)=(f(n-1)+m%n)%n，f(n-1)=(f(n-2)+m%(n-1))%(n-1)，化简得到就一个式子f(n)=(f(n-1)+m)%n，对于n∈[0,n]都是成立的。那么我们就可以写递归代码了，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> (func(n<span class="number">-1</span>)+m)%n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,func(n) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3) 但是这样递归，其实多了很多重复计算的步骤，是可以优化的，即DP，所以转移方程也就是上文提到的<code>f(n)=(f(n-1)+m)%n</code>，甚至不需要数组来存，直接就能出来，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,s=<span class="number">0</span>,i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    s=(s+m)%i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>有谬误敬请指出，敬请不吝赐教</p><hr><hr>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解篇-E3</title>
      <link href="/2019/11/17/%E9%A2%98%E8%A7%A3%E7%AF%87-E3/"/>
      <url>/2019/11/17/%E9%A2%98%E8%A7%A3%E7%AF%87-E3/</url>
      
        <content type="html"><![CDATA[<h2 id="A-网络流来了"><a href="#A-网络流来了" class="headerlink" title="A-网络流来了"></a>A-网络流来了</h2><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>想哥带着叶姐去了游乐园，有个项目可以让他们在一个m*n (m,n&lt;=30)方格中，取走一些礼物，同时要求任意2个取走的礼物所在方格没有公共边，且取出的礼物让叶姐的满意度最大。</p><p>想哥忙于学(lian)习(ai)，难以完成，所以求助于你。</p><p>时间限制：1000ms，内存限制：65536KB</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>第1行有2个正整数m和n，分别表示棋盘的行数和列数。</p><p>接下来的m行，每行有n个正整数，表示方格中的礼物的满意度。</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p> 输出一行，为最大满意度 </p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2 3</span><br><span class="line">3 2 3</span><br><span class="line">2 3 1</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure><h3 id="AC代码-EK"><a href="#AC代码-EK" class="headerlink" title="AC代码(EK)"></a>AC代码(EK)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> n,m,start,<span class="built_in">end</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">35</span>][<span class="number">35</span>],<span class="built_in">map</span>[<span class="number">1000</span>][<span class="number">1000</span>],path[<span class="number">1500</span>],flow[<span class="number">1500</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line"><span class="built_in">map</span>[u][v]=c;</span><br><span class="line"><span class="built_in">map</span>[v][u]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EK_bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,t;</span><br><span class="line"><span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line"><span class="built_in">memset</span>(path,<span class="number">-1</span>,<span class="keyword">sizeof</span>(path));</span><br><span class="line">path[start]=<span class="number">0</span>;</span><br><span class="line">flow[start]=INF;</span><br><span class="line">q.push(start);</span><br><span class="line"><span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">t=q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">if</span>(t==<span class="built_in">end</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=<span class="built_in">end</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i!=start &amp;&amp; path[i]==<span class="number">-1</span> &amp;&amp; <span class="built_in">map</span>[t][i]) &#123;</span><br><span class="line">flow[i]=flow[t]&lt;<span class="built_in">map</span>[t][i]?flow[t]:<span class="built_in">map</span>[t][i];<span class="comment">// 更新流量，但不能超过容量，取更小 </span></span><br><span class="line">q.push(i);</span><br><span class="line">path[i]=t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(path[<span class="built_in">end</span>]==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> flow[<span class="built_in">end</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EK</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> max_flow=<span class="number">0</span>,<span class="built_in">step</span>,now,pre;</span><br><span class="line"><span class="keyword">while</span>((<span class="built_in">step</span>=EK_bfs())!=<span class="number">-1</span>) &#123;</span><br><span class="line">max_flow+=<span class="built_in">step</span>;</span><br><span class="line">now=<span class="built_in">end</span>;</span><br><span class="line"><span class="keyword">while</span>(now!=start) &#123;</span><br><span class="line">pre=path[now];</span><br><span class="line"><span class="built_in">map</span>[pre][now]-=<span class="built_in">step</span>;<span class="comment">// 更新残余网络，因为流更新后，残余网络也更新了 </span></span><br><span class="line"><span class="built_in">map</span>[now][pre]+=<span class="built_in">step</span>;</span><br><span class="line">now=pre;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max_flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,cnt=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> S,T;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m,&amp;n);</span><br><span class="line">S=<span class="number">0</span>,T=n*m+<span class="number">1</span>;</span><br><span class="line">start=S,<span class="built_in">end</span>=T;</span><br><span class="line"><span class="built_in">memset</span>(<span class="built_in">map</span>,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="built_in">map</span>));</span><br><span class="line"><span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i][j]);</span><br><span class="line">sum+=a[i][j];</span><br><span class="line">cnt++;</span><br><span class="line"><span class="keyword">if</span>((i+j)%<span class="number">2</span>)&#123;</span><br><span class="line">insert(S,cnt,a[i][j]);</span><br><span class="line"><span class="keyword">if</span>(j&lt;n) insert(cnt,cnt+<span class="number">1</span>,INF);</span><br><span class="line"><span class="keyword">if</span>(j&gt;<span class="number">1</span>) insert(cnt,cnt<span class="number">-1</span>,INF);</span><br><span class="line"><span class="keyword">if</span>(i&lt;m) insert(cnt,cnt+n,INF);</span><br><span class="line"><span class="keyword">if</span>(i&gt;<span class="number">1</span>) insert(cnt,cnt-n,INF);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">insert(cnt,T,a[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,sum-EK());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AC代码-Dinic"><a href="#AC代码-Dinic" class="headerlink" title="AC代码(Dinic)"></a>AC代码(Dinic)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max 1000000</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a&lt;b) <span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> v;</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line"><span class="keyword">int</span> next;</span><br><span class="line">&#125;e[<span class="built_in">max</span>];</span><br><span class="line"><span class="keyword">int</span> head[<span class="built_in">max</span>],e_num=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,S,T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">e_num++;</span><br><span class="line">e[e_num].v=v;</span><br><span class="line">e[e_num].c=c;</span><br><span class="line">e[e_num].next=head[u];</span><br><span class="line">head[u]=e_num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">add(u,v,c);</span><br><span class="line">add(v,u,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> depth[<span class="built_in">max</span>];<span class="comment">// 层次网络 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;<span class="comment">//定义一个bfs寻找分层图时的队列</span></span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) q.pop();</span><br><span class="line">    <span class="built_in">memset</span>(depth,<span class="number">-1</span>,<span class="keyword">sizeof</span>(depth));</span><br><span class="line">    depth[S]=<span class="number">0</span>;<span class="comment">//源点深度为0</span></span><br><span class="line">    q.push(S);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=e[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=e[i].v;</span><br><span class="line">            <span class="keyword">if</span>(e[i].c&gt;<span class="number">0</span>&amp;&amp;depth[v]==<span class="number">-1</span>)&#123;</span><br><span class="line">                q.push(v);</span><br><span class="line">                depth[v]=depth[u]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (depth[T]!=<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> flow)</span></span>&#123;        <span class="comment">//flow表示当前搜索分支的流量上限</span></span><br><span class="line">    <span class="keyword">if</span>(u==T)&#123;</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=e[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(e[i].c&gt;<span class="number">0</span>&amp;&amp;depth[u]+<span class="number">1</span>==depth[v])&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=dfs(v,<span class="built_in">min</span>(flow,e[i].c));    <span class="comment">// 递归计算顶点 v，用 c(u, v) 来更新当前流量上限</span></span><br><span class="line">            flow-=tmp;</span><br><span class="line">            e[i].c-=tmp;</span><br><span class="line">            res+=tmp;</span><br><span class="line">            e[i^<span class="number">1</span>].c+=tmp;      <span class="comment">// 修改反向弧的容量</span></span><br><span class="line">            <span class="keyword">if</span>(flow==<span class="number">0</span>)&#123;        <span class="comment">// 流量达到上限，不必继续搜索了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(res==<span class="number">0</span>)&#123;     <span class="comment">// 当前没有经过顶点 u 的可行流，不再搜索顶点 u</span></span><br><span class="line">        depth[u]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">()</span></span>&#123;        <span class="comment">// 函数返回值就是最大流的结果</span></span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(bfs())&#123;</span><br><span class="line">        res+=dfs(S,INF);    <span class="comment">// 初始流量上限为 INF</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">35</span>][<span class="number">35</span>],sum=<span class="number">0</span>,eid=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m,&amp;n);</span><br><span class="line">    S=<span class="number">0</span>,T=n*m+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i][j]);</span><br><span class="line">        sum+=a[i][j];</span><br><span class="line">        eid++;</span><br><span class="line"><span class="keyword">if</span>((i+j)%<span class="number">2</span>)&#123;</span><br><span class="line">insert(S,eid,a[i][j]);</span><br><span class="line"><span class="keyword">if</span>(j&lt;n) insert(eid,eid+<span class="number">1</span>,INF);</span><br><span class="line"><span class="keyword">if</span>(j&gt;<span class="number">1</span>) insert(eid,eid<span class="number">-1</span>,INF);</span><br><span class="line"><span class="keyword">if</span>(i&lt;m) insert(eid,eid+n,INF);</span><br><span class="line"><span class="keyword">if</span>(i&gt;<span class="number">1</span>) insert(eid,eid-n,INF);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">insert(eid,T,a[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,sum-dinic());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先要弄明白是怎么化成最大流(最小割)问题的，由题可知，相邻的不让取，因此可以想到分开染色再建图即可，将一部分染成黑色，与其相邻的染成白色，然后将这些看成顶点分开放置，黑色连接源点，边权即黑色点点权(即礼物满意度)，白色连接汇点(边权等于点权同理)，相邻的黑色和白色连边，边权为INF(最大值)，然后因为要让不相邻的满意度和最大，所以即把相邻的满意度和最小求出来即可，而相邻的满意度即对应我们所建图的割(如果想不明白可以自己画图割一割)，所以我们要让相邻的满意度和最小，即求最小割即可，所以就是让我们求我们所建图的最大流，最后再用所有满意度之和减去最大流即为答案，所以套板子即可(EK、Dinic均可)。</p><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>需要注意建图时怎样更方便，即相邻染色怎么染的问题。</p><hr><h2 id="B-婚车"><a href="#B-婚车" class="headerlink" title="B-婚车"></a>B-婚车</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>航哥是个土豪，他想在让城市布满他的婚车。但是城市的每条道路单位时间能通过的婚车是有限的，超出则会造成拥堵。他在1号点屯了足够数量的车子，他想知道从城市1号点派出婚车去n号点迎接新娘，在买通交警只允许他的婚车在车道上行驶的条件下，足够多时间之后，n号点单位时间内最多能容纳多少量婚车。</p><p>道路都是双向的</p><p>时间限制：1000ms，内存限制：65536KB</p><h3 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h3><p>第一行两个整数，n和m，n为点数，m为边数，点的标号为1~n。</p><p>接下来M行，每行三个整数a, b, c, 表示城市中两个点之间有一条单位时间最多通行c辆车的道路。</p><p>建图连边之前请注意审题……</p><p>1≤n≤1000</p><p>1≤m≤100000</p><p>1≤a,b≤n,a≠b</p><p>1≤c≤10</p><h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><p>  输出一个整数，点n处单位时间内最多接受的婚车数量。 </p><h3 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">4 6</span><br><span class="line">1 2 5</span><br><span class="line">1 3 2</span><br><span class="line">1 4 3</span><br><span class="line">2 3 3</span><br><span class="line">2 4 3</span><br><span class="line">3 4 10</span><br></pre></td></tr></table></figure><h3 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> n,m,tend,start;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">1001</span>][<span class="number">1001</span>],path[<span class="number">1001</span>],flow[<span class="number">1001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EK_bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,t;</span><br><span class="line"><span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line"><span class="built_in">memset</span>(path,<span class="number">-1</span>,<span class="keyword">sizeof</span>(path));</span><br><span class="line">path[start]=<span class="number">0</span>;</span><br><span class="line">flow[start]=INF;</span><br><span class="line">q.push(start);</span><br><span class="line"><span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">t=q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">if</span>(t==tend) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i!=start &amp;&amp; path[i]==<span class="number">-1</span> &amp;&amp; <span class="built_in">map</span>[t][i]) &#123;</span><br><span class="line">flow[i]=flow[t]&lt;<span class="built_in">map</span>[t][i]?flow[t]:<span class="built_in">map</span>[t][i];</span><br><span class="line">q.push(i);</span><br><span class="line">path[i]=t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(path[tend]==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> flow[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EK</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> max_flow=<span class="number">0</span>,<span class="built_in">step</span>,now,pre;</span><br><span class="line"><span class="keyword">while</span>((<span class="built_in">step</span>=EK_bfs())!=<span class="number">-1</span>) &#123;</span><br><span class="line">max_flow+=<span class="built_in">step</span>;</span><br><span class="line">now=tend;</span><br><span class="line"><span class="keyword">while</span>(now!=start) &#123;</span><br><span class="line">pre=path[now];</span><br><span class="line"><span class="built_in">map</span>[pre][now]-=<span class="built_in">step</span>;</span><br><span class="line"><span class="built_in">map</span>[now][pre]+=<span class="built_in">step</span>;</span><br><span class="line">now=pre;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max_flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,a,b,c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">tend=n,start=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(<span class="built_in">map</span>,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="built_in">map</span>));</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line"><span class="built_in">map</span>[a][b]=c;</span><br><span class="line"><span class="built_in">map</span>[b][a]=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,EK());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>从题目描述可以非常清晰的知道是一道间的最大流问题，直接套板子即可(EK,Dinic均可，这里只提供EK)，唯一需要注意的就是道路是双向的，即双向边。还有就是这道题EK如果初始化不用memset可能会超时，用Dinic没有任何问题。</p><hr><h2 id="C-要成为魔法少女吗"><a href="#C-要成为魔法少女吗" class="headerlink" title="C-要成为魔法少女吗"></a>C-要成为魔法少女吗</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>酸奶酱是一位魔法少女，并且她很热衷于点化她的其他小伙伴和她一起成为魔法少女。</p><p>现在有一个棘手的问题摆在酸奶酱面前——她有M套成为魔法少女不可缺少的魔法战斗服，以及N个想成为魔法少女的小伙伴。魔法战斗服是有灵性的，它有想要跟随的主人。酸奶酱想尽可能多的把更多的魔法战斗服分给她的小伙伴，她现在想知道最多能有几套魔法战斗服能被交到她的小伙伴手里。</p><p>注意：一位小伙伴只能拿一件魔法战斗服，一件魔法战斗服也只能交给一位小伙伴。</p><p>时间限制：1000ms，内存限制：65536KB</p><h3 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h3><p>第一行为两个整数N和M，分别表示小伙伴的数量和魔法战斗服的数量。（0&lt;=N，M&lt;=100）</p><p>接下来M行，第i行的第一个整数K表示第i件魔法战斗服想要跟随的主人的数量。接下来K个整数num，表示魔法战斗服想要跟随的主人编号。（0&lt;=K，num&lt;=N）</p><h3 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h3><p>对于每组数据，输出一行，为最多能送出的魔法战斗服的数量。</p><h3 id="输入样例-2"><a href="#输入样例-2" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3 4</span><br><span class="line">1 2</span><br><span class="line">3 1 2 3</span><br><span class="line">1 1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="输出样例-2"><a href="#输出样例-2" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="AC代码-最大二分匹配"><a href="#AC代码-最大二分匹配" class="headerlink" title="AC代码(最大二分匹配)"></a>AC代码(最大二分匹配)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>,n,m;</span><br><span class="line"><span class="keyword">int</span> link[<span class="number">1005</span>],use[<span class="number">1005</span>],<span class="built_in">map</span>[<span class="number">105</span>][<span class="number">105</span>];<span class="comment">//map数组为邻接矩阵，use表示当前点是否匹配，link[i]表示与顶点i所连的点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!use[i]&amp;&amp; <span class="built_in">map</span>[x][i]) &#123; <span class="comment">//若不在交替路中</span></span><br><span class="line">use[i] = <span class="number">1</span>;<span class="comment">//则加入交替路</span></span><br><span class="line"><span class="keyword">if</span>(!link[i] || dfs(link[i])) &#123;</span><br><span class="line">link[i] = x;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xyl</span><span class="params">( )</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(link, <span class="number">0</span>, <span class="keyword">sizeof</span>(link));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="built_in">memset</span>(use,<span class="number">0</span>,<span class="keyword">sizeof</span>(use));</span><br><span class="line"><span class="keyword">if</span>(dfs(i)) ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,k,num;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10005</span>],b[<span class="number">10005</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">ans=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(<span class="built_in">map</span>, <span class="literal">false</span>, <span class="keyword">sizeof</span>(<span class="built_in">map</span>));</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num);</span><br><span class="line"><span class="built_in">map</span>[i][num]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*for(i=1; i&lt;=n; i++) &#123;</span></span><br><span class="line"><span class="comment">scanf("%d",&amp;a[i]);</span></span><br><span class="line"><span class="comment">map[i][a[i]]=true;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">for(i=1; i&lt;=n; i++) &#123;</span></span><br><span class="line"><span class="comment">scanf("%d",&amp;b[i]);</span></span><br><span class="line"><span class="comment">map[b[i]][i]=true;</span></span><br><span class="line"><span class="comment">&#125; //输入map*/</span></span><br><span class="line">xyl();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);<span class="comment">// ans为最大匹配数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AC代码-贪心"><a href="#AC代码-贪心" class="headerlink" title="AC代码(贪心)"></a>AC代码(贪心)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> times[<span class="number">105</span>]=&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">105</span>];</span><br><span class="line">&#125;a[<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a,<span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum1=<span class="number">0</span>,sum2=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">c</span>,<span class="title">d</span>;</span></span><br><span class="line">c=*(struct node *)a;</span><br><span class="line">d=*(struct node *)b;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;c.k;i++) sum1+=times[c.num[i]];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;d.k;i++) sum2+=times[d.num[i]];</span><br><span class="line"><span class="keyword">if</span>(c.k!=d.k) <span class="keyword">return</span> c.k&gt;d.k;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> sum1&gt;sum2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a,<span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> c,d;</span><br><span class="line">c=*(<span class="keyword">int</span> *)a;</span><br><span class="line">d=*(<span class="keyword">int</span> *)b;</span><br><span class="line"><span class="keyword">return</span> times[c]&gt;times[d];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,m,i,j,ans=<span class="number">0</span>,flag[<span class="number">105</span>]=&#123;&#125;;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i].k);</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;a[i].k;j++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i].num[j]);</span><br><span class="line">times[a[i].num[j]]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">qsort(a,m,<span class="keyword">sizeof</span>(struct node),cmp);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">qsort(a[i].num,a[i].k,<span class="keyword">sizeof</span>(<span class="keyword">int</span>),cmp2);<span class="comment">// 这里没有必要排序的，在下面取的时候遍历取最小值即可，抱歉没有改</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;a[i].k;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!flag[a[i].num[j]])&#123;</span><br><span class="line">flag[a[i].num[j]]=<span class="number">1</span>;</span><br><span class="line">ans++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>很明显这是一道最大二分匹配的问题，还是简简单单套板子即可(匈牙利算法)。</p><p>然后后来发现可以用贪心做这道题。首先可以知道如果魔法战斗服只想跟随一个魔法少女，那肯定是要先对它进行分配的，所以首先肯定对魔法战斗服想跟随的魔法少女的数量进行排序。再考虑这种情况：如果魔法战斗服(把它称为<code>a</code>)最少都有两个想跟随的魔法少女的话，那么该怎么选择呢，肯定需要对想跟随这两个魔法少女的所有魔法战斗服的数量进行排序，并且把<code>a</code>战斗服给想跟随的魔法战斗服的数量更少的那一位。还有一种情况：两件魔法战斗服想跟随的魔法少女数量相同，这时还是需要对这两件魔法战斗服想跟随的所有魔法少女，求出想跟随她们的所有魔法战斗服的数量总和然后进行排序，对更小的先取即可。所以将上面所有情况考虑即可。(然后本人还了解到有其他贪心的方法，即将魔法少女作为结构体来处理而非魔法战斗服，这里不再赘述，供读者自行思考)</p><hr><h2 id="D-SkyLee的脱单大计"><a href="#D-SkyLee的脱单大计" class="headerlink" title="D-SkyLee的脱单大计"></a>D-SkyLee的脱单大计</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>SkyLee想要脱单，可是他又不想拆散可能在一起的有缘人，毕竟SkyLee是一个善良的人。</p><p>SkyLee想知道最理想的情况下，即可能在一起的人数最多时，还有哪些女生仍然是单身。假设学校男女比非常和谐，恰好为1：1</p><p> 时间限制：1000ms，内存限制：65536kb </p><h3 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h3><p>多组数据输入</p><p>第一行一个整数n，为学校男生数量或女生数量（都一样的啦）保证n&lt;10000</p><p>接下来1行，每行n个整数a[i] (表示男生i暗恋的女生编号)</p><p>接下来1行，每行n个整数b[i] (表示女生i暗恋的男生编号)</p><p>（如果暗恋的人编号为0说明没有暗恋的人）</p><h3 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h3><p>对于每组数据，输出一行，为最后剩下的女生的人数</p><h3 id="输入样例-3"><a href="#输入样例-3" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 1 1</span><br><span class="line">2 0 1</span><br></pre></td></tr></table></figure><h3 id="输出样例-3"><a href="#输出样例-3" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="AC代码-二分匹配"><a href="#AC代码-二分匹配" class="headerlink" title="AC代码(二分匹配)"></a>AC代码(二分匹配)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 2147483647</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>,n,dis;</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">10005</span>],dy[<span class="number">10005</span>],cx[<span class="number">10005</span>],cy[<span class="number">10005</span>];</span><br><span class="line"><span class="keyword">bool</span> used[<span class="number">10005</span>];</span><br><span class="line"><span class="keyword">int</span> man[<span class="number">10005</span>];</span><br><span class="line"><span class="keyword">int</span> woman[<span class="number">10005</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">searchP</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    dis=inf;</span><br><span class="line">    <span class="built_in">memset</span>(dx,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dx));</span><br><span class="line">    <span class="built_in">memset</span>(dy,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dy));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cx[i]==<span class="number">-1</span>) &#123;q.push(i);dx[i]=<span class="number">0</span>;&#125;<span class="comment">//对于未遍历的点入队</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//准备分层</span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(dx[u]&gt;dis) <span class="keyword">break</span>;<span class="comment">//如果目前的层次大于最小增广长度，那么退出</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)<span class="comment">//对于一切可能的点遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((man[u]==j||woman[j]==u)&amp;&amp;dy[j]==<span class="number">-1</span>)&#123;<span class="comment">//只对未分层的点遍历</span></span><br><span class="line">                dy[j]=dx[u]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cy[j]==<span class="number">-1</span>) dis=dy[j];</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dx[cy[j]]=dy[j]+<span class="number">1</span>;</span><br><span class="line">                    q.push(cy[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis!=inf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findpath</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!used[j]&amp;&amp;(man[x]==j||woman[j]==x)&amp;&amp;dy[j]==dx[x]+<span class="number">1</span>)<span class="comment">//符合继续搜索的条件有三个：未访问过，图上联通和层次符合</span></span><br><span class="line">        &#123;</span><br><span class="line">            used[j]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(cy[j]!=<span class="number">-1</span>&amp;&amp;dis==dy[j]) <span class="keyword">continue</span>;<span class="comment">//如果下一个点还是匹配点且目前已经到达增广最小层次，不需要扩展了</span></span><br><span class="line">            <span class="keyword">if</span>(cy[j]==<span class="number">-1</span>||findpath(cy[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                cy[j]=x;cx[x]=j;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hk</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(cx,<span class="number">-1</span>,<span class="keyword">sizeof</span>(cx));</span><br><span class="line">    <span class="built_in">memset</span>(cy,<span class="number">-1</span>,<span class="keyword">sizeof</span>(cy));</span><br><span class="line">    <span class="keyword">while</span>(searchP())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(used,<span class="number">0</span>,<span class="keyword">sizeof</span>(used));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cx[i]==<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(findpath(i)) ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10005</span>],b[<span class="number">10005</span>];</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)) &#123;</span><br><span class="line">ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">man[i]=a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;b[i]);</span><br><span class="line">woman[i]=b[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,n-hk());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AC代码-贪心-1"><a href="#AC代码-贪心-1" class="headerlink" title="AC代码(贪心)"></a>AC代码(贪心)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> ttime[<span class="number">10005</span>]=&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">man</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> times;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num;</span><br><span class="line">&#125;woman[<span class="number">10005</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; m[<span class="number">10005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a,<span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">man</span> <span class="title">c</span>,<span class="title">d</span>;</span></span><br><span class="line"><span class="keyword">int</span> sumc=<span class="number">0</span>,sumd=<span class="number">0</span>;</span><br><span class="line">c=*(struct man*)a;</span><br><span class="line">d=*(struct man*)b;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=c.times;i++)&#123;</span><br><span class="line">sumc+=ttime[c.num[i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=d.times;i++)&#123;</span><br><span class="line">sumd+=ttime[d.num[i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(c.times==d.times)&#123;</span><br><span class="line">sumc&gt;sumd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c.times&gt;d.times;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">com</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> ttime[a]&gt;ttime[b];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,i,j,wom,flag[<span class="number">10005</span>]=&#123;&#125;;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">woman[i].times=<span class="number">0</span>;</span><br><span class="line">woman[i].num.<span class="built_in">clear</span>();</span><br><span class="line">ttime[i]=<span class="number">0</span>;</span><br><span class="line">flag[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;wom);</span><br><span class="line"><span class="keyword">if</span>(wom) &#123;</span><br><span class="line">ttime[i]++;</span><br><span class="line">woman[wom].times++;</span><br><span class="line"><span class="keyword">if</span>(woman[wom].num.empty())&#123;</span><br><span class="line">woman[wom].num.push_back(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">woman[wom].num.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;wom); </span><br><span class="line"><span class="keyword">if</span>(wom) &#123;</span><br><span class="line">ttime[wom]++;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;woman[i].num.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(woman[i].num[j]==wom) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(j==woman[i].num.<span class="built_in">size</span>())&#123;</span><br><span class="line">woman[i].times++;</span><br><span class="line"><span class="keyword">if</span>(woman[i].num.empty())&#123;</span><br><span class="line">woman[i].num.push_back(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">woman[i].num.push_back(wom);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">qsort(woman,n,<span class="keyword">sizeof</span>(struct man),cmp);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">min</span>=<span class="number">2147483647</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=woman[i].times;j++)&#123;</span><br><span class="line"><span class="keyword">int</span> temp=woman[i].num[j];</span><br><span class="line"><span class="comment">/*if(woman[i].times&gt;1)&#123;</span></span><br><span class="line"><span class="comment">sort(woman[i].num.begin(),woman[i].num.end(),com);</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=woman[i].times;k++)&#123;</span><br><span class="line"><span class="keyword">if</span>(woman[i].num[j]&lt;<span class="built_in">min</span>) <span class="built_in">min</span>=woman[i].num[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*if(!flag[woman[i].num[j]])&#123;</span></span><br><span class="line"><span class="comment">flag[woman[i].num[j]]=1;</span></span><br><span class="line"><span class="comment">ans++;</span></span><br><span class="line"><span class="comment">break;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">if</span>(!flag[<span class="built_in">min</span>])&#123;</span><br><span class="line">flag[<span class="built_in">min</span>]=<span class="number">1</span>;</span><br><span class="line">ans++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,n-ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>从题目可以看出这是一道非常明显的二分匹配，但是注意给出的n&lt;10000并且内存只有65536KB，如果直接建图，肯定分分钟MLE，所以需要一些技巧，因为从题意可以知道，每个男生只有一个心仪的女生，同样对女生也同样。所以我们可以直接定义两个一维数组(woman[]和man[])即可，这样内存完全够用，然后在判断的时候就不用判断是否为<code>true</code>了，而是判断<code>man[u]==[v],woman[v]==u</code>即可。然后还是套板子就可以了(匈牙利、HK均可，这里用的HK)</p><p>从上一题的贪心可以知道，这道题肯定是可以贪心解决的，具体就不赘述，一样的道理。只要注意使用vector就可以了。</p><hr><h2 id="E-计网的烦恼"><a href="#E-计网的烦恼" class="headerlink" title="E-计网的烦恼"></a>E-计网的烦恼</h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>计网课上有一道题：一条街道安装无线网络，需要放置M个路由器。整条街道上一共有N户居民，分布在一条直线上，每一户居民必须被至少一台路由器覆盖到。现在的问题是所有路由器的覆盖半径是一样的，我们希望用覆盖半径尽可能小的路由器来完成任务，因为这样可以节省成本。</p><h3 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h3><p>输入第一行包含两个整数M和N，以下N行每行一个整数Hi表示该户居民在街道上相对于某个点的坐标。</p><h3 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h3><p>输出仅包含一个数，表示最小的覆盖半径，保留一位小数。</p><h3 id="输入样例-4"><a href="#输入样例-4" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2 3</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">10</span><br></pre></td></tr></table></figure><h3 id="输出样例-4"><a href="#输出样例-4" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.0</span><br></pre></td></tr></table></figure><h3 id="HINT-1"><a href="#HINT-1" class="headerlink" title="HINT"></a>HINT</h3><p>【样例输出】（在2，10位置上各放一个）</p><p>【数据规模】</p><p>对于100%的数据，有1 ≤N, M ≤100000，-10000000 ≤Hi ≤10000000。</p><h3 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 2147483647</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[MaxSize], B[MaxSize];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is</span><span class="params">(<span class="keyword">double</span> t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> cur = a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]-cur&gt;<span class="number">2</span>*t)&#123;</span><br><span class="line">cnt++;</span><br><span class="line">cur = a[i];</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cnt&lt;m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;m, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line">sort(a,a+n);</span><br><span class="line"><span class="keyword">double</span> left = <span class="number">0</span>, right = <span class="number">10000000</span>, mid, ans;</span><br><span class="line"><span class="keyword">while</span> (right - left &gt;= <span class="number">1e-9</span>) &#123;</span><br><span class="line">mid= (left + right)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (is(mid))&#123;</span><br><span class="line">left = mid;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">right = mid;</span><br><span class="line">ans = mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.1lf"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>这是一道很明显的二分题，同时是一维的覆盖。原理如下：我们找一个半径去覆盖所有，如果不能覆盖，则把半径变大，如果已经完全覆盖了，则把半径减小。怎么判断是否已经覆盖了呢，我们同时通过计数器来判断是否到达<code>m</code>然后如果没有覆盖，则让该坐标最为下次的起始位置即可，详情可查看代码。</p><hr><h2 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h2><p><a href="https://accoding.cn/index" target="_blank" rel="noopener">北航OJ</a></p><hr><hr>]]></content>
      
      
      <categories>
          
          <category> 网络流 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Prince and Princess</title>
      <link href="/2019/11/12/Prince-and-Princess/"/>
      <url>/2019/11/12/Prince-and-Princess/</url>
      
        <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><hr><p>这是突然看到的一个非常有意思的题，是ACM-ICPC的原题，在这里稍微做一些分析，希望对大家有帮助。</p><a id="more"></a><h2 id="Prince-and-Princess"><a href="#Prince-and-Princess" class="headerlink" title="Prince and Princess"></a>Prince and Princess</h2><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><hr><p>王子<code>m</code>和公主<code>Hff</code>相爱，想要娶公主。虽然公主非常愿意，但是并不是王国里每个人都支持这一场婚姻。而为了娶到公主，王子需要完成一个挑战：在n个房间中找出公主在哪。</p><p>每个房间有一个人，他们彼此知道谁在哪个房间。可以每次问任意一个房间里的人三种问题之一：</p><p>1、你的名字是什么？</p><p>2、在第xx个房间里的人的名字是什么？</p><p>3、公主在哪个房间？</p><p>这n个人可以分为三类：一类支持婚姻，一定说真话；一类反对婚姻，一定说假话；一类立场不确定，可能说真话可能说假话。</p><p>王子知道这三类人的人数分别为 a,b,c，求能否通过问若干个问题保证找到公主在哪，如果能，输出<code>YES</code>和最少需要的问题数；如果不能，输出<code>NO</code>。</p><p>时间限制：1000ms，内存限制：65536KB</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><hr><p>第一行一个整数n表示数据组数</p><p>接下来n行，每行3个整数a,b,c</p><p>数据范围：1≤a≤10000，0≤b≤10000，0≤c≤10000</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><hr><p>对于每组数据：</p><p>若能问到公主在哪，输出两行：第一行为：<code>YES</code>，第二行输出一个整数表示答案。</p><p>若不能，输出一行：<code>NO</code></p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1 2 0</span><br><span class="line">2 0 0</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a,b,c,n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line"><span class="keyword">if</span>(b==<span class="number">0</span>&amp;&amp;c==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line"><span class="keyword">if</span>(a==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a&gt;b+c)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="number">2</span>*b+<span class="number">2</span>*c+<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><hr><p>因为我们分析的是最坏的情况，所以，最坏情况下，c对应的所有人都说假话即可，然后我们再考虑下面这种情况：只有两个人，一个说真话，一个说假话。大家可以自行分析一下，可以发现这是无法得到公主在哪个房间的，并且通过这里，我们可以知道，其实只有第三个问题是有价值的，所以在说真话和说假话的人数相同的时候，我们是推不出来的，所以我们可以直接推广到<code>a&lt;=b+c</code>的情况是无法推出来的，所以我们只用考虑<code>a&gt;b+c</code>即可。因为王子是知道a、b、c所对应的人的数目的，所以<code>a&gt;b+c</code>是肯定能推出来的，只用问第三个问题即可，找出答案中数目最多的房间即公主所在房间，那么需要问的次数则是<code>2\*b+2\*c+1</code>，为什么呢，因为b和c是必须要问完的，然后在a中问比b+c多一个问题就可以得到答案了。然后是特殊情况的分析，即a=1，b=0，c=0的情况，是不用问就能知道的。</p><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><hr><p>无</p><hr><hr>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划(DP)——背包问题</title>
      <link href="/2019/11/11/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-DP-%E2%80%94%E2%80%94%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2019/11/11/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-DP-%E2%80%94%E2%80%94%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="背包问题（简单DP）"><a href="#背包问题（简单DP）" class="headerlink" title="背包问题（简单DP）"></a>背包问题（简单DP）</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><hr><p>该讲主要介绍三类背包问题，都是比较经典的DP问题，比之前所讲的股票问题难度有所提升。</p><a id="more"></a><h3 id="背包Ⅰ-01背包"><a href="#背包Ⅰ-01背包" class="headerlink" title="背包Ⅰ(01背包)"></a>背包Ⅰ(01背包)</h3><h4 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h4><hr><p>有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。 </p><p>时间限制：5000ms，内存限制：65536kb</p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><hr><p>多组输入数据</p><p>每组数据第一行两个数n，v，表示物品的数量和背包的容量。(1≤n≤500,1≤v≤30000)</p><p>接下来n行，每行两个整数，表示物品的费用和价值(1≤c<sub>i</sub>,w<sub>i</sub>≤500)</p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><hr><p>每组数据一行一个数。</p><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 6</span><br><span class="line">2 1</span><br><span class="line">3 2</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><h4 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h4><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> value;</span><br><span class="line"><span class="keyword">int</span> price;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">a</span>[505];</span></span><br><span class="line"><span class="keyword">int</span> b[<span class="number">30005</span>]=&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&gt;=m) <span class="keyword">return</span> n;</span><br><span class="line"><span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,val,vmax=<span class="number">0</span>,i,j,v;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;val))&#123;</span><br><span class="line">vmax=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a[i].price,&amp;a[i].value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=val;i++)&#123;</span><br><span class="line">b[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(v=val;v&gt;=a[i].price;v--)&#123;</span><br><span class="line">b[v]=<span class="built_in">max</span>(b[v],b[v-a[i].price]+a[i].value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,b[val]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><hr><p>我们还是直接从DP的角度开始分析这个问题，这是一个01背包问题，我们先假设一些变量，<kbd>b[i,j]</kbd>表示当前背包被占用的容量是<kbd>j</kbd>的情况下，前<kbd>i</kbd>个物品的最佳组合的总价值。<kbd>a[i].price</kbd>和<kbd>a[i].value</kbd>即表示当前商品所需要的容量和当前商品的价值。然后对于当前这个商品有以下两种可能：</p><ul><li>包剩余的容量不够装当前商品，总价值保持不变，不装入该商品，即<kbd>b[i,j]=b[i-1,j]</kbd>;</li><li>有足够容量装该商品，但是装了之后不一定是最佳的价值(因为占用了容量无法保证后面商品是否更好)，需要一个选择，即<kbd>b[i,j]=max(b[i-1,j],b[i-1,j-a[i].price]+a[i].value)</kbd>;</li></ul><p>第二个式子怎么理解呢，如果当前产品装进去了，那么装入之前的状态就是<kbd>b[i-1,j-a[i].price]</kbd>，这样说应该比较好理解了。然后这样我们可以得到一个转移方程如下，当然可以通过初始赋值将其转化为一个方程，代码实现我也放在下方。</p><ul><li>j&gt;=a[i].price: b[i,j]=max(b[i-1，j],b[i-1，j-a[i].price]+a[i].value)</li><li>j&lt;a[i].price: b[i，j]=b[i-1，j]</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=v;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;=a[i].price)&#123;</span><br><span class="line">            b[i][j]=<span class="built_in">max</span>(b[i<span class="number">-1</span>][j],b[i<span class="number">-1</span>][j-a[i].price]+a[i].value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            b[i][j]=b[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>上文这样确实是能够解决问题，但其实是可以再进行优化的，从二维数组优化到一维数组来解决。因为我们可以知道每一次往二维数组<kbd>b[i,j]</kbd>中写入数据的时候都是从上一次得到的数据来写入的，其实<kbd>i</kbd>就变得没有必要了，因为总是从<kbd>b[i-1,...]</kbd>中获取数据的，因此只需要一维数组即可，但是对于<kbd>j</kbd>来说，则需要一点思考，到底是由顶向下还是由底向上循环。假设考虑由底向上循环，我们考虑模拟取第<kbd>i</kbd>件物品的情况，<kbd>v</kbd>应该是从<kbd>a[i].price</kbd>到<kbd>val</kbd>的，那么在最开始的时候就相当于模拟取了一件了，那么在<kbd>v</kbd>取到<kbd>2*a[i].price</kbd>的时候，就相当于模拟取了两个第<kbd>i</kbd>件了，这明显是与题意不符的(这是后面会说到的完全背包)，所以我们采用由顶向下的循环就不会出现这种问题了。大家如果还不明白可以自己画画图推一推就好了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(v=val;v&gt;=<span class="number">1</span>;v--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v&gt;=a[i].price) b[v]=<span class="built_in">max</span>(b[v],b[v-a[i].price]+a[i].value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="转移方程"><a href="#转移方程" class="headerlink" title="转移方程"></a>转移方程</h4><hr><ul><li>b[j]=max(b[j],b[j-a[i].price]+a[i].value)</li></ul><h4 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h4><hr><p>注意初始化。</p><hr><hr><h3 id="背包Ⅱ-完全背包"><a href="#背包Ⅱ-完全背包" class="headerlink" title="背包Ⅱ(完全背包)"></a>背包Ⅱ(完全背包)</h3><h4 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h4><hr><p>有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 </p><p>时间限制：1000ms，内存限制：65536kb</p><h4 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h4><hr><p>多组输入数据</p><p>每组数据第一行两个数n，v，表示物品的数量和背包的容量。(1≤n≤500,1≤v≤30000)</p><p>接下来n行，每行两个整数，表示物品的费用和价值(1≤c<sub>i</sub>,w<sub>i</sub>≤500)</p><h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h4><hr><p>每组数据一行一个数。</p><h4 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例"></a>输入样例</h4><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 6</span><br><span class="line">2 1</span><br><span class="line">3 2</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><h4 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例"></a>输出样例</h4><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure><h4 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h4><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> value;</span><br><span class="line"><span class="keyword">int</span> price;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">a</span>[505];</span></span><br><span class="line"><span class="keyword">int</span> b[<span class="number">30005</span>]=&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&gt;=m) <span class="keyword">return</span> n;</span><br><span class="line"><span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,val,vmax=<span class="number">0</span>,i,j,v;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;val))&#123;</span><br><span class="line">vmax=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a[i].price,&amp;a[i].value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=val;i++)&#123;</span><br><span class="line">b[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(v=a[i].price;v&lt;=val;v++)&#123;</span><br><span class="line">b[v]=<span class="built_in">max</span>(b[v],b[v-a[i].price]+a[i].value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,b[val]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><hr><p>刚拿到这个题目相信大家很容易从贪心的思想去解决，其实是错误的，因为这个容量是有限的，不可分割的，即使我们算出平均最大价值，但是装入背包时其容量还是不可分割的，所以贪心肯定是没法实现的，其他具体不能用贪心的原因，在此也不再赘述。</p><p>然后我们还是直接从DP的角度开始分析这个问题，这是一个完全背包问题，我们还是先假设一些变量，<kbd>b[i,j]</kbd>表示当前背包被占用的容量是<kbd>j</kbd>的情况下，前<kbd>i</kbd>个物品的最佳组合的总价值。<kbd>a[i].price</kbd>和<kbd>a[i].value</kbd>即表示当前商品所需要的容量和当前商品的价值。然后对于当前这个商品有<kbd>k</kbd>种选择，因为可以选择<kbd>k=0,1,2....</kbd>个当前的物品种数，只要不超过背包总容量即可，所以我们直接给出转移方程：</p><ul><li>b[i,j] = max(b[i-1,j-k*a[i].price]+k*a[i].value)    0&lt;=k*a[i].price&lt;=j</li></ul><p>这里就不贴代码了，因为很明显时间复杂度太大，需要三个循环才能实现，并且还不是那么容易。所以我们直接开始说优化的过程。还是同样先优化为一维数组。因为每次取物品的时候都是可以无限量的取的，所以我们的<kbd>k</kbd>就可以省略了，直接采用两重循环实现，并且要保证每次的量的无限，我们的<kbd>j</kbd>的循环则需要从小到大进行循环，代码如下文所示。为什么呢，在这里举个例子说明以下吧：假设我们取第<kbd>i</kbd>件物品需要取<kbd>j</kbd>件才能满足最大价值的时候，我们的第二重循环运转的时候，<kbd>v</kbd>是从<kbd>a[i].price</kbd>一直循环到<kbd>val</kbd>也就是我们可以在取了一次后，<kbd>b[v]</kbd>更新，这样在<kbd>v</kbd>取到<kbd>2*a[i].price</kbd>的时候就能模拟第二次取，并且此时的<kbd>b[v-a[i].price]</kbd>是之前第一次取后更新了过后的值，这样一直循环下去便实现了模拟取无穷次的过程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">1</span>;v&lt;=val;v++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v&gt;=a[i].price) b[v]=<span class="built_in">max</span>(b[v],b[v-a[i].price]+a[i].value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="转移方程-1"><a href="#转移方程-1" class="headerlink" title="转移方程"></a>转移方程</h4><hr><ul><li>b[j]=max(b[j],b[j-a[i].price]+a[i].value)</li></ul><h4 id="HINT-1"><a href="#HINT-1" class="headerlink" title="HINT"></a>HINT</h4><hr><p>注意初始化。</p><hr><hr><h3 id="背包Ⅲ-多重背包"><a href="#背包Ⅲ-多重背包" class="headerlink" title="背包Ⅲ(多重背包)"></a>背包Ⅲ(多重背包)</h3><h4 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h4><hr><p> 有N种物品和一个容量为V的背包。第i种物品最多有m[i]件可用，每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 </p><p>时间限制：1000ms，内存限制：65536kb</p><h4 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h4><hr><p>多组输入数据</p><p>每组数据第一行两个数n，v，表示物品的数量和背包的容量。(1≤n≤500,1≤v≤30000)</p><p>接下来n行，每行三个整数，表示物品的费用,价值,数量(1≤c<sub>i</sub>,w<sub>i</sub>≤500,1≤m<sub>i</sub>≤200) </p><h4 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h4><hr><p>每组数据一行一个数。</p><h4 id="输入样例-2"><a href="#输入样例-2" class="headerlink" title="输入样例"></a>输入样例</h4><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 10</span><br><span class="line">2 1 3</span><br><span class="line">3 2 2</span><br></pre></td></tr></table></figure><h4 id="输出样例-2"><a href="#输出样例-2" class="headerlink" title="输出样例"></a>输出样例</h4><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h4 id="AC代码-2"><a href="#AC代码-2" class="headerlink" title="AC代码"></a>AC代码</h4><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> value;</span><br><span class="line"><span class="keyword">int</span> price;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">a</span>[505];</span></span><br><span class="line"><span class="keyword">int</span> b[<span class="number">30005</span>]=&#123;&#125;,val;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&gt;=m) <span class="keyword">return</span> n;</span><br><span class="line"><span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ZeroOnePack</span><span class="params">(<span class="keyword">int</span> *b,<span class="keyword">int</span> price,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> v;</span><br><span class="line"><span class="keyword">for</span>(v=val;v&gt;=price;v--)&#123;</span><br><span class="line">b[v]=<span class="built_in">max</span>(b[v],b[v-price]+value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CompletePack</span><span class="params">(<span class="keyword">int</span> *b,<span class="keyword">int</span> price,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> v;</span><br><span class="line"><span class="keyword">for</span>(v=price;v&lt;=val;v++)&#123;</span><br><span class="line">b[v]=<span class="built_in">max</span>(b[v],b[v-price]+value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MultiplePack</span><span class="params">(<span class="keyword">int</span> *b,<span class="keyword">int</span> price,<span class="keyword">int</span> value,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (price*num&gt;=val)&#123;</span><br><span class="line">CompletePack(b,price,value);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(k&lt;num)&#123;</span><br><span class="line">ZeroOnePack(b,k*price,k*value);</span><br><span class="line">num=num-k; </span><br><span class="line">k=<span class="number">2</span>*k; </span><br><span class="line">&#125;</span><br><span class="line">ZeroOnePack(b,price*num,value*num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,i,j,v;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;val))&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a[i].price,&amp;a[i].value,&amp;a[i].num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=val;i++)&#123;</span><br><span class="line">b[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">MultiplePack(b,a[i].price,a[i].value,a[i].num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,b[val]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><hr><p>我们还是从最简单的方法开始分析，因为多重背包，我们直接将某个物品拆成<kbd>m[i]</kbd>个同样的物品，只不过每件物品只能取一次，这样就变成了我们上文说到的01背包了，方法非常的简单。转移方程给在下方：</p><ul><li>b[i,j]=max(b[i-1,j-k*a[i].price]+k*a[i].value) 0&lt;=k&lt;=m[i]</li></ul><p>这样的时间复杂度为<kbd>O(V*Σn)</kbd>，我们可以对其进行优化，如何优化呢，我们直接引入二进制来优化，将第<kbd>i</kbd>件物品分成若干件物品，，每个物品的数目，分别为1,2,4,8,….,2<sup>k-1</sup>,n-2<sup>k</sup>+1，k是满足n-2<sup>k</sup>+1&gt;0的最大整数。如果不够明白，举个例子，假设某物品有49件，那么可以分为49=1+2+4+8+16+18这5件物品，并且1~49间的任何数都可以由这五件物品构成，所以这样应该比较容易理解了。所以时间复杂度也降为<kbd>O(V*Σlogn)</kbd>了。</p><p>那应该怎么实现呢，首先对于第<kbd>i</kbd>件物品来说，如果<kbd>a[i].price*a[i].num>=val</kbd>即如果没法全部装下的话，就不用将其全部拆分了，直接当作完全背包处理就好，模拟出装几件该物品更好即可(如果不太理解可以去看上文的完全背包的分析)。如果是小于的话，那我们就采用拆分的办法即可，代码给出在下方。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MultiplePack</span><span class="params">(<span class="keyword">int</span> *b,<span class="keyword">int</span> price,<span class="keyword">int</span> value,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (price*num&gt;=val)&#123;</span><br><span class="line">CompletePack(b,price,value);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(k&lt;num)&#123;</span><br><span class="line">ZeroOnePack(b,k*price,k*value);</span><br><span class="line">num=num-k; </span><br><span class="line">k=<span class="number">2</span>*k; </span><br><span class="line">&#125;</span><br><span class="line">ZeroOnePack(b,price*num,value*num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="HINT-2"><a href="#HINT-2" class="headerlink" title="HINT"></a>HINT</h4><hr><p>其实还可以更深度的优化到<kbd>O(V*n)</kbd>需要用到优先队列，在本文不再赘述，供大家思考。</p><hr><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr><p>《背包九讲》</p><h2 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h2><hr><p><a href="https://accoding.cn/index" target="_blank" rel="noopener">北航OJ</a></p><hr><hr>]]></content>
      
      
      <categories>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建(hexo-Github)博客</title>
      <link href="/2019/11/10/%E6%90%AD%E5%BB%BAhexo-Github%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/11/10/%E6%90%AD%E5%BB%BAhexo-Github%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><hr><p>本文主要向大家介绍了如何搭建hexo-Github博客的详细过程，有需要的朋友们可以尝试阅读，希望对大家有帮助。</p><a id="more"></a><h3 id="简要吐槽"><a href="#简要吐槽" class="headerlink" title="简要吐槽"></a>简要吐槽</h3><hr><p>搭博客其实没那么麻烦，但是在网上各类教程的“指导下”，我不知道放弃了多少次又重新试了多少次，大部分还是得靠自己。。。<br>今天在这里给大家简要分享一下我搭博客(hexo-Github)的教程，基于自己很多很多日日夜夜的尝试与摸索后的经验教训，希望对大家有一些帮助。</p><h3 id="直入主题"><a href="#直入主题" class="headerlink" title="直入主题"></a>直入主题</h3><hr><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><hr><p>首先需要三个工具，git、npm、node.js。可以在windows下用命令行(win+R)验证一下(如下)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>只要显示了版本号即证明OK。如果没有的话可以去官网下载安装即可(下方附上官网地址)，并且不要忘了添加环境变量不然还是看不到版本号也没法在命令行里使用这三个命令。</p><p> <a href="https://www.git-scm.com/download/" target="_blank" rel="noopener">git安装地址</a></p><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">node.js安装地址</a>(安装这个就包含了npm)</p><h4 id="在Github上搭建仓库"><a href="#在Github上搭建仓库" class="headerlink" title="在Github上搭建仓库"></a>在Github上搭建仓库</h4><hr><p>首先需要注册一个Github账号(需要邮箱)，然后进入后点击右上角的人脸选择<strong>your repositories</strong>(如下图)</p><p><img src="https://raw.githubusercontent.com/DbettKK/pictures/master/blog/1.jpg" alt="blog1"></p><hr><p><img src="https://raw.githubusercontent.com/DbettKK/pictures/master/blog/2.jpg" alt="blog2"></p><p>然后点击右上角绿色的new(如上图)创建一个自己的仓库，进入后就会出现下面这个界面</p><p><img src="https://raw.githubusercontent.com/DbettKK/pictures/master/blog/3.jpg" alt="blog1"></p><p>图中打了×的都是可填可不填的，description就是一个简单的描述，public和private就是选择你的项目是否公开，但是private需要花钱，最后那个是添加一个README文件可有可无。但是最重要的是第一个打勾的地方，要搭建博客的话这个仓库名称必须是“username”.github.io，username是你自己的账号名字，如上图我的仓库名称就应该为DbettKK.github.io(!!!!!千万不要写错，不然还得删了重来，本人不知道删过多少次了)，最后点击create repository即可。进去后还要记住那个https后面(如下图)的地址后面还有用。</p><p><img src="https://raw.githubusercontent.com/DbettKK/pictures/master/blog/4.jpg" alt="blog4"></p><h4 id="配置SSH-key"><a href="#配置SSH-key" class="headerlink" title="配置SSH key"></a>配置SSH key</h4><hr><h5 id="为啥要配置这个"><a href="#为啥要配置这个" class="headerlink" title="为啥要配置这个"></a>为啥要配置这个</h5><hr><p>因为提交代码是需要GitHub权限的，就相当于每次都需要输入你的邮箱和密码，非常的麻烦和容易出错，有了这个SSH key就能让本地和GitHub服务器连接起来，以上的问题就迎刃而解，非常的方便与安全。</p><h5 id="生成本地SSH-key"><a href="#生成本地SSH-key" class="headerlink" title="生成本地SSH key"></a>生成本地SSH key</h5><hr><p>可以先用以下代码在GIT BASH中查看本机是否已经有SSH存在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/. ssh</span><br></pre></td></tr></table></figure><p>如果显示No such file……就说明需要重新生成，命令如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;邮箱地址&quot;</span><br></pre></td></tr></table></figure><p>邮箱地址是你自己的GitHub邮箱地址即”[username].github.io”，然后连续敲几次回车即可，这个SSH key就保存在C盘用户目录里的.ssh文件夹里，然后找到该文件夹里的id_rsa.pub文件，用记事本打开并且复制里面的全部内容，在你的GitHub中还是点击右上角的人脸选择settings(这里就不配图了)，然后选择左边的SSH and GPG keys(如下图)，并且选择新增SSH keys，下图中的title可以随意填写，Key就是把你之前复制的粘贴下来点击Add SSH key即可完成，完成后就能看到自己的SSH key了。</p><p><img src="https://raw.githubusercontent.com/DbettKK/pictures/master/blog/5.jpg" alt="update5"></p><h5 id="测试成功与否"><a href="#测试成功与否" class="headerlink" title="测试成功与否"></a>测试成功与否</h5><hr><p>在git bash里输入一下命令进行验证是否连接成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>上面那个邮箱地址是不用更改的，就这样写就可以了，如果有需要输入的就输入yes/y就可以了，最后如果看到其中显示<strong><em>Hi …..! You’ve successfully……</em></strong>就说明配置成功了。</p><h5 id="将git与Github绑定"><a href="#将git与Github绑定" class="headerlink" title="将git与Github绑定"></a>将git与Github绑定</h5><hr><p>在git bash中输入以下命令将git与你的GitHub账号和邮箱绑定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;.....&quot;</span><br><span class="line">git config --global user.email &quot;...@...&quot;</span><br></pre></td></tr></table></figure><p>上面引号中的内容都填写你自己的账号用户名和邮箱即可。</p><h4 id="开始配置Hexo"><a href="#开始配置Hexo" class="headerlink" title="开始配置Hexo"></a>开始配置Hexo</h4><hr><h5 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a>Hexo简介</h5><hr><p>Hexo是个静态页面生成、上传的工具。可以将我们写的.md文件生成静态的html网页，然后再将这个网页上传到服务器。使用非常的方便、简洁。下方给一个主页地址，有非常详细的介绍，这里不再赘述。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://hexo.io/zh-cn/</span><br></pre></td></tr></table></figure><h5 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h5><hr><p>Hexo的安装不需要去官网，直接再git bush中就能完成，在任意地方打开git bash，然后输入一下命令进行安装，可能需要等一会，这个过程不要去乱按键盘即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure><p>等到有版本号出来的时候就说明安装完成了，然后进行下一步，初始化hexo，现在自己找一个位置新建一个文件夹hexo(什么名字都可以，我写hexo方便下文描述)，这也就是你之后写博客、存放代码的位置，所以选择还是慎重一些。然后进去这个文件夹，右键git bash here打开git bash然后输入一下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>这个过程还是不短，还是耐心等待一会啦，最后初始化完之后，这个文件夹里应该会有以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">node_modules</span><br><span class="line">public # 这个里面是存放源码的地方，一般用不到。</span><br><span class="line">scaffolds</span><br><span class="line">source # 这个里面会有一个_posts，_posts里就是你写.md文档的地方，那里面可能会有默认的一个.md。</span><br><span class="line">themes # 这个是主题，最开始里面应该都只有一个landscape，有需要可以去官网下载。</span><br><span class="line">.gitignore</span><br><span class="line">_config.yml # 这个是配置文件，很多操作都需要对它进行编辑修改。</span><br><span class="line">db.json # 这个及后面的暂时不介绍，暂时用不到。</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>然后就可以查看自己博客的初始状态啦，当然只能在本地服务器查看，因为还没有上传到github。用以下命令来查看，还是在刚刚下载好的地方用git bash，后文若无特殊说明，都是在此目录下打开git bash。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g # 这个命令用于将source/_posts/里的.md文件生成到自己的博客上（本地）</span><br><span class="line">hexo s # 这个命令用于启动本地的服务器，使用这个命令就可以开始访问啦</span><br></pre></td></tr></table></figure><p>输入命令hexo s命令后，应该出现以下内容，此时就可以在本地网站里输入下方的网址进行访问啦</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure><p>进入后应该能看到自己博客最初始的状态啦，里面应该只有一个内容就是hello world，不过之后可以自己添加啦。</p><h5 id="Hexo一些配置"><a href="#Hexo一些配置" class="headerlink" title="Hexo一些配置"></a>Hexo一些配置</h5><hr><p>因为要上传到github，所以还需要配置一些东西才行。首先是在_config,yml里修改，首先用记事本或者其他编辑软件打开(个人比较推荐editplus)，在其最后有一个deploy的部分进行修改。修改如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:[username]/[username].github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>其中的username还是你自己的用户名。然后还需要在git bush中安装一个小插件，命令如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>然后就可以开始上传啦，使用以下命令进行上传</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo g </span><br><span class="line">hexo d # 这个指令用于上传</span><br><span class="line">也可以两个合为 hexo g -d使用</span><br></pre></td></tr></table></figure><p>然后在网址里输入[username].github.io就能访问自己的博客啦，当然别人也同样可以啦。</p><h5 id="配置一下自己的博客"><a href="#配置一下自己的博客" class="headerlink" title="配置一下自己的博客"></a>配置一下自己的博客</h5><hr><p>虽然已经可以进行线上访问了，但是博客还是需要名字的呀，不然大家都是hexo了。修改方式还是非常简单的，首先找到根目录下的_config.yml文件还是用编辑软件打开，打开后可以看到一个# Site 的内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: Hexo # 就是博客的大标题啦</span><br><span class="line">subtitle: &apos;&apos; # 副标题</span><br><span class="line">description: &apos;&apos; # 简单描述</span><br><span class="line">keywords: &apos;&apos; </span><br><span class="line">author: &apos;&apos; # 作者名，在文末会看到哦</span><br><span class="line">language: en # 语言，这里是英文，中文是zh-CN</span><br><span class="line">timezone: &apos;&apos;</span><br></pre></td></tr></table></figure><p>然后对其中的内容进行修改就可以啦，修改的时候记得去掉’ ‘哦</p><h5 id="具体怎么写博客呢"><a href="#具体怎么写博客呢" class="headerlink" title="具体怎么写博客呢"></a>具体怎么写博客呢</h5><hr><p>具体怎么写呢，非常简单，就是写.md文件就可以了，使用以下命令来新建一个.md 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo n &quot;你喜欢的名字都可以&quot;</span><br></pre></td></tr></table></figure><p>或者也可以直接在source/_posts/目录下新建.md文档，效果是一样的。不过需要在里面添加一下title等东西，可以参考用命令生成的.md文档。然后开始写就可以啦，写完还是同样的方式上传即可。</p><h5 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h5><hr><p>当然大家都希望自己的博客功能多样，比如访客量、漂亮的背景图、鼠标点击效果、不同的主题等等，这些我在这里就不一一介绍啦，大家可以去网上看教程，还是非常丰富的。我在这里就给大家简单分享一下如何在博客里方便的插入图片的方法吧。</p><h6 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h6><hr><p>这个方法是在网上看到的，虽然我没有成功，但还是分享给大家吧。</p><p>首先在_config.yml里找到# Writting大类里的post_asset_folder，将其置为true。</p><p>然后在根目录里运行cmd并运行以下命令，下载一个小插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-asset-image –save</span><br></pre></td></tr></table></figure><p>安装完成后，在使用hexo n ”…“创建新博文时，就有一个同样标题的文件夹，把图片放进去即可，然后在.md文档里插入图片时就如下写，方括号里是图片不展示时显示的文字，2是代表你放图片的文件夹名，1是代表图片名字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![...](2/1.jpg)</span><br></pre></td></tr></table></figure><p>虽然本人没有成功，希望大家能够成功啦。</p><h6 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h6><hr><p>这个方法非常的好用与方便，也不怕掉链子。</p><p>就是使用github来保存自己的图片，然后在.md里引用时就用github网址即可。具体操作如下。</p><p>首先找一个文件夹，里面放你本次.md里需要的图片，并且在github上新建一个专门用来存放图片的仓库。然后在这个文件夹所在的目录使用git bush将这个文件夹push到你的图片仓库里，具体操作如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git init # 初始化</span><br><span class="line">git add . # 将该目录所有文件添加，注意这个&quot;.&quot;，也可以指定添加，git add 文件名</span><br><span class="line">git commit -m &quot;...&quot; # 双引号内即你给这个文件夹的备注，可以随意填写，不要省略双引号</span><br><span class="line">git remote add origin 仓库地址 # 后面填写你该仓库的地址。</span><br><span class="line">git push -u origin master # 第一次push时加上-u，后面不用。</span><br></pre></td></tr></table></figure><p>然后完成后，在自己的仓库里找到相应的图片，点击download按钮，会进去一个只有图片的网页，然后右键图片点击复制地址，再在你的.md文档里插入图片时写上网址即可，非常的方便，不用担心本地文件丢失等等问题，希望对大家有帮助。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>终于写完了这篇博客，希望对大家有所帮助呀，当然如果有什么问题也敬请指出来，我的邮箱会留在下方，欢迎随时联系，同时希望大家都能拥有属于自己的博客呀！！！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">邮箱：394739138@qq.com</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><hr><p> <a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html" target="_blank" rel="noopener">https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html</a> </p><hr><hr>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划(DP)——股票问题</title>
      <link href="/2019/11/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-DP-%E2%80%94%E2%80%94%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/"/>
      <url>/2019/11/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-DP-%E2%80%94%E2%80%94%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="股票问题（简单DP）"><a href="#股票问题（简单DP）" class="headerlink" title="股票问题（简单DP）"></a>股票问题（简单DP）</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><hr><p>本文主要介绍了和DP相关的股票问题，分析比较简单，容易理解，适合刚接触DP的朋友们学习。</p><a id="more"></a><h3 id="股票Ⅰ"><a href="#股票Ⅰ" class="headerlink" title="股票Ⅰ"></a>股票Ⅰ</h3><h4 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h4><hr><p>假设您有一个数组，第i个元素是第i天给定股票的价格。</p><p>如果只允许您最多完成一笔交易（即买入和卖出一股股票），请设计一种算法以找到最大的利润(卖出的价格-买入的价格)。</p><p>请注意，您不能在买股票之前卖出股票。</p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><hr><p>多组输入数据</p><p>每组数据第一行一个数n，(1≤n≤10<sup>5</sup>)</p><p>接下来一行n个数表示股票的价格(1≤a<sub>i</sub>≤10<sup>9</sup>)</p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><hr><p>每组数据一行一个数。</p><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure><h4 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h4><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&gt;=m) <span class="keyword">return</span> n;</span><br><span class="line"><span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,a[<span class="number">100005</span>]=&#123;&#125;;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> buy,sell;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))&#123;</span><br><span class="line">buy1=<span class="number">-1000000001</span>,sell1=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">buy=<span class="built_in">max</span>(buy,-a[i]);</span><br><span class="line">sell=<span class="built_in">max</span>(sell,buy+a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,sell);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><hr><p>我们直接从DP的角度开始分析这个问题，首先看清题意，只能买入和卖出一股股票，并且卖出必须在买入之后完成。那么我们每一天的选择就是买或者不买或者卖，也就是有两种状态买<kbd>buy</kbd>和卖<kbd>sell</kbd>，而买入股票对应的就是花钱，我们最开始的钱为0，买入后就变会损失也就是<kbd>-a[i]</kbd>，并且当天的总收益就为<kbd>-a[i]</kbd>，也就是<kbd>buy</kbd>的值，卖出后则为收益也就是<kbd>+a[i]</kbd>，并且当天的总收益就为<kbd>buy+a[i]</kbd>。所以我们就考虑当天买和之前买了(即与之前<kbd>buy</kbd>里的值进行比较)哪个收益更高，同时当天卖和之前已经卖了(即与之前<kbd>sell</kbd>里的值进行比较)哪个收益更高即可完成。</p><h4 id="转移方程"><a href="#转移方程" class="headerlink" title="转移方程"></a>转移方程</h4><hr><ul><li>buy = max(buy, -a[i])</li><li>sell = max(sell, buy+a[i])</li></ul><h4 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h4><hr><p>首先观察数据范围发现最终结果是可能超int的，所以对<kbd>buy</kbd>和<kbd>sell</kbd>的定义应为long long，然后是<kbd>buy</kbd>的初始值应该设置为负值而不是0，因为第一次买入的时候此时总收益就为负值。</p><hr><hr><h3 id="股票Ⅱ"><a href="#股票Ⅱ" class="headerlink" title="股票Ⅱ"></a>股票Ⅱ</h3><hr><h4 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h4><hr><p>假设您有一个数组，第i个元素是第i天给定股票的价格。</p><p>设计算法以找到最大的利润。您可以根据需要完成尽可能多的交易。</p><p>请注意，无法同时进行多项交易（即必须先出售股票才能再次购买）</p><h4 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h4><hr><p>多组输入数据</p><p>每组数据第一行一个数n，(1≤n≤10<sup>5</sup>)</p><p>接下来一行n个数表示股票的价格(1≤a<sub>i</sub>≤10<sup>9</sup>)</p><h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h4><hr><p> 每组数据一行一个数 </p><h4 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例"></a>输入样例</h4><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure><h4 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例"></a>输出样例</h4><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h4 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h4><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&gt;=m) <span class="keyword">return</span> n;</span><br><span class="line"><span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,a[<span class="number">100005</span>]=&#123;&#125;;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> buy,sell;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))&#123;</span><br><span class="line">buy=<span class="number">-1000000001</span>,sell=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">buy=<span class="built_in">max</span>(buy,sell-a[i]);</span><br><span class="line">sell=<span class="built_in">max</span>(sell,buy+a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,sell);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><hr><p>我们直接从上一问的思路继续分析，本题是要求利润最大并且可以完成任意多的交易(即可以买了又卖卖了再买)，那我们还是同样分析，买了之后当天的总收益为<kbd>sell-a[i]</kbd>(因为之前是处于卖了之后的状态所以用<kbd>sell</kbd>来减)，然后卖了之后当天的总收益为<kbd>buy-a[i]</kbd>(因为之前是处于买了之后的状态所以用<kbd>buy</kbd>来减)，然后我们考虑每一天的情况即可。</p><h4 id="转移方程-1"><a href="#转移方程-1" class="headerlink" title="转移方程"></a>转移方程</h4><hr><ul><li><p>buy = max(buy, sell-a[i])</p></li><li><p>sell = max(sell, buy+a[i])</p></li></ul><h4 id="HINT-1"><a href="#HINT-1" class="headerlink" title="HINT"></a>HINT</h4><hr><p>还是一样需要注意数据类型的选择和buy的初始赋值，然后是sell最初值置0才能保证第一次买后总收益的正确性。</p><hr><hr><h3 id="股票Ⅲ"><a href="#股票Ⅲ" class="headerlink" title="股票Ⅲ"></a>股票Ⅲ</h3><hr><h4 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h4><hr><p>假设您有一个数组，第i个元素是第i天给定股票的价格。</p><p>设计算法以找到最大的利润。您最多可以完成两次交易。</p><p>请注意，无法同时进行多项交易（即必须先出售股票才能再次购买）</p><h4 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h4><hr><p>多组输入数据</p><p>每组数据第一行一个数n，(1≤n≤10<sup>5</sup>)</p><p>接下来一行n个数表示股票的价格(1≤a<sub>i</sub>≤10<sup>9</sup>)</p><h4 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h4><hr><p> 每组数据一行一个数 </p><h4 id="输入样例-2"><a href="#输入样例-2" class="headerlink" title="输入样例"></a>输入样例</h4><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure><h4 id="输出样例-2"><a href="#输出样例-2" class="headerlink" title="输出样例"></a>输出样例</h4><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h4 id="AC代码-2"><a href="#AC代码-2" class="headerlink" title="AC代码"></a>AC代码</h4><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&gt;=m) <span class="keyword">return</span> n;</span><br><span class="line"><span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,a[<span class="number">100005</span>]=&#123;&#125;;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> buy1,sell1,buy2,sell2;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))&#123;</span><br><span class="line">buy1=<span class="number">-1000000001</span>,sell1=<span class="number">0</span>,buy2=<span class="number">-1000000001</span>,sell2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">buy1=<span class="built_in">max</span>(buy1,-a[i]);</span><br><span class="line">sell1=<span class="built_in">max</span>(sell1,buy1+a[i]);</span><br><span class="line">buy2=<span class="built_in">max</span>(buy2,sell1-a[i]);</span><br><span class="line">sell2=<span class="built_in">max</span>(sell2,buy2+a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,sell2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><hr><p>我们还是延续思路继续分析，本题是要求利润最大并且只能完成两次交易，那我们还是同样分析，因为有两次交易，所以需要4个变量来存，第一次买了之后当天的总收益为<kbd>-a[i]</kbd>(因为相当于之前没有卖出)，然后第一次卖了之后当天的总收益为<kbd>buy1-a[i]</kbd>(因为之前是处于第一次买了之后的状态所以用<kbd>buy1</kbd>来减)，然后第二次买了之后当天的总收益为<kbd>sell1-a[i]</kbd>(因为相当于之前有一次卖出)，然后第二次卖了之后当天的总收益为<kbd>buy2-a[i]</kbd>(因为之前是处于第二次买了之后的状态所以用<kbd>buy2</kbd>来减)，然后我们考虑每一天的情况即可。</p><h4 id="转移方程-2"><a href="#转移方程-2" class="headerlink" title="转移方程"></a>转移方程</h4><hr><ul><li>buy1=max(buy1,-a[i]);</li><li>sell1=max(sell1,buy1+a[i]);    </li><li>buy2=max(buy2,sell1-a[i]);</li><li>sell2=max(sell2,buy2+a[i]);</li></ul><h4 id="HINT-2"><a href="#HINT-2" class="headerlink" title="HINT"></a>HINT</h4><hr><p>还是一样需要注意数据类型的选择和sell1、buy1、buy2的初始赋值，然后是sell1最初值置0才能保证第一次买后总收益的正确性。然后是对方程的理解，是怎么样实现的。</p><hr><hr><h3 id="股票Ⅳ"><a href="#股票Ⅳ" class="headerlink" title="股票Ⅳ"></a>股票Ⅳ</h3><hr><h4 id="题面-3"><a href="#题面-3" class="headerlink" title="题面"></a>题面</h4><hr><p>假设您有一个数组，第i个元素是第i天给定股票的价格。</p><p>设计算法以找到最大的利润。您最多可以完成k次交易。</p><p>请注意，无法同时进行多项交易（即必须先出售股票才能再次购买）</p><h4 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h4><hr><p>多组输入数据</p><p>每组数据第一行两个数n,k，(1≤n,k≤10<sup>3</sup>)</p><p>接下来一行n个数表示股票的价格(1≤a<sub>i</sub>≤10<sup>9</sup>)</p><h4 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h4><hr><p> 每组数据一行一个数 </p><h4 id="输入样例-3"><a href="#输入样例-3" class="headerlink" title="输入样例"></a>输入样例</h4><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 2</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure><h4 id="输出样例-3"><a href="#输出样例-3" class="headerlink" title="输出样例"></a>输出样例</h4><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h4 id="AC代码-3"><a href="#AC代码-3" class="headerlink" title="AC代码"></a>AC代码</h4><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&gt;=m) <span class="keyword">return</span> n;</span><br><span class="line"><span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,k,a[<span class="number">100005</span>]=&#123;&#125;;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> buy[<span class="number">1005</span>],sell[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k))&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">buy[i]=<span class="number">-1000000001</span>;</span><br><span class="line">sell[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">buy[<span class="number">1</span>]=<span class="built_in">max</span>(buy[<span class="number">1</span>],-a[i]);</span><br><span class="line">sell[<span class="number">1</span>]=<span class="built_in">max</span>(sell[<span class="number">1</span>],buy[<span class="number">1</span>]+a[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=k;j++)&#123;</span><br><span class="line">buy[j]=<span class="built_in">max</span>(buy[j],sell[j<span class="number">-1</span>]-a[i]);</span><br><span class="line">sell[j]=<span class="built_in">max</span>(sell[j],buy[j]+a[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,sell[k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><hr><p>我们还是相同思路继续分析，本题是要求利润最大并且只能完成k次交易，因为有k次交易，所以需要2k个变量来存，即用两个数组来存即可，第一次买了之后当天的总收益为<kbd>-a[i]</kbd>(因为相当于之前没有卖出)，然后第一次卖了之后当天的总收益为<kbd>buy[1]-a[i]</kbd>(因为之前是处于第一次买了之后的状态所以用<kbd>buy[1]</kbd>来减)，然后第二次买了之后当天的总收益为<kbd>sell[1]-a[i]</kbd>(因为相当于之前有一次卖出)，然后第二次卖了之后当天的总收益为<kbd>buy[2]-a[i]</kbd>(因为之前是处于第二次买了之后的状态所以用<kbd>buy[2]</kbd>]来减)，然后用一个从2-k的循环来实现此过程即可。</p><h4 id="转移方程-3"><a href="#转移方程-3" class="headerlink" title="转移方程"></a>转移方程</h4><hr><ul><li>buy[j]=max(buy[j], sell[j-1]-a[i])</li><li>sell[j]=max(sell[j], buy[j]+a[i])</li></ul><h4 id="HINT-3"><a href="#HINT-3" class="headerlink" title="HINT"></a>HINT</h4><hr><p>还是一样需要注意数据类型的选择和buy[],sell[]的初始赋值，然后是上文的AC代码的循环其实不用把buy[1]、sell[1]单独拿出来讨论的，只是更方便理解。</p><h2 id="题目来源"><a href="#题目来源" class="headerlink" title="题目来源"></a>题目来源</h2><hr><p><a href="https://accoding.cn/index" target="_blank" rel="noopener">北航OJ</a></p><hr><hr>]]></content>
      
      
      <categories>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>First Time!!!</title>
      <link href="/2019/11/09/hello-world/"/>
      <url>/2019/11/09/hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><hr><p>作为一个大懒鬼以及大菜鸡，今天终于搭好了自己的第一个博客，<strong>太不容易了吧</strong>，之后肯定也会一直更新的啦，主要还是关于算法以及硬件基础方面的东西啦，当然要是我觉得有用的东西，我也会写在博客里供大家参考，希望对大家有用哦；不过主要本人水平实在有限，大家就当看着玩玩啦，请大家多多指教哦！</p><a id="more"></a><hr><hr>]]></content>
      
      
      <categories>
          
          <category> 简介 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
