<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="NO DEPENDENCE ONLY PRIDE">
<meta property="og:type" content="website">
<meta property="og:title" content="BBBBBlog">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;index.html">
<meta property="og:site_name" content="BBBBBlog">
<meta property="og:description" content="NO DEPENDENCE ONLY PRIDE">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>BBBBBlog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">BBBBBlog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/04/22/Java%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Bcutty Kmy">
      <meta itemprop="description" content="NO DEPENDENCE ONLY PRIDE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BBBBBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/22/Java%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">Linux上Java相关环境变量配置</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-04-22 17:40:20 / Modified: 19:30:31" itemprop="dateCreated datePublished" datetime="2021-04-22T17:40:20+08:00">2021-04-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%83%A8%E7%BD%B2%E7%AF%87/" itemprop="url" rel="index"><span itemprop="name">部署篇</span></a>
                </span>
            </span>

          
            <span id="/2021/04/22/Java%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/" class="post-meta-item leancloud_visitors" data-flag-title="Linux上Java相关环境变量配置" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2021/04/22/Java%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/04/22/Java%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Linux上Java相关环境配置"><a href="#Linux上Java相关环境配置" class="headerlink" title="Linux上Java相关环境配置"></a>Linux上Java相关环境配置</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>主要是记录一下Linux上Java相关的环境配置过程，希望能够帮助到大家，同时也防止自己忘记。</p>
<p>主要包括：JDK的配置、Maven的配置、Zookeeper的配置</p>
<p>主要步骤都相同：下载——解压——配置环境变量——source</p>
<p>linux版本：ubuntu18.04 or ubuntu20.04</p>
<h2 id="JDK配置"><a href="#JDK配置" class="headerlink" title="JDK配置"></a>JDK配置</h2><p><em>注意：本人未使用openjdk，也未通过包管理器进行下载，而是通过在oracle官网下载的方式</em></p>
<p>①下载对应版本jdk。进入Oracle官网，选择对应的jdk版本，需要登录，然后下载对应linux的安装包，tar.gz结尾，如<code>jdk-8u291-linux-x64.tar.gz</code></p>
<p>②在虚拟机新建一个目录（放置这些文件），我个人比较喜欢放在<code>/usr/bin/java</code>下，所以在<code>/usr/bin</code>目录下<code>sudo mkdir java</code>即可。</p>
<p>③上传压缩包。将该压缩包上传到服务器对应目录中<code>/usr/bin/java</code></p>
<blockquote>
<p>如果是本地虚拟机，则可以通过sftp的方式</p>
<p>如果是使用WSL2，则可以通过<code>/mnt</code>目录找到下载的压缩包</p>
<p>如果使用的是云服务器，也可以通过sftp或者云服务提供商相关来上传文件</p>
<p><em>最不是办法的办法：上传到github或者其他服务器能够拉取的地方进行拉取</em></p>
</blockquote>
<p>④解压压缩包，然后删除压缩包（也可以不删）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo tar xvf jdk-8u291-linux-x64.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash"> sudo rm jdk-8u291-linux-x64.tar.gz 删除压缩包</span></span><br></pre></td></tr></table></figure>

<p>⑤配置jdk环境变量</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/profile</span><br></pre></td></tr></table></figure>

<p>在文件最后添加以下文字</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/bin/java/jdk1.8.0_291	# 根据自己的java目录进行设置</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br></pre></td></tr></table></figure>

<p>最后<code>:wq</code>进行保存即可</p>
<p>刷新，保证配置生效</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>

<p>⑥检查是否配置成功</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>

<h2 id="Maven配置"><a href="#Maven配置" class="headerlink" title="Maven配置"></a>Maven配置</h2><p>①同理在maven官网选择自己需要的版本进行下载，然后上传到服务器上对应位置并进行解压</p>
<p>②配置jdk环境变量</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/profile</span><br></pre></td></tr></table></figure>

<p>在文件最后添加以下文字</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/bin/java/jdk1.8.0_291	# 确保java存在</span><br><span class="line">export MAVEN_HOME=/usr/bin/java/apache-maven-3.6.3	# 自己放置maven的目录</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin:$PATH:$MAVEN_HOME/bin	# 增加一个$MAVEN_HOME/bin</span><br><span class="line"><span class="meta">#</span><span class="bash"> CLASSPATH不变</span></span><br></pre></td></tr></table></figure>

<p>最后<code>:wq</code>进行保存即可</p>
<p>刷新，保证配置生效</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>

<p>③检查是否配置成功</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn -V</span><br></pre></td></tr></table></figure>

<h2 id="Zookeeper配置"><a href="#Zookeeper配置" class="headerlink" title="Zookeeper配置"></a>Zookeeper配置</h2><p>①同理在Zookeeper官网选择自己需要的版本进行下载，然后上传到服务器上对应位置并进行解压</p>
<p>②配置jdk环境变量</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/profile</span><br></pre></td></tr></table></figure>

<p>在文件最后添加以下文字</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> zookeeper 确保java已经安装</span></span><br><span class="line">export ZOOKEEPER_HOME=/usr/bin/java/apache-zookeeper-3.6.3-bin</span><br><span class="line">export PATH=$PATH:$ZOOKEEPER_HOME/bin</span><br></pre></td></tr></table></figure>

<p>最后<code>:wq</code>进行保存即可</p>
<p>刷新，保证配置生效</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>

<p>③检查是否配置成功</p>
<p>进入zookeeper对应bin目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/bin/java/apache-zookeeper-3.6.3-bin/bin</span><br></pre></td></tr></table></figure>

<p>执行启动命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./zkServer.sh start</span><br></pre></td></tr></table></figure>

<p>注意：可能会提示你JAVA_HOME不存在</p>
<p>则</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim zkEnv.sh</span><br></pre></td></tr></table></figure>

<p>然后在大概77行增加这样一行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME="/usr/bin/java/jdk1.8.0_291" # 根据自己的java目录来</span><br></pre></td></tr></table></figure>

<p><img src="https://ae01.alicdn.com/kf/Udddfcc0ffe674b5ea4f1cc6b8fe01d79O.jpg" alt></p>
<p>然后再次尝试即可。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/04/01/python%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Bcutty Kmy">
      <meta itemprop="description" content="NO DEPENDENCE ONLY PRIDE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BBBBBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/01/python%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">Python学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-01 00:13:05" itemprop="dateCreated datePublished" datetime="2021-04-01T00:13:05+08:00">2021-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-27 21:45:27" itemprop="dateModified" datetime="2020-05-27T21:45:27+08:00">2020-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/" itemprop="url" rel="index"><span itemprop="name">学习篇</span></a>
                </span>
            </span>

          
            <span id="/2021/04/01/python%E5%AD%A6%E4%B9%A0/" class="post-meta-item leancloud_visitors" data-flag-title="Python学习" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2021/04/01/python%E5%AD%A6%E4%B9%A0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/04/01/python%E5%AD%A6%E4%B9%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Python学习"><a href="#Python学习" class="headerlink" title="Python学习"></a>Python学习</h1><p><em>学习自廖雪峰的博客网站python篇</em></p>
<h3 id="Pycharm内容"><a href="#Pycharm内容" class="headerlink" title="Pycharm内容"></a>Pycharm内容</h3><p><code>ctrl+d</code>复制当前行，<code>ctrl+y</code>删除当前行，<code>shift+enter</code>换行(当前行任意位置均可换行)，<code>ctrl+/</code>批量注释或批量取消注释，<code>Tab</code>键和<code>shift+Tab</code>键完成批量缩进和取消缩进，<code>ctrl+f</code>查找，<code>ctrl+r</code>替换，<code>ctrl+&#39;+&#39;/&#39;-&#39;</code>折叠或者展开代码或<code>ctrl+shift+&#39;+&#39;/&#39;-&#39;</code>全部折叠或展开代码。设置-&gt;KeyMap设置快捷键。#TODO 记录要做的事情。</p>
<h3 id="小Tips"><a href="#小Tips" class="headerlink" title="小Tips"></a>小Tips</h3><p>转义字符——除了用<code>\</code>外，还可以用<code>r&#39; &#39;</code>代表单引号内的内容不转义，特殊的<code>%%</code>表示<code>%</code>。<br>多行写代码——用<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>的格式表示多行字符，并且还能在前面加上<code>r</code>一起使用表示内部内容不转义。<br>python除法——<code>/</code>默认是结果为浮点数，而<code>//</code>则默认会去掉小数部分保留整数。<br>字符编码——ASCII码(单字节)-&gt;Unicode码(通常双字节)-&gt;utf-8编码(可变长编码)，计算机中编码：内存统一使用Unicode编码，需要保存到硬盘或者需要传输时则转为utf-8，用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件，浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器。<br>格式化输出——利用<code>%</code>来实现，和c语言类似。例如<code>print(&#39;hello %s %d&#39; % (&#39;world&#39;,4))</code>就会输出<code>hello world 4</code>如果只有一个格式化输出，则不用添加括号。在<code>%d</code>前面添加数字代表空格数或者<code>%f</code>前加<code>.</code>和数字控制小数位数，若不确定要格式化输出的内容可以用<code>%s</code>代替，会将所有内容转换为字符串输出。还有一种格式化方法是使用<code>format()</code>方法，它会用传入的参数依次替换字符串内的占位符<code>{0}</code>、<code>{1}</code>……，不过这种方式写起来比%要麻烦得多，如<code>&#39;Hello, {0}, 成绩提升了 {1:.1f}%&#39;.format(&#39;小明&#39;, 17.125)</code>，输出<code>Hello, 小明, 成绩提升了 17.1%</code>。<br>条件判断——可用<code>elif</code>表示<code>else if</code>，同时如果<code>if</code>后面只有一个变量就和C语言类似。<br>IO——<code>input()</code>的返回类型为<code>str</code>，可用<code>int()</code>转换为整数型，<code>float()</code>转换为浮点数类型。<br>不可变对象——对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。</p>
<p>全局变量——在函数中想要修改全局遍历，如果是可变类型，则可以直接进行修改，如果是不可变类型，则需要使用global声明才可修改。</p>
<h3 id="Python基础"><a href="#Python基础" class="headerlink" title="Python基础"></a>Python基础</h3><h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>python3以unicode编码，即支持多种语言的字符串。<br>对于单个字符(英文或中文)，可用<code>ord()</code>和<code>chr()</code>函数分别读取字符的整数表示和把编码转换为字符。还可以用十六进制表示其他语言如：<code>&#39;\u4e2d\u6587&#39;</code>等价于<code>中文</code>。<br>对于<code>bytes</code>类型的数据用带<code>b</code>前缀的单引号或双引号表示，如<code>x = b&#39;ABC&#39;</code>,<code>bytes</code>类型的数据每个字符占用一个字节。用unicode编码的字符串可以通过<code>encode()</code>函数编码为指定的<code>bytes</code>,内部参数为<code>ascii或者utf-8</code>等其他编码方式,反过来就是使用<code>decode()</code>函数，如果<code>bytes</code>中只有一小部分无效的字节，可以传入<code>errors=&#39;ignore&#39;</code>。纯英文的<code>str</code>可以用<code>ASCII</code>编码为<code>bytes</code>，内容是一样的，含有中文的<code>str</code>可以用<code>UTF-8</code>编码为<code>bytes</code>。<br>对于<code>str</code>字符串可用<code>len()</code>函数计算字符数，如果换为<code>bytes</code>类型，则计算字节数。为了避免乱码问题，我们应该坚持使用<code>utf-8</code>来对<code>str</code>和<code>bytes</code>进行转换。</p>
<h5 id="list"><a href="#list" class="headerlink" title="list"></a>list</h5><p>Python内置的数据类型——列表list，用<code>[]</code>表示。有序的集合，<code>len()</code>获取长度，可用下标访问元素(从0开始的)，也可以使用<code>-1</code>作为下标来直接访问最后一个元素，以此类推用<code>-2</code>,<code>-3</code>等来获取倒数第几个元素。可使用<code>append()方法</code>在列表最后添加元素，或者使用<code>insert(int index, Object obj)方法</code>来添加元素到指定位置；使用<code>pop()方法</code>删除列表末尾的元素或者添加参数<code>index</code>来指定下标；如果需要替换可以直接通过<code>str[i]=&quot;...&quot;</code>来实现，并且<code>list</code>内部的各个元素的数据类型也是可以不相同的，比如可以就是<code>list</code>类型。</p>
<h5 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h5><p>Python内置的另一种有序列表类型——元组，用<code>()</code>表示。和<code>list</code>不同，<code>tuple</code>一旦初始化就不能更改，也没有append()，insert()这样的方法，但是可以通过下标访问元素，不过不能替换，也更加安全，还有一个需要注意的就是如果定义的时候只有一个元素需要加上一个<code>,</code>来避免歧义，<code>t=(1,)</code>，因为如果不加，<code>t</code>就是一个值为1的整型变量了。不过，如果<code>tuple</code>中存在<code>list</code>类型的元素，这个就<code>list</code>中的元素就可以改变了，从而可以理解为<code>tuple</code>也是”可变“的。</p>
<h5 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h5><p>首先是<code>for..in</code>循环，依次把<code>list</code>,<code>tuple</code>中的元素打印出来，例如<code>for x in [1,2,3,4,5]:</code>；或者使用<code>range(x)</code>表示从0开始到小于x的整数序列<code>for x in range(5):</code>，还可以使用<code>list()</code>将<code>range()</code>转换为list类型。</p>
<h5 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h5><p>Python内置的字典类，其他语言也叫<code>map</code>，采用键值对存储方式存储。可通过<code>d[&#39;key&#39;]</code>查询对应的值，还可通过该方法放入键值对。一个<code>key</code>对应一个<code>value</code>，若对一个关键字放入多个值，则后面放入的会把前面放入的冲掉。如果<code>key</code>值不存在，字典会报错，为了避免，可使用<code>&#39;key&#39; in d</code>来查看key是否存在于字典中，若不存在则返回<code>False</code>；或者使用<code>get()方法</code>，如果不存在会返回<code>None</code>，或者返回自己指定的<code>value</code>，还可以使用<code>pop(&#39;key&#39;)方法</code>删除键值对。最重要的是<code>key</code>对象必须是不可变对象。</p>
<h5 id="set"><a href="#set" class="headerlink" title="set"></a>set</h5><p>和dict类似，也是一组key的集合，只是不存储value值，也同样不能重复。通过<code>add()</code>和<code>remove()</code>方法实现添加或者删除key，set可以看作数学上的集合，可以进行∩、∪等操作。并且要创建一个set，需要提供一个list作为输入集合，<code>s = set([1, 2, 3])</code></p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h5 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h5><p><code>max()</code>——可以从传入任意个参数，返回最大的那个。<br><code>str()</code>,<code>int()</code>,<code>bool()</code>等——数据类型转换函数。<br><code>hex()</code>函数——把一个整数转换成十六进制表示的字符串。</p>
<p>函数名实际是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”。即<code>a = abs</code>，然后可以用<code>a()</code>来实现<code>abs()</code>的功能。<br>如果想要保证传入函数的参数类型是正确的，可用<code>isinstance()方法</code>判断是否参数类型满足你所定义的参数类型。<br>函数是可以返回多个值的，可以用多个变量来接收，也可以用一个，因为返回的实际上是一个<code>tuple</code></p>
<h5 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h5><p><code>def f(x,n=2)</code>这里就给n设置了一个默认参数，如果调用函数<code>f()</code>时只传入了一个参数x，则会默认传入一个等于2的n进函数，这样就比较方便，例如<code>f(5)</code>实际上就是<code>f(5,2)</code>。不过设置默认参数的时候也有几个需要注意的地方：第一是必选参数在前，默认参数在后，第二是默认参数必须指向不变对象。如果指向一个list，则每次调用时都会改变list里的元素从而导致函数无法发挥作用。可见，默认参数降低了函数调用的难度，而一旦需要更复杂的调用时，又可以传递更多的参数来实现。无论是简单调用还是复杂调用，函数只需要定义一个。</p>
<p>在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个<code>*</code>号。在函数内部，参数<code>numbers</code>接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数：<code>def calc(numbers)</code>，<code>def calc(*numbers)</code>前者调用需要传入list或tuple，<code>calc([1,2,3])</code>而后者则不需要，<code>calc(1,2,3)</code>。同时可变参数还可传入一个list或tuple进函数，不过需要添加<code>*</code>号，例如<code>nums = [1,2,3]</code>，<code>calc(*nums)</code>即可，<code>*nums</code>表示把<code>nums</code>这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见。</p>
<h5 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h5><p>关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。示例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, **kw)</span>:</span></span><br><span class="line">    print(<span class="string">'name:'</span>, name, <span class="string">'age:'</span>, age, <span class="string">'other:'</span>, kw)</span><br><span class="line"><span class="comment"># 不传入关键字参数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Michael'</span>, <span class="number">30</span>)</span><br><span class="line">name: Michael age: <span class="number">30</span> other: &#123;&#125;</span><br><span class="line"><span class="comment"># 传入任意个数的关键字参数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Bob'</span>, <span class="number">35</span>, city=<span class="string">'Beijing'</span>)</span><br><span class="line">name: Bob age: <span class="number">35</span> other: &#123;<span class="string">'city'</span>: <span class="string">'Beijing'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Adam'</span>, <span class="number">45</span>, gender=<span class="string">'M'</span>, job=<span class="string">'Engineer'</span>)</span><br><span class="line">name: Adam age: <span class="number">45</span> other: &#123;<span class="string">'gender'</span>: <span class="string">'M'</span>, <span class="string">'job'</span>: <span class="string">'Engineer'</span>&#125;</span><br><span class="line"><span class="comment"># 和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>extra = &#123;<span class="string">'city'</span>: <span class="string">'Beijing'</span>, <span class="string">'job'</span>: <span class="string">'Engineer'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Jack'</span>, <span class="number">24</span>, **extra)</span><br><span class="line">name: Jack age: <span class="number">24</span> other: &#123;<span class="string">'city'</span>: <span class="string">'Beijing'</span>, <span class="string">'job'</span>: <span class="string">'Engineer'</span>&#125;</span><br></pre></td></tr></table></figure>

<p><code>**extra</code>表示把<code>extra</code>这个dict的所有key-value用关键字参数传入到函数的<code>**kw</code>参数，<code>kw</code>将获得一个dict，注意<code>kw</code>获得的dict是<code>extra</code>的一份拷贝，对<code>kw</code>的改动不会影响到函数外的<code>extra</code>。</p>
<h5 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果要限制关键字参数的名字，就可以用命名关键字参数</span></span><br><span class="line"><span class="comment"># 例如，只接收city和job作为关键字参数。这种方式定义的函数如下：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, *, city, job)</span>:</span></span><br><span class="line">    print(name, age, city, job)</span><br><span class="line"><span class="comment"># 如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, *args, city, job)</span>:</span></span><br><span class="line">    print(name, age, args, city, job)</span><br><span class="line"><span class="comment"># 命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错，即需要写上city='..',job='..'</span></span><br><span class="line"><span class="comment"># 由于调用时缺少参数名city和job，Python解释器把这4个参数均视为位置参数，但person()函数仅接受2个位置参数。</span></span><br><span class="line"><span class="comment"># 命名关键字参数可以有缺省值，从而简化调用：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, *, city=<span class="string">'Beijing'</span>, job)</span>:</span></span><br><span class="line">    print(name, age, city, job)</span><br></pre></td></tr></table></figure>

<h5 id="参数组合"><a href="#参数组合" class="headerlink" title="参数组合"></a>参数组合</h5><p>在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。比如定义一个函数，包含上述若干种参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(a, b, c=<span class="number">0</span>, *args, **kw)</span>:</span></span><br><span class="line">    print(<span class="string">'a ='</span>, a, <span class="string">'b ='</span>, b, <span class="string">'c ='</span>, c, <span class="string">'args ='</span>, args, <span class="string">'kw ='</span>, kw)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(a, b, c=<span class="number">0</span>, *, d, **kw)</span>:</span></span><br><span class="line">    print(<span class="string">'a ='</span>, a, <span class="string">'b ='</span>, b, <span class="string">'c ='</span>, c, <span class="string">'d ='</span>, d, <span class="string">'kw ='</span>, kw)</span><br></pre></td></tr></table></figure>

<p>在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">0</span> args = () kw = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>, <span class="number">2</span>, c=<span class="number">3</span>)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = () kw = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="string">'b'</span>)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = (<span class="string">'a'</span>, <span class="string">'b'</span>) kw = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, x=<span class="number">99</span>)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = (<span class="string">'a'</span>, <span class="string">'b'</span>) kw = &#123;<span class="string">'x'</span>: <span class="number">99</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f2(<span class="number">1</span>, <span class="number">2</span>, d=<span class="number">99</span>, ext=<span class="literal">None</span>)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">0</span> d = <span class="number">99</span> kw = &#123;<span class="string">'ext'</span>: <span class="literal">None</span>&#125;</span><br></pre></td></tr></table></figure>

<p>最神奇的是通过一个tuple和dict，你也可以调用上述函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>args = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kw = &#123;<span class="string">'d'</span>: <span class="number">99</span>, <span class="string">'x'</span>: <span class="string">'#'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1(*args, **kw)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = (<span class="number">4</span>,) kw = &#123;<span class="string">'d'</span>: <span class="number">99</span>, <span class="string">'x'</span>: <span class="string">'#'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>args = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kw = &#123;<span class="string">'d'</span>: <span class="number">88</span>, <span class="string">'x'</span>: <span class="string">'#'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f2(*args, **kw)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> d = <span class="number">88</span> kw = &#123;<span class="string">'x'</span>: <span class="string">'#'</span>&#125;</span><br></pre></td></tr></table></figure>

<p>所以，对于任意函数，都可以通过类似<code>func(*args, **kw)</code>的形式调用它，无论它的参数是如何定义的。</p>
<h5 id="参数小结"><a href="#参数小结" class="headerlink" title="参数小结"></a>参数小结</h5><p>Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。<br>默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！<br>要注意定义可变参数和关键字参数的语法：<br><code>*args</code>是可变参数，args接收的是一个tuple；<br><code>**kw</code>是关键字参数，kw接收的是一个dict。<br>以及调用函数时如何传入可变参数和关键字参数的语法：<br>可变参数既可以直接传入：<code>func(1, 2, 3)</code>，又可以先组装list或tuple，再通过<code>*args</code>传入：<code>func(*(1, 2, 3))</code>；<br>关键字参数既可以直接传入：<code>func(a=1, b=2)</code>，又可以先组装dict，再通过<code>**kw</code>传入：<code>func(**{&#39;a&#39;: 1, &#39;b&#39;: 2})</code>。<br>使用<code>*args</code>和<code>**kw</code>是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。<br>命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。<br>定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符<code>*</code>，否则定义的将是位置参数。</p>
<h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><p>尾递归优化——尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。python未提供该优化。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 上面的fact(n)函数由于return n * fact(n - 1)引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> fact_iter(n, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact_iter</span><span class="params">(num, product)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> product</span><br><span class="line">    <span class="keyword">return</span> fact_iter(num - <span class="number">1</span>, num * product)</span><br><span class="line"><span class="comment"># 可以看到，return fact_iter(num - 1, num * product)仅返回递归函数本身，`num - 1`和`num * product`在函数调用前就会被计算，不影响函数调用。</span></span><br></pre></td></tr></table></figure>

<h3 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h3><h5 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h5><p>正向切片——<code>L[0:3]</code>，从索引0开始取到索引3为止且不包含索引为3的元素，如果第一个索引为0，还可以省略，即<code>L[:3]</code>。<br>倒数切片——<code>L[-10:-1]</code>，即取从倒数第十到倒数第一的元素且不包含最后一个元素，如果想取最后一个元素，则<code>L[-10:]</code>即可。<br>设置间隔——<code>L[0:10:2]</code>，即取前十个数且每两个数取一个，或者<code>L[::5]</code>，取所有，每5个取一个。如果只写<code>:</code>则复制原有的<code>list</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试</span></span><br><span class="line"><span class="comment"># 利用切片操作，实现一个trim()函数，去除字符串首尾的空格，注意不要调用str的strip()方法：</span></span><br><span class="line"><span class="comment"># 自己写的</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trim</span><span class="params">(s)</span>:</span></span><br><span class="line">    l = len(s)</span><br><span class="line">    end = <span class="number">0</span></span><br><span class="line">    front = l</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(l):</span><br><span class="line">        <span class="keyword">if</span> s[i] != <span class="string">' '</span>:</span><br><span class="line">            front = i</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(l - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> s[i] != <span class="string">' '</span>:</span><br><span class="line">            end = i</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> front &gt; end:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    <span class="keyword">return</span> s[front:end+<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 网上的一些</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trim</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="number">0</span>==len(s):</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">while</span> <span class="string">' '</span>==s[<span class="number">0</span>]:</span><br><span class="line">        s=s[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span>==len(s):</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">while</span> <span class="string">' '</span>==s[<span class="number">-1</span>]:</span><br><span class="line">        s=s[:<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span>==len(s):</span><br><span class="line">            <span class="keyword">return</span> s         </span><br><span class="line">    <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>

<h5 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h5><p>只要是可迭代对象，就可以通过<code>for</code>进行迭代，用<code>dict</code>举例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> d:</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> d.values():</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> d.items():</span><br><span class="line"><span class="comment"># 如何判断是否可以迭代呢</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line">isinstance(<span class="string">'abc'</span>, Iterable) <span class="comment"># 判断是否可迭代</span></span><br></pre></td></tr></table></figure>

<h5 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h5><p>用来生成<code>list</code>，例<code>list(range(1,11))</code>，并且可以和<code>if,for</code>配合使用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>)]  <span class="comment"># [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span></span><br><span class="line">[x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]  <span class="comment"># [4, 16, 36, 64, 100]</span></span><br><span class="line">[m + n <span class="keyword">for</span> m <span class="keyword">in</span> <span class="string">'ABC'</span> <span class="keyword">for</span> n <span class="keyword">in</span> <span class="string">'XYZ'</span>]  <span class="comment"># ['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']</span></span><br><span class="line">d = &#123;<span class="string">'x'</span>: <span class="string">'A'</span>, <span class="string">'y'</span>: <span class="string">'B'</span>, <span class="string">'z'</span>: <span class="string">'C'</span> &#125;</span><br><span class="line">[k + <span class="string">'='</span> + v <span class="keyword">for</span> k, v <span class="keyword">in</span> d.items()]  <span class="comment"># ['y=B', 'x=A', 'z=C']</span></span><br><span class="line">L = [<span class="string">'Hello'</span>, <span class="string">'World'</span>, <span class="string">'IBM'</span>, <span class="string">'Apple'</span>]</span><br><span class="line">[s.lower() <span class="keyword">for</span> s <span class="keyword">in</span> L]  <span class="comment"># ['hello', 'world', 'ibm', 'apple']</span></span><br></pre></td></tr></table></figure>

<p>可见，在一个列表生成式中，<code>for</code>前面的<code>if ... else</code>是表达式，而<code>for</code>后面的<code>if</code>是过滤条件，不能带<code>else</code>。</p>
<h5 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h5><p><code>generator</code>一边循环，一边计算，可以把列表生成式的<code>[]</code>改为<code>()</code>即可，可以用<code>next(g)</code>来打印生成器的下一个值，在没有元素时会抛出异常。也可以通过<code>for</code>来迭代从而避免异常。定义generator的另一种方法，如果一个函数定义中包含<code>yield</code>关键字，那么这个函数就不再是一个普通函数，而是一个generator。</p>
<p>生成器每次停止是在遇到<code>yield</code>关键字停止，下一次开始也同样从这里开始。调用generator时，需要先生成一个generator对象，<code>o=odd() # odd是一个generator</code>，同样使用for来迭代：<code>for n in odd()</code>，但是使用for语句会拿不到generator<code>return</code>语句的值，需要使用错误捕获来获得。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">triangles</span><span class="params">()</span>:</span></span><br><span class="line">    list  = [<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> list[:]</span><br><span class="line">        list.append(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> index,value <span class="keyword">in</span> enumerate(list[:<span class="number">-1</span>]):</span><br><span class="line">            list[index+<span class="number">1</span>] += value</span><br></pre></td></tr></table></figure>

<h5 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h5><p><code>isinstance([], Iterable)</code>判断是否是Iterable对象。可以被<code>next()</code>函数调用并不断返回下一个值的对象称为迭代器：<code>Iterator</code>。生成器都是<code>Iterator</code>对象，但<code>list</code>、<code>dict</code>、<code>str</code>虽然是<code>Iterable</code>，却不是<code>Iterator</code>。把<code>list</code>、<code>dict</code>、<code>str</code>等<code>Iterable</code>变成<code>Iterator</code>可以使用<code>iter()</code>函数。<code>Iterator</code>的计算是惰性的，只有在需要返回下一个数据时它才会计算。所以list等就不是<code>Iterator</code>。</p>
<h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><h5 id="map-reduce"><a href="#map-reduce" class="headerlink" title="map/reduce"></a>map/reduce</h5><p><code>map()</code>函数接受两个参数，一个是函数，一个<code>Iterable</code>，<code>map</code>将传入的函数依次作用到序列的每个元素，并把结果作为新的<code>Iterator</code>返回。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">     <span class="keyword">return</span> x * x</span><br><span class="line"></span><br><span class="line">r = map(f, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"><span class="comment"># map()传入的第一个参数是f，即函数对象本身。由于结果r是一个Iterator，Iterator是惰性序列</span></span><br><span class="line"><span class="comment"># 因此通过list()函数让它把整个序列都计算出来并返回一个list。</span></span><br><span class="line">list(r) <span class="comment"># [1, 4, 9, 16, 25, 36, 49, 64, 81]</span></span><br></pre></td></tr></table></figure>

<p><code>reduce()</code>也接受两个参数，一个是函数，一个<code>Iterable</code>，<code>reduce</code>把一个函数作用在一个序列<code>[x1, x2, x3, ...]</code>上，这个函数必须接收两个参数，<code>reduce</code>把结果继续和序列的下一个元素做累积计算。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">reduce(add, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]) <span class="comment"># 25</span></span><br><span class="line"><span class="comment"># 利用map()函数，把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。</span></span><br><span class="line"><span class="comment"># 输入：['adam', 'LISA', 'barT']，输出：['Adam', 'Lisa', 'Bart']：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">normalize</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> name[:<span class="number">1</span>].upper() + name[<span class="number">1</span>:].lower()</span><br><span class="line"><span class="comment"># str2float</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">str2float</span><span class="params">(s)</span>:</span></span><br><span class="line">    DIGITS = &#123;<span class="string">'0'</span>: <span class="number">0</span>, <span class="string">'1'</span>: <span class="number">1</span>, <span class="string">'2'</span>: <span class="number">2</span>, <span class="string">'3'</span>: <span class="number">3</span>, <span class="string">'4'</span>: <span class="number">4</span>, <span class="string">'5'</span>: <span class="number">5</span>, <span class="string">'6'</span>: <span class="number">6</span>, <span class="string">'7'</span>: <span class="number">7</span>, <span class="string">'8'</span>: <span class="number">8</span>, <span class="string">'9'</span>: <span class="number">9</span>, <span class="string">'.'</span>: <span class="number">-1</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> DIGITS[x]</span><br><span class="line">    L = list(map(f, s))</span><br><span class="line">    index = L.index(<span class="number">-1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">r</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    	<span class="keyword">return</span> x *<span class="number">10</span> + y</span><br><span class="line">    x1 = reduce(r, L[:index])</span><br><span class="line">    x2 = reduce(r, L[index+<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> float(str(x1)+<span class="string">'.'</span>+str(x2))</span><br></pre></td></tr></table></figure>

<h5 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h5><p><code>filter()</code>函数用于过滤序列。和<code>map()</code>类似，<code>filter()</code>也接收一个函数和一个序列。和<code>map()</code>不同的是，<code>filter()</code>把传入的函数依次作用于每个元素，然后根据返回值是<code>True</code>还是<code>False</code>决定保留还是丢弃该元素。且<code>filter()</code>返回的是<code>Iterator</code>，惰性序列，需要使用<code>list()</code>来生成。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用于生成素数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成器-从3开始的奇数序列</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_odd_iter</span><span class="params">()</span>:</span></span><br><span class="line">    n = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n = n + <span class="number">2</span></span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line"><span class="comment"># 筛选函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_not_divisible</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x: x % n &gt; <span class="number">0</span>  </span><br><span class="line"><span class="comment"># 生成素数序列的生成器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">primes</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    it = _odd_iter() <span class="comment"># 初始序列</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n = next(it) <span class="comment"># 返回序列的第一个数</span></span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line">        it = filter(_not_divisible(n), it) <span class="comment"># 构造新序列</span></span><br><span class="line"><span class="comment"># 打印1000以内的素数:</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> primes():</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">1000</span>:</span><br><span class="line">        print(n)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<h5 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h5><p>Python内置的<code>sorted()</code>函数就可以直接对list进行排序(默认从小到大)，此外，<code>sorted()</code>函数也是一个高阶函数，它还可以接收一个<code>key</code>函数来实现自定义的排序。<code>key</code>指定的函数将作用于<code>list</code>的每一个元素上，并根据<code>key</code>函数返回的结果进行排序。要进行反向排序，不必改动key函数，可以传入第三个参数<code>reverse=True</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sorted([<span class="string">'bob'</span>, <span class="string">'about'</span>, <span class="string">'Zoo'</span>, <span class="string">'Credit'</span>], key=str.lower, reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># ['Zoo', 'Credit', 'bob', 'about']</span></span><br></pre></td></tr></table></figure>

<h5 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lazy_sum</span><span class="params">(*args)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">()</span>:</span></span><br><span class="line">        ax = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> args:</span><br><span class="line">            ax = ax + n</span><br><span class="line">        <span class="keyword">return</span> ax</span><br><span class="line">    <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure>

<p>返回的是一个函数，并且是在调用返回的函数<code>f</code>时，才会真正开始计算。且每次调用<code>lazy_sum()</code>返回的都是不同的函数，即使函数相同。</p>
<p>闭包——我们在函数<code>lazy_sum</code>中又定义了函数<code>sum</code>，并且，内部函数<code>sum</code>可以引用外部函数<code>lazy_sum</code>的参数和局部变量，当<code>lazy_sum</code>返回函数<code>sum</code>时，相关参数和变量都保存在返回的函数中的程序结构，就称为闭包。需要注意，返回的函数不是立即执行，而是在函数调用时才会执行。所以返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每次返回递增整数的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_counter</span>:</span></span><br><span class="line">    l = [<span class="number">0</span>] <span class="comment"># 这里使用int类型会报错 如果使用l = 0，后面l += 1，则会报错</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">counter</span>:</span></span><br><span class="line">    	l[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> l[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> counter</span><br><span class="line"><span class="comment"># 原因：不可变类型所指向的地址随值的变化而变化，即l=0指向一个地址，而l+=1，l=1后，指向其他地址</span></span><br><span class="line"><span class="comment"># 而对于可变对象，则其指向的地址不会随值变化而变化，l[0]对应的地址一直不会变，只是该地址对应的值在变</span></span><br></pre></td></tr></table></figure>

<h5 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h5><p><code>lambda</code>关键字表示匿名函数，匿名函数有个限制，就是只能有一个表达式，不用写<code>return</code>，返回值就是该表达式的结果。用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> x: x * x <span class="comment"># def f(x): return x * x </span></span><br><span class="line"><span class="comment"># 也可以没有参数，即和函数没有参数一样的道理，例子:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x, y)</span></span></span><br><span class="line"><span class="function">	<span class="title">return</span> <span class="title">lambda</span>:</span> x + y</span><br></pre></td></tr></table></figure>

<h5 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h5><p>函数有一个<code>_name_</code>属性，可以通过该属性拿到函数的名字。在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。即不改变函数定义，增加功能。装饰器接受函数作为参数，且使用装饰器时，要借助Python的@语法，把decorator置于函数的定义处。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 装饰器</span></span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        print(<span class="string">'call %s():'</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@log</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'2015-3-25'</span>)</span><br><span class="line"><span class="comment"># 即表示now = log(now)</span></span><br><span class="line"><span class="comment"># 且now._name_ = wrapper</span></span><br></pre></td></tr></table></figure>

<p>如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数，写出来会更复杂。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(text)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">        @functools.wraps(func)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">            print(<span class="string">'%s %s():'</span> % (text, func.__name__))</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@log('execute')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'2015-3-25'</span>)</span><br><span class="line"><span class="comment"># 即now = log('execute')(now)</span></span><br></pre></td></tr></table></figure>

<p>在oop设计模式中还有一些应用。</p>
<h5 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h5><p><code>functools.partial</code>帮助我们创建一个偏函数，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。但是创建完后，也仍然可以传递参数来改变功能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line">int2 = functools.partial(int, base=<span class="number">2</span>)</span><br><span class="line">int2(<span class="string">'1000000'</span>) <span class="comment"># 64</span></span><br><span class="line">int2(<span class="string">'1000000'</span>, base=<span class="number">10</span>) <span class="comment"># 1000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际上固定了int()函数的关键字参数base，也就是：</span></span><br><span class="line">int2(<span class="string">'10010'</span>)</span><br><span class="line"><span class="comment"># 相当于</span></span><br><span class="line">kw = &#123; <span class="string">'base'</span>: <span class="number">2</span> &#125;</span><br><span class="line">int(<span class="string">'10010'</span>, **kw)</span><br><span class="line"></span><br><span class="line">max2 = functools.partial(max, <span class="number">10</span>)</span><br><span class="line">max2(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line"><span class="comment"># 相当于</span></span><br><span class="line">args = (<span class="number">10</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line">max(*args)</span><br></pre></td></tr></table></figure>

<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><h5 id="使用模块"><a href="#使用模块" class="headerlink" title="使用模块"></a>使用模块</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">' a test module '</span></span><br><span class="line"></span><br><span class="line">__author__ = <span class="string">'Michael Liao'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	<span class="comment"># xxxxxx</span></span><br></pre></td></tr></table></figure>

<p>第1行和第2行是标准注释，第1行注释可以让这个<code>hello.py</code>文件直接在Unix/Linux/Mac上运行，第2行注释表示.py文件本身使用标准UTF-8编码。第4行是一个字符串，表示模块的文档注释，任何模块代码的第一个字符串都被视为模块的文档注释。第6行使用<code>__author__</code>变量把作者写进去。</p>
<p><code>sys</code>模块中的<code>agrv</code>变量，即命令行参数，第一个参数是该<code>.py</code>文件的名称，<code>argv</code>是一个<code>list</code>。</p>
<p>当我们在命令行运行模块文件时，Python解释器把一个特殊变量<code>__name__</code>置为<code>__main__</code>，而如果在其他地方导入该模块时，<code>if</code>判断将失败，因此，这种<code>if</code>测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。</p>
<p>模块的作用域——在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用。在Python中，是通过<code>_</code>前缀来实现的。类似<code>_xxx</code>和<code>__xxx</code>这样的函数或变量就是非公开的（private），不应该被直接引用，比如<code>_abc</code>，<code>__abc</code>等；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># example</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_private_1</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello, %s'</span> % name</span><br></pre></td></tr></table></figure>

<h5 id="模块搜索路径"><a href="#模块搜索路径" class="headerlink" title="模块搜索路径"></a>模块搜索路径</h5><p>当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错。默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在<code>sys</code>模块的<code>path</code>变量中，如果我们要添加自己的搜索目录，有两种方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一是直接修改sys.path，添加要搜索的目录：</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">'/Users/michael/my_py_scripts'</span>)</span><br><span class="line"><span class="comment"># 这种方法是在运行时修改，运行结束后失效。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种方法是设置环境变量PYTHONPATH，该环境变量的内容会被自动添加到模块搜索路径中。</span></span><br><span class="line"><span class="comment"># 设置方式与设置Path环境变量类似。注意只需要添加你自己的搜索路径，Python自己本身的搜索路径不受影响。</span></span><br></pre></td></tr></table></figure>

<h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><h5 id="类和实例"><a href="#类和实例" class="headerlink" title="类和实例"></a>类和实例</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, age, score)</span>:</span></span><br><span class="line">        self.age = age</span><br><span class="line">        self.score = score</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get_grade</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.score &gt;= <span class="number">90</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'A'</span></span><br><span class="line">        <span class="keyword">elif</span> self.score &gt;= <span class="number">60</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'B'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'C'</span></span><br><span class="line">        </span><br><span class="line">Jack = Student() <span class="comment"># 实例</span></span><br><span class="line">Jack.name = jack <span class="comment"># 添加属性</span></span><br></pre></td></tr></table></figure>

<p>定义类，用<code>class</code>关键字，<code>Object</code>即该类的父类。创建实例即类名+<code>()</code>，还可以自由地给一个实例变量绑定属性，比如，给实例<code>Jack</code>绑定一个<code>name</code>属性。<code>__init__方法</code>可以理解为构造方法，可以绑定需要的属性。且<code>__init__方法</code>的第一个参数永远为<code>self</code>，表示创建的实例本身。和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量<code>self</code>，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。</p>
<h5 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h5><p>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线<code>__</code>，在Python中，实例的变量名如果以<code>__</code>开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, age, score)</span>:</span></span><br><span class="line">        self.__age = age</span><br><span class="line">        self.__score = score</span><br><span class="line"><span class="comment"># 无法从外部访问实例变量.__age和实例变量.__score</span></span><br></pre></td></tr></table></figure>

<p>如果想要访问相应的私有变量，可以通过<code>getter</code>和<code>setter</code>方法来获得和修改私有变量。还有需要注意的是，在Python中，变量名类似<code>__xxx__</code>的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用<code>__name__</code>、<code>__score__</code>这样的变量名。</p>
<p>有些时候，你会看到以一个下划线开头的实例变量名，比如<code>_name</code>，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。</p>
<p>双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问<code>__name</code>是因为Python解释器对外把<code>__name</code>变量改成了<code>_Student__name</code>，所以，仍然可以通过<code>_Student__name</code>来访问<code>__name</code>变量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Jack._Student__name <span class="comment"># jack</span></span><br></pre></td></tr></table></figure>

<p>最后注意下面的这种<strong>错误写法</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bart = Student(<span class="string">'Bart Simpson'</span>, <span class="number">59</span>)</span><br><span class="line">bart.get_name()</span><br><span class="line"><span class="comment"># 'Bart Simpson'</span></span><br><span class="line">bart.__name = <span class="string">'New Name'</span> <span class="comment"># 设置__name变量！</span></span><br><span class="line">bart.__name</span><br><span class="line"><span class="comment"># 'New Name'</span></span><br><span class="line">bart.get_name() <span class="comment"># get_name()内部返回self.__name</span></span><br><span class="line"><span class="comment"># 'Bart Simpson'</span></span><br></pre></td></tr></table></figure>

<p>表面上看，外部代码“成功”地设置了<code>__name</code>变量，但实际上这个<code>__name</code>变量和class内部的<code>__name</code>变量<em>不是</em>一个变量！内部的<code>__name</code>变量已经被Python解释器自动改成了<code>_Student__name</code>，而外部代码给<code>bart</code>新增了一个<code>__name</code>变量。</p>
<h5 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Animal is running...'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Dog is running...'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Cat is running...'</span>)</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_twice</span><span class="params">(animal)</span>:</span></span><br><span class="line">    animal.run()</span><br><span class="line">    animal.run()</span><br></pre></td></tr></table></figure>

<p>在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。但是，反过来就不行。</p>
<p>多态的开闭原则：1）对扩展开放：允许新增<code>Animal</code>子类    2）对修改封闭：不需要修改依赖<code>Animal</code>类型的<code>run_twice()</code>等函数。</p>
<p><strong>静态语言和动态语言</strong>——对于静态语言（例如Java）来说，如果需要传入<code>Animal</code>类型，则传入的对象必须是<code>Animal</code>类型或者它的子类，否则，将无法调用<code>run()</code>方法。对于Python这样的动态语言来说，则不一定需要传入<code>Animal</code>类型。我们只需要保证传入的对象有一个<code>run()</code>方法就可以了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Timer</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Start...'</span>)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 这里没有继承于Animal 但是还是可以当作Animal类型的类传入，因为其具有run()方法</span></span><br></pre></td></tr></table></figure>

<p>这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</p>
<p>Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个<code>read()</code>方法，返回其内容。但是，许多对象，只要有<code>read()</code>方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了<code>read()</code>方法的对象。</p>
<h5 id="获取对象信息"><a href="#获取对象信息" class="headerlink" title="获取对象信息"></a>获取对象信息</h5><p>判断对象类型，使用<code>type()</code>函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type(<span class="number">123</span>) <span class="comment"># &lt;class 'int'&gt;</span></span><br><span class="line">type(<span class="string">'str'</span>) <span class="comment"># &lt;class 'str'&gt;</span></span><br><span class="line">type(<span class="literal">None</span>) <span class="comment"># &lt;type(None) 'NoneType'&gt;</span></span><br><span class="line">type(abs) <span class="comment"># &lt;class 'builtin_function_or_method'&gt;</span></span><br><span class="line">type(a) <span class="comment"># &lt;class '__main__.Animal'&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以在<code>if</code>语句中判断两个变量的类型是否相等</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">type(<span class="number">123</span>)==type(<span class="number">456</span>) <span class="comment"># True</span></span><br><span class="line">type(<span class="number">123</span>)==int <span class="comment"># True</span></span><br><span class="line">type(<span class="string">'abc'</span>)==type(<span class="string">'123'</span>) <span class="comment"># True</span></span><br><span class="line">type(<span class="string">'abc'</span>)==str <span class="comment"># True</span></span><br><span class="line">type(<span class="string">'abc'</span>)==type(<span class="number">123</span>)<span class="comment"># False</span></span><br><span class="line"><span class="comment"># 还可以使用types模块中来判断函数、生成器、对象等等</span></span><br><span class="line"><span class="keyword">import</span> types</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">type(fn)==types.FunctionType <span class="comment"># True</span></span><br><span class="line">type(abs)==types.BuiltinFunctionType <span class="comment"># True</span></span><br><span class="line">type(<span class="keyword">lambda</span> x: x)==types.LambdaType <span class="comment"># True</span></span><br><span class="line">type((x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)))==types.GeneratorType <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p>还可以使用<code>isinstance()</code>来判断类的继承等关系，而不建议使用<code>type()</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># object -&gt; Animal -&gt; Dog -&gt; Husky</span></span><br><span class="line">a = Animal()</span><br><span class="line">d = Dog()</span><br><span class="line">h = Husky()</span><br><span class="line">isinstance(h, Husky) <span class="comment"># True</span></span><br><span class="line">isinstance(h, Dog) <span class="comment"># True</span></span><br><span class="line">isinstance(h, Animal) <span class="comment"># True</span></span><br><span class="line"><span class="comment"># isinstance()判断的是一个对象是否是该类型本身，或者位于该类型的父继承链上。</span></span><br><span class="line">isinstance(d, Husky) <span class="comment"># False</span></span><br><span class="line"><span class="comment"># 能用type()判断的基本类型也可以用isinstance()判断：</span></span><br><span class="line">isinstance(<span class="string">'a'</span>, str) <span class="comment"># True</span></span><br><span class="line"><span class="comment"># 并且还可以判断一个变量是否是某些类型中的一种，比如下面的代码就可以判断是否是list或者tuple：</span></span><br><span class="line">isinstance([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (list, tuple)) <span class="comment"># True</span></span><br><span class="line">isinstance((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (list, tuple)) <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p>如果要获得一个对象的所有属性和方法，可以使用<code>dir()</code>函数，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dir(<span class="string">'ABC'</span>)</span><br><span class="line"><span class="comment"># ['__add__', '__class__',..., '__subclasshook__', 'capitalize', 'casefold',..., 'zfill']</span></span><br></pre></td></tr></table></figure>

<p>类似<code>__xxx__</code>的属性和方法在Python中都是有特殊用途的，比如<code>__len__</code>方法返回长度。在Python中，如果你调用<code>len()</code>函数试图获取一个对象的长度，实际上，在<code>len()</code>函数内部，它自动去调用该对象的<code>__len__()</code>方法，所以，下面的代码是等价的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">len(<span class="string">'ABC'</span>) <span class="comment"># 3</span></span><br><span class="line"><span class="string">'ABC'</span>.__len__() <span class="comment"># 3</span></span><br><span class="line"><span class="string">'ABC'</span>.lower() <span class="comment"># abc</span></span><br></pre></td></tr></table></figure>

<p>同样如果是我们自己写的类，如果也想用<code>len(myObj)</code>的话，也可以自己写一个<code>__len__()</code>方法。还有就是<code>lower()</code>普通方法。</p>
<p>仅仅把属性和方法列出来是不够的，配合<code>getattr()</code>、<code>setattr()</code>以及<code>hasattr()</code>，我们可以直接操作一个对象的状态：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.x = <span class="number">9</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">power</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.x * self.x</span><br><span class="line"></span><br><span class="line">obj = MyObject()</span><br></pre></td></tr></table></figure>

<p>紧接着，可以测试该对象的属性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hasattr(obj, <span class="string">'x'</span>) <span class="comment"># 有属性'x'吗？ True</span></span><br><span class="line">obj.x <span class="comment"># 9</span></span><br><span class="line">hasattr(obj, <span class="string">'y'</span>) <span class="comment"># 有属性'y'吗？ False</span></span><br><span class="line">setattr(obj, <span class="string">'y'</span>, <span class="number">19</span>) <span class="comment"># 设置一个属性'y'</span></span><br><span class="line">hasattr(obj, <span class="string">'y'</span>) <span class="comment"># 有属性'y'吗？ True</span></span><br><span class="line">getattr(obj, <span class="string">'y'</span>) <span class="comment"># 获取属性'y' 19</span></span><br><span class="line">obj.y <span class="comment"># 获取属性'y' 19</span></span><br></pre></td></tr></table></figure>

<p>如果试图获取不存在的属性，会抛出AttributeError的错误：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getattr(obj, <span class="string">'z'</span>) <span class="comment"># 获取属性'z'</span></span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment"># File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span></span><br><span class="line"><span class="comment"># AttributeError: 'MyObject' object has no attribute 'z'</span></span><br></pre></td></tr></table></figure>

<p>还可以传入一个default参数，如果属性不存在，就返回默认值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getattr(obj, <span class="string">'z'</span>, <span class="number">404</span>) <span class="comment"># 获取属性'z'，如果不存在，返回默认值404</span></span><br><span class="line"><span class="comment"># 404</span></span><br></pre></td></tr></table></figure>

<p>也可以获得对象的方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hasattr(obj, <span class="string">'power'</span>) <span class="comment"># 有属性'power'吗？ True</span></span><br><span class="line">getattr(obj, <span class="string">'power'</span>) <span class="comment"># 获取属性'power'</span></span><br><span class="line"><span class="comment"># &lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;</span></span><br><span class="line">fn = getattr(obj, <span class="string">'power'</span>) <span class="comment"># 获取属性'power'并赋值到变量fn</span></span><br><span class="line">fn <span class="comment"># fn指向obj.power</span></span><br><span class="line"><span class="comment"># &lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;</span></span><br><span class="line">fn() <span class="comment"># 调用fn()与调用obj.power()是一样的 81</span></span><br></pre></td></tr></table></figure>

<p>通过内置的一系列函数，我们可以对任意一个Python对象进行剖析，拿到其内部的数据。要注意的是，只有在不知道对象信息的时候，我们才会去获取对象信息。如果可以直接使用类名.属性的形式来进行。</p>
<p>一个正确的用法的例子如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readImage</span><span class="params">(fp)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> hasattr(fp, <span class="string">'read'</span>):</span><br><span class="line">        <span class="keyword">return</span> readData(fp)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<h5 id="实例属性和类属性"><a href="#实例属性和类属性" class="headerlink" title="实例属性和类属性"></a>实例属性和类属性</h5><p>实例属性归属于类本身，但是类的实例也可以像访问属性一样访问，同时还可以通过类名.类属性名来访问。</p>
<p>需要注意的是，千万不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/04/01/JavaScript%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Bcutty Kmy">
      <meta itemprop="description" content="NO DEPENDENCE ONLY PRIDE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BBBBBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/01/JavaScript%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">JavaScript学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-01 00:13:04" itemprop="dateCreated datePublished" datetime="2021-04-01T00:13:04+08:00">2021-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-25 11:55:28" itemprop="dateModified" datetime="2020-04-25T11:55:28+08:00">2020-04-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/" itemprop="url" rel="index"><span itemprop="name">学习篇</span></a>
                </span>
            </span>

          
            <span id="/2021/04/01/JavaScript%E5%AD%A6%E4%B9%A0/" class="post-meta-item leancloud_visitors" data-flag-title="JavaScript学习" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2021/04/01/JavaScript%E5%AD%A6%E4%B9%A0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/04/01/JavaScript%E5%AD%A6%E4%B9%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="JavaScript学习"><a href="#JavaScript学习" class="headerlink" title="JavaScript学习"></a>JavaScript学习</h2><p><em>time:2020/04/10</em></p>
<h4 id="Javascript基础"><a href="#Javascript基础" class="headerlink" title="Javascript基础"></a>Javascript基础</h4><p>数据类型和变量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Number类型，不区分整数和浮点数统一为Number类型。</span></span><br><span class="line"><span class="comment">//NaN和Infinity是特殊的Number类型</span></span><br><span class="line"><span class="comment">//一个表示无法表示的数，另一个则是在JavaScript中超过最大能表示的范围，就为Infinity</span></span><br><span class="line"><span class="comment">//%取模运算在JavaScript中可以对浮点数使用</span></span><br><span class="line"><span class="number">10.5</span>%<span class="number">3</span>==<span class="number">1.5</span>;</span><br><span class="line"><span class="number">0</span>/<span class="number">0</span>==<span class="literal">NaN</span>;</span><br><span class="line"><span class="number">2</span>/<span class="number">0</span>==<span class="literal">Infinity</span>;</span><br><span class="line"><span class="comment">//==和===运算符，前者会自动转换类型再比较，所以应坚持使用后者进行比较</span></span><br><span class="line"><span class="comment">//NaN和所有值都不同，包括其自身，需使用isNaN()来判断</span></span><br><span class="line"><span class="comment">//浮点数的比较也需要注意,eg.1/3!=1-2/3</span></span><br></pre></td></tr></table></figure>

<p>字符串</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可用`...`来表示多行字符串</span></span><br><span class="line"><span class="string">`这是一个</span></span><br><span class="line"><span class="string">多行</span></span><br><span class="line"><span class="string">字符串`</span>;</span><br><span class="line"><span class="comment">//除了用'+'连接字符串，还可以使用$&#123;&#125;来实现</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'小明'</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">`你好, <span class="subst">$&#123;name&#125;</span>, 你今年<span class="subst">$&#123;age&#125;</span>岁了!`</span>;</span><br><span class="line"><span class="comment">//var message = '你好, ' + name + ', 你今年' + age + '岁了!';</span></span><br><span class="line"><span class="comment">//字符串可以使用下标访问特定位置的字符。</span></span><br><span class="line"><span class="comment">//字符串是不变的，所以对某位置的字符进行改变，全字符串是不变的</span></span><br></pre></td></tr></table></figure>

<p><em>time:2020/04/16</em></p>
<p>数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以直接给Array的length赋值，并且会改变Array的大小</span></span><br><span class="line"><span class="comment">//可以给Array超过范围的索引赋值，同样会改变Array</span></span><br><span class="line"><span class="comment">//indexOf()方法，可以返回一个索引或者返回索引对应的元素，即参数可以是索引也可以是元素</span></span><br><span class="line"><span class="comment">//slice()方法，就是和string的substring方法是同样的效果，且参数是参数包含开始索引不包含结束索引,不传递参数，则代表剪切整个字符串，可以这样复制数组</span></span><br><span class="line"><span class="comment">//push()和pop()方法，字符串末尾添加或者删除元素</span></span><br><span class="line"><span class="comment">//unshift()和shift()方法，字符串开头添加或者删除元素(unshift添加)</span></span><br><span class="line"><span class="comment">//sort()方法，排序;reverse()方法，调转数组。</span></span><br><span class="line"><span class="keyword">var</span> arr=&#123;<span class="string">'A'</span>,<span class="string">'b'</span>&#125;;</span><br><span class="line">arr.sort();</span><br><span class="line"><span class="comment">//splice()方法,第一个参数指定索引，第二个参数指定从该索引开始删除的元素个数，然后后面可以跟一些字符串表示从该索引开始添加的元素，也可以不添加，即只有两个参数。并且该方法会返回删除的元素形成的数组</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">'Microsoft'</span>, <span class="string">'Apple'</span>, <span class="string">'Yahoo'</span>, <span class="string">'AOL'</span>, <span class="string">'Excite'</span>, <span class="string">'Oracle'</span>];</span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">3</span>, <span class="string">'Google'</span>, <span class="string">'Facebook'</span>); <span class="comment">// 返回删除的元素 ['Yahoo', 'AOL', 'Excite']</span></span><br><span class="line">arr; <span class="comment">// ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// ['Google', 'Facebook']</span></span><br><span class="line">arr; <span class="comment">// ['Microsoft', 'Apple', 'Oracle']</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="string">'Google'</span>, <span class="string">'Facebook'</span>); <span class="comment">// 返回[],因为没有删除任何元素</span></span><br><span class="line">arr; <span class="comment">// ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']</span></span><br><span class="line"><span class="comment">//concat方法，连接两个数组并返回新数组</span></span><br><span class="line"><span class="keyword">var</span> c=a.concat(b);</span><br><span class="line"><span class="comment">//join方法，把数组中的元素用特定的字符串连接起来，返回字符串</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.join(<span class="string">'-'</span>); <span class="comment">// 'A-B-C-1-2-3'，可以是字符串 不一定只有一个字符</span></span><br></pre></td></tr></table></figure>

<p>对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stu = &#123;</span><br><span class="line">    name:<span class="string">'小小'</span></span><br><span class="line">&#125;;</span><br><span class="line">stu.name;</span><br><span class="line">stu[<span class="string">'name'</span>]; <span class="comment">//这两种访问都是可以的</span></span><br><span class="line">stu.number = <span class="string">'153'</span>; <span class="comment">//可以动态添加属性</span></span><br><span class="line"><span class="keyword">delete</span> stu.number; <span class="comment">//删除属性</span></span><br><span class="line"><span class="string">'name'</span> <span class="keyword">in</span> stu; <span class="comment">//检查对象是否拥有某属性,或者其是否继承某属性 布尔型</span></span><br><span class="line">stu.hasOwnProperty(<span class="string">'name'</span>); <span class="comment">//检查自身是否拥有某一属性 布尔型</span></span><br></pre></td></tr></table></figure>

<p>循环</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//条件判断语句if else与常规语言没有什么区别</span></span><br><span class="line"><span class="comment">//for循环的基本使用也都一样</span></span><br><span class="line"><span class="comment">//for...in...，可以将一个对象的所有属性都循环一遍</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    name: <span class="string">'Jack'</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    city: <span class="string">'Beijing'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> o) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key); <span class="comment">// 'name', 'age', 'city'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//要过滤掉对象继承的属性，用hasOwnProperty()来实现</span></span><br><span class="line"><span class="comment">//Array也是对象，也可以使用for..in..循环，循环得到的是索引</span></span><br><span class="line"><span class="comment">//需要注意，得到的索引是String而不是Number</span></span><br></pre></td></tr></table></figure>

<p>Map和Set</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Map</span></span><br><span class="line"><span class="comment">//初始化map需要一个二维数组，或者可以初始化为空</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'Michael'</span>, <span class="number">95</span>], [<span class="string">'Bob'</span>, <span class="number">75</span>], [<span class="string">'Tracy'</span>, <span class="number">85</span>]]);</span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>(); <span class="comment">// 空Map</span></span><br><span class="line">m.set(<span class="string">'Adam'</span>, <span class="number">67</span>);<span class="comment">//通过set方法添加键值对</span></span><br><span class="line">m.get(<span class="string">'Adam'</span>);<span class="comment">//通过get方法取得键对应的值</span></span><br><span class="line">m.has(<span class="string">'Adam'</span>); <span class="comment">//通过has方法检查是否存在键 布尔型</span></span><br><span class="line">m.delete(<span class="string">'Adam'</span>); <span class="comment">//通过delete方法删除键值对</span></span><br><span class="line"><span class="comment">//由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉</span></span><br><span class="line"><span class="comment">//Set</span></span><br><span class="line"><span class="comment">//要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set</span></span><br><span class="line"><span class="comment">//重复元素在Set中自动被过滤</span></span><br><span class="line"><span class="comment">//通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果；通过delete(key)方法可以删除元素</span></span><br></pre></td></tr></table></figure>

<p><em>time:2020/04/18</em></p>
<p>iterable</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//for..of..迭代器循环</span></span><br><span class="line"><span class="comment">//可用来遍历array的所有元素</span></span><br><span class="line"><span class="comment">//forEach()方法</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]);</span><br><span class="line">s.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">element, sameElement, set</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(element);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">'x'</span>], [<span class="number">2</span>, <span class="string">'y'</span>], [<span class="number">3</span>, <span class="string">'z'</span>]]);</span><br><span class="line">m.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">value, key, map</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//需要提供回调函数function，对每个元素都执行一遍function</span></span><br></pre></td></tr></table></figure>

<p>函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//javascrpit中函数也可以看作对象，函数名可以认为是指向该函数的变量</span></span><br><span class="line"><span class="keyword">var</span> abs = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> -x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//允许传入多个参数，没有定义的参数传入也不会改变什么，传入的参数少也是可以的</span></span><br><span class="line"><span class="comment">//没有参数传入，函数内部的参数接收到的就是undefined，可以在函数内部进行检查以避免</span></span><br><span class="line"><span class="comment">//javascript函数中存在默认参数arguments，里面存放了所有参数，为Array类型</span></span><br><span class="line"><span class="comment">//而且就算函数不定义参数，如果传入了参数，也可以通过arguments拿到参数值</span></span><br><span class="line"><span class="comment">//还可以利用arguments拿到传入参数的个数</span></span><br><span class="line"><span class="comment">//rest参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b, ...rest</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a = '</span> + a);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'b = '</span> + b);</span><br><span class="line">    <span class="built_in">console</span>.log(rest);</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 结果:</span></span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// b = 2</span></span><br><span class="line"><span class="comment">// Array [ 3, 4, 5 ]</span></span><br><span class="line"><span class="comment">//如果没有多余的参数，rest就会接受一个空数组</span></span><br></pre></td></tr></table></figure>

<p>变量作用域与解构赋值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//变量提升</span></span><br><span class="line"><span class="comment">//javascript的函数中会自动把变量的声明提到函数顶部，但不会把赋值提前进行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="string">'Hello, '</span> + y;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">    <span class="keyword">var</span> y = <span class="string">'Bob'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不会报错，但是打印的y是undefined</span></span><br><span class="line"><span class="comment">//由于JavaScript的这一怪异的“特性”，我们在函数内部定义变量时，请严格遵守“在函数内部首先申明所有变量”这一规则。</span></span><br><span class="line"><span class="comment">//最常见的做法是用一个var申明函数内部用到的所有变量</span></span><br><span class="line"><span class="comment">//不在任何函数内定义的变量就具有全局作用域。</span></span><br><span class="line"><span class="comment">//实际上，JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性</span></span><br><span class="line"><span class="comment">//可以通过window.变量进行访问该变量</span></span><br><span class="line"><span class="comment">//某些函数也同样是全局的，可通过window进行访问</span></span><br><span class="line"><span class="comment">//局部作用域</span></span><br><span class="line"><span class="comment">//由于JavaScript的变量作用域实际上是函数内部，我们在for循环等语句块中是无法定义具有局部作用域的变量的</span></span><br><span class="line"><span class="comment">//为了解决块级作用域，ES6引入了新的关键字let，用let替代var可以申明一个块级作用域的变量</span></span><br><span class="line"><span class="comment">//ES6标准引入了新的关键字const来定义常量，const与let都具有块级作用域</span></span><br><span class="line"><span class="keyword">const</span> PI = <span class="number">3.14</span>;</span><br><span class="line"><span class="comment">//解构赋值</span></span><br><span class="line"><span class="comment">//从ES6开始，JavaScript引入了解构赋值，可以同时对一组变量进行赋值。</span></span><br><span class="line"><span class="keyword">var</span> [x, y, z] = [<span class="string">'hello'</span>, <span class="string">'JavaScript'</span>, <span class="string">'ES6'</span>];</span><br><span class="line"><span class="comment">//注意，对数组元素进行解构赋值时，多个变量要用[...]括起来。</span></span><br><span class="line"><span class="comment">//如果数组本身还有嵌套，也可以通过下面的形式进行解构赋值，注意嵌套层次和位置要保持一致：</span></span><br><span class="line"><span class="keyword">let</span> [x, [y, z]] = [<span class="string">'hello'</span>, [<span class="string">'JavaScript'</span>, <span class="string">'ES6'</span>]];</span><br><span class="line"><span class="comment">//解构赋值还可以忽略某些元素：</span></span><br><span class="line"><span class="keyword">let</span> [, , z] = [<span class="string">'hello'</span>, <span class="string">'JavaScript'</span>, <span class="string">'ES6'</span>]；</span><br><span class="line"><span class="comment">//如果需要从一个对象中取出若干属性，也可以使用解构赋值，便于快速获取对象的指定属性：</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    gender: <span class="string">'male'</span>,</span><br><span class="line">    passport: <span class="string">'G-12345678'</span>,</span><br><span class="line">    school: <span class="string">'No.4 middle school'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> &#123;name, age, passport&#125; = person;</span><br><span class="line"><span class="comment">//使用解构赋值对对象属性进行赋值时，如果对应的属性不存在，变量将被赋值为undefined</span></span><br><span class="line"><span class="comment">//如果要使用的变量名和属性名不一致，可以用下面的语法获取：</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    gender: <span class="string">'male'</span>,</span><br><span class="line">    passport: <span class="string">'G-12345678'</span>,</span><br><span class="line">    school: <span class="string">'No.4 middle school'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把passport属性赋值给变量id:</span></span><br><span class="line"><span class="keyword">let</span> &#123;name, <span class="attr">passport</span>:id&#125; = person</span><br><span class="line"><span class="comment">//解构赋值还可以使用默认值，这样就避免了不存在的属性返回undefined的问题：</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    gender: <span class="string">'male'</span>,</span><br><span class="line">    passport: <span class="string">'G-12345678'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果person对象没有single属性，默认赋值为true:</span></span><br><span class="line"><span class="keyword">var</span> &#123;name, single=<span class="literal">true</span>&#125; = person;</span><br><span class="line">name; <span class="comment">// '小明'</span></span><br><span class="line">single; <span class="comment">// true</span></span><br><span class="line"><span class="comment">//有些时候，如果变量已经被声明了，再次赋值的时候，正确的写法也会报语法错误：</span></span><br><span class="line"><span class="keyword">var</span> x, y;</span><br><span class="line"><span class="comment">// 解构赋值:</span></span><br><span class="line">&#123;x, y&#125; = &#123; <span class="attr">name</span>: <span class="string">'小明'</span>, <span class="attr">x</span>: <span class="number">100</span>, <span class="attr">y</span>: <span class="number">200</span>&#125;;</span><br><span class="line"><span class="comment">// 语法错误: Uncaught SyntaxError: Unexpected token =</span></span><br><span class="line"><span class="comment">//这是因为JavaScript引擎把&#123;开头的语句当作了块处理，于是=不再合法。解决方法是用小括号括起来：</span></span><br><span class="line">(&#123;x, y&#125; = &#123; <span class="attr">name</span>: <span class="string">'小明'</span>, <span class="attr">x</span>: <span class="number">100</span>, <span class="attr">y</span>: <span class="number">200</span>&#125;);</span><br><span class="line"><span class="comment">//解构赋值在很多时候可以大大简化代码。例如，交换两个变量x和y的值，可以这么写，不再需要临时变量：</span></span><br><span class="line"><span class="keyword">var</span> x=<span class="number">1</span>, y=<span class="number">2</span>;</span><br><span class="line">[x, y] = [y, x]</span><br><span class="line"><span class="comment">//如果一个函数接收一个对象作为参数，那么，可以使用解构直接把对象的属性绑定到变量中。例如，下面的函数可以快速创建一个Date对象：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildDate</span>(<span class="params">&#123;year, month, day, hour=<span class="number">0</span>, minute=<span class="number">0</span>, second=<span class="number">0</span>&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(year + <span class="string">'-'</span> + month + <span class="string">'-'</span> + day + <span class="string">' '</span> + hour + <span class="string">':'</span> + minute + <span class="string">':'</span> + second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//它的方便之处在于传入的对象只需要year、month和day这三个属性：</span></span><br><span class="line">buildDate(&#123; <span class="attr">year</span>:<span class="number">2017</span>, <span class="attr">month</span>:<span class="number">1</span>, <span class="attr">day</span>:<span class="number">1</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JavaScript的函数内部如果调用了this，那么这个this到底指向谁？</span></span><br><span class="line"><span class="comment">//如果是通过对象的形式进行调用，那么this指向的是调用的对象，是符合情理的</span></span><br><span class="line"><span class="comment">//如果单独调用函数，比如getAge()，此时，该函数的this指向全局对象，也就是window。</span></span><br><span class="line"><span class="comment">//要保证this指向正确，必须用obj.xxx()的形式调用！</span></span><br><span class="line"><span class="comment">//也可以先使用that捕获this，然后再使用</span></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    age: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>; <span class="comment">// 在方法内部一开始就捕获this</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getAgeFromBirth</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">            <span class="keyword">return</span> y - that.birth; <span class="comment">// 用that而不是this</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getAgeFromBirth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//这样就能避免出错了</span></span><br><span class="line"><span class="comment">//apply</span></span><br><span class="line"><span class="comment">//指定函数的this指向哪个对象，可以用函数本身的apply方法</span></span><br><span class="line"><span class="comment">//它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。</span></span><br><span class="line"><span class="comment">//使用apply来避免this的出错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">    <span class="keyword">return</span> y - <span class="keyword">this</span>.birth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    age: getAge</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.age(); <span class="comment">// 25</span></span><br><span class="line">getAge.apply(xiaoming, []); <span class="comment">// 25, this指向xiaoming, 参数为空</span></span><br><span class="line"><span class="comment">//另一个与apply()类似的方法是call()，唯一区别是：</span></span><br><span class="line"><span class="comment">//apply()把参数打包成Array再传入；</span></span><br><span class="line"><span class="comment">//call()把参数按顺序传入。</span></span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>]); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">Math</span>.max.call(<span class="literal">null</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>); <span class="comment">// 5</span></span><br><span class="line"><span class="comment">//对普通函数调用，我们通常把this绑定为null</span></span><br><span class="line"><span class="comment">//装饰器</span></span><br><span class="line"><span class="comment">//利用apply()，我们还可以动态改变函数的行为。</span></span><br><span class="line"><span class="comment">//现在假定我们想统计一下代码一共调用了多少次parseInt()，</span></span><br><span class="line"><span class="comment">//可以把所有的调用都找出来，然后手动加上count += 1，</span></span><br><span class="line"><span class="comment">//不过这样做太傻了。最佳方案是用我们自己的函数替换掉默认的parseInt()</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> oldParseInt = <span class="built_in">parseInt</span>; <span class="comment">// 保存原函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.parseInt = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> oldParseInt.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>); <span class="comment">// 调用原函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p> 闭包</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Array的map()方法</span></span><br><span class="line"><span class="comment">//传入参数为函数对象，作用为将此函数作用于数组的所有元素</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">var</span> results = arr.map(pow); <span class="comment">// [1, 4, 9, 16, 25, 36, 49, 64, 81]</span></span><br><span class="line"><span class="comment">//reduce()方法</span></span><br><span class="line"><span class="comment">//Array的reduce()把一个函数作用在这个Array的[x1, x2, x3...]上</span></span><br><span class="line"><span class="comment">//这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算，其效果就是：</span></span><br><span class="line">[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4);</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>];</span><br><span class="line">arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">10</span> + y;</span><br><span class="line">&#125;); <span class="comment">// 13579,reduce的一些好用的地方</span></span><br><span class="line"><span class="comment">//可以省略function，进而变成arr.map(x=&gt;10*x)或者arr.reduce((x,y)=&gt;10*x+y)</span></span><br></pre></td></tr></table></figure>

<p>箭头函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用箭头函数来省略function</span></span><br><span class="line">x=&gt;x*x;</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;<span class="keyword">return</span> x*x;&#125;;<span class="comment">//两者等价</span></span><br><span class="line"><span class="comment">//箭头函数相当于匿名函数</span></span><br><span class="line"><span class="comment">//如果函数只用return一个表达式，则可以全部省略</span></span><br><span class="line"><span class="comment">//如果函数体里包含了一些其他结构，则不能省略return</span></span><br><span class="line">x =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>) <span class="keyword">return</span> x * x;</span><br><span class="line">    <span class="keyword">else</span>  <span class="keyword">return</span> - x * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果存在多个参数需要用括号括起来</span></span><br><span class="line">(x, y) =&gt; x * x + y * y</span><br><span class="line">() =&gt; <span class="number">3.14</span></span><br><span class="line"><span class="comment">// 可变参数:</span></span><br><span class="line">(x, y, ...rest) =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> i, sum = x + y;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;rest.length; i++) &#123;</span><br><span class="line">        sum += rest[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在返回对象的时候需要用小括号括起来，因为&#123;&#125;会导致歧义</span></span><br><span class="line">x=&gt;(&#123;<span class="attr">foo</span> : x&#125;);</span><br><span class="line"><span class="comment">//使用箭头函数也不用担心this的错用，箭头函数会保证this指向外部作用域</span></span><br><span class="line"><span class="comment">//this在箭头函数中已经词法绑定了</span></span><br><span class="line"><span class="comment">//用call()或者apply()调用箭头函数时，无法对this进行绑定，即传入的第一个参数被忽略</span></span><br><span class="line">arr.sort(<span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x-y;</span><br><span class="line">&#125;);<span class="comment">//简化sort写法</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 10, 20]</span></span><br></pre></td></tr></table></figure>

<p>generator</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/04/01/HTML%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Bcutty Kmy">
      <meta itemprop="description" content="NO DEPENDENCE ONLY PRIDE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BBBBBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/01/HTML%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">HTML学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-01 00:13:04" itemprop="dateCreated datePublished" datetime="2021-04-01T00:13:04+08:00">2021-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-10 21:54:40" itemprop="dateModified" datetime="2020-04-10T21:54:40+08:00">2020-04-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/" itemprop="url" rel="index"><span itemprop="name">学习篇</span></a>
                </span>
            </span>

          
            <span id="/2021/04/01/HTML%E5%AD%A6%E4%B9%A0/" class="post-meta-item leancloud_visitors" data-flag-title="HTML学习" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2021/04/01/HTML%E5%AD%A6%E4%B9%A0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/04/01/HTML%E5%AD%A6%E4%B9%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>时隔几个月，终于又开始写博客了，原因呢，大学太颓废，还是得找点事给自己干，所以从现在开始学习前端开发，最开始，当然，从HTML开始，虽然之前也学过一些，但是总结的东西都不多，所以这次就当是正式开始系统的学习前端知识了，我的一个思路呢就是HTML-&gt;CSS-&gt;JS，先把这三大基础整透，再说后面的内容。写博客的目的呢，一是监督自己学习，二呢就是方便自己在学习的时候做好相关的笔记记录，这样也能给予自己前进的动力了，好了废话就说这么多，开始这一系列第一篇博客的更新了。</p>
<p><em>time：2020/04/07</em></p>
<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p>在开始这篇博客前已经完成了一些准备工作如下：</p>
<p>vscode安装、webstorm安装、sublime安装，虽然这三个IDE都比较推荐，但我还是全都安装下来了，在使用过程中再来取舍。</p>
<h4 id="HTML基础"><a href="#HTML基础" class="headerlink" title="HTML基础"></a>HTML基础</h4><p>用 style 属性代替旧的一些标签以及属性，如<code>&lt;font&gt;,&lt;basefont&gt;,&lt;s&gt;,&lt;u&gt;,alion,color,bgcolor</code>等等。将其变成以下样式：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span> = <span class="string">"background-color:red"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span> = <span class="string">"color:red"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span> = <span class="string">"font-family:verdana"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"text-align:center"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>文本格式化标签</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--粗体--&gt;</span> <span class="tag">&lt;<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--着重文字--&gt;</span> <span class="tag">&lt;<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--斜体--&gt;</span> <span class="tag">&lt;<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--加重语气,和加粗差不多--&gt;</span> <span class="tag">&lt;<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--插入字,即下划线--&gt;</span> <span class="tag">&lt;<span class="name">ins</span>&gt;</span><span class="tag">&lt;/<span class="name">ins</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--删除字--&gt;</span> <span class="tag">&lt;<span class="name">del</span>&gt;</span><span class="tag">&lt;/<span class="name">del</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--大号和小号--&gt;</span> <span class="tag">&lt;<span class="name">big</span>&gt;</span><span class="tag">&lt;/<span class="name">big</span>&gt;</span> <span class="tag">&lt;<span class="name">small</span>&gt;</span><span class="tag">&lt;/<span class="name">small</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>计算机输出标签</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--代码--&gt;</span> <span class="tag">&lt;<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">code</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--键盘码--&gt;</span> <span class="tag">&lt;<span class="name">kbd</span>&gt;</span><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--计算机代码样本--&gt;</span> <span class="tag">&lt;<span class="name">sample</span>&gt;</span><span class="tag">&lt;/<span class="name">sample</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--打印机代码--&gt;</span> <span class="tag">&lt;<span class="name">tt</span>&gt;</span><span class="tag">&lt;/<span class="name">tt</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--变量，用于定义--&gt;</span> <span class="tag">&lt;<span class="name">var</span>&gt;</span><span class="tag">&lt;/<span class="name">var</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--预格式文本,在code内包围代码可实现保留空格回车--&gt;</span> <span class="tag">&lt;<span class="name">pre</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>引用</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--短的引用--&gt;</span> <span class="tag">&lt;<span class="name">q</span>&gt;</span><span class="tag">&lt;/<span class="name">q</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--长引用，并会进行缩进处理--&gt;</span> <span class="tag">&lt;<span class="name">blockquote</span>&gt;</span><span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--定义缩写，为浏览器提供帮助--&gt;</span> <span class="tag">&lt;<span class="name">abbr</span>&gt;</span><span class="tag">&lt;/<span class="name">abbr</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--定义缩写的意义，鼠标放置即可查看--&gt;</span> <span class="tag">&lt;<span class="name">dfn</span>&gt;</span><span class="tag">&lt;/<span class="name">dfn</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--定义文档或者文章的联系信息--&gt;</span> <span class="tag">&lt;<span class="name">address</span>&gt;</span><span class="tag">&lt;/<span class="name">address</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--定义著作的标题--&gt;</span> <span class="tag">&lt;<span class="name">cite</span>&gt;</span><span class="tag">&lt;/<span class="name">cite</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--双向书写，可以从左边开始--&gt;</span> <span class="tag">&lt;<span class="name">bdo</span>&gt;</span><span class="tag">&lt;/<span class="name">bdo</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<p><em>time：2020/04/08</em></p>
<p>外部样式表</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"mystyle.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>内部样式表</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-tag">body</span> &#123;<span class="attribute">background-color</span>: red&#125;</span></span><br><span class="line"><span class="css"><span class="selector-tag">p</span> &#123;<span class="attribute">margin-left</span>: <span class="number">20px</span>&#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>内联样式</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color: red; margin-left: 20px"</span>&gt;</span></span><br><span class="line">This is a paragraph</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<p>链接</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"url"</span>&gt;</span>Link text<span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="comment">&lt;!--链接不一定是网页，也可以是图片等等--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"url"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="comment">&lt;!--使链接在新窗口打开--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">"xxx"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="comment">&lt;!--定义锚点--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#xxx"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="comment">&lt;!--本文档其他位置可以创建访问锚点的链接,适用于pdf--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://....#xxx"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="comment">&lt;!--其他界面创建访问该锚点的链接--&gt;</span></span><br></pre></td></tr></table></figure>

<p>图片</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--alt在图片未加载的时候显示，无闭合标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">alt</span>=<span class="string">"loading..."</span> <span class="attr">alion</span>=<span class="string">"left"</span> <span class="attr">width</span>=<span class="string">""</span> <span class="attr">height</span>=<span class="string">""</span>/&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--还可用&lt;a&gt;包裹图片制作图片链接--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--还可利用&lt;map&gt;,&lt;area&gt;来定义图像地图--&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>time：2020/04/09</em></p>
<p>表格</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span> <span class="attr">cellpadding</span>=<span class="string">"10"</span> <span class="attr">cellspacing</span>=<span class="string">"10"</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--border表示表格边框的厚度 cellpadding表示边界与单元内容之间的距离 cellspacing规定单元格之间的距离--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">caption</span>&gt;</span>我的标题<span class="tag">&lt;/<span class="name">caption</span>&gt;</span> <span class="comment">&lt;!--表格标题--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">th</span> <span class="attr">rowspan</span>=<span class="string">"2"</span>&gt;</span>Heading<span class="tag">&lt;/<span class="name">th</span>&gt;</span> <span class="comment">&lt;!--表头 加粗居中 横跨两行--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">th</span> <span class="attr">colspan</span>=<span class="string">"2"</span>&gt;</span>Another Heading<span class="tag">&lt;/<span class="name">th</span>&gt;</span> <span class="comment">&lt;!--横跨两列--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">td</span>&gt;</span>row 1, cell 1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">td</span>&gt;</span>row 1, cell 2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">td</span>&gt;</span>&amp;nbsp;<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="comment">&lt;!--避免空单元格，会使边框无法显示，使用空格占位--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">td</span>&gt;</span>row 2, cell 2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--表格中每个单元格都可设置颜色、背景、对齐方式、frame属性等等--&gt;</span></span><br></pre></td></tr></table></figure>

<p>列表</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--无序列表 type代表小圆点的类型--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">type</span>=<span class="string">"disc"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>咖啡<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>茶<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>牛奶<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--有序列表 start设置开始序号 type代表序号的类型--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">start</span>=<span class="string">"50"</span> <span class="attr">type</span>=<span class="string">"I"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>咖啡<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>牛奶<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>茶<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--列表都可以嵌套使用--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--自定义列表 dt标题 dd内容--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dt</span>&gt;</span>计算机<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dd</span>&gt;</span>用来计算的仪器 ... ...<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dt</span>&gt;</span>显示器<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dd</span>&gt;</span>以视觉方式显示信息的装置 ... ...<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>块</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--块元素和内联元素区别就是 块元素会以新行来开始 而内联元素则不会--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--块级：&lt;h1&gt;, &lt;p&gt;, &lt;ul&gt;, &lt;table&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--内联级：&lt;b&gt;, &lt;td&gt;, &lt;a&gt;, &lt;img&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;div&gt;块级元素 和CSS一起使用对大块地方进行样式设计--&gt;</span> <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;span&gt;内联级元素 和CSS一起使用对文本进行样式设计--&gt;</span> <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>类</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--对 HTML 进行分类（设置类），使我们能够为元素的类定义 CSS 样式。</span></span><br><span class="line"><span class="comment">为相同的类设置相同的样式，或者为不同的类设置不同的样式。--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.cities</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background-color</span><span class="selector-pseudo">:black</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">color</span><span class="selector-pseudo">:white</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">margin</span><span class="selector-pseudo">:20px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">padding</span><span class="selector-pseudo">:20px</span>;</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"cities"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>London<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">London is the capital city of England. </span><br><span class="line">It is the most populous city in the United Kingdom, </span><br><span class="line">with a metropolitan area of over 13 million inhabitants.</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>布局</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--&lt;div&gt; 元素常用作布局工具，因为能够轻松地通过 CSS 对其进行定位。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--DIV的ID属性和CLASS属性的区别--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--id对应css是用样式选择符“#”（井号）class对应css是用样式选择符“.”(英文半角输入句号)--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--id属性，只能被一个元素调用（以“#”选择符命名CSS样式在一个页面只能使用调用一次）</span></span><br><span class="line"><span class="comment">class类标记，可以用于被多个元素调用(以“.”选择符命名样式可以一个页面使用多次)--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--一个代表身份证，一个代表衣服,下方是实例--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-id">#header</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background-color</span><span class="selector-pseudo">:black</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">color</span><span class="selector-pseudo">:white</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">text-align</span><span class="selector-pseudo">:center</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">padding</span><span class="selector-pseudo">:5px</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-id">#nav</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">line-height</span><span class="selector-pseudo">:30px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background-color</span>:<span class="selector-id">#eeeeee</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">height</span><span class="selector-pseudo">:300px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">width</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">float</span><span class="selector-pseudo">:left</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">padding</span><span class="selector-pseudo">:5px</span>;	      </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-id">#section</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">width</span><span class="selector-pseudo">:350px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">float</span><span class="selector-pseudo">:left</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">padding</span><span class="selector-pseudo">:10px</span>;	 	 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-id">#footer</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background-color</span><span class="selector-pseudo">:black</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">color</span><span class="selector-pseudo">:white</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">clear</span><span class="selector-pseudo">:both</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">text-align</span><span class="selector-pseudo">:center</span>;</span></span><br><span class="line"><span class="css">   <span class="selector-tag">padding</span><span class="selector-pseudo">:5px</span>;	 	 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"header"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>City Gallery<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"nav"</span>&gt;</span></span><br><span class="line">London<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">Paris<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">Tokyo<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"section"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>London<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">London is the capital city of England. It is the most populous city in the United Kingdom,</span><br><span class="line">with a metropolitan area of over 13 million inhabitants.</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">Standing on the River Thames, London has been a major settlement for two millennia,</span><br><span class="line">its history going back to its founding by the Romans, who named it Londinium.</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"footer"</span>&gt;</span></span><br><span class="line">Copyright ? W3Schools.com</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>time:2020/04/10</em></p>
<p>框架</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--框架结构标签&lt;frameset&gt;,rows和cols的值规定了每个框架所占的面积--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--框架标签&lt;frame&gt;,每个frame中设置一个html文档--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--假如一个框架有可见边框，用户可以拖动边框来改变它的大小。为了避免这种情况发生，可以在 &lt;frame&gt; 标签中加入：noresize="noresize"。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--重要提示：不能将 &lt;body&gt;&lt;/body&gt; 标签与 &lt;frameset&gt;&lt;/frameset&gt; 标签同时使用！不过，假如你添加包含一段文本的 &lt;noframes&gt; 标签，就必须将这段文字嵌套于 &lt;body&gt;&lt;/body&gt; 标签内。（在下面的第一个实例中，可以查看它是如何实现的。）--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--这里都是简要介绍，具体的应用现在还无法完全掌握--&gt;</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/31/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Bcutty Kmy">
      <meta itemprop="description" content="NO DEPENDENCE ONLY PRIDE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BBBBBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/31/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/" class="post-title-link" itemprop="url">Java面经整理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-03-31 20:09:50 / Modified: 20:10:22" itemprop="dateCreated datePublished" datetime="2021-03-31T20:09:50+08:00">2021-03-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          
            <span id="/2021/03/31/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/" class="post-meta-item leancloud_visitors" data-flag-title="Java面经整理" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2021/03/31/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/03/31/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java面经整理"><a href="#Java面经整理" class="headerlink" title="Java面经整理"></a>Java面经整理</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>几种常见的数据结构</p>
<blockquote>
<p>树、图、链表、优先队列(堆)、跳表(链表+多级索引)</p>
<p>跳表(redis的zset使用跳表)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;跳表的查询的时间复杂度为 O(logn)，因为找到位置之后插入和删除的时间复杂度很低，为 O(1)，所以最终插入和删除的时间复杂度也为 O(logn)</span><br><span class="line">&gt;删除操作:</span><br><span class="line">* 如果这个结点在索引中也有出现，我们除了要删除原始链表中的结点，还要删除索引中的。</span><br><span class="line">* 同时我们删除节点时需要获得前驱节点(双向链表除外)</span><br><span class="line">&gt;插入操作</span><br><span class="line">* 插入元素过多，可能导致两个索引间节点过多，效率降低。我们需要维护索引与原始链表的大小平衡。。</span><br><span class="line">* 跳表是通过一个随机函数来维护这个平衡的，当我们向跳表中插入数据时，我们可以选择同时把这个数据插入到索引里，那我们插入到哪一级的索引呢，这就需要随机函数，来决定我们插入到哪一级的索引中。这样可以很有效的防止跳表退化，而造成效率变低。</span><br></pre></td></tr></table></figure>

<p>优先队列实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 清楚大顶堆、小顶堆定义</span></span><br><span class="line">&gt;<span class="comment">// Java PriorityQueue 通过数组实现</span></span><br><span class="line">&gt;<span class="comment">// 插入元素 从末尾开始找</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123; <span class="comment">// k代表当前元素个数、x为需要插入的元素</span></span><br><span class="line">  Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;) x;</span><br><span class="line">  <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 找到父节点下标</span></span><br><span class="line">      <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">      Object e = queue[parent];</span><br><span class="line">      <span class="comment">// 如果是小顶堆 则判断 x &gt;= queue[parent] 如果符合说明找到了需要插入的位置 break</span></span><br><span class="line">      <span class="comment">// 进行插入该节点，并将该parent节点放入index为k的位置</span></span><br><span class="line">      <span class="keyword">if</span> (key.compareTo((E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// 否则 将该节点下降 并令k为parent继续循环</span></span><br><span class="line">      queue[k] = e;</span><br><span class="line">      k = parent;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 插入到找到的位置</span></span><br><span class="line">  queue[k] = key;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// poll方法 移除最小元素</span></span><br><span class="line">&gt;<span class="comment">// 传入index为size的元素 此时根节点为空 k从0开始</span></span><br><span class="line">&gt;<span class="comment">// 即index为k的元素被取走后，拿出数组最后的元素x 不断寻找位置进行插入 如果不满足 会将空节点的子节点放入空节点 然后对其子节点进行继续操作直到找到能插入的位置或者循环结束</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123; <span class="comment">// x为堆中最后的元素</span></span><br><span class="line">  Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;)x;</span><br><span class="line">  <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;        <span class="comment">// loop while a non-leaf</span></span><br><span class="line">  <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">      <span class="comment">// x 从根节点开始 每次和 index为2k+1和2k+2中更小的元素进行比较</span></span><br><span class="line">      <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// assume left child is least</span></span><br><span class="line">      Object c = queue[child];</span><br><span class="line">      <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">          ((Comparable&lt;? <span class="keyword">super</span> E&gt;) c).compareTo((E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">          <span class="comment">// 小顶堆：c为2k+1和2k+2中较小的一个 也就是k对应节点的左右节点中小的那个</span></span><br><span class="line">          c = queue[child = right];</span><br><span class="line">      <span class="comment">// 小顶堆：如果x比较c大，我们就和c交换位置 否则我们的数就应该在k位置上，k从0开始。</span></span><br><span class="line">      <span class="keyword">if</span> (key.compareTo((E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// 交换位置</span></span><br><span class="line">      queue[k] = c;</span><br><span class="line">      k = child;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 找到了位置</span></span><br><span class="line">  queue[k] = key;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">// remove方法 移除指定元素</span></span><br><span class="line">&gt;<span class="function">E <span class="title">removeAt</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="comment">// i为指定元素的index 是通过循环遍历得到的</span></span><br><span class="line">  <span class="comment">// assert i &gt;= 0 &amp;&amp; i &lt; size;</span></span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="keyword">int</span> s = --size; <span class="comment">// s为最后一个元素的下标</span></span><br><span class="line">  <span class="keyword">if</span> (s == i) <span class="comment">// removed last element</span></span><br><span class="line">      queue[i] = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 将s对应的节点也就是最后一个节点拿到 需要进行树的修复</span></span><br><span class="line">      E moved = (E) queue[s];</span><br><span class="line">      <span class="comment">// 将其置为null</span></span><br><span class="line">      queue[s] = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// 以queue[i]为根节点的树(堆) 进行树的修复</span></span><br><span class="line">      <span class="comment">// 小顶堆：将moved元素作为上文的x元素 和上文的poll方法类似 </span></span><br><span class="line">      <span class="comment">// 只是此处不是k=0开始，而是k=i开始 因为移除的是index=i的元素</span></span><br><span class="line">      siftDown(i, moved);</span><br><span class="line">      <span class="comment">// 此时以queue[i]为根节点的树(堆)已经修复完成了</span></span><br><span class="line">      <span class="keyword">if</span> (queue[i] == moved) &#123;</span><br><span class="line">          <span class="comment">// 如果moved在i位置上 说明moved元素较小 还可以继续向上调整</span></span><br><span class="line">          siftUp(i, moved); <span class="comment">// 向上调整 ？？？？</span></span><br><span class="line">          <span class="keyword">if</span> (queue[i] != moved)</span><br><span class="line">              <span class="keyword">return</span> moved;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

</blockquote>
<p>判断链表是否存在环</p>
<blockquote>
<p>快慢指针判断是否重合（如果需要找到入环点，在第一次相遇后一指针指向头部，然都保持慢指针速度继续前进，再次相遇的地方即为入环点）</p>
</blockquote>
<p>二叉搜索树、平衡二叉树、红黑树</p>
<blockquote>
<p>搜索二叉树：左节点 &lt; 根节点 &lt; 右节点，且左子树所有节点 &lt; 根节点 &lt; 右子树所有节点</p>
<p>平衡二叉树：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。对于插入节点和删除节点，如果破坏了平衡，那么都需要进行旋转以重新平衡。AVL树的查找、插入、删除操作在平均和最坏的情况下都是O（logn），代码可参考下方：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 只会存在4种旋转方式：左旋、右旋、先左再右、先右再左。</span></span><br><span class="line">&gt;<span class="comment">// 递归进行判断即可</span></span><br><span class="line">&gt;<span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">&gt;<span class="keyword">int</span> val;</span><br><span class="line">&gt;Node left, right;</span><br><span class="line"><span class="comment">// 构造方法...</span></span><br><span class="line">&gt;<span class="comment">/* 左旋，右旋省略 */</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Node newNode = <span class="keyword">new</span> Node(<span class="keyword">this</span>.val);</span><br><span class="line">  newNode.left = <span class="keyword">this</span>.left;</span><br><span class="line">  newNode.right = <span class="keyword">this</span>.right.left;</span><br><span class="line">  <span class="keyword">this</span>.val = <span class="keyword">this</span>.right.val;</span><br><span class="line">  <span class="keyword">this</span>.left = newNode;</span><br><span class="line">  <span class="keyword">this</span>.right = <span class="keyword">this</span>.right.right;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="comment">/* 添加节点 */</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 首先进行节点添加</span></span><br><span class="line">  <span class="keyword">if</span> (node.val &lt; <span class="keyword">this</span>.lval) &#123;</span><br><span class="line">  	<span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) <span class="keyword">this</span>.left = node;</span><br><span class="line">  	<span class="keyword">else</span> <span class="keyword">this</span>.left.add(node);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.val &gt; <span class="keyword">this</span>.lval) &#123;</span><br><span class="line">  	<span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) <span class="keyword">this</span>.right = node;</span><br><span class="line">  	<span class="keyword">else</span> <span class="keyword">this</span>.right.add(node);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// 判断是否需要旋转</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.getLeftHeight() - <span class="keyword">this</span>.getRightHeight() &gt; <span class="number">1</span>) &#123; <span class="comment">// 获得子树高度的get方法 略</span></span><br><span class="line">      <span class="comment">// 需要右旋 但需要先判断左子树是否需要先左旋</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.getLeftHeight() &lt; <span class="keyword">this</span>.left.getRightHeight()) &#123;</span><br><span class="line">          <span class="keyword">this</span>.left.leftRotate();</span><br><span class="line">      &#125;</span><br><span class="line">    	<span class="keyword">this</span>.rightRotate();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 左旋同理...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 删除节点</span></span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">  	1、查找到对应节点</span></span><br><span class="line"><span class="comment">  	2、判断该节点是否为叶节点，如果为叶节点，则直接删除</span></span><br><span class="line"><span class="comment">  		如果不是叶节点，则判断该节点是否存在左右子树</span></span><br><span class="line"><span class="comment">  			如果只有左子树 则获得左子树的最大值leftMax 并将需要删除的节点的值置为leftMax 然后递归删除左子树中的该节点</span></span><br><span class="line"><span class="comment">  			如果只有右子树 则获得右子树的最小值rigthMin 并将需要删除的节点的值置为rigthMin 然后递归删除右子树中的该节点</span></span><br><span class="line"><span class="comment">  			如果左右子树均存在，也一样获得右子树的最小值rigthMin 并将需要删除的节点的值置为rigthMin 然后递归删除右子树中的该节点</span></span><br><span class="line"><span class="comment">  	3、删除完成后 判断是否平衡 即和上面add方法的后半部分类似 然后进行旋转平衡接即可</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>==红黑树==：</p>
<ol>
<li><strong>任何一个节点都有颜色，黑色或者红色</strong></li>
<li><strong>根节点是黑色的</strong></li>
<li><strong>空节点被认为是黑色的</strong>(即NIL结点)</li>
<li><strong>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</strong></li>
<li><strong>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</strong>(这也叫做完美黑色平衡，与2-3树的完美平衡有些不同)</li>
</ol>
<p><strong>只有黑色节点的红黑树其实就是平衡二叉树</strong>。我们将<strong>红色点想成是填充节点</strong>。即每次插入都以红色插入，且将<strong>黑色想成主要节点</strong>。红色节点做填充。红色节点的作用就是使得树的高度更加灵活，不至于像平衡二叉树那样每次插入都需要 做平衡操作（减少了需要平衡的概率）。<strong>（红色节点的子节点是黑色节点）</strong>条件就使得高度受到限制，极限情况就是一个红色一个黑色串联。最多的查找次数 不会超过2倍的 最少的查找数。</p>
<p>红黑树其实就是 二叉查找树和平衡二叉树 两者优缺点的一种折中。可以防止出现二叉查找树那种极差的情况，也可以减少插入时平衡的次数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 旋转操作和平衡树保持一致</span></span><br><span class="line">&gt;<span class="comment">/* </span></span><br><span class="line"><span class="comment">&gt;插入操作有三种情况是不会破坏性质的 且插入的节点一定是红色</span></span><br><span class="line"><span class="comment">  1、插入节点作为根节点</span></span><br><span class="line"><span class="comment">  2、插入节点作为根节点的子节点</span></span><br><span class="line"><span class="comment">  3、插入节点的父结点是黑色的</span></span><br><span class="line"><span class="comment">&gt;如果会破坏性质 则说明不满足以上情况 也就是说明 新节点必定存在祖父节点、新节点父节点为红色</span></span><br><span class="line"><span class="comment">1、叔节点为红色——重绘，父节点和叔节点绘制为黑色，祖父节点绘制为红色</span></span><br><span class="line"><span class="comment">2、叔节点为黑色，祖-父-子节点在同侧——将父绘黑，祖绘红，然后以祖为枢纽进行向相反侧的方向旋转</span></span><br><span class="line"><span class="comment">3、叔节点为黑色，祖-父-子节点不在同侧——先根据子父所在的那一侧的方向，以父为枢向相反方向旋转，这样就实现了将子父祖异侧转换为了父子祖同侧，第二步是发现它符合上一种情况了，那就将现在的父(原来的子)绘黑，祖(原来的祖)绘红，然后再次旋转。</span></span><br><span class="line"><span class="comment">&gt;注意：需要修复时，还需要递归进行，即在一次修复后将指针指向此次操作的祖父节点 然后继续判断是否需要修复	</span></span><br><span class="line"><span class="comment">&gt;最后仍然需要将根节点绘制为红色。</span></span><br><span class="line"><span class="comment">&gt;*/</span></span><br></pre></td></tr></table></figure>

<img src="https://i.loli.net/2021/03/10/O3Kf8HcTyFd69kz.png" alt="红黑树remove.png" style="zoom: 33%;">
</blockquote>
<p>线段树、树状数组</p>
<blockquote>
<p>树状数组是一种特殊的线段树</p>
</blockquote>
<p>B树、B+树</p>
<blockquote>
<p>每个节点不止一个数据</p>
<p>B树：每个节点上都存了key-data</p>
<p>B+树：只有叶子节点存了data，其他节点可存更多key，且所有叶子节点之间存在顺序指针关系。</p>
</blockquote>
<h2 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h2><p>开机过程</p>
<blockquote>
<p>BIOS自检-&gt;加载bootloader到内存-&gt;bootloader加载OS到内存-&gt;从OS起始位置开始执行指令</p>
<p>BIOS位于RAM；bootstrap位于磁盘第一个主引导扇区；OS位于磁盘</p>
<p>以x86为例，bootloader一般会被加载到于内存0x7c00处</p>
</blockquote>
<p>内存管理</p>
<blockquote>
<p>段页式存储、虚拟内存、系统抖动。</p>
</blockquote>
<p>进程和线程区别，什么是协程</p>
<blockquote>
<p>进程是资源分配的基本单位。线程是CPU调度的基本单位。一个进程中可包含多个线程。</p>
<p>协程是轻量级的用户线程，一个线程可包含多个协程，只在用户态运行，开销小。</p>
</blockquote>
<p>进程调度的方式(CFS?)</p>
<blockquote>
<p><em>Linux*的调度器类主要实现两类进程调度算法：实时调度算法和完全公平调度算法</em>(CFS)*，实时调度算法SCHED_FIFO和SCHED_RR，按优先级执行，一般不会被抢占。直到实时进程执行完，才会执行普通进程。而大多数的普通进程，用的就是CFS算法。</p>
<p>CFS 调度程序并不采用严格规则来为一个优先级分配某个长度的时间片，而是为每个任务分配一定比例的 CPU 处理时间。每个任务分配的具体比例是根据友好值来计算的。友好值的范围从 -20 到 +19，数值较低的友好值表示较高的相对优先级。具有较低友好值的任务，与具有较高友好值的任务相比，会得到更高比例的处理器处理时间。默认友好值为 0。</p>
<blockquote>
<p>友好一词源自如下想法：当一个任务增加了它的友好值，如从 0 至 +10，该任务通过降低优先级，进而对其他任务更加友好。</p>
</blockquote>
<p>CFS 没有使用离散的时间片，而是采用目标延迟，这是每个可运行任务应当运行一次的时间间隔。根据目标延迟，按比例分配 CPU 时间。除了默认值和最小值外，随着系统内的活动任务数量超过了一定阈值，目标延迟可以增加。</p>
<p>CFS 调度程序没有直接分配优先级。相反，它通过每个任务的变量 vruntime 以便维护虚拟运行时间，进而记录每个任务运行多久。虚拟运行时间与基于任务优先级的衰减因子有关，更低优先级的任务比更高优先级的任务具有更高衰减速率。对于正常优先级的任务（友好值为 0），虚拟运行时间与实际物理运行时间是相同的。</p>
<p>因此，如果一个默认优先级的任务运行 200ms，则它的虚拟运行时间也为 200ms。然而，如果一个较低优先级的任务运行 200ms，则它的虚拟运行时间将大于 200ms。同样，如果一个更高优先级的任务运行 200ms，则它的虚拟运行时间将小于 200ms。当决定下步运行哪个任务时，调度程序只需选择具有最小虚拟运行时间的任务。此外，一个更高优先级的任务如成为可运行，就会抢占低优先级任务。</p>
<p>下面分析一下 CFS 调度程序是如何工作的。假设有两个任务，它们具有相同的友好值。一个任务是 I/O 密集型而另一个为 CPU 密集型。通常，I/O 密集型任务在运行很短时间后就会阻塞以便等待更多的 I/O；而 CPU 密集型任务只要有在处理器上运行的机会，就会用完它的时间片。</p>
<p>因此，I/O 密集型任务的虚拟运行时间最终将会小于 CPU 密集型任务的，从而使得 I/O 密集型任务具有更高的优先级。这时，如果 CPU 密集型任务在运行，而 I/O 密集型任务变得有资格可以运行（如该任务所等待的 I/O 已成为可用)，那么 I/O 密集型任务就会抢占 CPU 密集型任务。</p>
</blockquote>
<p>死锁</p>
<blockquote>
<p>两个线程互相持有对方所需要的资源，互相等待，谁也无法继续执行下去。</p>
<p>条件：互斥、持有并等待、不可抢占、循环等待</p>
<p>处理方法：死锁预防(破坏四个条件中的一个)、死锁避免(银行家)、死锁检测与消除</p>
</blockquote>
<p>进程、线程、协程的区别（详细）</p>
<blockquote>
<p>进程、线程，都是有内核进行调度，有 CPU 时间片的概念，进行 抢占式调度。</p>
<p>协程(用户级线程)完全由用户自己的程序进行调度（协作式调度），需要协程自己主动把控制权转让出去之后，其他协程才能被执行到。</p>
<p>协程，是在应用层模拟的线程，他避免了上下文切换的额外耗费，兼顾了多线程的优点。简化了高并发程序的复杂度。协程还是通过共享内存通讯.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;目前的协程框架一般都是设计成 1:N 模式。</span><br><span class="line">&gt;所谓 1:N 就是一个线程作为一个容器里面放置多个协程。</span><br><span class="line">&gt;那么谁来适时的切换这些协程？答案是有协程自己主动让出CPU，</span><br><span class="line">&gt;也就是每个协程池里面有一个调度器，这个调度器是被动调度的。</span><br><span class="line">&gt;意思就是他不会主动调度。</span><br><span class="line">&gt;而且当一个协程发现自己执行不下去了(比如异步等待网络的数据回来，但是当前还没有数据到)，</span><br><span class="line">&gt;这个时候就可以由这个协程通知调度器，</span><br><span class="line">&gt;这个时候执行到调度器的代码，调度器根据事先设计好的调度算法找到当前最需要CPU的协程。</span><br><span class="line">&gt;切换这个协程的CPU上下文把CPU的运行权交个这个协程，直到这个协程出现执行不下去需要等等的情况，</span><br><span class="line">&gt;或者它调用主动让出CPU的API之类，触发下一次调度。对的没错就是类似于 领导人模式那么这个实现有没有问题？</span><br><span class="line">&gt;其实是有问题的，假设这个线程中有一个协程是CPU密集型的他没有IO操作，也就是自己不会主动触发调度器调度的过程，</span><br><span class="line">&gt;那么就会出现其他协程得不到执行的情况，所以这种情况下需要程序员自己避免。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>深拷贝、浅拷贝（java）</p>
<blockquote>
<p>浅拷贝：只是增加了一个指针指向原内存。</p>
<p>深拷贝：深拷贝是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存。</p>
</blockquote>
<p>写时复制</p>
<blockquote>
<p>系统调用 fork() 创建了父进程的一个复制，以作为子进程。传统上，fork() 为子进程创建一个父进程地址空间的副本，复制属于父进程的页面。然而，考虑到许多子进程在创建之后立即调用系统调用 exec()，父进程地址空间的复制可能没有必要。</p>
<p>因此，可以采用一种称为写时复制的技术，它通过允许父进程和子进程最初共享相同的页面来工作。这些共享页面标记为写时复制，这意味着如果任何一个进程写入共享页面，那么就创建共享页面的副本。</p>
<p>当使用写时复制技术时，仅复制任何一进程修改的页面，所有未修改的页面可以由父进程和子进程共享。</p>
<p>注意：采用 vfork()，父进程被挂起，子进程使用父进程的地址空间。因为 vfork() 不采用写时复制，如果子进程修改父地址空间的任何页面，那么这些修改过的页面对于恢复的父进程是可见的。因此，应谨慎使用 vfork()，以确保子进程不会修改父进程的地址空间。</p>
</blockquote>
<p>mmap内存映射</p>
<blockquote>
<p>内存映射，简而言之就是将用户空间的一段内存区域映射到内核空间，映射成功后，用户对这段内存区域的修改可以直接反映到内核空间，同样，内核空间对这段区域的修改也直接反映用户空间。那么对于内核空间&lt;—-&gt;用户空间两者之间需要大量数据传输等操作的话效率是非常高的。</p>
</blockquote>
<p>缓冲区溢出</p>
<blockquote>
<p>例如栈溢出导致返回值或者方法返回地址被修改，进而导致被攻击。</p>
</blockquote>
<p>为何需要用户态、内核态</p>
<blockquote>
<p>应用程序不能直接访问外设，需要内核在其中充当被信任的第三方，只有内核才能执行特权指令。同时也是方便应用程 序通过内核提供的接口来更方便编写操作外设的程序。即不用关注和外设具体打交道的细节，其应该由操作系统来完成。</p>
</blockquote>
<p>read ahead文件预读</p>
<blockquote>
<p>所谓预读，是指文件系统为应用程序一次读出比预期更多的文件内容并缓存在page cache中，这样下一次读请求到来时部分页面直接从page cache读取即可。当然，这个细节对应用程序透明，应用程序可能的感觉就是下次读的速度会更快</p>
</blockquote>
<p>x86是大端还是小端，为什么</p>
<blockquote>
<p>小端</p>
</blockquote>
<p>select、poll、epoll</p>
<blockquote>
<p>select：bitmap、遍历bitmap获取数据、bitmap不可重用</p>
<p>poll：结构体数组(三个字段存在状态位)、遍历判断状态位获取数据、结构体数组可重用</p>
<p>epoll：类似poll结构体(两个字段 不存在状态位)、由内核对其进行排序并返回数量，直接遍历数量即可获得socket</p>
</blockquote>
<p>管道底层实现</p>
<blockquote>
<p>无名管道：内存中实现(内核中的缓存)，如<kbd>|</kbd>，有名管道：磁盘实现，如<kbd>mkfifo</kbd>。只有父子进程之间可以通过匿名管道。</p>
<p>管道采用半双工通信，使用一个管道一般的规则是<strong>读管道数据的进程关闭管道写入端,而写管道进程关<br>闭其读出端</strong>。</p>
<p>管道传输的数据是无格式的且大小受限。</p>
<p>父子进程之间的匿名管道，因为子进程复制父进程创建的文件描述符，所以各自拥有两个fd[0]、fd[1]，这样就实现了进程间通信。</p>
</blockquote>
<p>系统调用的具体过程，如何实现</p>
<blockquote>
<p>应用程序主动向操作系统发起服务请求，应用程序请求操作系统提供服务，切换到内核态，内核态响应服务然后完成后返回。</p>
</blockquote>
<p>select、poll、epoll机制</p>
<blockquote>
<p>select采用轮询机制，耗时较大，且监听的socket有限(可以改变)</p>
<p>select和poll只支持LT工作模式，epoll的默认的工作模式是LT模式，还支持ET（边缘触发）模式。</p>
<p>水平触发：①对于读操作，只要缓冲内容不为空，LT模式返回读就绪。②对于写操作，只要缓冲区还不满，LT模式会返回写就绪。</p>
<p>边缘触发：在ET模式下， 缓冲区从不可读变成可读，会唤醒应用进程，缓冲区数据变少的情况，则不会再唤醒应用进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">举例1：</span><br><span class="line">读缓冲区刚开始是空的</span><br><span class="line">读缓冲区写入2KB数据</span><br><span class="line">水平触发和边缘触发模式此时都会发出可读信号</span><br><span class="line">收到信号通知后，读取了1KB的数据，读缓冲区还剩余1KB数据</span><br><span class="line">水平触发会再次进行通知，而边缘触发不会再进行通知</span><br><span class="line">举例2：（以脉冲的高低电平为例）</span><br><span class="line">水平触发：0为无数据，1为有数据。缓冲区有数据则一直为1，则一直触发。</span><br><span class="line">边缘触发发：0为无数据，1为有数据，只要在0变到1的上升沿才触发。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>epoll红黑树</p>
<blockquote>
<p>epoll和poll的一个很大的区别在于，poll每次调用时都会存在一个将pollfd结构体数组中的每个结构体元素从用户态向内核态中的一个链表节点拷贝的过程，而内核中的这个链表并不会一直保存，当poll运行一次就会重新执行一次上述的拷贝过程，这说明一个问题：poll并不会在内核中为要监听的文件描述符长久的维护一个数据结构来存放他们，而epoll内核中维护了一个内核事件表，它是将所有的文件描述符全部都存放在内核中，系统去检测有事件发生的时候触发回调，当你要添加新的文件描述符的时候也是调用epoll_ctl函数使用EPOLL_CTL_ADD宏来插入，epoll_wait也不是每次调用时都会重新拷贝一遍所有的文件描述符到内核态。当我现在要在内核中长久的维护一个数据结构来存放文件描述符，并且时常会有插入，查找和删除的操作发生，这对内核的效率会产生不小的影响，因此需要一种插入，查找和删除效率都不错的数据结构来存放这些文件描述符，那么红黑树当然是不二的人选。</p>
</blockquote>
<p>epoll与select、poll的对比</p>
<blockquote>
<p><strong>1. 用户态将文件描述符传入内核的方式</strong></p>
<p>select：创建3个文件描述符集并拷贝到内核中，分别监听读、写、异常动作。这里受到单个进程可以打开的fd数量限制，默认是1024。poll：将传入的struct pollfd结构体数组拷贝到内核中进行监听。epoll：执行epoll_create会在内核的高速cache区中建立一颗红黑树以及就绪链表(该链表存储已经就绪的文件描述符)。接着用户执行的epoll_ctl函数添加文件描述符会在红黑树上增加相应的结点。</p>
<p><strong>2. 内核态检测文件描述符读写状态的方式</strong></p>
<p>select：采用轮询方式，遍历所有fd，最后返回一个描述符读写操作是否就绪的mask掩码，根据这个掩码给fd_set赋值。poll：同样采用轮询方式，查询每个fd的状态，如果就绪则在等待队列中加入一项并继续遍历。epoll：采用回调机制。在执行epoll_ctl的add操作时，不仅将文件描述符放到红黑树上，而且也注册了回调函数，内核在检测到某文件描述符可读/可写时会调用回调函数，该回调函数将文件描述符放在就绪链表中。</p>
<p><strong>3. 找到就绪的文件描述符并传递给用户态的方式</strong></p>
<p>select：将之前传入的fd_set拷贝传出到用户态并返回就绪的文件描述符总数。用户态并不知道是哪些文件描述符处于就绪态，需要遍历来判断。poll：将之前传入的fd数组拷贝传出用户态并返回就绪的文件描述符总数。用户态并不知道是哪些文件描述符处于就绪态，需要遍历来判断。epoll：epoll_wait只用观察就绪链表中有无数据即可，最后将链表的数据返回给数组并返回就绪的数量。内核将就绪的文件描述符放在传入的数组中，所以只用遍历依次处理即可。这里返回的文件描述符是通过mmap让内核和用户空间共享同一块内存实现传递的，减少了不必要的拷贝。</p>
<p><strong>4. 重复监听的处理方式</strong></p>
<p>select：将新的监听文件描述符集合拷贝传入内核中，继续以上步骤。poll：将新的struct pollfd结构体数组拷贝传入内核中，继续以上步骤。epoll：无需重新构建红黑树，直接沿用已存在的即可。</p>
<p><strong>epoll更高效的原因</strong></p>
<p>select和poll的动作基本一致，只是poll采用链表来进行文件描述符的存储，而select采用fd标注位来存放，所以select会受到最大连接数的限制，而poll不会。select、poll、epoll虽然都会返回就绪的文件描述符数量。但是select和poll并不会明确指出是哪些文件描述符就绪，而epoll会。造成的区别就是，系统调用返回后，调用select和poll的程序需要遍历监听的整个文件描述符找到是谁处于就绪，而epoll则直接处理即可。select、poll都需要将有关文件描述符的数据结构拷贝进内核，最后再拷贝出来。而epoll创建的有关文件描述符的数据结构本身就存于内核态中，系统调用返回时利用mmap()文件映射内存加速与内核空间的消息传递：即epoll使用mmap减少复制开销。select、poll采用轮询的方式来检查文件描述符是否处于就绪态，而epoll采用回调机制。造成的结果就是，随着fd的增加，select和poll的效率会线性降低，而epoll不会受到太大影响，除非活跃的socket很多。epoll的边缘触发模式效率高，系统不会充斥大量不关心的就绪文件描述符虽然epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</p>
</blockquote>
<h2 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h2><p>TCP</p>
<blockquote>
<p>特点：可靠、面向连接、点对点通信、全双工通信、拥塞控制、流量控制。（ARQ）</p>
<p>close_wait：防止被动关闭方仍然存在数据没有发送完。</p>
<p>time_wait为何等待两个MSL：①保证自己发送的ACK能够到达被动方，2MSL保证能够超时重传；②保证本次连接中产生的所有报文都已经在网络中消失，不会影响下一个连接。</p>
<p>time_wait太多：调整内核参数。即：①重用处于time_wait的socket；②快速回收处于time_wait的socket；③降低socket处于time_wait的时间④降低系统默认设置的time_wait的socket最大数量；⑤扩大可用于socket的端口范围</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_syncookies = 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭； --用于防御半连接攻击</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME_WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；</span><br><span class="line">net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME_WAIT sockets的快速回收，默认为0，表示关闭。</span><br><span class="line">net.ipv4.tcp_fin_timeout 修改系统默认的 TIMEOUT 时间</span><br></pre></td></tr></table></figure>

<p>流量控制：发送窗口不能大于接收窗口。</p>
<p>拥塞控制：慢开始(小于门限，指数增长)、拥塞避免(大于门限、线性增长)、快重传(收到三个重复确认时，直接重传丢失报文而非等待超时)、快恢复(门限值减半，拥塞窗口减半，直接开始拥塞避免)。对于超时的情况，门限减半，拥塞窗口直接从0开始执行慢开始算法。</p>
</blockquote>
<p>拥塞控制为何是3个ACK才快重传</p>
<blockquote>
<p>TCP segment乱序有2/5= 40%的概率会造成A收到三次duplicated ACK(N)；而如果N丢了，则会100%概率A会收到三次duplicated ACK(N);</p>
</blockquote>
<p>UDP</p>
<blockquote>
<p>不可靠、无连接、RIP协议使用、实现可靠传输需要上层应用层帮助(RUDPS、RTP、UDT模仿TCP)。不对数据包做任何操作，直接将其发送，也不考虑接收方。</p>
</blockquote>
<p>丢包问题一般发生在哪一层</p>
<blockquote>
</blockquote>
<p>ICMP协议作用</p>
<blockquote>
<p>类型：目标不可到达、源抑制和超时报文</p>
<p>是ip报文的组成部分。</p>
</blockquote>
<p>电脑联网失败，发生在哪一层</p>
<blockquote>
</blockquote>
<p>TCP和UDP的报头长度</p>
<blockquote>
<p>udp8字节，tcp20字节</p>
</blockquote>
<p>SCTP了解过吗, 介绍一下</p>
<blockquote>
<p>流控制传输协议（SCTP，Stream Control Transmission Protocol）是一种在网络连接两端之间同时传输多个数据流的协议。</p>
<p>SCTP是面向消息的（message-oriented）。它提供各个记录的按序递送服务。与UDP一样，由发送端写入的每一条记录的长度随数据一道传递给接收端应用。</p>
<p>SCTP能给在所连接的端点之间提供多个流，每个流各自可靠地按序递送消息。一个流上某个消息的丢失不会阻塞同一关联其他流上消息的投递。这种做法与TCP正好相反，就TCP而言，在单一字节流中任何位置的字节丢失都将在阻塞该连接上其后所有数据的递送，直到该丢失被修复为止。</p>
</blockquote>
<p>TELNET</p>
<blockquote>
<p>Telnet协议是TCP/IP协议家族中的一员，是Internet远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用telnet程序，用它连接到服务器。终端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制服务器。要开始一个telnet会话，必须输入用户名和密码来登录服务器。Telnet是常用的远程控制Web服务器的方法。</p>
<p>需要连接的机器开启telnet服务。</p>
</blockquote>
<p>半连接攻击（SYN_FLOOD）</p>
<blockquote>
<p>半连接就是通过不断地构造客户端的SYN连接数据包发向服务端，等到服务端的半连接队列满的时候，后续的正常用户的连接请求将会被丢弃，从而无法连接到服务端。此为半连接攻击方式。</p>
<p>可通过开启SYN Cookies来解决，即通过发送方的信息(端口、ip)和接收方的信息计算出一个cookie，并将其作为序列号进行回复，然后cookie对应一个时间范围，在时间范围内的ack都是合法的，不进入半连接队列，直接完成三次握手。</p>
</blockquote>
<p>全连接攻击</p>
<blockquote>
<p>全连接攻击：是通过消费服务端进程数和连接数，只连接而不进行发送数据的一种攻击方式。当客户端连接到服务端，仅仅只是连接，此时服务端会为每一个连接创建一个进程来处理客户端发送的数据。但是客户端只是连接而不发送数据，此时服务端会一直阻塞在recv或者read的状态，如此一来，多个连接，服务端的每个连接都是出于阻塞状态从而导致服务端的崩溃。</p>
<p>可通过设置超时时间来解决。</p>
</blockquote>
<p>为何需要三次握手而不是两次？四次挥手而不是三次？</p>
<blockquote>
<p>个人理解：三次握手分别保证客户端发送数据的能力、服务端发送数据和接收数据的能力以及客户端接收数据的能力。如果没有第三次握手，就无法保证客户端有接收数据的能力。同时三次握手保证了序列号的一致性以及双方连接建立的完整性(两次握手可能存在服务端的ack延迟到达客户端，此时客户端已经放弃连接了而服务端却以为建立好了连接)。而四次挥手则是因为被动关闭方可能还存在数据未发送完全，需要等待被动方发送完数据并主动发出FIN才能保证数据发送完毕。</p>
</blockquote>
<p>http：</p>
<blockquote>
<p>状态码：1xx信息、2xx成功、3xx重定向、4xx客户端错误、5xx服务端错误</p>
<p>100——继续、200——成功、301永久重定向、302临时重定向、400 Bad Request、404找不到页面、401未授权、403拒绝请求、500服务器内部错误。</p>
<p>301 302区别：301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），<strong>搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址</strong>；302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，<strong>搜索引擎会抓取新的内容而保存旧的网址。</strong></p>
<p>400——1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。2、请求参数有误。</p>
<p>403——服务器理解了请求但是拒绝执行</p>
</blockquote>
<p>http头部</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">通用头部：</span><br><span class="line">cache-control：请求和响应遵循的缓存机制</span><br><span class="line">pragma：Pragma头域用来包含实现特定的指令，最常用的是Pragma:no-cache</span><br><span class="line">connection：是否保持长连接 keep-alive等等</span><br><span class="line">date：时间</span><br><span class="line">请求头：</span><br><span class="line">accept：接收什么类型 text/html等等</span><br><span class="line">accept-encoding、accept-language</span><br><span class="line">referer：从何而来 如何跳转过来的</span><br><span class="line">user-agent：浏览器表明自己身份</span><br><span class="line">响应头：</span><br><span class="line">age：当代理服务器用自己缓存的实体去响应请求时，用该头部表明该实体从产生到现在经过多长时间了。</span><br><span class="line">server：表明自身是什么软件 Server：Apache/2.0.61 (Unix)</span><br><span class="line">Accept-Ranges：bytes表示接受、none表示不接受</span><br><span class="line">实体头：</span><br><span class="line">allow：支持哪些方法</span><br><span class="line">content-length：响应对象长度</span><br><span class="line">content-type：响应对象的类型</span><br><span class="line">last-modified：对象的最后修改时间</span><br></pre></td></tr></table></figure>


</blockquote>
<p>http各版本</p>
<blockquote>
<p><strong>1）HTTP 1.0：</strong></p>
<ul>
<li>请求与响应支持 HTTP 头，响应含状态行，增加了状态码，</li>
<li>支持 HEAD，POST 方法</li>
<li>支持传输 HTML 文件以外其他类型的内容</li>
</ul>
<p>HTTP1.0 使用的是非持久连接，主要缺点是客户端必须为每一个待请求的对象建立并维护一个新的连接，即每请求一个文档就要有两倍RTT的开销。因为同一个页面可能存在多个对象，所以非持久连接可能使一个页面的下载变得十分缓慢，而且这种短连接增加了网络传输的负担。（RTT(Round Trip Time)：一个连接的往返时间，即数据发送时刻到接收到确认的时刻的差值）</p>
<p><strong>2）HTTP 1.1：</strong></p>
<ul>
<li>支持长连接。</li>
<li>在HTTP1.0的基础上引入了更多的缓存控制策略。</li>
<li>引入了请求范围设置，优化了带宽。</li>
<li>在错误通知管理中新增了错误状态响应码。</li>
<li>增加了Host头处理，可以传递主机名（hostname）。</li>
</ul>
<p><strong>缺点：</strong>传输内容是明文，不够安全</p>
<p><strong>3）HTTPS</strong></p>
<ul>
<li>HTTPS运行在安全套接字协议(Secure Sockets Layer，SSL )或传输层安全协议（Transport Layer Security，TLS）之上，所有在TCP中传输的内容都需要经过加密。</li>
<li>连接方式不同，HTTP的端口是80，HTTPS的端口是443。</li>
<li>HTTPS可以有效防止运营商劫持。</li>
</ul>
<p>注：SSL运行在TCP之上</p>
<p><strong>4）HTTP 1.x优化（SPDY）</strong><br>SPDY 并不是新的一种协议，而是在 HTTP 之前做了一层会话层。为了达到减少页面加载时间的目标，SPDY 引入了一个新的二进制分帧数据层，以实现优先次序、最小化及消除不必要的网络延迟，目的是更有效地利用底层 TCP 连接。</p>
<ul>
<li>多路复用，为多路复用设立了请求优先级。</li>
<li>对header部分进行了压缩。</li>
<li>引入了HTTPS加密传输。</li>
<li>客户端可以在缓存中取到之前请求的内容。</li>
</ul>
<p><strong>5）HTTP2.0（SPDY的升级版）：</strong></p>
<ul>
<li>HTTP2.0支持明文传输，而HTTP 1.X强制使用SSL/TLS加密传输。</li>
<li>和HTTP 1.x使用的header压缩方法不同。</li>
<li>HTTP2.0 基于二进制格式进行解析，而HTTP 1.x基于文本格式进行解析。</li>
<li>多路复用，HTTP1.1是多个请求串行化单线程处理，HTTP 2.0是并行执行，一个请求超时并不会影响其他请求。</li>
</ul>
<p>HTTP2.0的多路复用提升了网页性能：</p>
<ul>
<li>在 HTTP1 中浏览器限制了同一个域名下的请求数量（Chrome下一般是六个），当在请求很多资源的时候，由于队头阻塞，当浏览器达到最大请求数量时，剩余的资源需等待当前的六个请求完成后才能发起请求。</li>
<li>HTTP2 中引入了多路复用的技术，这个技术可以只通过一个TCP连接就可以传输所有的请求数据。多路复用可以绕过浏览器限制同一个域名下的请求数量的问题，进而提高了网页的性能。</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>主流浏览器只支持基于TLS部署的HTTP 2.0协议，所以要将网站升级为HTTP 2.0，就需要先升级为HTTPS。</li>
<li>HTTP 2.0完全兼容HTTP 1.x,所以对于部署了HTTP 2.0的网站可以自动向下兼容HTTP 1.X。</li>
</ul>
<p><strong>6） HTTP 3.0 (QUIC)：</strong></p>
<p>QUIC (Quick UDP Internet Connections)，快速 UDP 互联网连接。QUIC是基于UDP协议的。</p>
<p>两个主要特性：</p>
<p>（1）线头阻塞(HOL)问题的解决更为彻底：</p>
<p>基于TCP的HTTP/2，尽管从逻辑上来说，不同的流之间相互独立，不会相互影响，但在实际传输方面，数据还是要一帧一帧的发送和接收，一旦某一个流的数据有丢包，则同样会阻塞在它之后传输的流数据传输。而基于UDP的QUIC协议则可以更为彻底地解决这样的问题，让不同的流之间真正的实现相互独立传输，互不干扰。</p>
<p>（2）切换网络时的连接保持：</p>
<p>当前移动端的应用环境，用户的网络可能会经常切换，比如从办公室或家里出门，WiFi断开，网络切换为3G或4G。基于TCP的协议，由于切换网络之后，IP会改变，因而之前的连接不可能继续保持。而基于UDP的QUIC协议，则可以内建与TCP中不同的连接标识方法，从而在网络完成切换之后，恢复之前与服务器的连接。</p>
</blockquote>
<p>线头阻塞(HOL)</p>
<blockquote>
<p>TCP协议中，序号为1、3的数据包接收到后，不能直接传递给上层，需要等待到序号为2的数据包到达，这种等待的情况称为线头阻塞。</p>
</blockquote>
<p>https身份认证</p>
<blockquote>
<p>身份认证（CA数字证书）：</p>
<p>https协议中身份认证的部分是由数字证书来完成的，证书由<strong>公钥、证书主题、数字签名</strong>等内容组成，在客户端发起SSL请求后，服务端会将数字证书发给客户端，客户端对证书进行验证，并获取用于秘钥交换的非对称秘钥</p>
<p>数字证书作用：</p>
<ul>
<li>身份授权 确保浏览器访问的网站是经过CA验证的可信任网站</li>
<li>分发公钥 每个数字证书都包含了注册者生成的公钥。在SSL握手时通过certificate消息传输给客户端</li>
</ul>
<p>数字证书验证：</p>
<p>申请者拿到CA的证书并部署在网站服务器端，浏览器发起握手接收到证书后，如何确认这个证书就是CA签发的呢？怎样避免第三方伪造这个证书？答案就是数字签名（digital signature）。数字签名是证书的防伪标签，目前使用最广泛的是SHA-RSA（SHA用于哈希算法，RSA用于非对称加密算法）数字签名</p>
</blockquote>
<p>浏览器如何验证CA证书</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">首先，浏览器通过URL网址去请求服务端，服务端接收到请求后，就会给浏览器发送一个自己的CA数字证书</span><br><span class="line">然后，浏览器接收到证书以后，开始验证。首先从证书中得知证书的颁发机构，然后从浏览器系统中去寻找此颁发机构的根证书(世界上权威CA机构的根证书都是预先嵌入到浏览器中的)，如果在浏览器系中没有找到对应的根证书，就代表此机构不是受信任的，那么就会警告无法确认证书的真假，比如以前打开12360网站就会提示。</span><br><span class="line">之后，如果找到了证书颁发机构的根证书，那么就从根证书中取得那个根公钥，用根公钥去解密此证书的数字签名，成功解密的话就得到证书的指纹和指纹算法，指纹是证书内容通过指纹算法计算得到的一个hash值，这里我们称之为h1，h1代表证书的原始内容；然后用指纹算法对当前接收到的证书内容再进行一次hash计算得到另一个值h2，h2则代表当前证书的内容，如果此时h1和h2是相等的，就代表证书没有被修改过。如果证书被篡改过，h2和h1是不可能相同的。</span><br><span class="line"></span><br><span class="line">假如证书上的指纹是不法分子伪造的，伪造是没有用的，因为你伪造的指纹不可能用CA机构的根私钥去加密（根私钥是CA机构绝对保密的），伪造者只能拿自己的秘钥去加密这个伪造的指纹，但当我们拿机构的根公钥去解密伪造指纹的时候是不可能成功的（加密内容只能由一对公钥私钥解密）</span><br><span class="line"></span><br><span class="line">在证书没有被修改过的基础上，再检查证书上的使用者的URL（比如csdn.net）和我们请求的URL是否相等，如果相等，那么就可以证明当前浏览器链接的网址也是正确的，而不是一些钓鱼网之类的。</span><br><span class="line"></span><br><span class="line">但如果浏览器的连接被某个中间人截取了，中间人也可以发一个由权威的CA机构颁发的证书给浏览器，然后也可以通过证书没有被篡改的验证，但是在证书没有被篡改的前提下，通过对比证书上的URL和我们请求的URL是否相同，我们还是可以判断当前证书是不是服务器发的证书。可以这么理解，因为URL具有唯一性，所以中间人的证书的上的URL和我们的证书的URL是不可能相同的，如果中间人修改了自己证书上的URL，那么就通过不了证书没有被篡改的验证，所以中间人的证书也是欺骗不了我们的。</span><br><span class="line">然后生成对称密钥即可。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>https密钥协商机制</p>
<blockquote>
<p>1）非对称加密：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">客户端发送 ClientHello（包含支持的协议版本、加密算法和 随机数A (Client random)）到服务端</span><br><span class="line">服务端返回 ServerHello、公钥、证书、随机数B (Server random) 到客户端</span><br><span class="line">客户端使用CA证书验证返回证书无误后。生成 随机数C (Premaster secret)，用公钥对其加密，发送到服务端</span><br><span class="line">服务端用 私钥 解密得到 随机数C (Premaster secret)，随后根据已经得到的 随机数ABC生成对称密钥（hello的时候确定的加密算法），并对需要发送的数据进行对称加密发送</span><br><span class="line">客户端使用对称密钥（客户端也用随机数ABC生成对称密钥）对数据进行解密。</span><br><span class="line">双方手持对称密钥 使用对称加密算法通讯</span><br></pre></td></tr></table></figure>

<p>2）DH密钥协商：可以做到——“通讯双方在完全没有对方任何预先信息的条件下通过不安全信道创建起一个密钥”</p>
<p>但无法防止中间人篡改。需要和RSA配合签名机制使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 客户端先连上服务端</span><br><span class="line">2. 服务端生成一个随机数 s 作为自己的私钥，然后根据算法参数计算出公钥 S（算法参数通常是固定的）</span><br><span class="line">3. 服务端使用某种签名算法把“算法参数（模数p，基数g）和服务端公钥S”作为一个整体进行签名</span><br><span class="line">4. 服务端把“算法参数（模数p，基数g）、服务端公钥S、签名”发送给客户端</span><br><span class="line">5. 客户端收到后验证签名是否有效</span><br><span class="line">6. 客户端生成一个随机数 c 作为自己的私钥，然后根据算法参数计算出公钥 C</span><br><span class="line">7. 客户端把 C 发送给服务端</span><br><span class="line">8. 客户端和服务端（根据上述 DH 算法）各自计算出 k 作为会话密钥</span><br></pre></td></tr></table></figure>

<p>如何防范偷窥（嗅探）:</p>
<p>嗅探者可以通过监视网络传输，得到算法参数（模数p，基数g）以及双方的公钥，但是【无法】推算出双方的私钥，也【无法】推算出会话密钥（这是由 DH 算法在数学上保证的）</p>
<p>如何防范篡改（假冒身份）</p>
<p>攻击方式1：攻击者可以第4步篡改数据（修改算法参数或服务端公钥）。但因为这些信息已经进行过数字签名。篡改之后会被客户端发现。</p>
<p>攻击方式2：攻击者可以在第7步篡改客户端公钥。这步没有签名，服务端收到数据后不会发现被篡改。但是，攻击者篡改之后会导致“服务端与客户端生成的会话密钥【不一致】”。在后续的通讯步骤中会发现这点，并导致通讯终止。</p>
</blockquote>
<p>TLS</p>
<blockquote>
<p>整个TLS传输的过程如下：<br>(1）TCP三次握手<br>(2）SSL的ClientHello和ServerHello和对应的秘钥交换KeyExchange<br>(3）Client和Server互相ChangeCipherSpec通知进入加密模式，此时可以进入数据传输状态<br>(4）应用数据传输过程<br>(5）应用数据传输完成，TCP两次挥手<br>抛开TCP连接和数据包文传输的部分，TLS握手部分将使用2个RTT。</p>
</blockquote>
<p>前向安全性</p>
<blockquote>
<p>指的是长期使用的主密钥泄漏不会导致过去的会话密钥泄漏</p>
</blockquote>
<p>http一些参数</p>
<blockquote>
<p>Content-Length：指明响应体的数据大小</p>
<p>content-type：数据格式。</p>
<ul>
<li>application/json:JSON数据格式</li>
<li>text/html:HTML格式</li>
<li>text/xml:XML格式</li>
</ul>
<p>Connection: keep-alive：保持长连接</p>
</blockquote>
<p>http——chunk</p>
<blockquote>
<p>当客户端向服务器请求一个静态页面或者一张图片时，服务器可以很清楚的知道内容大小，然后通过Content-Length消息首部字段告诉客户端需要接收多少数据。但是如果是动态页面等时，服务器是不可能预先知道内容大小，这时就可以使用Transfer-Encoding：chunk模式来传输数据了。即如果要一边产生数据，一边发给客户端，服务器就需要使用”Transfer-Encoding: chunked”这样的方式来代替Content-Length。</p>
<p>在进行chunked编码传输时，在回复消息的头部有Transfer-Encoding: chunked</p>
<p>编码使用若干个chunk组成，由一个标明长度为0的chunk结束。每个chunk有两部分组成，第一部分是该chunk的长度，第二部分就是指定长度的内容，每个部分用CRLF隔开。在最后一个长度为0的chunk中的内容是称为footer的内容，是一些没有写的头部内容。</p>
<blockquote>
<p>chunk编码格式如下：</p>
<p>[chunk size][\r\n][chunk data][\r\n][chunk size][\r\n][chunk data][\r\n][chunk size = 0][\r\n][\r\n]</p>
<p>chunk size是以十六进制的ASCII码表示，比如：头部是3134这两个字节，表示的是1和4这两个ascii字符，被http协议解释为十六进制数14，也就是十进制的20，后面紧跟[\r\n](0d 0a)，再接着是连续的20个字节的chunk正文。chunk数据以0长度的chunk块结束，也就是（30 0d 0a 0d 0a）。</p>
</blockquote>
<p>原理</p>
<p>HTTP 1.1引入分块传输编码提供了以下几点好处：</p>
<p>HTTP分块传输编码允许服务器为动态生成的内容维持HTTP持久链接。通常，持久链接需要服务器在开始发送消息体前发送Content-Length消息头字段，但是对于动态生成的内容来说，在内容创建完之前是不可知的。</p>
<p>分块传输编码允许服务器在最后发送消息头字段。对于那些头字段值在内容被生成之前无法知道的情形非常重要，例如消息的内容要使用散列进行签名，散列的结果通过HTTP消息头字段进行传输。没有分块传输编码时，服务器必须缓冲内容直到完成后计算头字段的值并在发送内容前发送这些头字段的值。</p>
</blockquote>
<p>DNS</p>
<blockquote>
<p>浏览器输入一个地址，发生了什么？</p>
<p>根据域名查找ip地址(浏览器缓存——本机host缓存——DNS系统调用——本地DNS服务器缓存——递归查询直到获得ip地址——可能因为负载均衡每次获得不同的ip地址)，然后向该ip发送http请求，服务器响应回复html文档，浏览器解析html并根据content-type判断如何处理(显示、下载等等)，浏览器获取html文档内嵌的图片、音频、js等等，最后浏览器还可以发送ajax异步请求。</p>
<p>DNS区域传输的时候使用TCP协议：辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。</p>
<p>域名解析时使用UDP协议</p>
</blockquote>
<p>DNS over TLS / HTTPS</p>
<blockquote>
<p>加密的DNS协议。但是延时也很高，需要耗费4 RTT来保证安全。</p>
</blockquote>
<p>cookie和session、token</p>
<blockquote>
<p>cookie：客户端会话技术，存储数据在客户端浏览器，默认浏览器关闭后清除，能存放的数据有限且安全性较低。存放sessionID，之后的请求默认携带。</p>
<p>session：服务端会话技术，存储在服务端，用来保存状态，依赖于cookie，存放的数据无限制且安全性高，但需要单独存储，耗费空间。</p>
<p>token：无状态的令牌。采用签名的方式来验证(私钥签名、公钥验证)，每次传输过来的数据再次进行签名以对比。再次请求需要手动添加token。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当用户首次与Web服务器建立连接的时候，服务器会给用户分发一个 SessionID作为标识。SessionID是一个由24个字符组成的随机字符串。用户每次提交页面，浏览器都会把这个SessionID包含在 HTTP头中提交给Web服务器，这样Web服务器就能区分当前请求页面的是哪一个客户端。这个SessionID就是保存在客户端的，属于客户端Session。</span><br><span class="line">其实客户端Session默认是以cookie的形式来存储的，所以当用户禁用了cookie的话，服务器端就得不到SessionID。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>http和rpc区别</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RPC:可以基于TCP协议，也可以基于HTTP协议</span><br><span class="line">HTTP:基于HTTP协议</span><br><span class="line"></span><br><span class="line">RPC:可以基于thrift实现高效的二进制传输</span><br><span class="line">HTTP:大部分是通过json来实现的，字节大小和序列化耗时都比thrift要更消耗性能</span><br><span class="line"></span><br><span class="line">RPC：基本都自带了负载均衡策略</span><br><span class="line">HTTP：需要配置Nginx，HAProxy来实现</span><br><span class="line"></span><br><span class="line">RPC主要用于公司内部的服务调用，性能消耗低，传输效率高，服务治理方便。</span><br><span class="line">HTTP主要用于对外的异构环境，浏览器接口调用，APP接口调用，第三方接口调用等。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>nginx</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">工作流程：</span><br><span class="line">1、用户通过域名发出访问Web服务器的请求，该域名被DNS服务器解析为反向代理服务器的IP地址；</span><br><span class="line">2、反向代理服务器接受用户的请求；</span><br><span class="line">3、反向代理服务器在本地缓存中查找请求的内容，找到后直接把内容发送给用户；</span><br><span class="line">4、如果本地缓存里没有用户所请求的信息内容，反向代理服务器会代替用户向源服务器请求同样的信息内容，并把信息内容发给用户，如果信息内容是非缓存的还会把它保存到缓存中。</span><br><span class="line">--------</span><br><span class="line">Nginx模块：</span><br><span class="line">Nginx有五大优点：模块化、事件驱动、异步、非阻塞、多进程单线程。由内核和模块组成的，其中内核完成的工作比较简单，仅仅通过查找配置文件将客户端请求映射到一个location block，然后又将这个location block中所配置的每个指令将会启动不同的模块去完成相应的工作。</span><br><span class="line">--------</span><br><span class="line">作用：</span><br><span class="line">* 保护了真实的web服务器，保证了web服务器的资源安全</span><br><span class="line">* 节约了有限的IP地址资源</span><br><span class="line">* 减少WEB服务器压力，提高响应速度</span><br><span class="line"> 	- 反向代理就是通常所说的web服务器加速，它是一种通过在繁忙的web服务器和外部网络之间增加一个高速的web缓冲服务器来降低实际的web服务器的负载的一种技术。反向代理是针对web服务器提高加速功能，作为代理缓存，它并不是针对浏览器用户，而针对一台或多台特定的web服务器，它可以代理外部网络对内部网络的访问请求。</span><br><span class="line">	- 反向代理服务器会强制将外部网络对要代理的服务器的访问经过它，这样反向代理服务器负责接收客户端的请求，然后到源服务器上获取内容，把内容返回给用户，并把内容保存到本地，以便日后再收到同样的信息请求时，它会把本地缓存里的内容直接发给用户，以减少后端web服务器的压力，提高响应速度。因此Nginx还具有缓存功能。</span><br><span class="line">* 请求的统一控制，包括设置权限、过滤规则等；</span><br><span class="line">* 区分动态和静态可缓存内容；</span><br><span class="line">* 实现负载均衡，内部可以采用多台服务器来组成服务器集群，外部还是可以采用一个地址访问；</span><br><span class="line">* 解决Ajax跨域问题；</span><br><span class="line">* 作为真实服务器的缓冲，解决瞬间负载量大的问题；</span><br></pre></td></tr></table></figure>

</blockquote>
<p>接口幂等性</p>
<blockquote>
<p>接口幂等用于表示任意多次请求执行的结果均与一次请求执行的结果相同</p>
<p>实现幂等性的关键步骤分为以下三个：</p>
<p>（1）每个请求操作必须有唯一的 ID，而这个 ID 就是用来表示此业务是否被执行过的关键凭证，例如，订单支付业务的请求，就要使用订单的 ID 作为幂等性验证的 Key；</p>
<p>（2）每次执行业务之前必须要先判断此业务是否已经被处理过；</p>
<p>（3）第一次业务处理完成之后，要把此业务处理的状态进行保存，比如存储到 Redis 中或者是数据库中，这样才能防止业务被重复处理</p>
<p>get请求为幂等、post则不是</p>
</blockquote>
<p>理解restful(Representational State Transfer)</p>
<blockquote>
<p>（1）每一个URI代表一种资源；</p>
<p>（2）客户端和服务器之间，传递这种资源的某种表现层；</p>
<p>（3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RESTful 架构的核心规范与约束：统一接口</span><br><span class="line">分为四个子约束：</span><br><span class="line">1.每个资源都拥有一个资源标识，每个资源的资源标识可以用来唯一地标明该资源</span><br><span class="line">2.消息的自描述性</span><br><span class="line">3.资源的自描述性。</span><br><span class="line">4.HATEOAS Hypermedia As The Engine Of Application State(超媒体作为应用状态引擎)</span><br><span class="line">即客户只可以通过服务端所返回各结果中所包含的信息来得到下一步操作所需要的信息，如到底是向哪个URL发送请求等。也就是说，一个典型的REST服务不需要额外的文档标示通过哪些URL访问特定类型的资源，而是通过服务端返回的响应来标示到底能在该资源上执行什么样的操作</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/03/12/T5aPvYtkK9zIefD.png" alt="image.png"></p>
<p>使用标准的状态码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">GET</span><br><span class="line">安全且幂等、获取表示、变更时获取表示（缓存）</span><br><span class="line">200（OK） - 表示已在响应中发出</span><br><span class="line">204（无内容） - 资源有空表示</span><br><span class="line">301（Moved Permanently） - 资源的URI已被更新</span><br><span class="line">303（See Other） - 其他（如，负载均衡）</span><br><span class="line">304（not modified）- 资源未更改（缓存）</span><br><span class="line">400 （bad request）- 指代坏请求（如，参数错误）</span><br><span class="line">404 （not found）- 资源不存在</span><br><span class="line">406 （not acceptable）- 服务端不支持所需表示</span><br><span class="line">500 （internal server error）- 通用错误响应</span><br><span class="line">503 （Service Unavailable）- 服务端当前无法处理请求</span><br><span class="line"></span><br><span class="line">POST</span><br><span class="line">不安全且不幂等</span><br><span class="line">使用服务端管理的（自动产生）的实例号创建资源</span><br><span class="line">创建子资源</span><br><span class="line">部分更新资源</span><br><span class="line">如果没有被修改，则不过更新资源（乐观锁）</span><br><span class="line">200（OK）- 如果现有资源已被更改</span><br><span class="line">201（created）- 如果新资源被创建</span><br><span class="line">202（accepted）- 已接受处理请求但尚未完成（异步处理）</span><br><span class="line">301（Moved Permanently）- 资源的URI被更新</span><br><span class="line">303（See Other）- 其他（如，负载均衡）</span><br><span class="line">400（bad request）- 指代坏请求</span><br><span class="line">404 （not found）- 资源不存在</span><br><span class="line">406 （not acceptable）- 服务端不支持所需表示</span><br><span class="line">409 （conflict）- 通用冲突</span><br><span class="line">412 （Precondition Failed）- 前置条件失败（如执行条件更新时的冲突）</span><br><span class="line">415 （unsupported media type）- 接受到的表示不受支持</span><br><span class="line">500 （internal server error）- 通用错误响应</span><br><span class="line">503 （Service Unavailable）- 服务当前无法处理请求</span><br><span class="line"></span><br><span class="line">PUT</span><br><span class="line">不安全但幂等</span><br><span class="line">用客户端管理的实例号创建一个资源</span><br><span class="line">通过替换的方式更新资源</span><br><span class="line">如果未被修改，则更新资源（乐观锁）</span><br><span class="line">200 （OK）- 如果已存在资源被更改</span><br><span class="line">201 （created）- 如果新资源被创建</span><br><span class="line">301（Moved Permanently）- 资源的URI已更改</span><br><span class="line">303 （See Other）- 其他（如，负载均衡）</span><br><span class="line">400 （bad request）- 指代坏请求</span><br><span class="line">404 （not found）- 资源不存在</span><br><span class="line">406 （not acceptable）- 服务端不支持所需表示</span><br><span class="line">409 （conflict）- 通用冲突</span><br><span class="line">412 （Precondition Failed）- 前置条件失败（如执行条件更新时的冲突）</span><br><span class="line">415 （unsupported media type）- 接受到的表示不受支持</span><br><span class="line">500 （internal server error）- 通用错误响应</span><br><span class="line">503 （Service Unavailable）- 服务当前无法处理请求</span><br><span class="line"></span><br><span class="line">DELETE</span><br><span class="line">不安全但幂等</span><br><span class="line">删除资源</span><br><span class="line">200 （OK）- 资源已被删除</span><br><span class="line">301 （Moved Permanently）- 资源的URI已更改</span><br><span class="line">303 （See Other）- 其他，如负载均衡</span><br><span class="line">400 （bad request）- 指代坏请求</span><br><span class="line">404 （not found）- 资源不存在</span><br><span class="line">409 （conflict）- 通用冲突</span><br><span class="line">500 （internal server error）- 通用错误响应</span><br><span class="line">503 （Service Unavailable）- 服务端当前无法处理请求</span><br></pre></td></tr></table></figure>
</blockquote>
<p>路由器和交换机具体实现了什么功能，路由选择如何实现</p>
<blockquote>
<p>路由器属于网络层，使用ip地址通信，连接局域网和外网。</p>
<p>交换机属于数据链路层，使用mac地址通信，工作在局域网内部。 </p>
</blockquote>
<p>介绍下IPV6</p>
<blockquote>
<p>128位，16字节，16进制</p>
</blockquote>
<p>jwt(JSON Web Token)</p>
<blockquote>
<p>JSON Web Token由三部分组成，它们之间用圆点(.)连接。这三部分分别是：</p>
<ul>
<li>Header、Payload、Signature</li>
</ul>
<p><strong>header</strong>典型的由两部分组成：token的类型（“JWT”）和算法名称（比如：HMAC SHA256或者RSA等等）。例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    'alg': "HS256",</span><br><span class="line">    'typ': "JWT"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用Base64对这个JSON编码就得到JWT的第一部分</p>
<p><strong>payload</strong>，它包含声明（要求）。声明是关于实体(通常是用户)和其他数据的声明。声明有三种类型: registered, public 和 private。</p>
<p>Registered claims : 这里有一组预定义的声明，它们不是强制的，但是推荐。比如：iss (issuer), exp (expiration time), sub (subject), aud (audience)等。</p>
<p>Public claims : 可以随意定义。</p>
<p>Private claims : 用于在同意使用它们的各方之间共享信息，并且不是注册的或公开的声明。 下面是一个例子：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"sub"</span>: '<span class="number">1234567890</span>',</span><br><span class="line">    <span class="attr">"name"</span>: 'john',</span><br><span class="line">    <span class="attr">"admin"</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对payload进行Base64编码就得到JWT的第二部分</p>
<p>注意，不要在JWT的payload或header中放置敏感信息，除非它们是加密的。</p>
<p><strong>Signature</strong></p>
<p>为了得到签名部分，你必须有编码过的header、编码过的payload、一个秘钥，签名算法是header中指定的那个，然对它们签名即可。例如：</p>
<blockquote>
<p>HMACSHA256(base64UrlEncode(header) + “.” + base64UrlEncode(payload), secret)</p>
</blockquote>
<p>签名是用于验证消息在传递过程中有没有被更改，并且，对于使用私钥签名的token，它还可以验证JWT的发送方是否为它所称的发送方。</p>
</blockquote>
<p>CSRF跨站点请求伪造(Cross—Site Request Forgery)</p>
<blockquote>
<p>攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 </p>
</blockquote>
<p>反爬策略</p>
<blockquote>
<ol>
<li>限制IP地址单位时间的访问次数</li>
<li>用户登录才能访问网站内容, 若识别为爬虫账号,封禁IP</li>
<li>header, User-Agent检查用户所用客户端的种类和版本, 在请求头中加入CSRF_token识别用户请求(参考form表单验证)</li>
<li>Referer, 检查请求由哪里来，通常可以做图片的盗链判断</li>
<li>Cookies,检测Cookie中session_id 的使⽤用次数，如果超过限制，就触发反爬策略略</li>
<li>动态加载,网站使用ajax动态加载内容</li>
<li>对前端请求的API的参数进行加密</li>
<li>对网站JS进行混淆加密(适用于对API参数加密的情况,对用于加密的JS进行混淆)</li>
<li>在用户登录时,进行验证码验证(图片验证码或滑动验证码或短信验证码等)</li>
<li>对网页数据展示的总页数进行限制,比如用户只能浏览200页</li>
</ol>
</blockquote>
<h2 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h2><p>包装类自动拆箱、自动装箱</p>
<blockquote>
<p>c == a + b    c.equals(a + b)</p>
</blockquote>
<p>注解</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">* 作用分类</span><br><span class="line">	* 编写文档：生成文档【doc文档】</span><br><span class="line">    * 代码分析：通过注解对代码进行分析【使用反射】</span><br><span class="line">    * 编译检查：让编辑器能实现基本的编译检查【@Override】</span><br><span class="line"></span><br><span class="line">* JDK中预定义的一些注解</span><br><span class="line">	* @Override：检测被该注解标注的方法是否是继承自父类(接口)的</span><br><span class="line">    * @Deprecated：将该注解标注的内容，表示已过时</span><br><span class="line">    * @SuppressWarnings：压制警告</span><br><span class="line">    	* 一般传递参数all	@SuppressWarnings(&quot;all&quot;)</span><br><span class="line">  </span><br><span class="line">* 自定义注解</span><br><span class="line">	* 格式：</span><br><span class="line">		* 元注解</span><br><span class="line">        * public @interface 注解名称() &#123;</span><br><span class="line">        	属性列表;</span><br><span class="line">        &#125;</span><br><span class="line">	* 本质：注解本质上就是一个接口，该接口默认继承Annotation</span><br><span class="line">		* public interface 注解名称 extends java.lang.annotation.Annotation &#123;&#125;</span><br><span class="line">	* 属性：接口中的抽象方法</span><br><span class="line">		* 要求：</span><br><span class="line">			1. 属性的返回值类型有下列取值：</span><br><span class="line">				* 基本数据类型</span><br><span class="line">				* String</span><br><span class="line">                * 枚举</span><br><span class="line">                * 注解</span><br><span class="line">                * 以上类型的数组</span><br><span class="line">			2. 定义了属性，在使用时需要给属性赋值</span><br><span class="line">				1. 如果定义属性时，使用default关键字给属性默认初始值，则使用注解时可以不进行属性的赋值</span><br><span class="line">                2. 如果只有一个属性需要赋值，并且属性的名称为value，则value可以省略，直接定义值即可【@SuppressWarnings】</span><br><span class="line">                3. 数组赋值时，值使用&#123;&#125;包裹，如果数组中只有一个值，则&#123;&#125;可以省略</span><br><span class="line"></span><br><span class="line">* 元注解：用于描述注解的注解</span><br><span class="line">	* @Target：描述注解能够作用的位置</span><br><span class="line">        * ElementType取值：</span><br><span class="line">        * TYPE：可以作用于类上</span><br><span class="line">        * METHOD：可以作用于方法上</span><br><span class="line">        * FIELD：可以作用于成员变量上</span><br><span class="line">	* @Retention：描述注解被保留的一个阶段</span><br><span class="line">		* @Rentention(RententionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到</span><br><span class="line">	* @Documented：描述注解是否被抽取到api文档中</span><br><span class="line">	* @Inherited：描述注解是否被子类继承</span><br><span class="line">  </span><br><span class="line">* 在程序中使用(解析)注解：获取注解中定义的属性值</span><br><span class="line">	1. 获取注解定义的位置的对象	【Class，Method，Field】</span><br><span class="line">	2. 获取指定的注解</span><br><span class="line">		* getAnnotation(Class)</span><br><span class="line">		* public class ProImpl implements Pro&#123;</span><br><span class="line">              public String className()&#123;</span><br><span class="line">                  return &quot;day01.annotation.Demo1&quot;;</span><br><span class="line">              &#125;</span><br><span class="line">              public String methodName()&#123;</span><br><span class="line">                  return &quot;show&quot;;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">	3. 调用注解中的抽象方法，获取配置的属性值</span><br></pre></td></tr></table></figure>


</blockquote>
<ul>
<li>RPC（Remote Procedure Call）远程过程调用，简单的理解是一个节点请求另一个节点提供的服务</li>
</ul>
<p>继承和多态</p>
<blockquote>
<p>继承：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。</p>
<p>多态：允许将子类类型的指针赋值给父类类型的指针。</p>
</blockquote>
<p>重写和重载</p>
<blockquote>
<p>重写：子类重写父类方法，返回值和形参都不能改变</p>
<p>重载：方法名字相同，而参数不同。返回类型可以相同也可以不同。每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</p>
</blockquote>
<p>TCP UDP对应的socket编程的API</p>
<blockquote>
<p>socket()：创建socket<br>bind()：绑定socket到本地地址和端口，通常由服务端调用<br>listen()：TCP专用，开启监听模式<br>accept()：TCP专用，服务器等待客户端连接，一般是阻塞态<br>connect()：TCP专用，客户端主动连接服务器<br>send()：TCP专用，发送数据<br>recv()：TCP专用，接收数据<br>sendto()：UDP专用，发送数据到指定的IP地址和端口<br>recvfrom()：UDP专用，接收数据，返回数据远端的IP地址和端口<br>closesocket()：关闭socket</p>
</blockquote>
<p>函数式编程</p>
<blockquote>
<p>示例：<code>Function&lt;Integer, Integer&gt; f = x -&gt; x + 1;</code></p>
<p>和匿名内部类的区别：</p>
<p>①this指向不同，lambda指向当前类，匿名内部类指向其本身<br>②lambda表达式并没有生成.class文件，匿名内部类则生成了</p>
</blockquote>
<p>RBAC模型</p>
<blockquote>
<p>权限控制？</p>
</blockquote>
<p>transient</p>
<blockquote>
<p>不进行序列化</p>
</blockquote>
<p>NIO</p>
<blockquote>
<p>BytebBuffer——HeapByteBuffer：在堆中创建的缓冲区。MappedByteBuffer：直接缓冲区。</p>
<p>allocate方法创建的直接缓冲区是创建的DirectByteBuffer实例。</p>
</blockquote>
<h2 id="java集合"><a href="#java集合" class="headerlink" title="java集合"></a>java集合</h2><p>HashMap源码、实现原理、转红黑树的时机(为何是7)、多线程优化、多线程失败的场景</p>
<blockquote>
<p>jdk7，数组加链表，hash冲突插入首部；jdk8，数组+链表+红黑树。hash冲突插入尾部，在链表长度大于7且数组长度大于64时转换为红黑树，否则先扩容。为何是7呢，因为链表中节点数是8的概率已经接近千分之一，而且此时链表的性能已经很差了。所以在这种比较罕见和极端的情况下，才会把链表转变为红黑树。而同时树节点的占用空间约为链表的两倍，占用空间较大。且在红黑树节点数为6时退化为链表。</p>
<p>容量：默认容量16，可自定义容量，如果不是2的幂次系统会默认设置为2的幂次，如果容量超过initial * loadFactor(默认0.75)会进行扩容(两倍)。(hash &amp; (len - 1) —— 10101001  00001111)</p>
<p>为何线程不安全：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">jdk7中由于头插法，会存在resize后链表中形成环的情况。</span><br><span class="line">    线程1阻塞前链表情况：a-&gt;b-&gt;null</span><br><span class="line">    线程2此时执行，会采用头插法将该链表放入新的table，放入后变成b-&gt;a-&gt;null</span><br><span class="line">    线程1此时返回，同样采用头插法插入该线程自己的新的table中，两次循环后变为b-&gt;a，但是由于线程2执行时的后果会导致b的next不是null而是a，所以循环多执行一次，e此时变为a会导致a.next = newTable[i](也就是b)然后发生循环。</span><br><span class="line"></span><br><span class="line">jdk8中采用尾插法会导致数据的覆盖。</span><br><span class="line">	假设两个线程A、B都在进行put操作，并且hash函数计算出的插入下标是相同的，当线程A执行完第13行代码后(hash碰撞判断，此时判断是没有碰撞的但还没有进行插入)由于时间片耗尽导致被挂起，而线程B得到时间片后在该下标处插入了元素，完成了正常的插入，然后线程A获得时间片，由于之前已经进行了hash碰撞的判断，所有此时不会再进行判断，而是直接进行插入，这就导致了线程B插入的数据被线程A覆盖了，从而线程不安全。</span><br><span class="line">	除此之外还存在一个++size的线程安全问题。</span><br><span class="line"></span><br><span class="line">jdk8解决成环问题：</span><br><span class="line">	采用两组指针loHead、loTail、hiHead、hiTail</span><br><span class="line">	这两组指针将链表分成了两部分，高位指针指向哪些扩容后下标变为(旧下标+扩容大小)，低位指针指向哪些扩容后下标还保持不变的节点。分成两条链表今次那个迁移，迁移后节点的前后顺序保持不变，不会出现环的情况。(扩容后链表节点的情况只有两种下标不变 or 旧下标+扩容的大小)</span><br><span class="line">	红黑树的拆分和链表的逻辑基本一致，不同的地方在于，重新映射后，会将红黑树拆分成两条链表，根据链表的长度，判断需不需要把链表重新进行树化。</span><br></pre></td></tr></table></figure>

<p>多线程优化：和读写锁配合。</p>
</blockquote>
<p>ConcurrentHashMap原理</p>
<blockquote>
<p>jdk7，Segment数组 + HashEntry数组 + ReentrantLock(对每个Segment上锁)；jdk8，Node数组 + CAS + Synchronized(只对每个node上锁)</p>
<p>具体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jdk7：保证segment数组为2的幂次、会再散列来获取下标</span><br><span class="line">初始化有三个参数：</span><br><span class="line">	initialCapacity：初始容量大小 ，默认16。</span><br><span class="line">	loadFactor, 扩容因子，默认0.75，当一个Segment存储的元素数量大于initialCapacity* loadFactor时，该Segment会进行一次扩容。</span><br><span class="line">	concurrencyLevel：并发度，默认16。Segment[]的数组长度。如果并发度设置的过小，会带来严重的锁竞争问题；如果并发度设置的过大，原本位于同一个Segment内的访问会扩散到不同的Segment中，CPU cache命中率会下降，从而引起程序性能下降。</span><br><span class="line">segment不扩容，扩容的是hashentry数组</span><br><span class="line"></span><br><span class="line">扩容时的get操作访问的是旧链表，对于put以及其他更新操作会阻塞直到扩容完成。</span><br></pre></td></tr></table></figure>

<p>get不需要加锁，除非读到的是null，原理是get方法中的变量都使用volatile关键字修饰。且对volatile字段的写入操作先于读取操作，所以即使两个线程同时修改和获取volatile变量，get操作也能保证拿到最新的值。</p>
</blockquote>
<p>ArrayList和LinkedList插入效率比较</p>
<blockquote>
<p>插入到最后，效率相当。插入到中间，LinkedList效率高。数据量过大，ArrayList动态扩容，LinkedList效率更高。</p>
</blockquote>
<p>ArrayList</p>
<blockquote>
<p>懒加载(但在jdk7及以前会直接初始化一个容量为10的数组)，需要扩容时，会首先扩容置原容量的1.5倍左右(<code>new = old + old &gt;&gt; 1</code>)，然后如果new满足需求，则会直接用new作为新容量，否则会将当前所需容量作为新容量。</p>
</blockquote>
<p>Java最顶层集合有哪些</p>
<blockquote>
<p>Collection、Map</p>
</blockquote>
<p>抽象类和接口的区别：</p>
<blockquote>
<p>抽象类更多是对事物的抽象，如人，是一种模板的设计；而接口则是对行为的抽象，如：运动，是一种行为的规范。</p>
<p>抽象类可以有静态方法、成员变量可以为任意类型。</p>
</blockquote>
<h2 id="java并发"><a href="#java并发" class="headerlink" title="java并发"></a>java并发</h2><p>synchronized和lock区别以及底层原理</p>
<blockquote>
<p>区别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;1.首先synchronized是java内置关键字，在jvm层面，Lock是个java类；</span><br><span class="line">&gt;2.synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；</span><br><span class="line">&gt;3.synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；</span><br><span class="line">&gt;4.用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；</span><br><span class="line">&gt;5.synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可中断、可公平（两者皆可）</span><br><span class="line">&gt;6.Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。</span><br></pre></td></tr></table></figure>

<p>底层原理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt;synchronized:</span><br><span class="line">&gt;原子性：保证语句块内是原子的</span><br><span class="line">&gt;可见性：通过在unlock前需要将变量同步回主存，其他线程需要重新获取</span><br><span class="line">&gt;有序性：一个变量在同一时刻只允许一条线程对其操作</span><br><span class="line">&gt;方法级的同步是通过方法调用和返回中实现的，方法常量池的ACC_SYNCHRONIZED标志是否为同步方法，如果方法是同步方法，则执行线程需要先持有monitor然后执行方法，返回后释放。</span><br><span class="line">&gt;代码块的同步是通过monitorenter和monitorexit实现的。遇到monitorenter试图获取monitor对象，如果未加锁或者已经被自己持有，则锁计数器+1，执行，遇到monitorexit则锁计数-1.计数器为0代表锁释放。如果获取monitor对象失败会进入阻塞。且是可重入的。</span><br><span class="line">&gt;1.6前慢的原因：对象内部的监视器锁是通过底层OS的Mutex实现的，存在用户态到内核态的切换，成本极高</span><br><span class="line">&gt;1.6后的优化：四种锁状态 无锁——偏向锁——轻量级锁——重量级锁。(不可降级)</span><br><span class="line">&gt;--</span><br><span class="line">&gt;偏向锁：无实际竞争，且将来只有第一个申请锁的线程会使用锁。只有一次CAS</span><br><span class="line">&gt;锁对象第一次被获取时，jvm将对象头锁标志位设为01偏向模式，然后通过CAS将线程id记录到对象的markword中。如果成功，该线程在以后每次进入该同步块时，jvm不进行任何操作。如果不是第一次获取锁，则判断偏向线程id是否为当前线程，是的话就进入同步块。否则则根据当前偏向的线程是否存活，未存活则取消锁到无锁状态，存活则升级为轻量级锁。</span><br><span class="line">&gt;--</span><br><span class="line">&gt;轻量级锁：无实际竞争，多个线程交替使用锁；允许短时间的锁竞争。申请和释放需要CAS</span><br><span class="line">&gt;轻量级锁是相对于重量级锁而言的。使用轻量级锁时，不需要申请互斥量，而是在当前线程栈帧中开辟空间Lock Record用来记录当前对象markword的拷贝。然后将Mark Word中的部分字节CAS更新指向线程栈中的Lock Record，如果更新成功，则轻量级锁获取成功，记录锁状态为00轻量级锁；否则，说明已经有线程获得了轻量级锁，如果指向的是当前线程的栈帧，则重入代码块，否则出现了竞争，会尝试几次CAS，如果不行，升级为重量级锁，标志位11，markword中指针指向重量级锁。</span><br><span class="line">&gt;--</span><br><span class="line">&gt;重量级锁：有实际竞争，且锁竞争时间长。monitor实现。</span><br><span class="line">&gt;Lock: 有三个实现类，ReentrantLock, ReentrantReadWriteLock类中的两个静态内部类ReadLock和WriteLock。</span><br><span class="line">&gt;底层实现为AQS。</span><br><span class="line">&gt;AQS：CLH锁队列(双向链表)+state状态变量，线程通过CAS去改变状态，成功则获取锁成功，失败则进入等待队列，等待被唤醒。</span><br><span class="line">&gt;lock的存储结构：一个int类型状态值（用于锁的状态变更），一个双向链表（用于存储等待中的线程）</span><br><span class="line">&gt;lock获取锁的过程：本质上是通过 CAS 来获取状态值修改，如果当场没获取到，会将该线程放在线程等待链表中。</span><br><span class="line">&gt;lock释放锁的过程：修改状态值，调整等待链表。</span><br><span class="line">&gt;lock()-acquire()-tryAcquire()-未成功获取锁-addwaiter()-acquireQueued()</span><br><span class="line">&gt;acquireQueued的主要作用是把已经追加到队列的线程节点进行阻塞，但阻塞前又通过tryAccquire重试是否能获得锁，如果重试成功能则无需阻塞，直接返回。</span><br></pre></td></tr></table></figure>
</blockquote>
<img src="https://i.loli.net/2021/03/10/qU1w9tpoERWl45b.png" alt="image.png" style="zoom:200%;">

<p>ReebtrantLock</p>
<blockquote>
<p>可重入的互斥锁。可公平可非公平(公平锁会判断当前线程前是否有其他等待线程，有的话就进入等待队列，没有的话才会尝试获取锁，而非公平锁则是直接尝试获取锁)</p>
</blockquote>
<p>ReebtrantReadWriteLock</p>
<blockquote>
<p>支持公平和非公平、可重入、锁降级(获得写锁—获得读锁—释放写锁)，不支持锁升级。</p>
<p>状态变量：高16位标识读，低16位表示写。通过位运算来获得读写的状态。</p>
</blockquote>
<p>BlockingQueue原理</p>
<blockquote>
<p>ArrayBlockingxxx, LinkedBlockingxxx, PriorityBlockingxxx, Delayxxx(延时获取元素), Synchronousxxx(不存储元素), LinkedTransferxxx(无界), LinkedBlockingDeque</p>
<p>处理方式：抛出异常(add)、返回特殊值(offer)、一直阻塞(put、超时退出(offer(e, time, unit))</p>
<p>使用Condition + LockSupport实现。</p>
</blockquote>
<p>线程池</p>
<blockquote>
<p>Executors的几个静态方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">newFixedThreadPool() 阻塞队列无限，会OOM</span><br><span class="line">newSingleThreadExecutor() 阻塞队列无限，会OOM</span><br><span class="line">newCachedThreadPool() 最大线程数为Integer.MAX 也会OOM</span><br></pre></td></tr></table></figure>

<p>自定义线程池参数的设置(cpu密集 or io密集)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cpu使用率较高（也就是一些复杂运算，逻辑处理），所以线程数一般只需要cpu核数的线程就可以了，减少上下文切换</span><br><span class="line">cpu使用率较低，程序中会存在大量I/O操作占据时间，导致线程空余时间出来，所以通常就需要开cpu核数的两倍的线程， 当线程进行I/O操作cpu空暇时启用其他线程继续使用cpu，提高cpu使用率 </span><br></pre></td></tr></table></figure>

<p>核心线程数、最大线程数、存活时间、时间单位、阻塞队列、创建线程的工厂、拒绝策略</p>
<p>拒绝策略：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AbortPolicy：默认的策略，直接抛出 RejectedExecutionException 异常，阻⽌系统正常运⾏。</span><br><span class="line">CallerRunsPolicy：既不会抛出异常，也不会终⽌任务，⽽是将任务返回给调⽤者，从⽽降低新任务的流量。</span><br><span class="line">DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加⼊队列中尝试再次提交任务。</span><br><span class="line">DiscardPolicy：该策略默默地丢弃⽆法处理的任务，不予任何处理也不抛出异常。如果允许任务丢失，这是最好的⼀种策略。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>读写锁的实现类</p>
<blockquote>
<p>ReentrantReadWriteLock、ReadWriteLockView in StampedLock</p>
</blockquote>
<p>公平锁和非公平锁</p>
<blockquote>
<p>公平锁保证了FIFO原则但是耗费大量资源在上下文切换，而非公平锁则保证了极大的吞吐量和效率，但可能造成饥饿。</p>
</blockquote>
<p>CAS</p>
<blockquote>
<p>compareAndSet，自旋保证原子操作，和volatile关键字配合使用。</p>
</blockquote>
<p>重排序</p>
<blockquote>
<p>volatile，内存屏障。final</p>
</blockquote>
<p>AQS</p>
<blockquote>
<p>acquire方法中：tryAcquire()—失败—addWaiter()加入等待队列—addQueued()再尝试一次失败就阻塞。</p>
<p>只有前节点唤醒或者中断才会继续执行。</p>
</blockquote>
<p>volatile</p>
<blockquote>
<p>内存屏障保证有序性，总线嗅探机制保证可见性。</p>
<p>伪共享：volatile修饰变量需要更新时，其他和volatile修饰变量在同一缓存行的变量也需要重新获取，性能降低。通过添加一些long的变量来填充缓存行。</p>
</blockquote>
<p>创建线程的方式</p>
<blockquote>
<p>①继承自Thread重写run方法②实现Runnable接口并实现run方法③实现Callerable接口，实现call方法，可有返回值</p>
</blockquote>
<p>TLAB</p>
<blockquote>
<p>缺省情况下仅占有整个Eden空间的1%</p>
</blockquote>
<p>LockSupport</p>
<blockquote>
<p>park()、unpark(Thread t)、parkNaos、parkUtil</p>
</blockquote>
<p>Condition接口</p>
<blockquote>
<p>await方法原理：将当前获得锁的线程从同步队列移到等待队列最后，并且释放同步状态。</p>
<p>signal：将当前condition对应的等待队列的首节点放入到同步队列最后，然后通过unpark唤醒线程，进而线程通过acquireQueued方法尝试获取同步状态。</p>
</blockquote>
<p>乐观锁、悲观锁：</p>
<blockquote>
<p>容易发生冲突且冲突量大时使用悲观锁，否则乐观锁(多读少写)。</p>
<p>数据库等适合悲观锁。</p>
</blockquote>
<p>concurrent包下有哪些：</p>
<blockquote>
<p>java.util.concurrent包下包含：tools、locks、collections、executor、atomic</p>
<p>其中tools包含CountDownLatch、Semaphore、Executors、Exchanger等等</p>
<p>locks则是包含了Lock、Condition、LockSupport、ReadWriteLock</p>
<p>collections则是一些支持并发的集合：阻塞队列、ConcurrentHashMap、ConcurrentSkipList等等</p>
<p>executors则是线程池，atomic为原子类。</p>
</blockquote>
<p>Java线程的通信方式</p>
<blockquote>
<p>volatile</p>
<p>等待/通知机制</p>
<p>join方式</p>
<p>threadLocal</p>
</blockquote>
<p>ThreadLoacl 类、内存泄漏（key是弱引用 ，value是强引用） 每次使用后remove。</p>
<blockquote>
<p>由于Thread中包含变量ThreadLocalMap，因此ThreadLocalMap与Thread的生命周期是一样长，如果都没有手动删除对应key，都会导致内存泄漏。</p>
<p>但是使用<strong>弱引用</strong>可以多一层保障：弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用set(),get(),remove()【源码保证】的时候会被清除。</p>
<p>因此，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。</p>
<p>解决方案：</p>
<ul>
<li>每次使用完ThreadLocal都调用它的remove()方法清除数据</li>
<li>将ThreadLocal变量定义成private static，这样就一直存在ThreadLocal的强引用，也就能保证任何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进而清除掉 。</li>
</ul>
</blockquote>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>JVM内存结构</p>
<blockquote>
<p>class文件——类加载子系统——运行时数据区(方法区、堆、虚拟机栈、本地方法栈、PC寄存器)——执行引擎——本地方法库</p>
</blockquote>
<p>垃圾回收算法</p>
<blockquote>
<p>标记-清除、标记-整理、复制算法</p>
<p>垃圾回收器：CMS、G1、ParNew、Serial Old、Parellel Old</p>
</blockquote>
<p>类加载过程</p>
<blockquote>
<p>加载(已经存在Class对象)——链接(验证、准备、解析，准备阶段对类变量赋默认值)——初始化(clinit方法)</p>
</blockquote>
<p>类加载机制</p>
<blockquote>
<ul>
<li>隐式加载 new 创建类的实例,</li>
<li>显式加载：loaderClass,forName等</li>
<li>访问类的静态变量，或者为静态变量赋值</li>
<li>调用类的静态方法</li>
<li>使用反射方式创建某个类或者接口对象的Class对象。</li>
<li>初始化某个类的子类</li>
<li>直接使用<code>java.exe</code>命令来运行某个主类</li>
</ul>
</blockquote>
<p>双亲委派模型</p>
<blockquote>
<p>1) 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类豳加载器去执行;<br>2) 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器<br>3) 如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。 </p>
</blockquote>
<p>破坏双亲委派机制</p>
<blockquote>
<p>在Java应用中存在着很多服务提供者接口（Service Provider Interface，SPI），这些接口允许第三方为它们提供实现，如常见的 SPI 有 JDBC、JNDI等，这些 SPI 的接口属于 Java 核心库，一般存在rt.jar包中，由Bootstrap类加载器加载，而 SPI 的第三方实现代码则是作为Java应用所依赖的 jar 包被存放在classpath路径下，由于SPI接口中的代码经常需要加载具体的第三方实现类并调用其相关方法，但SPI的核心接口类是由引导类加载器来加载的，而Bootstrap类加载器无法直接加载SPI的实现类，同时由于双亲委派模式的存在，Bootstrap类加载器也无法反向委托AppClassLoader加载器SPI的实现类。在这种情况下，我们就需要一种特殊的类加载器来加载第三方的类库，而线程上下文类加载器就是很好的选择。</p>
<p>线程上下文类加载器（contextClassLoader）是从 JDK 1.2 开始引入的，我们可以通过java.lang.Thread类中的getContextClassLoader()和 setContextClassLoader(ClassLoader cl)方法来获取和设置线程的上下文类加载器。如果没有手动设置上下文类加载器，线程将继承其父线程的上下文类加载器，初始线程的上下文类加载器是系统类加载器（AppClassLoader）,在线程中运行的代码可以通过此类加载器来加载类和资源</p>
</blockquote>
<p>沙箱安全机制</p>
<blockquote>
<p>假如自定义java.lang.String类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件(rt.jar包中java\lang\String.class)，报错信息说没有main方法，就是因为加载的是rt.jar包中的String类。这样可以保证对java核心源代码的保护，这就是<strong>沙箱安全机制</strong>。</p>
</blockquote>
<p>ClassLoader的方法</p>
<blockquote>
<p>getParent()获取父加载器、loadClass(String name)加载指定name的类并返回Class对象、findClass(String name)查找指定name的类并返回Class对象、 findLoadedClass(String name)查找已经加载的类并返回、defineClass(String name, byte[] b, int off, int len)将字节数组中的内容转换为一个类、resolveClass(Class&lt;?&gt; c)链接指定的一个类。</p>
<p>遵循双亲委派——重写findClass方法即可、打破双亲委派——重写loadClass方法</p>
</blockquote>
<p>OOM如何分析，一些分析工具，常用命令</p>
<blockquote>
<p>jvisualVM、jprofiler</p>
<p>jmap、jflag、jinfo、jstate</p>
</blockquote>
<p>堆和栈的区别</p>
<blockquote>
<p>堆中存在OOM和GC，栈中只存在OOM。堆是存储的单位，栈是运行时的单位。</p>
</blockquote>
<p>对象头</p>
<blockquote>
<p>MarkWord(hashcode、锁标志位、分代年龄、是否偏向锁、偏向线程id等等)</p>
<p>元数据指针(指向方法区的类型数据信息)</p>
<p>数组长度(如果是数组的话)</p>
</blockquote>
<p>对象实例化过程</p>
<blockquote>
<p>①查看对应的类信息是否加载②计算所需内存并分配空间③并发问题(CAS)分配TLAB④默认初始化⑤设置对象头⑥显示初始化</p>
</blockquote>
<p>NIO</p>
<blockquote>
<p>直接内存，DirectByteBuffer操作本地内存，没有中间状态。IO多路复用</p>
</blockquote>
<p>String不可变原理：</p>
<blockquote>
<p>final修饰char数组(jdk9后采用byte数组)。</p>
<p>原因：①字符串常量池②String缓存了自身的hashcode，如果可变但hash没变，散列会存在问题③String会作为参数</p>
<p>StringBuffer线程安全，synchronized修饰，StringBuilder性能更高。</p>
</blockquote>
<p>String str1=”a”；String str2=”a”+”bc”;</p>
<blockquote>
<p>都在字符串常量池中创建一个对象。</p>
<p>String a = new String(“11”)+new String(“22”);创建了几个对象？</p>
<p>new String(“xx”)都会创建两个对象，然后如果+两边存在变量，那么都会存在一个StringBuilder对象，StirngBuilder还会通过toString方法再创建一个对象。</p>
</blockquote>
<p>ClassNotFoundException场景</p>
<blockquote>
<p>1、调用class的forName方法时，找不到指定的类<br>2、ClassLoader 中的 findSystemClass() 方法时，找不到指定的类<br>3、ClassLoader 中的 loadClass() 方法时，找不到指定的类</p>
</blockquote>
<p>GC ROOTS</p>
<blockquote>
<p>在Java语言中，GC Roots包括以下几类元素：</p>
<p>①虚拟机栈中引用的对象。比如：各个线程被调用的方法中使用到的参数、局部变量等。<br>②本地方法栈内JNI(通常说的本地方法)引用的对象<br>③方法区中类静态属性引用的对象。比如: Java类的引用类型静态变量<br>④方法区中常量引用的对象。比如:字符串常量池（string Table）里的引用<br>⑤所有被同步锁synchronized持有的对象<br>⑥Java虚拟机内部的引用。基本数据类型对应的class对象，一些常驻的异常对象（如:NullPointerException、OutOfMemoryError）、系统类加载器<br>⑦反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。<br>⑧在某些特殊情况下，还可能存在一些对象临时加入到Root中的情况。(如：在分代垃圾收集时，如果只回收新生代的对象，那么一些老年代的对象也可以作为Root)</p>
</blockquote>
<p>OOM排查</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1、先查看应用进程号pid: ps -ef | grep 应用名</span><br><span class="line">2、查看pid垃圾回收情况: jstat -gc pid 5000（时间间隔）</span><br><span class="line">3、开启OOM快照: </span><br><span class="line">	-XX：+HeapDumpOnOutOfMemoryError（开启堆快照）</span><br><span class="line">	-XX：HeapDumpPath=C:/m.hprof（保存文件到哪个目录）</span><br><span class="line">4、dump 查看方法栈信息：</span><br><span class="line">	jstack -l pid &gt; /home/test/jstack.txt</span><br><span class="line">5、dump 查看JVM内存分配以及使用情况</span><br><span class="line">	jmap -heap pid &gt; /home/test/jmapHeap.txt</span><br><span class="line">6、dump jvm二进制的内存详细使用情况 </span><br><span class="line">	jmap -dump:format=b,file=/home/test/oom.hprof pid</span><br></pre></td></tr></table></figure>


</blockquote>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>java连接数据库 jdbc原生</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">conn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String URL = <span class="string">"jdbc:mysql://127.0.0.1:3306/Supermarket?characterEncoding=utf-8"</span>;</span><br><span class="line">		String USER = <span class="string">"root"</span>;</span><br><span class="line">		String PASSWORD = <span class="string">"123"</span>;</span><br><span class="line">		<span class="comment">// 1.加载驱动程序</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">			<span class="comment">// 2.获得数据库链接</span></span><br><span class="line">			Connection conn = DriverManager.getConnection(URL, USER, PASSWORD);</span><br><span class="line">			<span class="comment">// 3.通过数据库的连接操作数据库，实现增删改查（使用Statement类）</span></span><br><span class="line">			String name=<span class="string">"张三"</span>;</span><br><span class="line">			<span class="comment">//预编译</span></span><br><span class="line">			String sql=<span class="string">"select * from userinfo where UserName=?"</span>;</span><br><span class="line">			PreparedStatement statement = conn.prepareStatement(sql);</span><br><span class="line">			statement.setString(<span class="number">1</span>, name);</span><br><span class="line">			ResultSet rs = statement.executeQuery();</span><br><span class="line"><span class="comment">//			String sql="select * from userinfo where UserName='"+name+"'";</span></span><br><span class="line"><span class="comment">//			Statement statement = conn.createStatement();			</span></span><br><span class="line"><span class="comment">//			ResultSet rs = statement.executeQuery(sql);</span></span><br><span class="line">			<span class="comment">// 4.处理数据库的返回结果(使用ResultSet类)</span></span><br><span class="line">			<span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">				System.out.println(rs.getString(<span class="string">"UserName"</span>) + <span class="string">" "</span> + rs.getString(<span class="string">"Password"</span>));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">		conn.close();</span><br><span class="line">		rs.close();</span><br><span class="line">		statement.close();			</span><br><span class="line">	&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;			</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (SQLException e) &#123;			</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<p>IOC AOP</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">IOC: Inversion of Control，控制反转</span><br><span class="line">DI: Dependency Injection，依赖注入</span><br><span class="line">关系：IOC是一种面向编程设计思想，DI是IOC思想的实现方式，即：DI实现IOC这一思想</span><br><span class="line">A需要B，A不直接控制B，A给IOC容器需要的信息，然后IOC容器为A创建B。</span><br><span class="line">主动获取反转为被动获取，解耦。</span><br><span class="line"></span><br><span class="line">AOP: jdk or cglib</span><br><span class="line">JDK动态代理主要涉及java.lang.reflect包下边的两个类：Proxy和InvocationHandler。其中，InvocationHandler是一个接口，可以通过实现该接口定义横切逻辑，并通过反射机制调用目标类的代码，动态地将横切逻辑和业务逻辑贬值在一起。</span><br><span class="line">所以使用JDK动态代理的话，他有一个限制，就是它只能为接口创建代理实例，而对于没有通过接口定义业务方法的类，如何创建动态代理实例呢？答案就是CGLib。</span><br><span class="line">CGLib采用底层的字节码技术，全称是：Code Generation Library，CGLib可以为一个类创建一个子类，在子类中采用方法拦截的技术拦截所有父类方法的调用并顺势织入横切逻辑。</span><br><span class="line">在spring中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">JDK的动态代理</span><br><span class="line">	final Advice advice = new Advice();   // 获得增强对象</span><br><span class="line">    final Target target = new Target();</span><br><span class="line">    // 返回值就是生成的动态代理对象</span><br><span class="line">    TargetInterface proxy = (TargetInterface) Proxy.newProxyInstance(</span><br><span class="line">            target.getClass().getClassLoader(), // 目标对象的类加载器</span><br><span class="line">            target.getClass().getInterfaces(),  // 目标对象相同的接口字节码对象数组</span><br><span class="line">            new InvocationHandler() &#123;</span><br><span class="line">                // 调用代理对象的任何方法，实质执行的为invoke方法</span><br><span class="line">                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">                    advice.before();// 前置增强</span><br><span class="line">                    method.invoke(target, args);// 执行目标方法</span><br><span class="line">                    advice.after();</span><br><span class="line">                    return null; // 该返回值对于方法本身而言 无意义</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    );</span><br><span class="line">    proxy.save();   // 调用代理对象的方法</span><br><span class="line">cglib的动态代理</span><br><span class="line">	final Advice advice = new Advice();   // 获得增强对象</span><br><span class="line">    final Target target = new Target();</span><br><span class="line">    // 返回值就是生成的动态代理对象 基于cglib</span><br><span class="line">    // 1.创建增强器</span><br><span class="line">    Enhancer enhancer = new Enhancer();</span><br><span class="line">    // 2.设置父类 (目标)</span><br><span class="line">    enhancer.setSuperclass(Target.class);</span><br><span class="line">    // 3.设置回调</span><br><span class="line">    enhancer.setCallback(new MethodInterceptor() &#123;</span><br><span class="line">        public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">            advice.before(); // 执行前置</span><br><span class="line">            Object invoke = method.invoke(target, args);</span><br><span class="line">            advice.after(); // 执行后置</span><br><span class="line">            return invoke;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    // 4.生成代理对象</span><br><span class="line">    Target proxy = (Target) enhancer.create();</span><br><span class="line"></span><br><span class="line">    proxy.save();</span><br></pre></td></tr></table></figure>


</blockquote>
<p>Spring加载bean的流程</p>
<blockquote>
<p>class对象——实例化得到原始bean对象——属性注入——初始化——放入单例池——销毁</p>
</blockquote>
<p>三级缓存与循环依赖</p>
<blockquote>
<p>class对象——实例化——放入三级缓存——属性注入——需要的属性先查找一级缓存、然后查找二级缓存、然后查找三级缓存，放入二级缓存、删除三级缓存。</p>
<p>三级缓存内存存的是函数式接口。</p>
<p>构造器的循环依赖和prototype的循环依赖无法解决。(?)</p>
</blockquote>
<p>Spring、MyBatis整合</p>
<blockquote>
<p>通过注解对mapper接口进行扫描并获得对应包名和接口，然后进行BD的注册，注册完后根据接口类型等信息对BD进行处理，即改变BD生成bean的方式(通过实现BeanFactory的方式来生成)，通过MapperBeanFactory进行后续的bean的生成。</p>
</blockquote>
<p>BeanFactory和FactoryBean</p>
<blockquote>
<p>FactoryBean是一个接口，当在IOC容器中的Bean实现了FactoryBean后，通过getBean(String BeanName)获取到的Bean对象并不是FactoryBean的实现类对象，而是这个实现类中的实现的getObject()方法返回的对象，如下图的MapperFactoryBean。而如果要想获取FactoryBean的实现类，就要getBean(&amp;BeanName)，在BeanName之前加上&amp;。</p>
<p>BeanFactory是一个接口，Spring内部实现了很多类，存放很多东西，如definitionmap、singletonmap等等。BeanFactory是个Factory，也就是IOC容器或对象工厂。在Spring中，所有的Bean都是由BeanFactory(也就是IOC容器)来进行管理的</p>
</blockquote>
<p>@Autowired和@Resource区别</p>
<blockquote>
<p>@Autowired//默认按type注入<br>@Qualifier(“cusInfoService”)//一般作为@Autowired()的修饰用<br>@Resource(name=”cusInfoService”)//默认按name注入，可以通过name和type属性进行选择性注入</p>
</blockquote>
<p>@Inject和@Autowired</p>
<blockquote>
<p>@Inject是Java EE 6（JSR-299）中引入的Java CDI（上下文和依赖项注入）标准的一部分</p>
<p>@Autowired则是Spring框架的一部分。</p>
<p>前者自动装配的bean范围是singleton，后者则是原型</p>
<p>前者和@Named一起使用，后者和@Qualifier一起使用。</p>
</blockquote>
<p>全局异常处理</p>
<blockquote>
<p>继承HandlerExceptionResolver接口，并将实现类作为bean进行注册到Spring，在resolveException中实现处理逻辑。</p>
</blockquote>
<p>SpringBoot怎么在服务端接收到HTTP请求后，再转发到控制层？</p>
<blockquote>
<p>filter-&gt;dispatchServlet(doService-&gt;doDispath)-&gt;intercepter(prehandle拦截器)-&gt;RequestMappingHandler(查找映射)-&gt;ServletInvocableHandlerMethod: invokeAndHandle(参数处理)-&gt;通过java 反射机制动态调用目标API方法进入相对应具体的controller-&gt;执行 handleReturnValue 方法， 首先会判断是否需要对response entity 进行二次处理（ResponseBodyAdvice: beforeBodyWrite）， 处理完成后， 调用注册进来的MessageConvertor 对返回信息进行转换处理， 比如使用faster Jackson 把对象类型转成 json 字符串，并以application/json 的形式返回 http response -&gt; 拦截器 postHandle 方法， 最后执行拦截器的afterCompletion 方法。</p>
<p>按照 Servlet 规范，所有请求都会被tomcat容器交到 dispatchServlet 的 doService 方法中去处理。跟到这个方法中去，我们发现其中设置了变量进 request 对象，然后执行了 doDispatch 方法，这个方法才是真正实现请求处理的核心。</p>
<p>该doDispatch方法中调用 getHandler 找到 url 匹配的 handler 方法（示例代码中的 hello 方法）。然后调用 ha.handle() 来获得处理结果。</p>
<p>对于getHandler 方法，是通过 HandlerMapping 接口对象的集合对象来操作的。HandlerMapping 接口要求实现类实现从请求到处理对象的映射的方法。以 RequestMappingHandlerMapping 实现为例，它底层注册了一个 url -&gt; handler方法的 map，每当请求过来，就会根据请求的url 去 map 中匹配，匹配到对应的handler 方法。</p>
</blockquote>
<p>Spring中的设计模式</p>
<blockquote>
<p>简单工厂模式——BeanFactory</p>
<p>工厂方法模式——FactoryBean</p>
<p>单例模式——单例池，bean(singleton)</p>
<p>适配器模式——AOP</p>
<p>包装器模式——Wrapper、Decorator</p>
<p>代理模式——AOP动态代理</p>
<p>观察者模式——</p>
<p>策略模式——</p>
</blockquote>
<h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><p>什么是MVC</p>
<blockquote>
<p>Controller（控制器）、Model（业务模型）、View（用户视图）实现代码分离，Controller用于同步Model和View</p>
</blockquote>
<p>SpringMVC流程</p>
<blockquote>
<p>（1）用户发送请求至前端控制器DispatcherServlet；<br>（2） DispatcherServlet收到请求后，调用HandlerMapping处理器映射器，请求获取Handle；<br>（3）处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet；<br>（4）DispatcherServlet 调用 HandlerAdapter处理器适配器；<br>（5）HandlerAdapter 经过适配调用 具体处理器(Handler，也叫后端控制器)；<br>（6）Handler执行完成返回ModelAndView；<br>（7）HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet；<br>（8）DispatcherServlet将ModelAndView传给ViewResolver视图解析器进行解析；<br>（9）ViewResolver解析后返回具体View；<br>（10）DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）<br>（11）DispatcherServlet响应用户。</p>
<p><img src="https://i.loli.net/2021/03/22/CAafT92nKwky5jU.png" alt="image.png"></p>
</blockquote>
<p>SpringMVC实现返回json</p>
<blockquote>
<p>通过一些json框架如(Jackson)，并在方法前加上@ResponseBody即可</p>
</blockquote>
<p>解决post、get乱码问题</p>
<blockquote>
<p>post：在web.xml中配置一个CharacterEncodingFilter过滤器，设置成utf-8；</p>
<p>get：①修改tomcat配置文件添加编码与工程编码一致；②对传过来的参数进行重新编码</p>
</blockquote>
<p>SpringMVC异常处理</p>
<blockquote>
<p>可以将异常抛给Spring框架，由Spring框架来处理；我们只需要配置简单的异常处理器，在异常处理器中添视图页面即可。</p>
</blockquote>
<p>SpringMVC控制器</p>
<blockquote>
<p>是单例的，多线程存在线程安全问题，不使用同步，会影响性能，在控制器中不写字段来保证线程安全。</p>
</blockquote>
<p>SpringMVC常用注解</p>
<blockquote>
<p>@RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。<br>@RequestBody：注解实现接收http请求的json数据，将json转换为java对象。<br>@ResponseBody：注解实现将conreoller方法返回对象转化为json对象响应给客户。</p>
<p>@Controller、@RestController(@Controller + @ResponseBody)</p>
</blockquote>
<p>如何在方法中得到session、request对象</p>
<blockquote>
<p>直接在方法中声明这个对象，SpringMvc就自动会把属性赋值到这个对象里面。</p>
</blockquote>
<p>SpringMvc用什么对象从后台向前台传递数据的？</p>
<blockquote>
<p>通过ModelMap对象，可以在这个对象里面调用put方法，把对象加到里面,前台就可以通过el表达式拿到。</p>
</blockquote>
<p>怎么样把ModelMap里面的数据放入Session里面？</p>
<blockquote>
<p>可以在类上面加上@SessionAttributes注解，里面包含的字符串就是要放入session里面的key。</p>
</blockquote>
<p>SpringMvc里面拦截器是怎么写的？</p>
<blockquote>
<p>有两种写法，一种是实现HandlerInterceptor接口，另外一种是继承适配器类，接着在接口方法当中，实现处理逻辑；然后在SpringMVC的配置文件中配置拦截器即可</p>
</blockquote>
<p>注解原理</p>
<blockquote>
<p>注解本质是一个继承了<code>Annotation</code>的特殊接口，其具体实现类是<code>Java</code>运行时生成的动态代理类。我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象。通过代理对象调用自定义注解的方法，会最终调用<code>AnnotationInvocationHandler</code>的<code>invoke</code>方法。该方法会从<code>memberValues</code>这个<code>Map</code>中索引出对应的值。而<code>memberValues</code>的来源是<code>Java</code>常量池。</p>
</blockquote>
<p>Controller局部异常处理</p>
<blockquote>
<p>①在某个方法上方使用@ExceptionHandler()注解，并给出想要处理的异常类型，然后该方法就会作为该Controller的异常处理方法</p>
<p>②定义一个异常处理类，并使用@ControllerAdvice()注解修饰，并给出想要处理的Controller，可以传入一个接口class对象，表示实现了该接口的Controller的异常都由该异常类处理，内部的exceptionHandler和方法①一致。</p>
</blockquote>
<h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><p>配置文件装载顺序</p>
<blockquote>
<p>①application.properties优先级大于application.yml<br>②先去项目根目录找config文件夹下找配置文件件；再去根目录下找配置文件；去resources下找cofnig文件夹下找配置文件；去resources下找配置文件<br>③如果高优先级的配置文件和低优先级的配置文件中属性不冲突，则可以实现互补配置。<br>④外部配置：如cmd命令，或者系统属性System.getProperties()；同样可以形成互补配置</p>
</blockquote>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>单线程原因：</p>
<blockquote>
<ol>
<li>单线程编程容易并且更容易维护；</li>
<li>Redis 的性能瓶颈不再 CPU ，主要在内存和网络；</li>
<li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li>
</ol>
</blockquote>
<p>缓存淘汰策略</p>
<blockquote>
<p>lru(最近最少未使用)、ttl(时间)、lfu(使用频率)、不驱逐</p>
</blockquote>
<p>布隆过滤器原理</p>
<blockquote>
<p>bitmap + 多次hash</p>
<p>对于hash结果不正确的，一定不存在。反之则不是，可能存在也可能不存在。</p>
</blockquote>
<p>一致性hash</p>
<blockquote>
<p>hash环(对2^32而不是一个固定值进行hash)，保证即使hash结果数要求发生变化，只用改变hash环上的分割即可。可使用虚拟节点进行hash环分配不均的改良。</p>
<p>虚拟节点即将单个节点虚拟为多个节点，使得数据能够平均分布在各个节点上。</p>
</blockquote>
<p>持久化机制</p>
<blockquote>
<p>AOF、RDB</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;RDB其实就是把数据以快照的形式保存在磁盘上。什么是快照呢，你可以理解成把当前时刻的数据拍成一张照片保存下来。Redis调forks。同时拥有父进程和子进程。子进程将数据集写入到一个临时RDB文件中。当子进程完成对新RDB文件的写入时，Redis用新RDB文件替换原来的RDB文件，并删除旧的RDB文件。</span><br><span class="line">&gt;RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。也是默认的持久化方式，这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为dump.rdb。</span><br><span class="line">&gt;三种触发机制save、bgsave、自动化。</span><br><span class="line">save: 阻塞redis，用新的RDB替换旧的并直到过程完成才继续</span><br><span class="line">bgsave: Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。具体操作是Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。基本上 Redis 内部所有的RDB操作都是采用bgsave命令。</span><br><span class="line">自动化：更改配置文件，它在“N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动进行数据集保存操作。</span><br><span class="line">&gt;RDB是一个非常紧凑的文件，方便传输</span><br><span class="line">&gt;快照持久化期间修改的数据不会被保存，可能丢失数据。</span><br><span class="line">&gt;----------------------------------------------------------------------------------------------------</span><br><span class="line">&gt;AOF：redis会将每一个收到的写命令都通过write函数追加到文件中。通俗的理解就是日志记录。每当Redis执行一个改变数据集的命令时（比如 SET）， 这个命令就会被追加到AOF文件的末尾。这样的话， 当Redis重新启时， 程序就可以通过重新执行AOF文件中的命令来达到重建数据集的目的</span><br><span class="line">&gt;为了压缩aof的持久化文件。redis提供了bgrewriteaof命令。将内存中的数据以命令的方式保存到临时文件中，同时会fork出一条新进程来将文件重写。</span><br><span class="line">&gt;每次修改同步always：同步持久化，每次发生数据变更会被立即记录到磁盘，性能较差但数据完整性比较好</span><br><span class="line">&gt;每秒同步everysec：异步操作，每秒记录 如果一秒内宕机，有数据丢失</span><br><span class="line">&gt;不同no：从不 fsync ：将数据交给操作系统来处理，由操作系统来决定什么时候同步数据。更快，也更不安全的选择。</span><br><span class="line">&gt;AOF重写：因为 AOF 的运作方式是不断地将命令追加到文件的末尾， 所以随着写入命令的不断增加， AOF 文件的体积也会变得越来越大。举个例子， 如果你对一个计数器调用了 100 次 INCR ， 那么仅仅是为了保存这个计数器的当前值， AOF 文件就需要使用 100 条记录（entry）。然而在实际上， 只使用一条 SET 命令已经足以保存计数器的当前值了， 其余 99 条记录实际上都是多余的。</span><br><span class="line">&gt;为了处理这种情况， Redis 支持一种有趣的特性： 可以在不打断服务客户端的情况下， 对 AOF 文件进行重建（rebuild）。执行 bgrewriteaof 命令， Redis 将生成一个新的 AOF 文件， 这个文件包含重建当前数据集所需的最少命令。</span><br></pre></td></tr></table></figure>

<p>Redis 持久化 之 AOF 和 RDB 同时开启，Redis听谁的？</p>
<blockquote>
<p>AOF</p>
</blockquote>
</blockquote>
<p>缓存雪崩、缓存击穿、缓存穿透</p>
<blockquote>
<p>缓存雪崩是指缓存同一时间大面积的失效（也可能为redis重启），所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p>缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。(一般出现于被攻击或者电商中高并发的场景)</p>
<p>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发<strong>查同一条数据</strong>，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p>
</blockquote>
<p>底层数据结构</p>
<blockquote>
<p><strong>字符串</strong>：SDS（char数组buf + len + 未使用的空间大小free），可以动态扩容(预分配)，惰性空间释放(改变free的值而非回收内存)。</p>
<p><strong>链表</strong>：双向链表，表头前置为null，表尾后置为null</p>
<p><img src="https://i.loli.net/2021/03/22/ycSbiXY1DC9edHO.png" alt="image.png"></p>
<p><strong>字典</strong>：新增时，先根据键值对的键计算出哈希值，然后根据 sizemask 属性和哈希值，计算索引值——即落入数组中的哪个位置。之后如果有一个位置多个键值对要存入时，组成单向链表即可。</p>
<p>这里和 HashMap 的不同之处在于，链表添加时总是添加在表头位置。因为 dictEntry 节点组成的链表没有指向链表表尾的指针，为了速度考虑，总是将新节点加在链表的表头位置。（为什么要这样，而不是遍历完整个链表后加在链表尾部，不遍历出现重复键怎么办？）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;rehash:</span><br><span class="line">&gt;rehash 也可以参考 Java 中 HashMap 的原理。</span><br><span class="line">&gt;负载因子 = 哈希表中已保存的节点数量 / 哈希表数组大小。</span><br><span class="line">&gt;当哈希表中存放的键值对不断增多或减少，为了让负载因子在一个合理的范围内，需要对大小进行扩展或者收缩。（这里类似 HashMap 中的重新散列方法）</span><br><span class="line">&gt;1. 字典的 ht[1] 分配空间，空间的大小由 ht[0] 已经使用的键值对数量以及执行的扩张和收缩来决定。</span><br><span class="line">- 扩展操作，那么 ht[1] 分配的空间大小应是比当前 ht[0].used 值的二倍大的第一个 2 的整数幂。（比如当前使用空间 14，那么找 28 的下一个 2 的整数幂，为 32）</span><br><span class="line">- 收缩操作，取 ht[0].used 的第一个大于等于的 2 的整数幂。（比如 14，那么就是 16）</span><br><span class="line">&gt;2. 将 ht[0] 中的所有键值对，rehash 到 ht[1] 上面：根据新的大小来重新计算所有键的哈希和索引，映射到新数组的指定位置上。</span><br><span class="line">&gt;3. ht[0] 的所有键值对都迁移到 ht[1] 之后，释放 ht[0] ，然后将 ht[1] 设置为 ht[0] ，然后在 ht[1] 处新创建空白哈希表，为下一次 rehash 做准备。</span><br><span class="line">&gt;扩展的条件</span><br><span class="line">服务器没有执行 BGSAVE 或者 BGREWRITEAOF 命令，并且哈希表的负载因子大于等于 1 。</span><br><span class="line">服务器正在执行 BGSAVE 或者 BGREWRITEAOP 命令，并且哈希表的负载因子大于等于 5 。</span><br><span class="line">&gt;这两种情况根据是否有后台命令执行来区分，是因为在执行 BGSAVE 或者 BGREWRITEAOF 的过程中，Redis 需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制（copy-on-write）技术来优化子进程的使用效率。所以在子进程存在期间，服务器会提高执行扩展操作所需的负载因子，尽可能避免在子进程存在期间进行哈希表的扩展操作，来避免不必要的内存写入操作，最大限度的节省内存。</span><br><span class="line">&gt;收缩的条件</span><br><span class="line">&gt;当哈希表的负载因子小于 0.1 时，自动开始对哈希表进行收缩操作。</span><br><span class="line">&gt;渐进式rehash:</span><br><span class="line">&gt;如果键值对量巨大时，一次性全部 rehash 必然造成一段时间的停止服务。所以要分多次、渐进式的将键值对从 ht[0] 慢慢的 rehash 到 ht[1] 中。</span><br><span class="line">&gt;具体过程：</span><br><span class="line">&gt;1. 为 ht[1] 分配空间，同时有 ht[0] 和 ht[1] 两个哈希表。</span><br><span class="line">&gt;2. 在字典中维持一个索引计数器变量 rehashindex ，并将其置为 0 ，表示 rehash 正式开始。</span><br><span class="line">&gt;3. 在 rehash 期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作之外，还会顺便将 ht[0] 哈希表在 rehashindex 索引上的所有键值对 rehash 到 ht[1] 上，当 rehash 工作完成之后，程序将 rehashindex 的值加一。</span><br><span class="line">&gt;4. 随着字典操作的不断进行，最终在某个时间点，ht[0] 的所有键值对都被 rehash 到 ht[1] ，这时程序将 rehashindex 的值置为 -1 ，表示 rehash 工作完成。</span><br><span class="line">&gt;渐进式 rehash 的过程中，更新删除查找等都会在两个哈希表上进行，比如查找，先在 ht[0] 中查找，如果没找到，就去 ht[1] 中查找。而新增操作，直接新增在 ht[1] 中，ht[0] 不会进行任何的新增操作。保证 ht[0] 的数量只减不增，最终变为空表。</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/03/22/gAHwEQy36MCmIZ8.png" alt="image.png"></p>
<p><strong>跳表</strong>：跳跃表是一种有序数据结构，通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。Redis 使用跳跃表作为有序集合键的底层实现之一。<br>跳跃表在 Redis 中，只有两个地方用到：一个是实现有序集合对象，另一个是在集群节点中用作内部数据结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;head：指向跳跃表的表头节点。</span><br><span class="line">&gt;tail：指向跳跃表的表尾节点。</span><br><span class="line">&gt;level：记录当前跳跃表中，层数最高的节点的层数（表头节点的层数不计算）。</span><br><span class="line">&gt;length：记录跳跃表的长度，即包含节点的数量。</span><br><span class="line">&gt;level：每一层都有前进指针和跨度，从头到尾遍历时，访问会沿着层的前进指针进行。</span><br><span class="line">&gt;BW：后退指针，指向前一个节点，从尾到头遍历时使用。</span><br><span class="line">&gt;score：分值，跳跃表中的分值按从小到大排列。</span><br><span class="line">&gt;obj：成员对象，各个节点保存有各个成员对象。</span><br></pre></td></tr></table></figure>



<p><img src="https://i.loli.net/2021/03/22/MIchbjWmDHw1S5E.png" alt="image.png"></p>
<p><strong>整数集合</strong>：整数集合是集合键的底层实现之一。当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis 就会使用整数集合作为集合键的底层实现。<br>整数集合是 Redis 保存整数值的集合的抽象数据结构，可以保存 int16_t ，int32_t ，int64_t 的整数值，并且集合中不会出现重复元素。<br>底层由数组实现，整数集合的每个元素都是数组的一个数组项，各个项在数组中按从小到大排列。length 属性记录了包含的元素数量，即数组的长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;升级:</span><br><span class="line">&gt;当一个新元素添加到整数集合中时，如果新元素类型比整数集合现有的所有元素的类型都要长时，整数集合要先进行升级，然后才能将新元素添加到整数集合中。</span><br><span class="line">&gt;1. 根据新元素类型，扩展整数集合底层数组的大小，并为新元素分配空间。</span><br><span class="line">&gt;2. 将底层数组现有的所有元素都转换成新元素相同的类型，并将类型转换后的元素放置到正确位置上，而且放置过程中需要维持底层数组的有序。</span><br><span class="line">&gt;3. 将新元素添加到底层数组中。</span><br><span class="line">&gt;因为引发升级的新元素的长度肯定比现有所有元素都大，才会出现升级的情况，所以这个值要么大于所有元素，放置的位置就对应新数组的末尾；要么小于所有元素，放置的位置在数组的开头。</span><br><span class="line">&gt;升级可以提高灵活性，不用担心类型错误，可以随意添加不同类型的元素。另外，可以节约内存，只在有需要的时候进行升级。</span><br><span class="line">&gt;另外，整数集合不支持降级操作。</span><br></pre></td></tr></table></figure>

<p><strong>压缩列表</strong></p>
<p>压缩列表（ziplist）是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项并且每个都是小整数值或者长度比较短的字符串时，Redis 就采用压缩列表做底层实现。当一个哈希键只包含少量键值对，并且每个键值对的键和值也是小整数值或者长度比较短的字符串时，Redis 就采用压缩列表做底层实现。</p>
<p>压缩列表是 Redis 为了节约内存而实现的，是一系列特殊编码的连续内存块组成的顺序型数据结构。<br><img src="https://i.loli.net/2021/03/22/dZbBafAUTePKVno.png" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;zlbytes ：4 字节。记录整个压缩列表占用的内存字节数，在内存重分配或者计算 zlend 的位置时使用。</span><br><span class="line">&gt;zltail ：4 字节。记录压缩列表表尾节点记录压缩列表的起始地址有多少个字节，可以通过该属性直接确定表尾节点的地址，无需遍历。</span><br><span class="line">&gt;zllen ：2 字节。记录了压缩列表包含的节点数量，由于只有 2 字节大小，那么小于 65535 时，表示节点数量。等于 65535 时，需要遍历得到总数。</span><br><span class="line">&gt;entry ：列表节点，长度不定，由内容决定。</span><br><span class="line">&gt;zlend ：1 字节，特殊值 0xFF ，用于标记压缩列表的结束。</span><br></pre></td></tr></table></figure>

<p>压缩列表节点保存一个字节数组或者一个整数值。<br>字节数组可以是下列值：</p>
<ul>
<li>长度小于等于 2^6-1 字节的字节数组</li>
<li>长度小于等于 2^14-1 字节的字节数组</li>
<li>长度小于等于 2^32-1 字节的字节数组</li>
</ul>
<p>整数可以是六种长度：</p>
<ul>
<li>4 位长，介于 0 到 12 之间的无符号整数</li>
<li>1 字节长的有符号整数</li>
<li>3 字节长的有符号整数</li>
<li>int16_t 类型整数</li>
<li>int32_t 类型整数</li>
<li>int64_t 类型整数</li>
</ul>
<p>每个压缩列表节点的结构如图：<br><img src="https://i.loli.net/2021/03/22/Q5VpZYUBADC2IfG.png" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;previous_entry_length 属性以字节为单位，记录了压缩列表中前一个节点的长度。该属性的长度可以是 1 字节或者 5 字节。如果前一个节点的长度小于 254 字节，那么该属性长度为 1 字节，保存小于 254 的值。如果前一节点的长度大于等于 254 字节，那么长度需要为 5 字节，属性的第一字节会被设置为 0xFE (254) 之后的 4 个字节保存其长度。</span><br><span class="line">&gt;压缩列表的从表尾到表头遍历：</span><br><span class="line">&gt;1. 首先，有指向压缩列表表尾节点起始地址的指针 p1 （指向表尾节点的指针可以通过指向压缩列表起始地址的指针加上 zltail 属性的值得出）；</span><br><span class="line">&gt;2. 通过用 p1 减去节点的 previous_entry_length 属性，得到前一个节点的起始地址的指针。</span><br><span class="line">&gt;3. 如此循环，最终从表尾遍历到表头节点。</span><br><span class="line">&gt;encoding 属性记录了节点的 content 属性所保存的数据的类型和长度：</span><br><span class="line">&gt;- 一字节、两字节或五字节长，值的最高位为 00、01 或者 10 的是字节数组编码，字节数组的长度由编码除去最高两位之后的其他位记录；</span><br><span class="line">&gt;- 一字节长，值的最高位以 11 开头的是整数编码，这种编码表示保存是整数值，整数值的类型和长度由其他位记录。</span><br><span class="line">&gt;出现新增或删除节点导致 previous_entry_length 1 字节或者 5 字节的长度变化，是连锁更新的问题，但出现几率比较小，而且数量不多的情况下不会对性能造成影响。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>数据结构底层实现</p>
<blockquote>
<p>字符串：①整数——int；②长字符串(大于44【64 - 19(头部) - 1(‘/0’)】字节)——raw；③短字符串(小于44字节)——embstr</p>
<p><img src="https://i.loli.net/2021/03/22/p53zlmPV8FIBZHE.png" alt="image.png"></p>
<p>列表：①满足列表对象所有字符串元素长度都小于64个字节且元素数量小于512——ziplist；②其他使用双向链表</p>
<p>hash：①满足元素数量小于512且所有元素长度小于64字节——ziplist；②哈希表</p>
<p>set：①所有元素都是整数，元素数量小于512——整数列表；②哈希表</p>
<p>zset：①所有元素都是整数，元素数量小于512——整数列表；②跳表</p>
</blockquote>
<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>Docker是一个容器化平台，它以容器的形式将您的应用程序及其所有依赖项打包在一起，以确保您的应用程序在任何环境中无缝运行。</p>
<p>Docker不是虚拟化方法。docker四种状态：运行、已暂停、重新启动、已退出。</p>
<p>DockerFile：FROM—指定基础镜像；LABEL—功能是为镜像指定标签；RUN—运行指定的命令；CMD—容器启动时要运行的命令。</p>
<blockquote>
<p>虽然ADD并且COPY在功能上类似，但是首选COPY。</p>
<p>那是因为它比ADD更易懂。COPY仅支持将本地文件复制到容器中，而ADD具有一些功能（如仅限本地的tar提取和远程URL支持），这些功能并不是很明显。因此，ADD的最佳用途是将本地tar文件自动提取到镜像中</p>
</blockquote>
<p>Docker镜像是Docker容器的源代码，类和对象实例的关系。</p>
<p>docker镜像本质：</p>
<blockquote>
<p>分层文件系统。</p>
<p>centos的镜像很小，复用了os的bootfs，只有其他层。tomcat镜像很大，因为依赖于其他的镜像。</p>
</blockquote>
<h2 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h2><p>选型</p>
<blockquote>
<table>
<thead>
<tr>
<th>MQ</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>RabbitMQ</td>
<td>erlang开发，对消息堆积的支持并不好，当大量消息积压的时候，会导致 RabbitMQ 的性能急剧下降。每秒钟可以处理几万到十几万条消息。</td>
</tr>
<tr>
<td>RocketMQ</td>
<td>java开发，面向互联网集群化功能丰富，对在线业务的响应时延做了很多的优化，大多数情况下可以做到毫秒级的响应，每秒钟大概能处理几十万条消息。</td>
</tr>
<tr>
<td>Kafka</td>
<td>Scala开发，面向日志功能丰富，性能最高。当你的业务场景中，每秒钟消息数量没有那么多的时候，Kafka 的时延反而会比较高。所以，Kafka 不太适合在线业务场景。</td>
</tr>
<tr>
<td>ActiveMQ</td>
<td>java开发，简单，稳定，性能不如前面三个。小型系统用也ok，但是不推荐。推荐用互联网主流的。</td>
</tr>
</tbody></table>
</blockquote>
<p>底层实现</p>
<blockquote>
<p>netty</p>
</blockquote>
<p>文件上传</p>
<blockquote>
<p>断点传输、文件秒传(已经上传过的不再上传)：hash</p>
</blockquote>
<p>文件传输粘包问题</p>
<blockquote>
<p>为何粘包：</p>
<p>A. TCP协议为了提高传输效率，发送方往往需要收集定量的数据才会封装给底层并发送，若出现连续send(data)，TCP会把该数据进行整合(直到装满数据缓冲区），这样就造成了粘包数据；<br>B. 接收方接收方的粘包是由于接收用户相关进程不及时接收数据，从而导致粘包问题，这是因为接收方先把接收到的数据放在系统接受缓冲区，用户进程从该缓冲区取定量的数据，但若下一包数据到达前，缓冲区的数据没有及时的被用户进程取走，则下一包数据与前一包部分数据在系统缓冲区，就可能导致用户设定的进程缓冲区从系统缓冲区取走两个包的部分数据，从而导致粘包</p>
<p>解决方案：</p>
<p>A 发送方在send()之前，先向接收方发送数据总量大小，并通过双端确认，server端发送数据包，然后接收方通过按数据量大小循环设立缓冲区接收数据;；<br>B: TCP提供了PUSH（强制数据立即传送）操作，但影响性能；</p>
</blockquote>
<p>传输文件的方式</p>
<blockquote>
<p>ftp、sftp</p>
</blockquote>
<p>事务消息：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">问题：</span><br><span class="line">1、账号服务扣款成功了，通知积分系统也成功了，但是积分增加的时候失败了，数据不一致了。</span><br><span class="line">2、账号服务扣款成功了，但是通知积分系统失败了，所以积分不会增加，数据不一致了。</span><br><span class="line">rocketmq的解决方案：</span><br><span class="line">针对问题1：如果消费失败了，是会自动重试的，如果重试几次后还是消费失败，那么这种情况就需要人工解决了，比如放到死信队列里然后手动查原因进行处理等。</span><br><span class="line">针对问题2：RocketMQ针对第二个问题解决方案是：如果你扣款成功了，但是往mq写消息的时候失败了，那么RocketMQ会进行回滚消息的操作，这时候我们也能回滚我们扣款的操作。（通过半消息实现）</span><br></pre></td></tr></table></figure>
</blockquote>
<p>顺序消息：</p>
<blockquote>
<p>方案1：发送消息到一个queue中来保证顺序消费(MessageQueueSelector)。<br>方案2：线程数设置为1，且通过消息体判断到哪个queue进行消费。</p>
</blockquote>
<p>消息持久化</p>
<blockquote>
<p>Broker端拿到消息后先将消息、topic、queue等内容存到ByteBuffer里，然后去持久化到commitlog文件中。commitlog文件大小为1G，超出大小会新创建commitlog文件来存储，采取的nio方式。</p>
</blockquote>
<p>如何保证消息不丢失</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">消息消费的流程：</span><br><span class="line">生产阶段：Producer通过网络将消息发送给Broker，这个发送可能会发生丢失，比如网络延迟不可达等。</span><br><span class="line">存储阶段：Broker肯定是先把消息放到内存的，然后根据刷盘策略持久化到硬盘中，刚收到Producer的消息，在内存中了，但是异常宕机了，导致消息丢失。(持久化位置为commitlog)</span><br><span class="line">消费阶段：消费失败了其实也是消息丢失的一种变体吧。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">解决方案：</span><br><span class="line">生产阶段：</span><br><span class="line">	1、通过同步发送来保证消息的成功送达。</span><br><span class="line">	2、如果发送失败会重试，默认为三次，可通过api调整。producer.setRetryTimesWhenSendFailed(10);</span><br><span class="line">	3、如果broker宕机，producer会重试发送到另一台broker</span><br><span class="line">	同步发送+自动重试机制+多个Master节点</span><br><span class="line">存储阶段：</span><br><span class="line">	1、同步刷盘来保证消息的不丢失，同样会损失一部分性能。（默认为异步）</span><br><span class="line">	2、集群部署保证高可用。等Master和Slave都刷完盘后才去通知Producer说消息ok了。brokerRole=SYNC_MASTER</span><br><span class="line">消费阶段：</span><br><span class="line">	1、手动ack</span><br><span class="line">	2、自动重试15次，进入死信队列</span><br></pre></td></tr></table></figure>
</blockquote>
<p>发消息的时候选择queue的算法</p>
<blockquote>
<p>random、hash、自定义</p>
</blockquote>
<p>为什么同一个消费组设置不同tag会出现奇怪现象</p>
<blockquote>
<p>两个相同组的消费者c1,c2相同topic，订阅tag1,tag2。此时往这个topic的两个tag分别发送10条消息。会发现c1没有收到消息，c2只收到了不到10条消息。消息能够正常发送。</p>
<p>原因：broker的问题。<br>Consumer端发心跳给Broker，Broker收到后存到consumerTable里（就是个Map），key是GroupName，value是ConsumerGroupInfo。<br>ConsumerGroupInfo里面是包含topic等信息的，但是问题就出在上一步骤，key是groupName，你同GroupName的话Broker心跳最后收到的Consumer会覆盖前者的。</p>
<p>所以c1的tag1被覆盖，无法接收到消息。为何c2没有收到10条消息呢，因为是集群模式消费，所以会有负载均衡，有一部分消息到达了c1但tag为tag2，无法消费，所以c2只收到了几条消息而非10条。如果换为广播模式，则c2能接收到10条消息。</p>
<p>注意：一个consumer可以订阅多个topic(存在一个map以topic为键)</p>
</blockquote>
<p>消费者负载均衡策略</p>
<blockquote>
<ul>
<li>queue个数大于Consumer个数，且queue个数能整除Consumer个数的话， 那么Consumer会平均分配queue。（比如上面表格的<strong>Consumer有2个 可以整除</strong>部分）</li>
<li>queue个数大于Consumer个数，且queue个数不能整除Consumer个数的话， 那么会有一个Consumer多消费1个queue，其余Consumer平均分配。（比如上面表格的<strong>Consumer有3个 不可整除</strong>部分）</li>
<li>queue个数小于Consumer个数，那么会有Consumer闲置，就是浪费掉了，其余Consumer平均分配到queue上。（比如上面表格的<strong>Consumer有5个 无法都分配</strong>部分）</li>
</ul>
</blockquote>
<h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><p>单服务器抗压</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1.对socket方面的优化</span><br><span class="line">1）操作系统（linux）的设置：</span><br><span class="line">增大socket的最大连接数</span><br><span class="line">echo 50000 &gt; /proc/sys/net/core/somaxconn   (系统默认的值是128，现在改成50000)</span><br><span class="line">加快系统的tcp回收机制 （系统默认tcp在断开后还会存活一段时间） 方法如下</span><br><span class="line">echo  1 &gt; /proc/sys/net/ipv4/tcp_tw_recycle  (系统默认是0，修改为1)</span><br><span class="line">允许空的tcp回收利用 方法如下</span><br><span class="line">echo 1 &gt;/proc/sys/net/ipv4/tcp_tw_reuse  (系统默认为0，修改为1)</span><br><span class="line">让系统不做洪水抵御保护，（当系统检测到80端口在大量的请求时，会自动给返回信息中增加 cookie ,还验证客户端身份，从而避免受到攻击，但这时只是高并发，并不是攻击，所以要把这个抵御机制给关闭） 方法如下</span><br><span class="line">echo 0 &gt;/proc/sys/net/ipv4/tcp_syncookie (系统默认为1，修改为0) </span><br><span class="line"></span><br><span class="line">2）nginx的设置：</span><br><span class="line">增大子进程打开的连接 ，在event段中   worker_connections 1024;  nginx默认能打开1024个连接</span><br><span class="line">修改worker_connections 10000;  修改为可以打开10000个socket连接</span><br><span class="line"></span><br><span class="line">2.对文件系统方面的优化</span><br><span class="line">1）操作系统方面：</span><br><span class="line">让操作系统允许打开更多的文件 ulimit -n(设置一个比较大的值)</span><br><span class="line">ulimit -n 10240;     (把操作系统允许打开文件的最大值设为10240，原本的默认值是1024)</span><br><span class="line"></span><br><span class="line">2）nginx 配置子进程可以打开的文件个数</span><br><span class="line">在nginx全局的配置中  worker_processes 1;下面加上worker_limit_nofile 10240;</span><br><span class="line">work_limit_nofile 10240  ;  (nginx的子进程可以打开10240个文件)</span><br></pre></td></tr></table></figure>


</blockquote>
<p>进程模型</p>
<blockquote>
<p>nginx模型有两种进程，master进程和worker进程。master进程主要用来管理worker进程，管理包含：接收来自外界的信号，向各worker进程发送信号，监控worker进程的运行状态，当worker进程退出后(异常情况下)，会自动重新启动新的worker进程。</p>
<p>而基本的网络事件，则是放在worker进程中来处理了。多个worker进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的。一个请求，只可能在一个worker进程中处理，一个worker进程，不可能处理其它进程的请求。worker进程的个数是可以设置的，一般我们会设置与机器cpu核数一致.</p>
</blockquote>
<p>启动方式</p>
<blockquote>
<p>Nginx的启动方式有两种：</p>
<p>单进程启动：此时系统中只有一个进程，这个进程既是master进程，也是worker进程。</p>
<p>多进程启动：此时系统中有且仅有一个master进程，有多个worker进程，master进程主要是用来管理worker进程的。</p>
</blockquote>
<p><img src="https://i.loli.net/2021/03/12/1cXe8UoavICM5Ws.png" alt="image.png"></p>
<p>如何处理请求</p>
<blockquote>
<p>worker进程之间是平等的，每个进程，处理请求的机会也是一样的。</p>
<p>当我们提供80端口的http服务时，一个连接请求过来，每个进程都有可能处理这个连接。首先，每个worker进程都是从master进程fork过来，在master进程里面，先建立好需要listen的socket之后，然后再fork出多个worker进程，这样每个worker进程都可以去accept这个socket。</p>
<p>一般来说，当一个连接进来后，所有在accept在这个socket上面的进程，都会收到通知，而只有一个进程可以accept这个连接，其它的则accept失败，这是所谓的惊群现象（<strong>惊群现象（thundering herd）就是当多个进程和线程在同时阻塞等待同一个事件时，如果这个事件发生，会唤醒所有的进程，但最终只可能有一个进程/线程对该事件进行处理，其他进程/线程会在失败后重新休眠，这种性能浪费就是惊群。</strong>）</p>
<p>当然，nginx也不会视而不见，所以nginx提供了一个accept_mutex这个东西，从名字上，我们可以看这是一个加在accept上的一把共享锁。有了这把锁之后，同一时刻，就只会有一个进程在accpet连接，这样就不会有惊群问题了。accept_mutex是一个可控选项，我们可以显示地关掉，默认是打开的。</p>
<p>当一个worker进程在accept这个连接之后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才断开连接，这样一个完整的请求就是这样的了。我们可以看到，一个请求，完全由worker进程来处理，而且只在一个worker进程中处理。</p>
</blockquote>
<p>通信</p>
<blockquote>
<p>linux与nginx之间通过信号进行通信。<br>master进程与worker进程通过sockpair（全双工通信）进行通信（channel）<br>worker进程间则是通过比较快速的共享内存进行通信。（mmap内存映射、通过文件、通过system v）</p>
</blockquote>
<h2 id="数据库MySQL"><a href="#数据库MySQL" class="headerlink" title="数据库MySQL"></a>数据库MySQL</h2><p>脏读、不可重复读、幻读</p>
<blockquote>
<p>脏读：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个被修改的数据，然后使用了这个数据。事务读取到了其他事务修改并且未提交的数据。</p>
<p>不可重复读：一个事务多次读取同一数据，该数据记录会改变。(其他事务进行了数据的修改)</p>
<p>幻读：多次读取，后面读取时数据记录数量发生改变。(其他事务进行了数据的插入、删除操作)</p>
</blockquote>
<p>四种隔离级别：</p>
<blockquote>
<p>读未提交、读已提交、可重复读、串行化。</p>
<p>读已提交解决脏读；可重复读解决脏读和不可重复读；串行化解决所有问题</p>
</blockquote>
<p>索引、索引类型(Hash、B+、全文索引)</p>
<blockquote>
<p>innodb、MyIsam——数据节点存储数据 or 存储数据地址(指针) </p>
<p>MyISAM索引文件和数据文件分开——非聚集索引、InnoDB则是索引文件和数据文件在一起——聚集索引。</p>
<p>主键索引、辅助索引。</p>
<p>最左前缀匹配。</p>
<p>索引类型：</p>
<p>1.普通索引；2.唯一索引；3.主键索引；4.组合索引；5.全文索引（innodb不支持）</p>
</blockquote>
<p>聚簇索引和非聚簇索引</p>
<blockquote>
<p>聚簇索引：索引和数据一起存放(innodb)，非聚簇索引：索引的叶节点是指针指向对应的数据，分开存放(myisam)</p>
<p>插入数据时，聚簇索引需要排序，非聚簇索引则需要维护索引到数据的指针。非聚集索引会存在索引和数据的两次io，更耗时。</p>
</blockquote>
<p>innodb四大特性</p>
<blockquote>
<p>插入缓存、两次写、自适应hash、提前读<a href="https://note.youdao.com/ynoteshare1/index.html?id=a6004953a0a7c80073ac74d8e76f1ebd&type=note" target="_blank" rel="noopener">click here</a> or <a href="https://www.jianshu.com/p/dcc0dc450a2c" target="_blank" rel="noopener">there</a></p>
</blockquote>
<p>innodb底层详解</p>
<blockquote>
<p>InnoDB的内存架构主要分为三大块，<strong>缓冲池</strong>（Buffer Pool）、<strong>重做缓冲池</strong>（Redo Log Buffer）和<strong>额外内存池</strong></p>
<p>缓冲池采用了<strong>LRU</strong>算法，但可能导致缓冲池污染。</p>
<p>mysql在写入记录前，会先记录到redo log，用于刷盘。</p>
<p>插入缓存：等数据达到某个阈值（例如50条）才批量的写入磁盘，降低io。</p>
<p>两次写：<strong>插入缓冲</strong>提高了MySQL的性能，而<strong>两次写</strong>则在此基础上提高了数据的可靠性。我们知道，当数据还在缓冲池中的时候，当机器宕机了，发生了<strong>写失效</strong>，有Redo Log来进行恢复。但是如果是在从缓冲池中将数据刷回磁盘的时候宕机了呢？这种情况叫做<strong>部分写失效</strong>，此时重做日志就无法解决问题。</p>
<p>在刷脏页时，并不是直接刷入磁盘，而是copy到内存中的Doublewrite Buffer中，然后再拷贝至磁盘共享表空间（你可以就理解为磁盘）中，每次写入1M，等copy完成后，再将Doublewrite Buffer中的页写入磁盘文件。有了两次写机制，即使在刷脏页时宕机了，在实例恢复的时候也可以从共享表空间中找到Doublewrite Buffer的页副本，直接将其覆盖原来的数据页即可。</p>
<p>自适应哈希索引：参考jit热点代码，对热点索引进行hash。</p>
<p>提前读：innodb中将64个页划分为一个extent，当一个extent中的页，被顺序读超过了多少个，比如50个，这个值是可以通过nnodb_read_ahead_threshold设置的，那么就会认为顺序读到下一个extent的可能性很大，会提前将下一个extent中的所有页都加载到buffer pool中，这叫线性预读</p>
</blockquote>
<p>间隙锁</p>
<blockquote>
<p>Innodb在<strong>可重复读</strong>提交下为了解决<strong>幻读</strong>问题时引入的锁机制。</p>
<p>针对范围查询，例如查询id为1-9之间的所有数据（前提，数据库中没有id为2 4 6的数据），但是范围锁就会将1-9的所有都锁上，如果此时想要插入一条id为2的数据，是无法插入的，会导致阻塞。</p>
<p>间隙锁可能导致死锁，间隙锁之间并不是互斥的。</p>
</blockquote>
<p>解决mysql读写效率</p>
<blockquote>
<p>sql优化、索引、缓存、主从复制+读写分离、垂直拆分（分布式）、水平拆分（解决主键问题）、分区</p>
</blockquote>
<p>MVCC原理</p>
<blockquote>
<p>多版本并发控制技术。保存数据的历史版本。可以通过比较版本号决定数据是否显示出来。读取数据的时候不需要加锁可以保证事务的隔离效果。</p>
<p>innodb：更新前建立undo log，根据各种策略读取时非阻塞就是MVCC，undo log中的行就是MVCC中的多版本。即：事务更新某记录时，先用排他锁锁定，然后copy一份记录到undo log然后让roll_ptr指向undo log，然后进行更新并填写事务编号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">解决读写之间阻塞的问题，通过 MVCC 可以让读写互相不阻塞，读不相互阻塞，写不阻塞读，这样可以提升数据并发处理能力。</span><br><span class="line">降低了死锁的概率，这个是因为 MVCC 采用了乐观锁的方式，读取数据时，不需要加锁，写操作，只需要锁定必要的行。</span><br><span class="line">解决了一致性读的问题，当我们朝向某个数据库在时间点的快照是，只能看到这个时间点之前事务提交更新的结果，不能看到时间点之后事务提交的更新结果。</span><br></pre></td></tr></table></figure>
<p><strong>InnoDB 的 MVCC 是如何实现的？</strong></p>
<p>InnoDB 是如何存储记录多个版本的？这些数据是 事务版本号，行记录中的隐藏列(row_id, tx_id, roll_ptr)和Undo Log。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">事务查询行记录：</span><br><span class="line">当前事务的 creator_trx_id 想要读取某个行记录，这个行记录ID的trx_id ，这样会有以下的情况：</span><br><span class="line">如果 trx_id &lt; 活跃的最小事务ID（up_limit_id）,也就是说这个行记录在这些活跃的事务创建前就已经提交了，那么这个行记录对当前事务是可见的。</span><br><span class="line">如果trx_id &gt; 活跃的最大事务ID（low_limit_id），这个说明行记录在这些活跃的事务之后才创建，说明这个行记录对当前事务是不可见的。</span><br><span class="line">如果 up_limit_id &lt; trx_id &lt;low_limit_id,说明该记录需要在 trx_ids 集合中，可能还处于活跃状态，因此我们需要在 trx_ids 集合中遍历，如果trx_id 存在于 trx_ids 集合中，证明这个事务 trx_id 还处于活跃状态，不可见，否则 ，trx_id 不存在于 trx_ids 集合中，说明事务trx_id 已经提交了，这行记录是可见的。</span><br><span class="line"></span><br><span class="line">如何查询一条记录</span><br><span class="line">1、获取事务自己的版本号，即事务ID</span><br><span class="line">2、获取 Read View</span><br><span class="line">3、查询得到的数据，然后 Read View 中的事务版本号进行比较。</span><br><span class="line">4、如果不符合 ReadView 规则， 那么就需要 UndoLog 中历史快照；</span><br><span class="line">5、最后返回符合规则的数据</span><br><span class="line">InnoDB 实现多版本控制 （MVCC）是通过 ReadView + UndoLog 实现的，UndoLog 保存了历史快照，ReadView 规则帮助判断当前版本的数据是否可见。</span><br></pre></td></tr></table></figure>

<p>innodb如何保证崩溃恢复能力</p>
<blockquote>
<p>两阶段日志提交</p>
</blockquote>
</blockquote>
<p>MVCC下的一些操作</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">增删查改</span><br><span class="line">在InnoDB中，给每行增加两个隐藏字段来实现MVCC，一个用来记录数据行的创建时间，另一个用来记录行的过期时间（删除时间）。在实际操作中，存储的并不是时间，而是事务的版本号，每开启一个新事务，事务的版本号就会递增。</span><br><span class="line">于是乎，默认的隔离级别（REPEATABLE READ）下，增删查改变成了这样：</span><br><span class="line"></span><br><span class="line">SELECT：读取创建版本小于或等于当前事务版本号，并且删除版本为空或大于当前事务版本号的记录。这样可以保证在读取之前记录是存在的。</span><br><span class="line">INSERT：将当前事务的版本号保存至行的创建版本号</span><br><span class="line">UPDATE：新插入一行，并以当前事务的版本号作为新行的创建版本号，同时将原记录行的删除版本号设置为当前事务版本号</span><br><span class="line">DELETE：将当前事务的版本号保存至行的删除版本号</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">快照读和当前读</span><br><span class="line">快照读：读取的是快照版本，也就是历史版本</span><br><span class="line">当前读：读取的是最新版本</span><br><span class="line">普通的SELECT就是快照读，而UPDATE、DELETE、INSERT、SELECT ...  LOCK IN SHARE MODE、SELECT ... FOR UPDATE是当前读。</span><br></pre></td></tr></table></figure>

</blockquote>
<p>read-view(一致性视图)</p>
<blockquote>
<p>未提交的事务id数组以及当前已经创建(不论是否提交)的最大事务id。(【未提交事务id】，max_id)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">当执行查询sql时会生成一致性视图read-view，它由执行查询时所有未提交事务id数组(数组里最小的id为min_id)和已创建的最大事务id (max_id)组成，查询的数据结果需要跟read-view做比对从而得到快照结果</span><br><span class="line">版本链比对规则:</span><br><span class="line">1.如果落在绿色部分( trx_id &lt; min_id )，表示这个版本是已提交的事务生成的，这个数据是可见的;</span><br><span class="line">2.如果落在红色部分( trx id &gt; max_id )，表示这个版本是由将来启动的事务生成的，是肯定不可见的;</span><br><span class="line">3.如果落在黄色部分(min_ id &lt;= trx_id &lt;= max_id)，那就包括两种情况</span><br><span class="line">	a.若row的trx_id在数组中，表示这个版本是由还没提交的事务生成的，不可见，当前自己的事务是可见的;</span><br><span class="line">	b.若row的trx_id不在数组中，表示这个版本是已经提交了的事务生成的，可见。</span><br><span class="line">对于删除的情况可以认为是update的特殊情况，会将版本链上最新的数据复制一份，然后将trx_id修改成删除操作的trx_id，同时在该条记录的头信（record header)里的(deleted_flag)标记位写上true，来表示当前记录已经被删除，在查间时按照上面的规则查到对应的记录如果delete flag标记位为true，意味着记录已被删除，则不返回数据。</span><br></pre></td></tr></table></figure>

<p>如果是可重复读的隔离级别，则MVCC中每个select记录使用的是之前select的read-view，即进行延用而非重新创建。（当一个session发起第一个查询时，此刻对应的全表的read-view已经确定了，之后的查询都会使用该read-view）</p>
<p>而如果是读已提交的隔离界别，则MVCC中每个select记录都会重新生成read-view。</p>
</blockquote>
<p>行锁和表锁(具体)</p>
<blockquote>
<p>行锁：锁定一行或者多行记录，<strong>行锁是基于索引加载的</strong>，可能死锁。<br>表锁：没有触发索引，则会锁表。<strong>表锁响应的是非索引字段，即全表扫描</strong>，不会死锁。</p>
</blockquote>
<p>如何实现的隔离级别</p>
<blockquote>
<p>读写锁 or MVCC。</p>
<p>事务看到的是自己查询时候的快照ReadView。</p>
</blockquote>
<p>回表查询</p>
<blockquote>
<p>第一遍定位主键值，再定位行记录，它的性能较扫一遍索引树更低。</p>
</blockquote>
<p>索引覆盖</p>
<blockquote>
<p>查询时不需要回表查询，直接通过索引就可以获取查询的结果数据，extra：using index代表索引覆盖</p>
</blockquote>
<p>mysql，数据查询慢怎么办</p>
<blockquote>
<p>慢查询抓取sql语句，然后用explain执行计划判断，建索引，B+树，为什么可以增快速度。</p>
</blockquote>
<p>explain</p>
<blockquote>
<p>id、select_type、table、partitions、type、possible_keys、key、key_len、ref、row、filtered、Extra</p>
</blockquote>
<p>分库、分表、分区</p>
<blockquote>
<p>就搞一个主库，挂多个从库，然后我们就单单只是写主库，然后主库会自动把数据给同步到从库上去。读从库。主从复制，binlog。</p>
<p>分库：垂直按功能模块切分、水平减少数据库压力、数据隔离、功能切分。</p>
<p>分表：数据冗余问题、热点数据等等。</p>
</blockquote>
<p>mysql主从复制原理</p>
<blockquote>
<p>①为何需要主从复制？</p>
<blockquote>
<p>并发量大时，需要读写分离，主库负责写，从库负责读，即使需要锁表，对读的性能也没有影响。<br>数据的预热。<br>降低单机IO压力。</p>
</blockquote>
<p>②主从复制原理(bin log)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">原理：</span><br><span class="line">	1)、在master机器上的操作：</span><br><span class="line">	当master上的数据发生变化时，该事件变化会按照顺序写入bin-log中。当slave链接到master的时候，master机器会为slave开启binlog dump线程。当master的binlog发生变化的时候，bin-log dump线程会通知slave，并将相应的binlog内容发送给slave。</span><br><span class="line">	2)、在slave机器上操作：</span><br><span class="line">	当主从同步开启的时候，slave上会创建两个线程：I\O线程。该线程连接到master机器，master机器上的binlog dump 线程会将binlog的内容发送给该I\O线程。该I/O线程接收到binlog内容后，再将内容写入到本地的relay log；sql线程。该线程读取到I/O线程写入的ralay log。并且根据relay log。并且根据relay log 的内容对slave数据库做相应的操作。</span><br><span class="line">	</span><br><span class="line">也就是说：</span><br><span class="line">    - 从库会生成两个线程,一个I/O线程,一个SQL线程;</span><br><span class="line">    - I/O线程会去请求主库的binlog,并将得到的binlog写到本地的relay-log(中继日志)文件中;</span><br><span class="line">    - 主库会生成一个log dump线程,用来给从库I/O线程传binlog;</span><br><span class="line">    - SQL线程,会读取relay log文件中的日志,并解析成sql语句逐一执行;</span><br></pre></td></tr></table></figure>

<p>③三种主要实现粒度</p>
<blockquote>
<p>详细的主从同步主要有三种形式：statement、row、mixed<br>1)、statement: 会将对数据库操作的sql语句写道binlog中<br>2)、row: 会将每一条数据的变化写道binlog中。<br>3)、mixed: statement与row的混合。Mysql决定何时写statement格式的binlog, 何时写row格式的binlog。</p>
</blockquote>
<p>④主从复制延迟问题</p>
<blockquote>
<p>原因：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1)、MySQL数据库主从同步延迟原理mysql主从同步原理：主库针对写操作，顺序写binlog，从库单线程去主库顺序读”写操作的binlog”，从库取到binlog在本地原样执行（随机写），来保证主从数据逻辑上一致。mysql的主从复制都是单线程的操作，主库对所有DDL和DML产生binlog，binlog是顺序写，所以效率很高，slave的Slave_IO_Running线程到主库取日志，效率比较高，下一步，问题来了，slave的Slave_SQL_Running线程将主库的DDL和DML操作在slave实施。DML和DDL的IO操作是随即的，不是顺序的，成本高很多，还可能可slave上的其他查询产生lock争用，由于Slave_SQL_Running也是单线程的，所以一个DDL卡主了，需要执行10分钟，那么所有之后的DDL会等待这个DDL执行完才会继续执行，这就导致了延时。有朋友会问：“主库上那个相同的DDL也需要执行10分，为什么slave会延时？”，答案是master可以并发，Slave_SQL_Running线程却不可以。</span><br><span class="line"></span><br><span class="line">2)、MySQL数据库主从同步延迟是怎么产生的？当主库的TPS并发较高时，产生的DDL数量超过slave一个sql线程所能承受的范围，那么延时就产生了，当然还有就是可能与slave的大型query语句产生了锁等待。首要原因：数据库在业务上读写压力太大，CPU计算负荷大，网卡负荷大，硬盘随机IO太高次要原因：读写binlog带来的性能影响，网络传输延迟。</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<p>①硬件方面；②禁用从库binlog；③分担压力等等</p>
</blockquote>
</blockquote>
<p>事务如何实现隔离性</p>
<blockquote>
<p>读写锁 or MVCC</p>
</blockquote>
<p>三大范式</p>
<blockquote>
<p>1NF：字段不可分<br>2NF：属性完全依赖于主键<br>3NF：属性不依赖于其它非主属性   属性直接依赖于主键<br>BCNF：无传递依赖</p>
</blockquote>
<p>事务特性</p>
<blockquote>
<p>ACID，原子性、一致性、隔离性、持久性</p>
<p>一致性：数据前后的完整性。</p>
</blockquote>
<p>sql很慢优化：</p>
<blockquote>
<p>索引、拆分表、大字段、减少函数运算、内存、cpu</p>
</blockquote>
<p>自增id用完</p>
<blockquote>
<p>id边界值使用后，越过此边界值插入数据会失败。主键冲突、无法插入。使用big int or 自己的主键</p>
</blockquote>
<p>mysql和redis数据一致性保证</p>
<blockquote>
</blockquote>
<p>索引下推</p>
<blockquote>
<p>即如果下图中<code>name</code>也有索引，则会将其过滤也放在底层进行过滤，进而增大效率。</p>
<p><img src="https://i.loli.net/2021/02/05/6zs9MQZ4KPrLpFc.png" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在不使用ICP的情况下，在使用非主键索引（又叫普通索引或者二级索引）进行查询时，存储引擎通过索引检索到数据，然后返回给MySQL服务器，服务器然后判断数据是否符合条件 。</span><br><span class="line">在使用ICP的情况下，如果存在某些被索引的列的判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器 。</span><br><span class="line">索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少MySQL服务器从存储引擎接收数据的次数。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>join和union区别</p>
<blockquote>
<p>join是通过on上面的条件进行的</p>
<p>union则是将两个结果集进行合并</p>
</blockquote>
<p>窗口函数(用于组内排名)</p>
<blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本语法</span></span><br><span class="line">&lt;窗口函数&gt; over (partition by &lt;用于分组的列名&gt; order by &lt;用于排序的列名&gt;)</span><br><span class="line"><span class="comment"># rank, dense_rank, row_number</span></span><br><span class="line"><span class="comment"># rank排名会间隔 如 1 2 2 4 5...</span></span><br><span class="line"><span class="comment"># 而dense_rank则不会间隔 如 1 2 2 3 4 5</span></span><br><span class="line"><span class="comment"># row_number则不考虑并列的情况</span></span><br></pre></td></tr></table></figure>

<p>&lt;窗口函数&gt;的位置，可以放以下两种函数：</p>
<p>1） 专用窗口函数，包括后面要讲到的rank, dense_rank, row_number等专用窗口函数。</p>
<p>2） 聚合函数，如sum. avg, count, max, min等</p>
<p>因为窗口函数是对where或者group by子句处理后的结果进行操作，所以<strong>窗口函数原则上只能写在select子句中</strong>。</p>
<p><strong>partition by用来对表分组</strong>，<strong>order by子句的功能是对分组后的结果进行排序(默认asc)</strong>。</p>
<p>partition by不会改变表的行数，而group by则会改变。</p>
<p>对于聚合函数，则会在分组内，按顺序进行。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select *,</span><br><span class="line">   sum(成绩) over (order by 学号) as current_sum,</span><br><span class="line">   avg(成绩) over (order by 学号) as current_avg,</span><br><span class="line">   count(成绩) over (order by 学号) as current_count,</span><br><span class="line">   max(成绩) over (order by 学号) as current_max,</span><br><span class="line">   min(成绩) over (order by 学号) as current_min</span><br><span class="line">from 班级表</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/03/14/xqXi9wM2LfDs3ok.png" alt="image.png"></p>
</blockquote>
<p>数据库分库分表主键处理</p>
<blockquote>
<p>①使用自增主键，适用于数据量大并发较小需要分表的情况。<br>②设置数据库 sequence 或者表自增字段步长。比如说，现在有 8 个服务节点，每个服务节点使用一个 sequence 功能来产生 ID，每个 sequence 的起始 ID 不同，并且依次递增，步长都是 8。方案简单，但是如果需要增加服务节点时，就较为麻烦。<br>③UUID，好处就是本地生成，不用基于数据库来了；不好之处就是，UUID 太长了、占用空间大，<strong>作为主键性能太差</strong>了，会导致索引效率低下<br>④snowflake 算法，把一个 64 位的 long 型的 id，1 个 bit 是不用的，用其中的 41 bit 作为毫秒数，用 10 bit 作为工作机器 id，12 bit 作为序列号。</p>
</blockquote>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>工厂模式、单例模式、原型模式、装饰器模式、代理模式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">工厂：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。</span><br><span class="line">单例：懒汉、饿汉、双重检验锁懒汉</span><br><span class="line"> public static Singleton getSingleton() &#123;  </span><br><span class="line">    if (singleton == null) &#123;  </span><br><span class="line">        synchronized (Singleton.class) &#123;  </span><br><span class="line">            if (singleton == null) &#123;  </span><br><span class="line">                singleton = new Singleton();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return singleton;  </span><br><span class="line">&#125;  </span><br><span class="line">原型模式：创建对象代价太大 采用实现Cloneable接口和重写clone方法</span><br><span class="line">装饰器模式：装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。</span><br><span class="line">代理模式：jdk代理和cglib代理</span><br></pre></td></tr></table></figure>

<h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>CAP</p>
<blockquote>
<ul>
<li>一致性(<strong>C</strong>onsistency)</li>
<li>可用性(<strong>A</strong>vailability)</li>
<li>分区容忍性(<strong>P</strong>artition tolerance)</li>
</ul>
</blockquote>
<p>BASE</p>
<blockquote>
<ul>
<li>Basically Availble –基本可用</li>
<li>Soft-state –软状态/柔性事务</li>
</ul>
<blockquote>
<p>“Soft state” 可以理解为”无连接”的, 而 “Hard state” 是”面向连接”的</p>
</blockquote>
<ul>
<li>Eventual Consistency –最终一致性</li>
</ul>
</blockquote>
<p>最终一致性（分布式事务）</p>
<blockquote>
<p>2PL，两阶段提交。</p>
<p>消息重试、补偿交易、事务消息、接口支持重入</p>
</blockquote>
<p>什么是可重入</p>
<blockquote>
</blockquote>
<h2 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h2><p>wc</p>
<blockquote>
<p>wc [-clw] 文件*</p>
<p>计算文件的行数 单词数 字节数</p>
<p>-c或–bytes或–chars 只显示Bytes数。-l或–lines 显示行数。-w或–words 只显示字数。</p>
<p>可以跟多个文件，则会都显示并进行汇总</p>
</blockquote>
<p>Linux查看内存, cpu的占有率的命令</p>
<blockquote>
<p>top</p>
</blockquote>
<p>netstat、find、cat、cp、mv、su、ftp（ftp+ip）</p>
<blockquote>
<p>netstat 命令用于显示网络状态。-a显示所有套接字和端口。例子：TCP    192.168.9.52:1299      60.210.8.160:https     CLOSE_WAIT</p>
<p>find命令格式：find path -xxx expression。将当前目录及其子目录下所有文件后缀为 <strong>.c</strong> 的文件列出来：find . -name “*.c”</p>
<p>把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：cat -n textfile1 &gt; textfile2 （-b和-n相似只是-b不会把空白行输出）</p>
</blockquote>
<p>chmod</p>
<blockquote>
<p>chmod [owner group others]<br>RWX——777</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 file</span><br></pre></td></tr></table></figure>
</blockquote>
<p>telnet</p>
<blockquote>
<p>telnet + ip登陆远程主机</p>
</blockquote>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>反转链表：递归、迭代</p>
<p>删除字符串中的空格，时间O(n)，空间O(1)</p>
<p>写一个程序判断机器是大端法还是小端法（什么是大端、什么是小端）</p>
<blockquote>
<p>小端法：低地址存放低位，高地址存放高位</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0x11223344</span>;</span><br><span class="line"><span class="keyword">char</span> *c = (<span class="keyword">char</span>*)(&amp;i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%x"</span>, *c); <span class="comment">// 0x44-小端 0x11-大端</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>很长的英文论文，统计出现最高频的k个单词。(hashmap + 堆)</p>
<p>一组无序的数，找出中位数。(快速选择，O(n))</p>
<p>熟悉的排序算法(归并、快排、冒泡、插入、选择) 从小到大</p>
<blockquote>
<p>插入排序：从第二个数开始，和前面的数进行比较，如果比前面的数小，则交换，直到没有比该数大的数。继续遍历下一个数。</p>
<p>选择排序：从当前遍历到的数开始遍历到结尾，找到最小的数，和当前数交换，直到遍历完数组。</p>
<p>冒泡排序：每一趟排序，将相邻的两个数进行比较，小的放在前面。重复len - 1趟，且每一趟都能确定len - 1 - i个数。</p>
<p>归并排序：分治 + 双指针。</p>
<p>快速排序：分治 + 选取枢纽。</p>
<p>稳定：插入、冒泡、归并</p>
<p>不稳定：选择、快排、堆排序</p>
</blockquote>
<p>10亿个数排序后打印，内存有限（拆分成小文件并排好序分别放入小文件，然后每个文件进行读取首数据然后关闭然后读取下一个文件，可以利用堆排序实现大文件的有序）</p>
<p>从100万个数中找出最大的前100个数（快速选择 or 维护最大堆）</p>
<p>java操作有500万数据的大表如何操作（多线程？分表？limit分页？）</p>
<p>两个线程交替打印1-100</p>
<p>分布锁？</p>
<p>下层层序序列的完全二叉树 打印前序遍历结果</p>
<p>找出一个字符串有多少回文字串，输出最大的</p>
<p>Leetcode 1438</p>
<p>最长上升子序列(需要输出子序列)</p>
<p>64匹马 8条赛道 找出跑的最快的4匹 最少需要几场比赛（11）</p>
<p>lru</p>
<p>高并发设计：</p>
<blockquote>
<p>拆分为服务、缓存、mq、分库分表、读写分离、分布式</p>
</blockquote>
<p>如果不用红黑树，怎么把hash后桶上的链表存入到磁盘空间内，要怎么设计 磁盘内的存储方式?</p>
<blockquote>
<p>桶上的链表再进行一次hash。<br>——————————<br>——————<br>————<br>———<br>—<br>👆这样划分磁盘的存储空间，使记录hash后的值时先在最大的那块记录，有冲突就往第二大的快记录。使最大的磁盘块能直接返回值，防止hash冲突。</p>
</blockquote>
<p>位运算实现加法</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">0 + 0 = 0 不进位</span><br><span class="line">1 + 0 = 1 不进位</span><br><span class="line">0 + 1 = 1 不进位</span><br><span class="line">1 + 1 = 0 进位1</span><br><span class="line">--------------</span><br><span class="line">加法本身：a ^ b</span><br><span class="line">进位：(a &amp; b) &lt;&lt; 1</span><br><span class="line">--------------</span><br><span class="line">结论：设a，b为两个二进制数，则a+b = a^b + (a&amp;b)&lt;&lt;1。</span><br><span class="line">证明：a^b是不考虑进位时加法结果。当二进制位同时为1时，才有进位，因此 (a&amp;b)&lt;&lt;1是进位产生的值，称为进位补偿。将两者相加便是完整加法结果。</span><br><span class="line">后续的加法通过递归即可</span><br><span class="line">public int add(int a, int b) &#123;</span><br><span class="line">    if (b == 0) return a; // 进位为0时退出递归</span><br><span class="line">    return add(a ^ b, (a &amp; b) &lt;&lt; 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>4亿个unsigned int型的数让你保存，然后给你一个数，判断它是否存在已经保存的数中。</p>
<blockquote>
<p>bitmap</p>
</blockquote>
<p>高考成绩查询高并发</p>
<blockquote>
<p>省份、成绩区间分库分表</p>
<p>redis预热数据</p>
<p>前端页面提前缓存CDN</p>
<p>nginx负载均衡</p>
<p>中间件</p>
</blockquote>
<p>三数之和</p>
<p>lc 678</p>
<p>lc 316(单调栈 + 贪心)</p>
<p>场景题：两堆大数，100亿个数和10亿个数，找交集</p>
<p>场景题：直播房间，一个大V发了一条消息，如何让上千万的粉丝收到这条消息，如果只是纯粹的广播会很耗资源</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/05/jvm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Bcutty Kmy">
      <meta itemprop="description" content="NO DEPENDENCE ONLY PRIDE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BBBBBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/05/jvm/" class="post-title-link" itemprop="url">JVM</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-03-05 19:06:50 / Modified: 19:07:58" itemprop="dateCreated datePublished" datetime="2021-03-05T19:06:50+08:00">2021-03-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
            <span id="/2021/03/05/jvm/" class="post-meta-item leancloud_visitors" data-flag-title="JVM" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2021/03/05/jvm/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/03/05/jvm/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h3 id="JVM的架构模型"><a href="#JVM的架构模型" class="headerlink" title="JVM的架构模型"></a>JVM的架构模型</h3><p>Java编译器输入的指令基本是一种<strong>基于栈的指令集架构</strong>，另外一种架构则是基于寄存器的指令集架构。</p>
<blockquote>
<p>栈：跨平台性、指令集小，但指令较多。执行性能比寄存器架构差一些。<br>寄存器：性能较好、指令少但是和硬件耦合性强，无法实现跨平台。</p>
</blockquote>
<h3 id="JVM的生命周期"><a href="#JVM的生命周期" class="headerlink" title="JVM的生命周期"></a>JVM的生命周期</h3><p>启动：通过引导类加载器(bootstrap class loader)创建一个初始类来完成的，该类由虚拟机具体实现指定。</p>
<p>执行：执行java程序。程序执行的时候就运行，程序结束的时候就停止。执行一个Java程序时，真实在执行的时候是一个进程。</p>
<p>退出：以下几种情况：①程序正常执行结束；②程序执行过程中出现异常或错误；③OS出现错误导致Java虚拟机进程终止；④某线程调用Runtime类或者System类的exit()方法或者Runtime类的halt()方法，且Java安全管理器也允许此次操作。⑤除此之外，JNI ( Java Native Interface)规范描述了用JNI Invocation API来加载或卸载Java虚拟机时，Java虚拟机的退出情况。</p>
<h3 id="JVM发展历程"><a href="#JVM发展历程" class="headerlink" title="JVM发展历程"></a>JVM发展历程</h3><p>Sun Classic VM：世界上第一款商用Java虚拟机，JDK 1.4时被完全淘汰。内部只提供解释器而没有JIT。</p>
<p>Exact VM：准确式内存管理，可以知道内存中某个位置的数据具体是什么类型。也已经能够编译器解释器混合工作和具备热点检测的功能。JDK 1.2时提供该虚拟机。</p>
<p>HotSpot VM：JDK 1.3时，HotSpot称为默认虚拟机。其名称即热点代码检测技术，通过计数器来找到热点代码触发即时编译或栈上替换。</p>
<blockquote>
<p>解释器——保证响应时间，编译器——保证执行性能。</p>
</blockquote>
<p>JRockit ：专注于服务器端应用，内部不包含解释器实现，全部靠JIT编译执行。是世界上最快的JVM。</p>
<p>J9：与HotSpot市场定位相似，在自家产品上性能很好。</p>
<h2 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h2><h3 id="内存结构概述"><a href="#内存结构概述" class="headerlink" title="内存结构概述"></a>内存结构概述</h3><p>见图</p>
<h3 id="类加载器和类加载过程"><a href="#类加载器和类加载过程" class="headerlink" title="类加载器和类加载过程"></a>类加载器和类加载过程</h3><ul>
<li>类加载器子系统负责从文件系统或者网络中加载class文件，class文件在文件开头有特定的文件标识。</li>
<li>ClassLoader只负责class文件的加载，至于它是否可以运行，则由ExecutionEngine决定。</li>
<li>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射)</li>
</ul>
<p>加载(Loading)：</p>
<blockquote>
<p>1．通过一个类的全限定名获取定义此类的二进制字节流<br>2．将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构<br>3．<font color="red">在内存中生成一个代表这个类的java.lang.Class对象</font>，作为方法区这个类的各种数据的访问入口</p>
<p>笔者理解：加载阶段内存中已经存在Class对象。</p>
</blockquote>
<p>补充: 加载.class文件的方式</p>
<blockquote>
<ul>
<li>从本地系统中直接加载</li>
<li>通过网络获取，典型场景: web Applet</li>
<li>从zip压缩包中读取，成为日后jar、war格式的基础</li>
<li>运行时计算生成，使用最多的是:动态代理技术</li>
<li>由其他文件生成，典型场景：JSP应用</li>
<li>从专有数据库中提取.class文件，比较少见</li>
<li>从加密文件中获取，典型的防class文件被反编译的保护措施</li>
</ul>
</blockquote>
<p>链接(Linking)：</p>
<blockquote>
<p>验证(Verify):</p>
<blockquote>
<ul>
<li>目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，<br>不会危害虚拟机自身安全。</li>
<li>主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</li>
</ul>
</blockquote>
<p>准备(Prepare):</p>
<blockquote>
<ul>
<li>为类变量分配内存并且设置该类变量的默认初始值，即零值。</li>
<li>这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式<br>初始化;</li>
<li>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。</li>
</ul>
<p>笔者理解：将所有类变量初始化为默认值。</p>
</blockquote>
<p>解析(Resolve) :</p>
<blockquote>
<ul>
<li>将常量池内的符号引用转换为直接引用的过程。</li>
<li>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。</li>
<li>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</li>
<li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的<br>CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等</li>
</ul>
</blockquote>
</blockquote>
<p>初始化(initialization)：</p>
<blockquote>
<ul>
<li>初始化阶段就是执行类构造器方法&lt;clinit&gt;()的过程。</li>
<li>此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。</li>
<li>构造器方法中指令按语句在源文件中出现的顺序执行。</li>
<li>&lt;clinit&gt;()不同于类的构造器。(关联：构造器是虚拟机视角下的&lt;init&gt;())若该类具有父类，JVM会保证子类的&lt;clinit&gt;()执行前，父类的&lt;clinit&gt;()己经执行完毕。</li>
<li>虚拟机必须保证一个类的&lt;clinit&gt;()方法在多线程下被同步加锁。</li>
</ul>
<p>笔者理解：clinit方法即赋值类的所有静态变量以及执行静态代码块。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        num = <span class="number">10</span>;</span><br><span class="line">        number = <span class="number">20</span>;</span><br><span class="line">        System.println.out(number); <span class="comment">// 报错 非法前向引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number = <span class="number">10</span>; </span><br><span class="line">    <span class="comment">// Linking的prepare阶段：number = 0 --&gt; initial: number = 20 --&gt; number = 10</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.println.out(number); <span class="comment">// 10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h3><p>JVM支持两种类型的类加载器，分别为引导类加载器(BootstrapClassLoader[由c、c++实现])和自定义类加载器(User-Defined classLoader） 。</p>
<p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。</p>
<p>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有4类，启动类加载器、扩展类加载器、系统类加载器、用户自定义加载器。且这里的四者之间的关系是包含关系。不是上层下层，也不是子父类的继承关系。</p>
<p>启动类加载器：</p>
<blockquote>
<p>这个类加载使用c/c++语言实现的，嵌套在JVM内部。</p>
<p>它用来加载Java的核心库（JAVA_HOME/jre/ lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类.</p>
<p>并不继承自java.lang.ClassLoader，没有父加载器。</p>
<p>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</p>
<p>出于安全考虑，Bootstrap启动类加载器只加载包名为java、 javax、sun等开头的类</p>
</blockquote>
<p>扩展类加载器（Extension classLoader)</p>
<blockquote>
<p>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</p>
<p>派生于classLoader类</p>
<p>父类加载器为启动类加载器</p>
<p>从java.ext.dirs系统属性所指定的目录加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录)下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</p>
</blockquote>
<p>应用程序类加载器（系统类加载器，AppclassLoader)</p>
<blockquote>
<p>java语言编写由sun.misc.Launcher$AppclassLoader实现</p>
<p>派生于classLoader类</p>
<p>父类加载器为扩展类加载器</p>
<p>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</p>
<p>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</p>
<p>通过ClassLoader.getSystemClassLoader()方法可以获取到该类加载器</p>
</blockquote>
<p>用户自定义类加载器</p>
<blockquote>
<p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。</p>
<p>为什么要自定义类加载器?</p>
<blockquote>
<p>隔离加载类(防止中间件和框架之间的冲突)</p>
<p>修改类加载的方式</p>
<p>扩展加载源</p>
<p>防止源码泄漏</p>
</blockquote>
<p>用户自定义类加载器实现步骤:</p>
<ul>
<li>开发人员可以通过继承抽象类java.lang.classLoader类的方式，实现自己的类加载器，以满足一些特殊的需求</li>
<li>在JDK1.2之前，在自定义类加载器时，总会去继承classLoader类并重写loadclass ()方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖loadclass ()方法，而是建议把自定义的类加载逻辑写在findclass()方法中</li>
<li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写findclass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li>
</ul>
</blockquote>
<h3 id="ClassLoader类"><a href="#ClassLoader类" class="headerlink" title="ClassLoader类"></a>ClassLoader类</h3><p>抽象类，其后所有类加载器都继承于该类(除了启动类加载器)。</p>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">getParent()</td>
<td align="center">返回该类加载器的超类加载器</td>
</tr>
<tr>
<td align="center">loadClass(String name)</td>
<td align="center">加载名称为name的类，返回结果为java.lang.Class类的实例</td>
</tr>
<tr>
<td align="center">findClass(String name)</td>
<td align="center">查找名称为name的类，返回结果为java.lang.Class类的实例</td>
</tr>
<tr>
<td align="center">findLoadedClass(String name)</td>
<td align="center">查找名称为name的已经被加载过的类，返回结果为java.lang.Class类的实例</td>
</tr>
<tr>
<td align="center">defineClass(String name, byte[] b, int off, int len)</td>
<td align="center">把字节数组b中的内容转换为一个Java类，返回结果为java.lang.Class类的实例</td>
</tr>
<tr>
<td align="center">resolveClass(Class&lt;?&gt; c)</td>
<td align="center">连接指定的一个Java类</td>
</tr>
</tbody></table>
<p>获取ClassLoader的途径</p>
<blockquote>
<p>获取当前类的类加载器：class.getClassLoader()</p>
<p>获取当前线程上下文的类加载器：Thread.currentThread().getContextClassLoader()</p>
<p>获取系统的类加载器：ClassLoader.getSystemClassLoader()</p>
<p>获取调用者的类加载器：DriverManager.getCallerClassLoader()</p>
</blockquote>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>Java虚拟机对class文件采用的是<font color="red">按需加载</font>的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是<font color="red">双亲委派模式</font>即把请求交由父类处理,它是一种任务委派模式。</p>
<p><font color="red">工作原理</font></p>
<blockquote>
<p>1)如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类豳加载器去执行;<br>2)如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器<br>3)如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</p>
</blockquote>
<p>双亲委派机制的优势</p>
<blockquote>
<p>避免类的重复加载</p>
<p>保护程序安全，防止核心API被随意篡改(java.lang.xxx是不允许自定义的)</p>
</blockquote>
<p>沙箱安全机制</p>
<blockquote>
<p>自定义java.lang.String类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件(rt.jar包中java\lang\String.class)，报错信息说没有main方法，就是因为加载的是rt.jar包中的String类。这样可以保证对java核心源代码的保护，这就是<strong>沙箱安全机制</strong>。</p>
</blockquote>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>在JVM中表示两个class对象是否为同一个类存在两个必要条件:</p>
<blockquote>
<p>类的完整类名必须一致，包括包名。<br>加载这个类的ClassLoader(指ClassLoader实例对象)必须相同。</p>
</blockquote>
<p>换句话说，在JVM中，即使这两个类对象(Class对象)来源同一个class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的。</p>
<p>对类加载器的引用</p>
<blockquote>
<p>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会<strong>将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</strong>。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。</p>
</blockquote>
<p>类的主动使用和被动使用</p>
<blockquote>
<p>主动使用，分为七种情况:</p>
<blockquote>
<p>创建类的实例<br>访问某个类或接口的静态变量，或者对该静态变量赋值<br>调用类的静态方法<br>反射（比如:Class.forName(“com.atguigu.Test”))<br>初始化一个类的子类<br>Java虚拟机启动时被标明为启动类的类<br>JDK 7 开始提供的动态语言支持:<br>java . lang.invoke.MethodHandle实例的解析结果<br>REF_getstatic、REF_putstatic、REF_invokestatic句柄对应的类没有初始化，则初始化</p>
</blockquote>
<p>除了以上七种情况，其他使用Java类的方式都被看作是对类的<strong>被动使用</strong>，都<strong>不会导致类的初始化</strong>。</p>
<p>即主动使用和被动使用的区别即是否会导致类的初始化(执行类构造器方法&lt;clinit&gt;())。</p>
</blockquote>
<h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><p>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。<strong>不同的JVM对于内存的划分方式和管理机制存在着部分差异</strong>。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。</p>
<p>线程私有：PC寄存器、栈、本地栈</p>
<p>线程间共享：堆、堆外内存(永久代、元空间、代码缓存)</p>
<p>每个JVM只有一个Runtime实例。即为运行时环境，相当于内存结构的中间的那个框框: 运行时环境。</p>
<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。</p>
<p>在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。</p>
<p>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法。</p>
<p>如果线程执行过程中发生异常退出，则java线程会直接退出，而本地线程则会根据当前是否全剩下守护线程决定jvm进程是否结束。</p>
<h3 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h3><p>JVM中的程序计数寄存器（Program counter Register)中，Register 的命名源于CPu的寄存器，寄存器存储指令相关的现场信息。CPu只有把数据装载到寄存器才能够运行。这里，并非是广义上所指的物理寄存器，或许将其翻译为pc计数器（或指令计数器）会更加贴切(也称为程序钩子)，并且也不容易引起一些不必要的误会。<strong>JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。</strong></p>
<p>作用:</p>
<blockquote>
<p>PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。然后由执行引擎读取下一条指令。</p>
</blockquote>
<p>它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。</p>
<p>在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</p>
<p>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址;或者，如果是在执行native方法，则是未指定值（undefined） 。</p>
<p>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
<p>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p>
<p>它是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p>
<h4 id="两个常见问题"><a href="#两个常见问题" class="headerlink" title="两个常见问题"></a>两个常见问题</h4><p>使用PC寄存器存储字节码指令地址有什么用呢？为什么使用PC寄存器记录当前线程的执行地址呢？</p>
<blockquote>
<p>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继维执行。<br>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。</p>
</blockquote>
<p>PC寄存器为何被设定为线程私有?</p>
<blockquote>
<p>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？<strong>为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器</strong>，这样一来各个线程之间便可以进行独立计算，从而不会出现相互千扰的情况。</p>
<p>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</p>
<p>这样必然导致经常中断或恢复，如何保证分毫无差呢﹖每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</p>
</blockquote>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p><font color="red">栈是运行时的单位，而堆是存储的单位。</font></p>
<blockquote>
<p>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。<br>堆解决的是数据存储的问题，即数据怎么放、放在哪儿。</p>
<p>例子–做菜：食材以及做菜的步骤 放在栈中；而具体的过程对菜的各种操作 放在堆中。</p>
</blockquote>
<p>Java虚拟机栈（Java virtual Machine stack)，早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧(Stack Frame)，对应着一次次的Java方法调用。<font color="red">是线程私有的</font>，生命周期和线程一致。</p>
<p>作用：主管Java程序的运行，它保存方法的局部变量(8种基本数据类型、对象的引用地址)、部分结果，并参与方法的调用和返回。</p>
<p>优点：</p>
<blockquote>
<p>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。<br>JVM直接对Java栈的操作只有两个:<br>    每个方法执行，伴随着进栈(入栈、压栈) &amp;&amp; 执行结束后的出栈工作<br>对于栈来说不存在垃圾回收问题</p>
</blockquote>
<p>栈中可能出现的异常</p>
<blockquote>
<p>Java虚拟机规范允许Java栈的大小是动态的或者是固定不变的。</p>
<p>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个StackOverflowError异常。</p>
<p>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法中请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈,那Java虚拟机将会抛出一个OutOfMemoryError异常。</p>
</blockquote>
<h4 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h4><ul>
<li><p>每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame)的格式存在。</p>
</li>
<li><p>在这个线程上正在执行的每个方法都各自对应一个栈帧(Stack Frame)。</p>
</li>
<li><p>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</p>
</li>
</ul>
<p>栈运行原理:</p>
<blockquote>
<p>JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循“先进后出”/“后进先出”原则。</p>
<p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为<strong>当前栈帧</strong>(current Frame)，与当前栈帧相对应的方法就是<strong>当前方法</strong>（CurrentMethod)，定义这个方法的类就是<strong>当前类</strong>(current class) 。</p>
<p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</p>
<p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</p>
<p>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。</p>
<p>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</p>
<p>Java方法有两种返回函数的方式，<strong>一种是正常的函数返回，使用return指令;另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</strong></p>
</blockquote>
<h4 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h4><p>每个栈帧中存储着：</p>
<blockquote>
<p>局部变量表<br>操作数栈(或表达式栈)<br>动态链接(或指向运行时常量池的方法引用)<br>方法返回地址(或方法正常退出或者异常退出的定义)<br>附加信息</p>
</blockquote>
<h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>局部变量表也被称之为局部变量数组或本地变量表</p>
<p>定义为一个<strong>数字数组</strong>，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型。</p>
<p>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题。</p>
<p><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。</p>
<p>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</p>
<p>局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后.随着方法栈帧的销毁，局部变量表也会随之销毁。</p>
<h5 id="关于slot的理解"><a href="#关于slot的理解" class="headerlink" title="关于slot的理解"></a>关于slot的理解</h5><p>参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束。</p>
<p>局部变量表，最基本的存储单元是slot（变量槽)</p>
<p>局部变量表中存放编译期可知的各种基本数据类型(8种)，引用类型(reference)，returnAddress类型的变量。</p>
<p>在局部变量表里，<strong>32位以内的类型只占用一个slot(包括returnAddress类型)，64位的类型(long和double)占用两个slot。</strong></p>
<blockquote>
<p>byte、short、char在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true。<br>long和double则占据两个slot。</p>
</blockquote>
<p>JVM会为局部变量表中的每一个slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</p>
<p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个slot上</p>
<p>如果需要访问局部变量表中一个64bit的局部变量值时，只需要<strong>使用前一个索引</strong>即可。(比如:访问long或double类型变量)</p>
<p>如果当前帧是由<strong>构造方法</strong>或者<strong>实例方法</strong>创建的，<strong>那么该对象引用this将会存放在index为0的slot处</strong>，其余的参数按照参数表顺序继续排列。</p>
<p>slot的重复利用</p>
<blockquote>
<p>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p>
</blockquote>
<p>局部变量和静态变量的对比</p>
<blockquote>
<p>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</p>
<p>我们知道类变量表有两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。</p>
<p>和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</p>
</blockquote>
<p>补充</p>
<blockquote>
<p>在栈帧中，方性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</p>
<p><font color="red">局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</font></p>
</blockquote>
<h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p>每一个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出(Last-In-First-Out)的操作数栈，也可以称之为表达式栈(Expression Stack) 。</p>
<p>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈(push)/出栈(pop) .</p>
<blockquote>
<p>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。 </p>
<p>比如: 执行复制、交换、求和等操作</p>
</blockquote>
<p>操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。</p>
<p>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。</p>
<p>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为max_stack的值。</p>
<p>栈中的任何一个元素都是可以任意的Java数据类型。</p>
<blockquote>
<p>32bit的类型占用一个栈单位深度<br>64bit的类型占用两个栈单位深度。</p>
</blockquote>
<p>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈(push)和出栈(pop)操作来完成一次数据访问。</p>
<p>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。</p>
<p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</p>
<p>另外，我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。</p>
<h5 id="栈顶缓存技术"><a href="#栈顶缓存技术" class="headerlink" title="栈顶缓存技术"></a>栈顶缓存技术</h5><p>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派(instruction dispatch）次数和内存读/写次数。</p>
<p>由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，<strong>将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。</strong></p>
<h4 id="动态链接-指向运行时常量池中的方法引用"><a href="#动态链接-指向运行时常量池中的方法引用" class="headerlink" title="动态链接(指向运行时常量池中的方法引用)"></a>动态链接(指向运行时常量池中的方法引用)</h4><p>帧数据区的概念：方法返回地址、动态链接和一些附加信息称为帧数据区</p>
<p><strong>每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用</strong>。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接( Dynamic Linking)。比如: invokedynamic指令</p>
<p>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用(symbolic Reference)保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。</p>
<h4 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h4><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关。</p>
<p>静态链接:</p>
<blockquote>
<p>当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。</p>
</blockquote>
<p>动态链接:</p>
<blockquote>
<p>如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。</p>
</blockquote>
<p>对应的方法的绑定机制为:早期绑定（Early Binding）和晚期绑定(Late Binding)。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</p>
<p>早期绑定:</p>
<blockquote>
<p>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</p>
</blockquote>
<p>晚期绑定:</p>
<blockquote>
<p>如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。</p>
</blockquote>
<p>随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</p>
<p>Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</p>
<p>非虚方法:</p>
<blockquote>
<p>如果方法在编译期就确定了具体的调用版本，这个版木在运行时是不可变的。这样的方法称为非虚方法。|</p>
<ul>
<li>静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。</li>
<li>其他方法称为虚方法。</li>
</ul>
</blockquote>
<p>虚拟机中提供了以下几条方法调用指令:</p>
<ul>
<li>普通调用指令:</li>
</ul>
<blockquote>
<p>invokestatic: 调用静态方法，解析阶段确定唯一方法版本</p>
<p>invokespecial: 调用&lt;init&gt;方法、私有及父类方法，解析阶段确定唯一方法版本</p>
<p>invokeviltual: 调用所有虚方法</p>
<p>invokeinterface: 调用接口方法</p>
</blockquote>
<ul>
<li>动态调用指令:</li>
</ul>
<blockquote>
<p>invokedynamic: 动态解析出需要调用的方法，然后执行</p>
</blockquote>
<p>前四条指令固化在虚拟机内部，方法的调用执行不可人为千预，而invokedynamic指令则支持由用户确定方法版本。<strong>其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。</strong></p>
<hr>
<p>JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现<strong>『动态类型语言』</strong>支持而做的一种改进。</p>
<p>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。</p>
<p>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。</p>
<p>动态类型语言和静态类型语言</p>
<blockquote>
<p>动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。</p>
<p>说的再直白一点就是，静态类型语言是判断变量自身的类型信息; 动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。</p>
</blockquote>
<p>Java 语言中方法重写的本质:</p>
<blockquote>
<p>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作 C。</p>
<p>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束;如果不通过，则返回java.lang.illegalAccessError异常。</p>
<p>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</p>
<p>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</p>
<p>illegalAccessError介绍:</p>
<p>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</p>
</blockquote>
<p>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，JVM采用在类的方法区建立一个虚方法表(virtual method table）(非虚方法不会出现在表中)来实现。使用索引表来代替查找。</p>
<p>每个类中都有一个<strong>虚方法表</strong>，表中存放着各个方法的实际入口。如果是重写父类的方法，则该方法入口则为本身，如果使用父类的方法，则方法入口为父类。</p>
<p>那么虚方法表什么时候被创建?</p>
<blockquote>
<p>虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。</p>
</blockquote>
<h4 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h4><p>存放调用该方法的pc寄存器的值。</p>
<p>一个方法的结束，有两种方式:</p>
<blockquote>
<p>正常执行完成<br>出现未处理的异常，非正常退出</p>
</blockquote>
<p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的PC计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</p>
<blockquote>
<p>一个方法在正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定。</p>
<p>在字节码指令中，返回指令包含ireturn (当返回值是boolean、byte、char、short和int类型时使用）、lreturn、 freturn、dreturn以及areturn，另外还有一个return指令供声明为void的方法、实例初始化方法、类和接口的初始化方法使用。</p>
</blockquote>
<p>在方法执行的过程中遇到了异常（Exception)，并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称<strong>异常完成出口</strong>。</p>
<p>方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码。</p>
<p><img src="https://i.loli.net/2021/02/17/NuiwLdIh7CYcTxb.png" alt="image.png"></p>
<p>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、<strong>将返回值压入调用者栈帧的操作数栈</strong>、设置Pc寄存器值等，让调用者方法继续执行下去。</p>
<p>正常完成出口和异常完成出口的区别在于: <strong>通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</strong></p>
<h4 id="一些附加信息"><a href="#一些附加信息" class="headerlink" title="一些附加信息"></a>一些附加信息</h4><p>无</p>
<h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><ul>
<li>举例栈溢出的情况？(StackOverFlowError)</li>
</ul>
<blockquote>
<p>递归，栈深度大于所分配</p>
</blockquote>
<ul>
<li>调整栈大小，就能保证不出现溢出吗?</li>
</ul>
<blockquote>
<p>不能，可以延迟</p>
</blockquote>
<ul>
<li>分配的栈内存越大越好吗?</li>
</ul>
<blockquote>
<p>不是，总内存是一定的</p>
</blockquote>
<ul>
<li>垃圾回收是否会涉及到虚拟机栈?</li>
</ul>
<blockquote>
<p>不会，但会出现OOM异常</p>
</blockquote>
<ul>
<li>方法中定义的局部变量是否线程安全?</li>
</ul>
<blockquote>
<p>具体问题具体分析。看是否关联到共享资源、是否将局部变量作为返回值进行返回了、是否作为参数。即是否在内部消亡。可判断是否安全。</p>
</blockquote>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><h4 id="本地方法接口"><a href="#本地方法接口" class="headerlink" title="本地方法接口"></a>本地方法接口</h4><p>简单地讲，一个Native Method就是一个Java调用非Java代码的接口。一个Native Method是这样一个Java方法:该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern “C”告知C++编译器去调用一个c的函数。</p>
<p>“A native method is a Java method whose implementation is provided by non-java code .”</p>
<p>在定义一个native method时，并不提供实现体（有些像定义一个Java interface) ，因为其实现体是由非java语言在外面实现的。</p>
<p>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序</p>
<p>为什么要使用Native Method ?</p>
<blockquote>
<p>Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</p>
<ul>
<li>与Java环境外交互:</li>
</ul>
<p>有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制:它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</p>
<ul>
<li>与操作系统交互:</li>
</ul>
<p>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用c写的。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</p>
<ul>
<li>sun’s Java</li>
</ul>
<p>sun的解释器是用c实现的，这使得它能像一些普通的c一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。例如:类java.lang.Thread的setPriority()方法是用Java实现的，但是它实现调用的是该类里的本地方法setPriority0()。这个本地方法是用c实现的，并被植入JVM内部，在windows 95的平台上，这个本地方法最终将调用win32 setPriority() API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库(external dynamic link library）提供，然后被JVM调用。</p>
<p>目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用socket通信，也可以使用web service等等，不多做介绍。</p>
</blockquote>
<hr>
<p>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。</p>
<p>本地方法栈，也是线程私有的。</p>
<p>允许被实现成固定或者是可动态扩展的内存大小。(在内存溢出方面是相同的)</p>
<blockquote>
<p>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个StackOverflowError异常。</p>
<p>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个OutOfMemoryError异常。</p>
</blockquote>
<p>本地方法是使用c语言实现的。</p>
<p>它的具体做法是Native Method Stack中登记native方法，在Execution Engine执行时加载本地方法库。</p>
<p>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</p>
<blockquote>
<p>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区。</p>
<p>它甚至可以直接使用本地处理器中的寄存器</p>
<p>直接从本地内存的堆中分配任意数量的内存。</p>
</blockquote>
<p>并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。</p>
<p>在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。</p>
<p>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。</p>
<blockquote>
<p>堆内存的大小是可以调节的。</p>
</blockquote>
<p>《Java虚拟机规范》规定，堆可以处于<strong>物理上不连续</strong>的内存空间中，但在<strong>逻辑上</strong>它应该被视为<strong>连续的</strong>。</p>
<p> 所有的线程共享Java堆，在这里还可以划分<strong>线程私有的缓冲区</strong>(Thread Local Allocation Buffer，TLAB)。</p>
<p>《Java虚拟机规范》中对Java堆的描述是: 所有的对象实例以及数组都应当在运行时分配在堆上。(The heap is the run-time data area from which memory for all class instances and arrays is allocated）</p>
<blockquote>
<p>我要说的是: “几乎”所有的对象实例都在这里分配内存。—从实际使用角度看的。</p>
</blockquote>
<p>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</p>
<p>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</p>
<p>堆，是GC (Garbage collection，垃圾收集器）执行垃圾回收的重点区域。</p>
<hr>
<p><strong>现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为:</strong></p>
<p>Java 7及之前堆内存逻辑上分为三部分：新生区+养老区+<strong>永久区</strong></p>
<blockquote>
<p>Young Generation Space    新生区    Young/New （又被划分为Eden区和Survivor区）</p>
<p>Tenure generation Space    养老区    old/Tenure</p>
<p>Permanent Space    永久区    Perm</p>
</blockquote>
<p>Java 8及之后堆内存逻辑上分为三部分：新生区+养老区+<strong>元空间</strong></p>
<blockquote>
<p>Young Generation Space    新生区    Young/New（又被划分为Eden区和Survivor区）</p>
<p>Tenure generation Apace    养老区    old/Tenure</p>
<p>Meta Space    元空间    Meta</p>
</blockquote>
<p>约定：新生区&lt;-&gt;新生代&lt;-&gt;年轻代    养老区&lt;-&gt;老年区&lt;-&gt;老年代    永久区&lt;-&gt;永久代</p>
<h4 id="设置堆内存大小和OOM"><a href="#设置堆内存大小和OOM" class="headerlink" title="设置堆内存大小和OOM"></a>设置堆内存大小和OOM</h4><p>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”-Xmx”和”-Xms”来进行设置。</p>
<blockquote>
<p>“-Xms”用于表示堆区的起始内存，等价于-XX:InitialHeapSize（-X是指jvm的运行参数，ms指memory start）</p>
<p>“-Xmx”则用于表示堆区的最大内存，等价于-XX:MaxHeapSize</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;查看设置的参数</span><br><span class="line">1、jps / jstat -gc 进程号</span><br><span class="line">2、-XX:+PrintGCDetails (需要程序执行完以后)</span><br></pre></td></tr></table></figure>

<p>注意：设置的值和实际通过Runtime实例获取的值可能存在差异，因为幸存者区S0和S1区只会有一个工作，所以有一个在计算时不会计算。</p>
</blockquote>
<p>一旦堆区中的内存大小超过“-Xmx”所指定的最大内存时，将会抛出OutOfMemoryError异常。</p>
<p>通常会将-Xms和-Xmx两个参数配置相同的值，其目的是为了能够在<strong>java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小</strong>，从而提高性能。</p>
<p>默认情况下，初始内存大小：物理电脑内存大小 / 64；最大内存大小：物理电脑内存大小 / 4</p>
<h4 id="年轻代和老年代"><a href="#年轻代和老年代" class="headerlink" title="年轻代和老年代"></a>年轻代和老年代</h4><p>存储在JVM中的Java对象可以被划分为两类:</p>
<blockquote>
<p>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速。</p>
<p>另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致。</p>
</blockquote>
<p>Java堆区进一步细分的话，可以划分为年轻代(YoungGen）和老年代（OldGen)</p>
<p>其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间(有时也叫做from区、to区）。</p>
<p>配置新生代与老年代在堆结构的占比：</p>
<blockquote>
<p>默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3</p>
<p>可以修改-XX:NewRatio=4，表示新生代占老年代占4，新生代占整个堆的1/5</p>
</blockquote>
<p>在HotSpot中，Eden空间和另外两个Survivor空间缺省所占的比例是8:1:1（但可能默认值并非为8）</p>
<blockquote>
<p>当然开发人员可以通过选项”-XX:SurvivorRatio”调整这个空间比例。比如-XX:SurvivorRatio=8</p>
<p><strong>几乎所有</strong>的Java对象都是在Eden区被new出来的。</p>
<p>绝大部分的Java对象的销毁都在新生代进行了。（IBM公司的专门研究表明，新生代中80%的对象都是”朝生夕死”的）</p>
<p>可以使用选项”-Xmn”设置新生代最大内存大小。（这个参数一般使用默认值就可以了，且该参数优先级比XX:NewRatio优先级更高）</p>
</blockquote>
<h4 id="对象分配过程"><a href="#对象分配过程" class="headerlink" title="对象分配过程"></a>对象分配过程</h4><p>为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p>
<p>①new的对象先放伊甸园区。此区有大小限制。<br>②当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收(Minor GC/Young GC)，将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区<br>③然后将伊甸园中的剩余对象移动到幸存者0区。<br>④如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。<br>⑤如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。<br>⑥啥时候能去养老区呢？可以设置次数。默认是15次。</p>
<blockquote>
<p>可以设置参数:-XX:MaxTenuringThreshold=&lt;N&gt;进行设置。</p>
<p>注意：在Eden区满时，YGC不仅会对Eden区进行GC，还会对对应的幸存者区进行GC。同时幸存者区满时，并不会触发YGC，即幸存者区是被动进行垃圾回收的。<br>同时，如果幸存者区中的对象还未达到阈值15就已经装不下了，则其中的一些”老”对象会直接进入老年区。</p>
</blockquote>
<p>总结:</p>
<blockquote>
<p>针对幸存者s0、s1区的总结：复制之后有交换，谁空谁是to。</p>
<p>关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不在永久区 / 元空间收集。</p>
</blockquote>
<img src="https://i.loli.net/2021/02/18/Pf6Mkxzy1YAluLB.png" alt="对象分配.png" style="zoom:50%;">

<h4 id="Minor-GC、Full-GC、Major-GC"><a href="#Minor-GC、Full-GC、Major-GC" class="headerlink" title="Minor GC、Full GC、Major GC"></a>Minor GC、Full GC、Major GC</h4><p>JVM在进行Gc时，并非每次都对上面三个内存(新生代、老年代、方法区)区域一起回收的，大部分时候回收的都是指新生代。</p>
<p>针对HotSpot VM的实现，它里面的GC按照回收区域又分为两大种类型:一种是部分收集(Partial GC)，一种是整堆收集（Full GC)</p>
<p>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为:</p>
<blockquote>
<p>新生代收集(Minor GC / Young GC)：只是新生代的垃圾收集</p>
<p>老年代收集(Major GC / Old GC)：只是老年代的垃圾收集。</p>
<blockquote>
<p>目前，只有<strong>CMS GC</strong>会有单独收集老年代的行为。<br><font color="red">注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</font></p>
</blockquote>
<p>混合收集（Mixed GC)：收集整个新生代以及部分老年代的垃圾收集。</p>
<blockquote>
<p>目前，只有<strong>G1 GC</strong>会有这种行为</p>
</blockquote>
</blockquote>
<p>整堆收集(Full GC)：收集整个java堆和<strong>方法区</strong>的垃圾收集。</p>
<hr>
<p>年轻代GC(Minor GC)触发机制：</p>
<blockquote>
<p>当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden区满，Survivor区满不会引发GC。(每次Minor GC会清理年轻代的内存。)</p>
<p>因为Java 对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</p>
<p>Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行。</p>
</blockquote>
<p>老年代GC (Major GC/Full GC)触发机制:</p>
<blockquote>
<p>指发生在老年代的GC，对象从老年代消失时，我们说“Major GC”或“Full GC”发生了。</p>
<p>出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。</p>
<blockquote>
<p>也就是在老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足，则触发Major GC。</p>
</blockquote>
<p>Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。<br>如果Major GC后，内存还不足，就报OOM了。</p>
</blockquote>
<p>触发Full GC执行的情况有如下五种:</p>
<blockquote>
<p>①调用System.gc()时，系统建议执行Full GC，但是不必然执行<br>②老年代空间不足<br>③方法区空间不足<br>④通过Minor GC后进入老年代的平均大小大于老年代的可用内存<br>⑤由Eden区、Survivor space（From Space）区向Survivor space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</p>
<p>说明: <font color="red">full gc是开发或调优中尽量要避免的。这样暂时时间会短一些。</font></p>
</blockquote>
<h4 id="堆空间分代思想"><a href="#堆空间分代思想" class="headerlink" title="堆空间分代思想"></a>堆空间分代思想</h4><p>为什么需要把Java堆分代?不分代就不能正常工作了吗?</p>
<blockquote>
<p>经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。</p>
<p>新生代: 有Eden、两块大小相同的survivor (又称为from/to，s0/s1)构成，to总为空。<br>老年代: 存放新生代中经历多次Gc仍然存活的对象。</p>
</blockquote>
<p>为什么需要把Java堆分代?不分代就不能正常工作了吗?</p>
<blockquote>
<p>其实不分代完全可以，分代的唯一理由就是优化<strong>GC</strong>性能。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用,这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收,这样就会腾出很大的空间出来。</p>
</blockquote>
<h4 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h4><p>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1 。对象在Survivor区中每熬过一次Minor GC ,年龄就增加岁，当它的年龄增加到一定程度（默认为15 岁，其实每个JVM、每个GC都有所不同)时，就会被晋升到老年代中。</p>
<p>针对不同年龄段的对象分配原则如下所示:</p>
<ul>
<li><p>优先分配到Eden</p>
</li>
<li><p>大对象直接分配到老年代</p>
<blockquote>
<p>尽量避免程序中出现过多的大对象</p>
</blockquote>
</li>
<li><p>长期存活的对象分配到老年代</p>
</li>
<li><p>动态对象年龄判断</p>
<blockquote>
<p>如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</p>
</blockquote>
</li>
<li><p>空间分配担保</p>
<blockquote>
<p>-xx: HandlePromotionFailure</p>
</blockquote>
</li>
</ul>
<h4 id="TLAB（Thread-Local-Allocation-Buffer）"><a href="#TLAB（Thread-Local-Allocation-Buffer）" class="headerlink" title="TLAB（Thread Local Allocation Buffer）"></a>TLAB（Thread Local Allocation Buffer）</h4><p>为了避免多个线程访问同一地址。</p>
<p>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。</p>
<p>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为<strong>快速分配策略</strong>。</p>
<p>据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。</p>
<p>TLAB简单说明：</p>
<blockquote>
<p>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是<font color="red">将TLAB作为内存分配的首选</font>。</p>
<p>在程序中，开发人员可以通过选项“-XX:UseTLAB”设置是否开启TLAB空间。</p>
<p>默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然我们可以通过选项“-XX:TLABWasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小。</p>
<p>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过<strong>使用加锁机制</strong>确保数据操作的原子性，从而直接在Eden空间中分配内存。</p>
</blockquote>
<h4 id="堆空间常用参数设置"><a href="#堆空间常用参数设置" class="headerlink" title="堆空间常用参数设置"></a>堆空间常用参数设置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintFlagsInitial: 查看所有的参数的默认初始值</span><br><span class="line">-XX:+PrintFlagsFinal: 查看所有的参数的最终值(可能会存在修改，不再是初始值)</span><br><span class="line">	具体查看某个参数的指令: jps查看进程号 -&gt; jinfo -flag SurvivalRatio 进程号</span><br><span class="line">-Xms: 初始堆空间内存(默认为物理内存的1/64)</span><br><span class="line">-Xmx: 最大堆空间内存(默认为物理内存的1/4)</span><br><span class="line">-Xmn: 设置新生代的大小。(初始值及最大值)</span><br><span class="line">-Xx:NewRatio: 配置新生代与老年代在堆结构的占比</span><br><span class="line">-Xx:SurvivorRatio: 设置新生代中Eden和s0/s1空间的比例</span><br><span class="line">-XX:MaxTenuringThreshold: 设置新生代垃圾的最大年龄</span><br><span class="line">-XX:+PrintGCDetails: 输出详细的GC处理日志</span><br><span class="line">	* 打印gc简要信息:1) -XX:+PrintGC 2)-verbose:gc</span><br><span class="line">-Xx:HandlePromotionFailure: 是否设置空间分配担保</span><br></pre></td></tr></table></figure>

<p>在发生Minor GC之前，虚拟机会检查老年代最大可用的<strong>连续空间</strong>是否大于新生代所有对象的总空间。</p>
<blockquote>
<p>如果大于，则此次Minor GC是安全的</p>
<p>如果小于，则虚拟机会查看-XX:HandlePromotionFailure设置值是否允许担保失败。如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于<strong>历次晋升到老年代的对象的平均大小</strong>。</p>
<ul>
<li>如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的;</li>
<li>如果小于，则改为进行一次Full Gc。</li>
</ul>
<p>如果HandlePromotionFailure=false，则改为进行一次Full GC.</p>
</blockquote>
<p>在JDK6 Update24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6 Update24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC.</p>
<h4 id="堆是对象存储的唯一选择吗？"><a href="#堆是对象存储的唯一选择吗？" class="headerlink" title="堆是对象存储的唯一选择吗？"></a>堆是对象存储的唯一选择吗？</h4><p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过<strong>逃逸分析(Escape Analysis)</strong>后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p>
<p>此外，前面提到的基于OpenJDK深度定制的TaoBaoVM，其中创新的GCIH (GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</p>
<p>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</p>
<p>通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p>
<p>逃逸分析的基本行为就是分析对象动态作用域:</p>
<blockquote>
<p>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。<br>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</p>
</blockquote>
<h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><p>使用逃逸分析,编译器可以对代码做如下优化:</p>
<p>一、栈上分配。将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。</p>
<blockquote>
<p>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</p>
<p>常见的逃逸的场景</p>
<blockquote>
<p>在逃逸分析中，已经说明了。分别是给成员变量赋值、方法返回值、实例引用传涕。</p>
</blockquote>
</blockquote>
<p>二、同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</p>
<blockquote>
<p>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</p>
<p>在动态编译同步块的时候，JIT编译器可以<strong>借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问</strong>而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。</p>
</blockquote>
<p>三、分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分(或全部）可以不存储在内存，而是存储在CPU寄存器中。</p>
<blockquote>
<p>标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</p>
<p>相对的，那些还可以分解的数据叫做聚合量(Aggregate), Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p>
<p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是<strong>标量替换</strong>。</p>
</blockquote>
<p><font color="red">但是栈上分配只是理论可行，hotspot虚拟机并没有实际应用，而能看到效果的原因是标量替换产生的效果。所以，还是可以认为，对象实例都是分配在堆空间中的。</font></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</p>
<p>老年代放置长生命周期的对象，通常都是从Survivor区域筛选拷贝过来的Java对象。当然，也有特殊情况，我们知道普通的对象会被分配在TLAB上:如果对象较大，JVM会试图直接分配在Eden其他位置上;如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代</p>
<p>当Gc只发生在年轻代中，回收年轻代对象的行为被称为Minor GC。当GC发生在老年代时则被称为Major GC或者Full GC。一般的，Minor GC的发生频率要比Major GC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区看作是一块独立于Java堆的内存空间。</p>
<p><img src="https://i.loli.net/2021/02/22/XkhOpQFZ5VGNyKg.png" alt="image.png"></p>
<p>且对于栈内存储的对象的referrence，指向堆中的对象实例，而堆中的对象实例中还存在对象类型的指针，而该指针则指向方法区。</p>
<p>方法区(Method Area)与Java堆一样，是各个线程共享的内存区域。</p>
<p>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。</p>
<p>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</p>
<p>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误: java.lang.outOfMemoryError: <strong>PermGen space</strong>或者java.lang.outofMemoryError: <strong>Metaspace</strong></p>
<p>关闭JVM就会释放这个区域的内存。</p>
<h4 id="设置方法区大小"><a href="#设置方法区大小" class="headerlink" title="设置方法区大小"></a>设置方法区大小</h4><p>方法区的大小不必是固定的，jvm可以根据应用的需要动态调整。</p>
<p>jdk7及以前:</p>
<blockquote>
<p>通过-XX:PermSize来设置永久代初始分配空间。默认值是20.75M</p>
<p>-XX:MaxPermsize来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M</p>
<p>当JVM加载的类信息容量超过了这个值，会报异常outofMemoryError: PermGen space 。</p>
</blockquote>
<p>jdk8及以后:</p>
<blockquote>
<p>元数据区大小可以使用参数-XX:MetaspaceSize和-XX:MaxMetaspaceSize指定，替代上述原有的两个参数。</p>
<p>默认值依赖于平台。windows下，-XX:Metaspacesize是21M，-XX:MaxMetaspacesize的值是-1，即没有限制。</p>
<p>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError: Metaspace </p>
<p>-XX:MetaspaceSize:设置初始的元空间大小。对于一个64位的服务器端JVM来说, 其默认的-XX:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类(即这些类对应的类加载器不再存活),然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspacesize时，适当提高该值。如果释放空间过多，则适当降低该值。</p>
<p>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC，建议将-XC: Metaspacesize设置为一个相对较高的值。</p>
</blockquote>
<p>如何解决OOM</p>
<blockquote>
<p>1、要解决OOM异常或heap space的异常，一般的手段是首先通过内存映像分析工具(如Eclipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（MemoryLeak）还是内存溢出(Memory Overflow)。</p>
<p>2、如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置。</p>
<p>3、如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数(-Xmx与-Xms)，与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</p>
</blockquote>
<h4 id="方法区内部结构"><a href="#方法区内部结构" class="headerlink" title="方法区内部结构"></a>方法区内部结构</h4><p>它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</p>
<p>类型信息：</p>
<blockquote>
<p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation)，JVM必须在方法区中存储以下类型信息:<br>①这个类型的完整有效名称(全名=包名.类名)<br>②这个类型直接父类的完整有效名(对于interface或是java.lang.0bject，都没有父类)<br>③这个类型的修饰符(public,abstract, final的某个子集)<br>④这个类型直接接口的一个有序列表</p>
</blockquote>
<p>域(Field)信息：</p>
<blockquote>
<p>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</p>
<p>域的相关信息包括：域名称、域类型、域修饰符(public, private,protected,static,final, volatile, transient的某个子集)</p>
</blockquote>
<p>方法(Method)信息：</p>
<blockquote>
<p>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序:</p>
<ul>
<li>方法名称</li>
<li>方法的返回类型(或void)</li>
<li>方法参数的数量和类型(按顺序)</li>
<li>方法的修饰符(public, private,protected,static, final, synchronized, native,abstract的一个子集)</li>
<li>方法的字节码、bytecodes操作数栈、局部变量表及大小(abstract和native方法除外）</li>
<li>异常表(abstract和native方法除外)<br>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li>
</ul>
</blockquote>
<p>补充说明:全局常量: <code>static final</code></p>
<blockquote>
<p>被声明为final的类变量的处理方法则不同，每个全局常量在<strong>编译</strong>的时候就会被分配了。</p>
</blockquote>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>方法区包含了<strong>运行时常量池</strong>，而字节码文件又包含了<strong>常量池</strong>。常量池包含了各种字面量和对类型、域、方法的符号引用。</p>
<p>为什么需要常量池?</p>
<blockquote>
<p>一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，需要换另一种方式，也就是可以存到<strong>常量池</strong>。同时字节码文件中也存储了该常量池。在真正进行加载执行的时候，才会进行动态链接，加载真正的引用。</p>
</blockquote>
<p>小结:</p>
<blockquote>
<p>常量池，可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。</p>
</blockquote>
<p>运行时常量池（Runtime constant Poo1）是方法区的一部分。</p>
<p>常量池表（Constant Pool Table）是class文件的一部分，用于存放编译期生成的各种字面量与符号引用，<strong>这部分内容将在类加载后存放到方法区的运行时常量池中。</strong></p>
<p>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</p>
<p>JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。</p>
<p>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为<strong>真实地址</strong>。</p>
<blockquote>
<p>运行时常量池，相对于class文件常量池的另一重要特征是：具备<strong>动态性</strong>。</p>
<p>比如：一些方法 String.intern()等等</p>
</blockquote>
<p>运行时常量池类似于传统编程语言中的符号表(symbol table)，但是它所包含的数据却比符号表要更加丰富一些。</p>
<p>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛OutOfMemoryError异常。</p>
<p>注意：(方法区实例演示过程中)</p>
<blockquote>
<p>在调用实例方法时，先入栈对象实例，然后入栈参数，然后invoke…..调用方法。</p>
</blockquote>
<h4 id="方法区演变细节"><a href="#方法区演变细节" class="headerlink" title="方法区演变细节"></a>方法区演变细节</h4><p>1、首先明确：只有HotSpot才有永久代。BEA、JRockit、IBM9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一。</p>
<p>2、Hotspot中方法区的变化:</p>
<table>
<thead>
<tr>
<th align="center">jdk版本</th>
<th align="center">方法区情况</th>
</tr>
</thead>
<tbody><tr>
<td align="center">jdk1.6及之前</td>
<td align="center">有永久代(permanent generation)，<strong>静态变量存放在永久代上</strong></td>
</tr>
<tr>
<td align="center">jdk1.7</td>
<td align="center">有永久代，但已经逐步“去永久代”，<strong>字符串常量池、静态变量移除，保存在堆中</strong></td>
</tr>
<tr>
<td align="center">jdk1.8及之后</td>
<td align="center">无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但<strong>字符串常量池、静态变量仍在堆</strong></td>
</tr>
</tbody></table>
<p>改动的原因：</p>
<p>①为永久代设置多大空间是很难确定（如web工程，需要动态加载的类很多，容易出现OOM）<br>②对永久代进行调优很困难</p>
<p>有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK 11时期的ZGC收集器就不支持类卸载)。</p>
<p>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前Sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的Hotspot虚拟机对此区域未完全回收而导致内存泄漏。方法区的垃圾收集主要回收两部分内容: 常量池中废弃的常量和不再使用的类型。</p>
<blockquote>
<p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“还再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件:</p>
<p>①该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。<br>②加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、SP的重加载等，否则通常是很难达成的。<br>③该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>
<p>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收,HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class以及-XX:+Traceclass-Loading、-XX:+TraceClassUnLoading查看类加载和卸载信息·在大量使用反射、动态代理、cGLib等字节码框架，动态生成JSP以及osGi这类频繁</p>
<p>自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</p>
</blockquote>
<p>StringTable为什么要调整?</p>
<blockquote>
<p>jdk7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在full gc的时候才会触发。而full gc是老年代的空间不足、永久代不足时才会触发。<br>这就导致StringTable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p>
</blockquote>
<p>需要注意：</p>
<blockquote>
<p>静态引用所对应的<strong>对象实体</strong>始终是存在于堆中，无论是jdk6还是jdk8，只要是对象实例，都在堆中分配。</p>
</blockquote>
<h4 id="方法区的垃圾收集"><a href="#方法区的垃圾收集" class="headerlink" title="方法区的垃圾收集"></a>方法区的垃圾收集</h4><p>有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在(如JDK 11时期的zGC收集器就不支持类卸载)。</p>
<p>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</p>
<p><strong>方法区的垃圾收集主要回收两部分内容:常量池中废弃的常量和不再使用的类型。</strong></p>
<p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量:</p>
<blockquote>
<p>1、类和接口的全限定名</p>
<p>2、字段的名称和描述符</p>
<p>3、方法的名称和描述符</p>
</blockquote>
<p>HotSpot虚拟机对常量池的回收策略是很明确的，<strong>只要常量池中的常量没有被任何地方引用，就可以被回收。</strong><br>回收废弃常量与回收Java堆中的对象非常类似。</p>
<p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件:</p>
<blockquote>
<p>①该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。<br>②加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。<br>③该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>
</blockquote>
<p>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收,HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class以及-XX:+TraceClass-Loading、-XX:+TraceClassUnLoading查看类加载和卸载信息</p>
<p>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><img src="/.com//C:%5CUsers%5C34879%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210225184559735.png" alt="image-20210225184559735"></p>
<h2 id="对象相关"><a href="#对象相关" class="headerlink" title="对象相关"></a>对象相关</h2><h4 id="对象的实例化"><a href="#对象的实例化" class="headerlink" title="对象的实例化"></a>对象的实例化</h4><p>创建对象的方式：</p>
<blockquote>
<p>new：①常用的，直接new对象 ②构造器私有，调用Xxx的静态方法获取 ③XxxBuilder/XxxFactory工厂模式</p>
<p>Class.newInstance()：反射，只能调用空参构造器，且权限要求public</p>
<p>Constructor.newInstance(Xxx)：反射，可以调用空参、带参的构造器，对权限无要求</p>
<p>clone()：不调用任何构造器，当前类需要实现Cloneable接口，重写clone()方法</p>
<p>反序列化：从文件中、网络中获取一个对象的二进制流</p>
<p>第三方库Objenesis</p>
</blockquote>
<p>创建对象的步骤</p>
<blockquote>
<p>①判断对象对应的类是否加载、链接、初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。(即判断类元信息是否存在)。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader+包名+类名为Key进行查找对应的.class文件。如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class类对象</span><br></pre></td></tr></table></figure>

<p>②为对象分配内存（计算对象占用空间大小，如果实例成员变量是引用类型，只占4个字节）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果内存规整 -&gt; 直接在空闲空间中放入对象，并将指针后移(指针碰撞)</span><br><span class="line">如果不规整 -&gt; 即已经使用的和没有使用的内存的互相交错，虚拟机将采用空闲列表法，即虚拟机维护了一个列表，记录那些内存可用，在分配时从列表中找到一块空间划分给对象，并更新列表。</span><br></pre></td></tr></table></figure>

<p>③处理并发安全问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">采用CAS配上失败重试保证更新的原子性</span><br><span class="line">为每个线程预先分配一块TLAB</span><br></pre></td></tr></table></figure>

<p>④初始化分配到的空间（对象属性默认初始化）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所有非静态属性设置默认值，保证对象实例字段在未赋值时可以直接使用。</span><br></pre></td></tr></table></figure>

<p>⑤设置对象的对象头</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">记录类信息、HashCode、GC信息、锁信息等数据</span><br></pre></td></tr></table></figure>

<p>⑥执行init方法进行初始化（显式初始化）</p>
</blockquote>
<h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><p>对象头</p>
<blockquote>
<p>①运行时元数据(Mark Word)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">包含：</span><br><span class="line">哈希值、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳</span><br></pre></td></tr></table></figure>

<p>②类型指针——指向方法区中的类元数据，确定该对象所属的类型(如obj.getClass()方法)</p>
<p>③如果是数组，还需记录数组长度</p>
</blockquote>
<p>实例数据</p>
<blockquote>
<p>是对象真正存储的有效信息，包括字段、以及父类继承的字段等等</p>
<p>存放规则</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">相同宽度的字段存放在一起</span><br><span class="line">父类定义的变量会放在子类之前</span><br><span class="line">如果CompactFields参数为true(默认为true)：子类的窄变量可能插入到父类变量的空隙</span><br></pre></td></tr></table></figure>
</blockquote>
<p>对齐填充</p>
<blockquote>
<p>非必须的，占位符</p>
</blockquote>
<h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><p>JVM是如何通过栈帧中的对象引用访问到其内部的对象实例的呢?</p>
<p>对象访问的方式有两种：①句柄访问    ②直接指针(HotSpot采用)</p>
<p>句柄访问的好处：reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改。‘</p>
<p>直接指针的好处：访问效率更高、速度快，也不用在堆空间中开辟一块内存存储句柄。</p>
<p><img src="https://i.loli.net/2021/02/27/erKuL7W94NUfzDT.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2021/02/27/N4uhJcVdFqR9BX2.png" alt="image.png"></p>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>来源于NIO，通过DirectByteBuffer操作本地内存。性能优于Java堆。读写效率高。</p>
<p>也同样可能引起OOM（Direct Buffer Memory），由OS提供的内存大小限制。</p>
<p>且分配回收的成本较高、不受JVM内存管理。</p>
<blockquote>
<p>直接内存大小可以通过MaxDirectMemorysize设置</p>
<p>如果不指定，默认与堆的最大值-xmx参数值一致</p>
</blockquote>
<h2 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h2><p><img src="https://i.loli.net/2021/02/28/9uA7mCrLo1dXHID.png" alt="image.png"></p>
<p>Java语言是半解释半编译的语言。</p>
<h3 id="JIT"><a href="#JIT" class="headerlink" title="JIT"></a>JIT</h3><p>将方法编译成机器码后执行。</p>
<p>首先明确:</p>
<blockquote>
<p>当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。<br>而编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。</p>
</blockquote>
<p>所以:</p>
<blockquote>
<p>尽管JRockit VM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。在此模式下，<strong>当Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。</strong></p>
<p>同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”。</p>
</blockquote>
<p>一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此也被称之为<strong>栈上替换</strong>，或简称为OSR (on StackReplacement）编译。</p>
<p>一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准?必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠热点探测功能。</p>
<p>目前HotSpot VM所采用的热点探测方式是<strong>基于计数器的热点探测。</strong></p>
<p>采用基于计数器的热点探测，HotSpot VM将会为每一个方法都建立2个不同类型的计数器，分别为方法调用计数器（Invocation Counter）和回边计数器(BackEdge Counter) 。</p>
<blockquote>
<p>方法调用计数器用于统计方法的调用次数</p>
<p>回边计数器则用于统计循环体执行的循环次数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当一个方法被调用时，首先会检查该方法是否存在已经被JIT编译好的版本，如果存在则直接使用本地代码；如果不存在则将方法的调用计数器加1，然后判断方法调用计数器和回边计数器之和是否超过阈值。如果超过阈值，则向JIT编译器提交一个该方法的代码编译请求。</span><br></pre></td></tr></table></figure>

<p><strong>热度衰减</strong></p>
<blockquote>
<p>如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个<strong>相对的执行频率</strong>，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的<strong>衰减(Counter Decay)</strong>，而这段时间就称为此方法统计的<strong>半衰周期(counter Half Tife Time)</strong>。</p>
<p>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数-XX:-UseCounterDecay来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。</p>
<p>另外，可以使用-XX:CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。</p>
</blockquote>
<p><strong>设置HotSpot执行模式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Xint：纯解释器</span><br><span class="line">-Xcomp：纯编译器</span><br><span class="line">-Xmixed：混合模式</span><br></pre></td></tr></table></figure>

<p>HotSpot中内置两个编译器C1和C2，分别对应Client Compiler和Server Compiler</p>
<blockquote>
<p>C1编译器会对字节码进行<strong>简单和可靠的优化</strong>，耗时短。以达到更快的编译速度。</p>
<p>C2进行<strong>耗时较长的优化，以及激进优化</strong>。但优化的代码执行效率更高。</p>
</blockquote>
<hr>
<p><strong>C1和C2编译器不同的优化策略∶</strong></p>
<p>在不同的编译器上有不同的优化策略，C1编译器上主要有方法内联，去虚拟化、冗余消除。</p>
<blockquote>
<p>方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程</p>
<p>去虚拟化：对唯一的实现类进行内联</p>
<p>冗余消除：在运行期间把一些不会执行的代码折叠掉</p>
</blockquote>
<p>C2的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在C2上有如下几种优化:</p>
<blockquote>
<p>标量替换：用标量值代替聚合对象的属性值</p>
<p>栈上分配：对于未逃逸的对象分配对象在栈而不是堆</p>
<p>同步消除：清除同步操作，通常指synchronized</p>
</blockquote>
<p>且在Java 7之后，server模式下默认开启分层编译策略，C1和C2协同工作来执行编译任务。</p>
<hr>
<p>自JDK10起，HotSpot又加入一个全新的即时编译器:：Graal编译器。编译效果短短几年时间就追评了C2编译器。未来可期。<br>目前，带着“实验状态”标签，需要使用开关参数-XX:+UnlockExperimentalvMoptions -XX:+UseJVMCICompiler去激活，才可以使用。</p>
<p><strong>AOT编译器(ahead of time)</strong></p>
<blockquote>
<p>在jdk9引入</p>
<p>所谓AOT编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而AOT编译指的则是，<strong>在程序运行之前，便将字节码转换为机器码的过程</strong>。</p>
</blockquote>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>jdk8及之前使用char数组存储字符串，jdk9及以后采用byte数组存储同时加以字符编码标识进行辅助。</p>
<blockquote>
<p>因为大部分String字符串存储的字符用1个字节就能存储，char在Java中占两个字节，会导致很多空间的浪费。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"abc"</span> <span class="comment">// 通过字面量定义的方式，"abc"存放于字符串常量池中</span></span><br><span class="line"><span class="comment">// 注意：字符串常量池中不允许重复字符串</span></span><br></pre></td></tr></table></figure>

<p>String的不可变性</p>
<blockquote>
<p>①对字符串重新赋值，会重写内存区域赋值。<br>②对现有字符串进行连接操作，也需要重新指定内存区域赋值<br>③当调用String的replace()方法修改字符串时，也需要重新指定内存区域赋值。</p>
</blockquote>
<p><strong>字符串常量池中不允许重复字符串</strong></p>
<p>字符串常量池底层也是由一个固定大小的HashTable实现的(jdk6默认长度为1009、jdk7默认大小为60013)。</p>
<blockquote>
<p>可使用-XX:StringTableSize进行设置。且从jdk8开始，可设置的最小值为1009。</p>
</blockquote>
<p>在Java语言中有8种基本数据类型和一种比较特殊的类型string。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。</p>
<p>常量池就类似一个Java系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的，String类型的常量池比较特殊。它的主要使用方法有两种。</p>
<blockquote>
<p>直接使用双引号声明出来的String对象会直接存储在常量池中。比如:string info = “atguigu .com” ;</p>
<p>如果不是用双引号声明的String对象，可以使用String提供的intern()方法。这个后面重点谈。</p>
</blockquote>
<p>？toString()方法返回的字符串来自哪里？常量池 or 堆</p>
<h3 id="字符串的拼接操作"><a href="#字符串的拼接操作" class="headerlink" title="字符串的拼接操作"></a>字符串的拼接操作</h3><p>1.常量与常量的拼接结果在常量池，原理是编译期优化<br>2.常量池中不会存在相同内容的常量。<br>3.只要其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder<br>4.如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址。</p>
<p>字符串拼接(a = a + “xxx”)的底层操作相当于new了一个StringBuilder对象和一个String对象，和StringBuilder的append()方法相比，效率差的非常多，且后者至始至终只创建过一个对象，前者每一次拼接都会创建两个新对象。</p>
<h3 id="intern-方法"><a href="#intern-方法" class="headerlink" title="intern()方法"></a>intern()方法</h3><p>new String(“aba”)会创建几个对象？</p>
<blockquote>
<p>①如果常量池中存在”aba”字符串常量，则会创建一个对象，即new出来的<br>②如果不存在，则会创建两个对象，一个”aba”字符串，一个new的String对象</p>
</blockquote>
<p>那对于String str = new String(“a”) + new String(“b”)呢？</p>
<blockquote>
<p>对象1：new StringBuilder()<br>对象2：常量池中的”a”<br>对象3：new String(“a”)<br>对象4：常量池中的”b”<br>对象5：new String(“b”)</p>
<p>StringBuilder的toString()方法<br>对象6：new String(“ab”)</p>
<p>注意：在字符串常量池中没有生成”ab”</p>
</blockquote>
<p>对于上文的str，调用str.intern()方法，发生了什么？</p>
<blockquote>
<p>因为此时常量池中没有”ab”，所以应该在常量池中进行生成一个。但是根据jdk版本不同存在差异。</p>
<p>对于jdk6：字符串常量池处于永久代。所以会在常量池中生成一个”ab”对象，且该对象!=str<br>对于jdk7/8：字符串常量池移到堆中，为了节省空间，不会在常量池中新创建”ab”对象，而是在常量池中创建一个引用指向str，并且返回的也是该地址，因为是str调用的intern方法，所以此时该引用==str。</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"a"</span>) + <span class="keyword">new</span> String(<span class="string">"b"</span>)</span><br><span class="line">str.intern();</span><br><span class="line">String s2 = <span class="string">"ab"</span>;</span><br><span class="line">System.out.println(str == s2);	<span class="comment">// jdk6: false	jdk7/8: true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"a"</span>) + <span class="keyword">new</span> String(<span class="string">"b"</span>);</span><br><span class="line">String s2 = str.intern();</span><br><span class="line">String s3 = <span class="string">"ab"</span>;</span><br><span class="line">System.out.println(str == s2);	<span class="comment">// jdk6: false	jdk7/8: true</span></span><br><span class="line">System.out.println(s3 == s2);	<span class="comment">// jdk6: true	jdk7/8: true</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>当需要存储大量字符串在内存中时，可以恰当的使用intern()方法，节省空间，促进GC。</p>
<p><strong>G1的String去重操作</strong></p>
<blockquote>
<p>当垃圾收集器工作的时候，会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的String对象。</p>
<p>如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的String对象。</p>
<p>使用一个hashtable来记录所有的被String对象使用的不重复的char数组。当去重的时候，会查这个hashtable，来看堆上是否已经存在一个一模一样的char数组。</p>
<p>如果存在，String对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。<br>如果查找失败，char数组会被插入到hashtable，这样以后的时候就可以共享这个数组了。</p>
<p>UseStringDeduplication (bool):开启String去重，默认是不开启的，需要手动开启。</p>
</blockquote>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="垃圾回收算法-标记阶段"><a href="#垃圾回收算法-标记阶段" class="headerlink" title="垃圾回收算法-标记阶段"></a>垃圾回收算法-标记阶段</h3><p>首先需在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为<strong>垃圾标记阶段</strong>。</p>
<p>那么在JVM中究竟是如何标记一个死亡对象呢?简单来说，当一个对象已经<strong>不再被任何的存活对象继续引用时</strong>，就可以宣判为已经死亡。</p>
<p>判断对象存活一般有两种方式：<strong>引用计数算法</strong>和<strong>可达性分析算法</strong>。</p>
<h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>引用计数算法(Reference Counting)比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。</p>
<p>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</p>
<blockquote>
<p>优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</p>
<p>缺点：①它需要单独的字段存储计数器，这样的做法增加了存储空间的开销。②每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。③引用计数器有一个严重的问题，即无法处理<strong>循环引用</strong>的情况。这是一条致命缺陷,导致在Java的垃圾回收器中没有使用这类算法。</p>
</blockquote>
<h4 id="可达性分析算法-根搜索算法、追踪性垃圾收集"><a href="#可达性分析算法-根搜索算法、追踪性垃圾收集" class="headerlink" title="可达性分析算法(根搜索算法、追踪性垃圾收集)"></a>可达性分析算法(根搜索算法、追踪性垃圾收集)</h4><p>所谓”GC Roots”根集合就是一组必须活跃的引用。</p>
<p>基本思路：可达性分析算法是以根对象集合(GC Roots)为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。</p>
<blockquote>
<p>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为<strong>引用链(Reference Chain)</strong></p>
<p>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。</p>
<p>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</p>
</blockquote>
<p>在Java语言中，G Roots包括以下几类元素：</p>
<p>①虚拟机栈中引用的对象。比如：各个线程被调用的方法中使用到的参数、局部变量等。<br>②本地方法栈内JNI(通常说的本地方法)引用的对象<br>③方法区中类静态属性引用的对象。比如: Java类的引用类型静态变量<br>④方法区中常量引用的对象。比如:字符串常量池（string Table）里的引用<br>⑤所有被同步锁synchronized持有的对象<br>⑥Java虚拟机内部的引用。基本数据类型对应的class对象，一些常驻的异常对象（如:NullPointerException、OutOfMemoryError）、系统类加载器<br>⑦反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。<br>⑧在某些特殊情况下，还可能存在一些对象临时加入到Root中的情况。(如：在分代垃圾收集时，如果只回收新生代的对象，那么一些老年代的对象也可以作为Root)</p>
<blockquote>
<p>如果一个指针，它指向堆内存里面的对象，但是其本身又不存放在堆内存里面，那它就是一个Root。</p>
</blockquote>
<p>因此采用此方法进行垃圾收集时，需要处于一个一致性的快照环境下。也就是STW的由来。</p>
<h4 id="对象的finalization机制"><a href="#对象的finalization机制" class="headerlink" title="对象的finalization机制"></a>对象的finalization机制</h4><p>Java语言提供了对象终止(finalization)机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，<strong>总会先调用这个对象的finalize()方法。</strong></p>
<p>永远不要主动调用某个对象的finalize()方法，应该交给垃圾回收机制调用。理由包括下面三点:</p>
<p>①在finalize()时可能会导致对象复活。<br>②finalize()方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则finalize()方法将没有执行机会。<br>③一个糟糕的finalize()会严重影响Gc的性能。</p>
<p>从功能上来说，finalize()方法与C++中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize()方法在本质上不同于C++中的析构函数。</p>
<p>由于finalize()方法的存在，虚拟机中的对象一般处于三种可能的状态。</p>
<blockquote>
<p>可触及的：从根节点开始，可以到达这个对象。<br>可复活的：对象的所有引用都被释放，但是对象有可能在finalize()中复活。且之后也无法再次调用finalize方法<br>不可触及的:对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为finalize ()只会被调用一次。</p>
<p>以上3种状态中，是由于finalize()方法的存在，进行的区分。只有在对象不可触及时才可以被回收。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">判定一个对象objA是否可回收，至少要经历两次标记过程:</span><br><span class="line">	1．如果对象objA到GC Roots没有引用链，则进行第一次标记。</span><br><span class="line">	2．进行筛选，判断此对象是否有必要执行finalize()方法</span><br><span class="line">		* 如果对象objA没有finalize()方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，obj重写finalize()方法,或者A被判定为不可触及的。</span><br><span class="line">		* 如果对象objA重写了finalize()方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize()方法执行。</span><br><span class="line">		* finalize()方法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的况。在这个情况下，finalize方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize方法只会被调用一次。</span><br></pre></td></tr></table></figure>

<h3 id="垃圾回收算法-清除阶段"><a href="#垃圾回收算法-清除阶段" class="headerlink" title="垃圾回收算法-清除阶段"></a>垃圾回收算法-清除阶段</h3><p>当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。</p>
<p>目前在JVM中比较常见的三种垃圾收集算法是标记一清除算法( Mark-Sweep )、复制算法（ copying )、标记–压缩算法( Mark-Compact )。</p>
<h4 id="标记-清除方法"><a href="#标记-清除方法" class="headerlink" title="标记-清除方法"></a>标记-清除方法</h4><p>执行过程：当堆中的有效内存空间(available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world)，然后进行两项工作，第一项则是标记，第二项则是清除。</p>
<blockquote>
<p>标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。(未标记的为垃圾)<br>清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。</p>
</blockquote>
<p>缺点：</p>
<blockquote>
<p>①效率不算高<br>②在进行GC的时候，需要停止整个应用程序，导致用户体验差<br>③这种方式清理出来的空闲内存是不连续的，产生内存碎片I需要维护一个空闲列表</p>
</blockquote>
<blockquote>
<p>补充：何为清除，即将需要被清除的对象的地址添加到空闲列表中接口，而没有“置空”之类的说法。</p>
</blockquote>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</p>
<blockquote>
<p>优点：没有标记和清除过程,实现简单，运行高效；复制过去以后保证空间的连续性，不会出现“碎片”问题。</p>
<p>缺点：此算法的缺点也是很明显的，就是需要两倍的内存空间。对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小。</p>
<p>特别的：如果系统中的非垃圾对象很多，复制算法不会太理想。因为复制算法需要复制的存活对象数量需要不能太大，或者说非常低才行。（所以可以应用到新生代中）</p>
</blockquote>
<h4 id="标记-压缩算法"><a href="#标记-压缩算法" class="headerlink" title="标记-压缩算法"></a>标记-压缩算法</h4><p>执行过程：</p>
<p>第一阶段和标记-清除算法一样，从根节点开始标记所有被引用对象。第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间。</p>
<blockquote>
<p>二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策（引用的修改）。</p>
<p>可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</p>
</blockquote>
<blockquote>
<p>优点：消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。<br>消除了复制算法当中，内存减半的高额代价。</p>
<p>缺点：从效率上来说，标记-整理算法要低于复制算法。移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址。_·移动过程中，需要全程暂停用户应用程序。即：STW</p>
</blockquote>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。</p>
<p>而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。</p>
<h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>分代收集算法，是基于这样一个事实:不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p>
<p>目前几乎所有的GC都是采用分代收集(Generational Collecting)算法执行垃圾回收的。</p>
<p>在Hotspot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。</p>
<blockquote>
<p>年轻代(Young Gen)：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</p>
<p>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</p>
<p>老年代(Tenured Gen)：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</p>
<p>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。</p>
<p>Mark阶段的开销与存活对象的数量成正比。<br>Sweep阶段的开销与所管理区域的大小成正相关。<br>Compact阶段的开销与存活对象的数据成正比。</p>
</blockquote>
<p>以Hotspot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于Mark-compact算法的Serial old回收器作为补偿措施:当内存回收不佳（碎片导致的doncurrent Mode Failure时)，将采用Serial old执行Full GC以达到对老年代内存的整理。</p>
<p>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代。</p>
<h4 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h4><p>基本思想：如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</p>
<p>总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。</p>
<blockquote>
<p>缺点：使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞叶量的下降。</p>
</blockquote>
<h4 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h4><p>一般来说，在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。</p>
<p>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间region。每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</p>
<h3 id="垃圾回收的相关概念"><a href="#垃圾回收的相关概念" class="headerlink" title="垃圾回收的相关概念"></a>垃圾回收的相关概念</h3><h4 id="System-gc"><a href="#System-gc" class="headerlink" title="System.gc()"></a>System.gc()</h4><p>在默认情况下，通过System.gc()或者Runtime. getRuntime( ).gc()的调用，会显式触发Full GC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</p>
<p>然而System.gc()调用附带一个免责声明，无法保证对垃圾收集器的调用。</p>
<p>JVM实现者可以通过System.gc()调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc()。</p>
<p>System.runFinalization()方法会强制调用失去引用的对象的finalize()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	System.gc(); <span class="comment">// 此时 b数组并不会被回收，虽然作用域已经结束，但是因为局部变量表中仍然存在一个插槽指向该对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">1</span>;</span><br><span class="line">	System.gc(); <span class="comment">// 此时 b数组会被回收，因为其之前在局部变量表中的插槽被val变量所占用了，所以属于垃圾对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="内存溢出与内存泄漏"><a href="#内存溢出与内存泄漏" class="headerlink" title="内存溢出与内存泄漏"></a>内存溢出与内存泄漏</h4><p>javadoc中对OutOfMemoryError的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。也就是在OOM之前通常会执行垃圾回收(除了分配超大对象时，垃圾收集也无济于事的情况)。</p>
<p>没有空闲内存的情况：①Java虚拟机的堆内存设置不够；②代码中创建了大量对象，且长时间不能被垃圾收集器收集（存在被引用）</p>
<hr>
<p>只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫<strong>内存泄漏</strong>。</p>
<p>但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致OOM，也可以叫做宽泛意义上的“内存泄漏”。</p>
<blockquote>
<p>eg. 当一个对象的引用属于类的静态成员时，该对象的生命周期就很长，随着类的消亡才会消亡。</p>
</blockquote>
<p>举例:</p>
<blockquote>
<p>1、单例模式<br>单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。</p>
<p>2、一些提供close的资源未关闭导致内存泄漏<br>数据库连接（dataSourse.getConnection())，网络连接(socket)和io连接必须手动close，否则是不能被回收的。</p>
</blockquote>
<h4 id="StopTheWord"><a href="#StopTheWord" class="headerlink" title="StopTheWord"></a>StopTheWord</h4><p>stop-the-world，简称STW，指的是GC事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW。</p>
<blockquote>
<p>可达性分析算法中枚举根节点(GC Roots）会导致所有Java执行线程停顿。</p>
<ul>
<li>分析工作必须在一个能确保一致性的快照中进行</li>
<li>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</li>
<li>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证</li>
</ul>
<p>被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少STW的发生。</p>
</blockquote>
<p>STW事件和采用哪款GC无关，所有的GC都有这个事件。</p>
<p>哪怕是G1也不能完全避免stop-the-world 情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。</p>
<p>STW是JVM在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的工作线程全部停掉。</p>
<p>开发中不要用System.gc();会导致stop-the-world的发生。</p>
<h4 id="垃圾回收的并行和并发"><a href="#垃圾回收的并行和并发" class="headerlink" title="垃圾回收的并行和并发"></a>垃圾回收的并行和并发</h4><p>并发：在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，即都在运行中，且这几个程序都是在同一个处理备上运行。</p>
<p>并行：当系统有一个以上CPU时，当一个CPu执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，我们称之为并行(Parallel)。其实决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以并行。</p>
<p>并发，指的是多个事情,在同一时间段内同时发生了。并发的多个任务之间是互相抢占资源的。<br>并行，指的是多个事情,在同一时间点上同时发生了。并行的多个任务之间是不互相抢占资源的。</p>
<hr>
<p>并行(Parallel)：指<strong>多条垃圾收集线程</strong>并行工作，但此时用户线程仍处于等待状态。如ParNew、Parallel scavenge、Parallel old;</p>
<p>串行(Serial)：相较于并行的概念,单线程执行。如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。</p>
<p>并发(Concurrent)：指用户线程与垃圾收集线程同时执行(但不一定是并行的，可能会交替执行)，垃圾回收线程在执行时不会停顿用户程序的运行。</p>
<blockquote>
<p>用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上；如：CMS、G1</p>
</blockquote>
<h4 id="安全点和安全区域"><a href="#安全点和安全区域" class="headerlink" title="安全点和安全区域"></a>安全点和安全区域</h4><p>程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点(Safe Point) ”。</p>
<p>Safe Point的选择很重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，通常会根据“是否具有让程序长时间执行的特征”为标准。比如:：选择一些执行时间较长的指令作为Safe Point，如方法调用、循环跳转和异常跳转等。</p>
<p>如何在GC发生时,检查所有线程都跑到最近的安全点停顿下来呢?</p>
<blockquote>
<p>抢先式中断：首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。（目前没有虚拟机采用了)</p>
<p>主动式中断：设置一个中断标志，各个线程运行到safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。</p>
</blockquote>
<p>安全区域</p>
<blockquote>
<p>Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safe Point 。但是，程序“不执行”的时候呢?例如线程处于sleep状态或Blocked状态，这时候线程无法响应JVM的中断请求，“走”到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域(Safe Region)来解决。</p>
<p>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的。我们也可以把Safe Region看做是被扩展了的Safe Point。</p>
</blockquote>
<p>实际执行时:<br>1、当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region,如果这段时间内发生GC，JVM会忽略标识为Safe Region状态的线程;</p>
<p>2、当线程即将离开Safe Region时，会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止。</p>
<h4 id="java引用"><a href="#java引用" class="headerlink" title="java引用"></a>java引用</h4><p>强引用——软引用——弱引用——虚引用，引用强度逐级递减。</p>
<p>强引用(Strong Reference)：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj=new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</p>
<p>软引用(Soft Reference)：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。</p>
<p>弱引用(Weak Reference)：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。</p>
<p>虚引用(Phantom Reference)：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。<strong>为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</strong>（对象回收跟踪）</p>
<h5 id="强引用——不回收"><a href="#强引用——不回收" class="headerlink" title="强引用——不回收"></a>强引用——不回收</h5><blockquote>
<p>在Java程序中，最常见的引用类型是强引用（普通系统99%以上都是强引用)，也就是我们最常见的普通对象引用，也是默认的引用类型。</p>
<p>当在]ava语言中使用new操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。</p>
<p>强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。</p>
<p>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应(强)引用赋值为null，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。</p>
<p>相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的（<font color="red">均为可达的</font>），在一定条件下，都是可以被回收的。<strong>所以，强引用是造成Java内存泄漏的主要原因之一</strong>。</p>
</blockquote>
<h5 id="软引用——内存不足即回收"><a href="#软引用——内存不足即回收" class="headerlink" title="软引用——内存不足即回收"></a>软引用——内存不足即回收</h5><blockquote>
<p>软引用是用来描述一些还有用，但非必需的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p>
<p>软引用通常用来实现内存敏感的缓存。比如：高速缓存就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p>
<p>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列(Reference Queue)。</p>
<p>类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。</p>
</blockquote>
<h5 id="弱引用——发现即回收"><a href="#弱引用——发现即回收" class="headerlink" title="弱引用——发现即回收"></a>弱引用——发现即回收</h5><blockquote>
<p>弱引用也是用来描述那些非必需对象，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。</p>
<p>但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。</p>
<p>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</p>
<p>软引用、弱引用都非常适合来保存那些可有可无的缓存数据。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用</p>
</blockquote>
<h5 id="虚引用——对象回收跟踪"><a href="#虚引用——对象回收跟踪" class="headerlink" title="虚引用——对象回收跟踪"></a>虚引用——对象回收跟踪</h5><blockquote>
<p>也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个。</p>
<p>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</p>
<p>它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get()方法取得对象时，总是null。</p>
<p>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。</p>
<p>虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用就会在回收对象后，<strong>将这个虚引用加入引用队列</strong>，以通知应用程序对象的回收情况，我们可以操作该队列来完成一个通知的机制。</p>
</blockquote>
<h5 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h5><blockquote>
<p>它用以实现对象的finalize()方法，也可以称为终结器引用。</p>
<p>无需手动编码,其内部配合引用队列使用。</p>
<p>在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象并调用它的finalize()方法，第二次GC时才能回收被引用对象。</p>
</blockquote>
<h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><h4 id="GC分类与性能指标"><a href="#GC分类与性能指标" class="headerlink" title="GC分类与性能指标"></a>GC分类与性能指标</h4><p>吞吐量：运行用户代码的时间占总运行时间的比例</p>
<blockquote>
<p>（总运行时间：程序的运行时间＋内存回收的时间)</p>
</blockquote>
<p>垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。<br>暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间。<br>收集频率：相对于应用程序的执行，收集操作发生的频率。<br>内存占用：Java 堆区所占的内存大小。<br>快速：一个对象从诞生到被回收所经历的时间。</p>
<p>暂停时间的重要性逐渐凸显。</p>
<h4 id="垃圾回收器和分代关系"><a href="#垃圾回收器和分代关系" class="headerlink" title="垃圾回收器和分代关系"></a>垃圾回收器和分代关系</h4><p>新生代收集器: Serial、ParNew、Parallel scavenge;<br>老年代收集器: serial old、Parallel old、CMS;<br>整堆收集器:G1;</p>
<p><img src="https://i.loli.net/2021/03/03/c8nYaLOTkhr3DlH.png" alt="image.png"></p>
<p>其中虚线为JDK8及以前的搭配。</p>
<p>且Serrial Old GC是作为CMS GC的后备方案。因为CMS需要在老年代未满时进行并发回收，如果老年代满了，只能通过Serial Old GC来收集。</p>
<h5 id="Serial-GC（串行回收）"><a href="#Serial-GC（串行回收）" class="headerlink" title="Serial GC（串行回收）"></a>Serial GC（串行回收）</h5><p>单线程。</p>
<p>新生代复制算法、老年代标记-整理算法。都需要STW。</p>
<h5 id="ParNew-GC（并行回收）"><a href="#ParNew-GC（并行回收）" class="headerlink" title="ParNew GC（并行回收）"></a>ParNew GC（并行回收）</h5><p>Serial的多线程版本。</p>
<p>New代表处理的是新生代，采用复制算法。也需要STW。、</p>
<p>可以和CMS和Serial Old搭配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UserParNewGC 启用ParNew GC</span><br><span class="line">-XX:PareallelGCThreads 限制线程数量 默认和CPU相同</span><br></pre></td></tr></table></figure>

<h5 id="Parallel-Scavenge回收器（吞吐量优先、并行）"><a href="#Parallel-Scavenge回收器（吞吐量优先、并行）" class="headerlink" title="Parallel Scavenge回收器（吞吐量优先、并行）"></a>Parallel Scavenge回收器（吞吐量优先、并行）</h5><p>同样新生代采用复制算法，需要STW。</p>
<p>且存在动态自适应调节策略。</p>
<p>Parallel Old采用标记压缩算法处理老年代，需要STW。</p>
<p>java8默认收集器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UserParallelGC 启用Parallel GC</span><br><span class="line">-XX:+UserParallelOldGC 且这两个参数互相激活</span><br><span class="line">-XX:PareallelGCThreads 年轻代垃圾收集的线程数</span><br><span class="line">-XX:GCTimeRatio 垃圾收集时间占总时间的比例</span><br><span class="line">-XX:MaxGCPauseMillis 慎用 设置最大暂停时间</span><br><span class="line">-XX:+UseAdaptivesizePolicy 自适应调节策略</span><br></pre></td></tr></table></figure>

<h5 id="CMS-GC（低延迟）"><a href="#CMS-GC（低延迟）" class="headerlink" title="CMS GC（低延迟）"></a>CMS GC（低延迟）</h5><p>concurrent-mark-sweep 并发-标记-清除 也会STW，为了能在并发清除时不用STW，所以使用mark-sweep</p>
<p>垃圾收集线程和用户线程同时工作</p>
<p>只能和Serial、ParNew配合工作。jdk14删除</p>
<p>CNS整个过程比之前的收集器要复杂,整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段。</p>
<blockquote>
<p>初始标记(Initial-Mark)阶段：在这个阶段中，程序中所有的工作线程都将会因为“Stop-the-world”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是标记出GC Roots能<strong>直接关联到的对象</strong>。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。</p>
<p>并发标记(Concurrent-Mark)阶段：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是<strong>不需要停顿用户线程</strong>，可以与垃圾收集线程一起并发运行。（耗时）</p>
<p>重新标记(Remark)阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</p>
<p>并发清除(Concurrent-Sweep)阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。（耗时）</p>
</blockquote>
<p><img src="https://i.loli.net/2021/03/03/w6mbDEpgxHdSyo2.png" alt="image.png"></p>
<p>在并发标记时，需要保证用户线程仍然有足够的内存可以使用。不能在老年代满的时候再收集。否则需要Serial Old GC作为后备方案。</p>
<p>也会产生内存碎片。需要空闲列表。</p>
<p>弊端：</p>
<blockquote>
<p>1)会产生内存碎片，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发Full GC。<br>2)CMS收集器对cPu资源非常敏感。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。<br>3)CMS收集器无法处理浮动垃圾。可能出现“concurrent Mode Failure”失败而导致另一次 Full cC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在<strong>并发标记阶段如果产生新的垃圾对象</strong>，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行Gc时释放这些之前未被回收的内存空间。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UserConcMarkSweepGC 老年代 默认新生代使用ParNew GC</span><br><span class="line">-XX:CMSInitiatingOccupyFraction 设置堆内存使用率的阈值 %65 jdk6+：%92</span><br><span class="line">还有参数设置多久执行一次内存碎片的整理</span><br></pre></td></tr></table></figure>

<h5 id="G1-GC（区域化分代式）"><a href="#G1-GC（区域化分代式）" class="headerlink" title="G1 GC（区域化分代式）"></a>G1 GC（区域化分代式）</h5><p>官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望。</p>
<p>G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1 跟踪各个Region里面的垃圾堆积的价值大小(回收所获得的空间大小以佟以收所需可间的约城值)，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。</p>
<p>特点</p>
<blockquote>
<p>并行与并发：</p>
<p>并行性: G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW。<br>并发性: G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况。</p>
<p>分代收集：</p>
<p>①从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。<br>②将堆空间分为若干个区域(Region)，这些区域中包含了逻辑上的年轻代和老年代。<br>③和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代。</p>
<p>空间整合：</p>
<p>CMS：“标记-清除”算法、内存碎片、若干次GC后进行一次碎片整理<br>G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。Region之间是复制算法，但整体上实际可看作是标记-压缩(Mark-Compact)算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。</p>
<p>可预测的停顿时间模型(即：软实时soft real-time)：</p>
<p>这是G1 相对于CMS 的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</p>
<p>①由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。<br>②G1 跟踪各个Region里面的垃圾堆积的价值大小(回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了G1 收集器在有限的时间内可以获取尽可能高的收集效率。<br>③相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseG1GC 手动指定使用G1收集器执行内存回收任务。</span><br><span class="line">-XX:G1HeapRegionSize设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000.</span><br><span class="line">-XX:MaxGCPauseMillis设置期望达到的最大Gc停顿时间指标(JVM会尽力实现，但不保证达到)。默认值是200ms</span><br><span class="line">-XX:Paralle1GCThread 设置STW工作线程数的值。最多设置为8</span><br><span class="line">-XX:ConcGChreads设置并发标记的线程数。将n设置为并行垃圾回收线程数(ParallelGCThreads)的1/4左右。</span><br><span class="line">-XX:InitiatingHeapOccupancyPercent 设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发Gc。默认值是45。</span><br></pre></td></tr></table></figure>

<p>G1的设计原则就是简化VM性能调优，开发人员只需要简单的三步即可完成调优:</p>
<p>第一步:开启G1垃圾收集器<br>第二步:设置堆的最大内存<br>第三步:设置最大的停顿时间</p>
<p>G1中提供了三种垃圾回收模式: YoungGc、Mixed Gc和Full Gc，在不同的条件下被触发。</p>
<p>设置H的原因:</p>
<blockquote>
<p>对于堆中的大对象，默认直接会被分配到老年代,I但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动Full Gc。G1的大多数行为都把H区作为老年代的一部分来看待。</p>
</blockquote>
<p>在region内部分配内存采用指针碰撞，还可以分配TLAB。</p>
<p><strong>垃圾回收细节</strong></p>
<p>G1垃圾回收主要包含三个环节：</p>
<p>①年轻代GC(Young GC)<br>②老年代并发标记过程(Concurrent Marking)<br>③混合回收(Mixed Gc)<br>(如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。)</p>
<p><img src="https://i.loli.net/2021/03/04/Idiyfvm8cHtTwxY.png" alt="image.png"></p>
<blockquote>
<p>应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程; G1的年轻代收集阶段是一个并行的独占式收集器。在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。</p>
<p>当堆内存使用达到一定值(默认45%)时，开始老年代并发标记过程。</p>
<p>标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了。同时，这个老年代Region是和年轻代一起被回收的。</p>
<p>举个例子：一个web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</p>
</blockquote>
<p><strong>Remebered Set</strong></p>
<p>一个对象被不同区域引用的问题</p>
<blockquote>
<p>一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时,是否需要扫描整个Java堆才能保证准确?</p>
<p>在其他的分代收集器，也存在这样的问题(而G1更突出)</p>
<p>回收新生代也不得不同时扫描老年代?</p>
<p>这样的话会降低Minor GC的效率?</p>
</blockquote>
<p>解决方法:</p>
<blockquote>
<p>无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描</p>
<p>每个Region都有一个对应的Remembered set;</p>
<p>每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作;</p>
<p>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region(其他收集器:检查老年代对象是否引用了新生代对象);</p>
<p>如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered set中;</p>
<p>当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set，就可以保证不进行全局扫描，也不会有遗漏。</p>
<p>笔者理解：即在回收某一个region时，如果该region中的对象仍然存在其他region的对象引用他们，则这些引用的对象肯定是存在于Remebered Set中的，这样就能够很好的进行标记了，也不会遗漏。</p>
</blockquote>
<p><img src="https://i.loli.net/2021/03/04/qxfND297J8VGFip.png" alt="image.png"></p>
<p><strong>垃圾回收过程</strong></p>
<p>YGC：</p>
<blockquote>
<p>JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。</p>
<p>年轻代垃圾回收只会回收Eden区和Survivor区。</p>
<p>YGC时，首先G1停止应用程序的执行(stop-The-world) ，G1创建回收集（collection Set)，回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区<strong>所有</strong>的内存分段。</p>
</blockquote>
<p>具体过程</p>
<blockquote>
<p>然后开始如下回收过程:</p>
<p>第一阶段，扫描根。<br>根是指static变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同RSet记录的外部引用作为扫描存活对象的入口。</p>
<p>第二阶段，更新RSet。<br>处理dirty card queue(见备注)中的card，更新RSet。此阶段完成后，RSet可以准确的反映老年代对所在的内存分段中对象的引用。</p>
<p>第三阶段，处理RSet。<br>识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。</p>
<p>第四阶段，复制对象。<br>此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到survivor区中空的内存分段survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到o1d区中空的内存分段。如果survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。</p>
<p>第五阶段,处理引用。<br>处理Soft，weak，Phantom，Final，JNI weak 等引用。最终Eden空间的数据为空，Gc停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果．减少碎片</p>
</blockquote>
<p>并发标记阶段：</p>
<blockquote>
<p>1、初始标记阶段：标记从根节点直接可达的对象。这个阶段是STW的，并且会触发一次年轻代GC。<br>2、根区域扫描（Root Region Scanning)：G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在Young GC之前完成。<br>3、并发标记(Concurrent Marking)：在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被Young GC中断。在并发标记阶段，<strong>若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收</strong>。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。<br>4、再次标记(Remark)：由于应用程序持续进行，需要修正上一次的标记结果是STW的。G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。<br>5、独占清理(cleanup,STW)：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。(这个阶段并不会实际上去做垃圾的收集)<br>6、并发清理阶段：识别并清理完全空闲的区域。</p>
</blockquote>
<p>混合回收</p>
<blockquote>
<p>当越来越多的对象晋升到老年代old region时,为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个old Gc，除了回收整个Young Region,还会回收一部分的old Region。这里需要注意：是一部分老年代，而不是全部老年代。可以选择哪些old Region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed Gc并不是Full Gc。</p>
</blockquote>
<p>导致G1Full GC的原因可能有两个:</p>
<p>①Evacuation的时候没有足够的to-space来存放晋升的对象<br>②并发处理过程完成之前空间耗尽。</p>
<p>优化建议</p>
<blockquote>
<p>年轻代大小：避免使用-Xmn或-XX;NewRatio等相关选项显式设置年轻代大小&gt;固定年轻代的大小会覆盖暂停时间目标<br>暂停时间目标不要太过严苛</p>
<p>G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间<br>评估G1 Gc的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</p>
</blockquote>
<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p><img src="https://i.loli.net/2021/03/04/oFTlgyn5s2i61VQ.png" alt="image.png"></p>
<p>怎么选择垃圾回收器?</p>
<blockquote>
<p>Java垃圾收集器的配置对于VM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一个很大的提升。</p>
<p>优先调整堆的大小让JVM自适应完成。</p>
<p>如果内存小于100M，使用串行收集器</p>
<p>如果是单核、单机程序，并且没有停顿时间的要求，串行收集器</p>
<p>如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择</p>
<p>如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用)，使用并发收集器，官方推荐G1，性能高。现在互联网的项目，基本都是使用G1。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/04/Java%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Bcutty Kmy">
      <meta itemprop="description" content="NO DEPENDENCE ONLY PRIDE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BBBBBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/04/Java%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/" class="post-title-link" itemprop="url">Java面试准备</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-04 13:48:50" itemprop="dateCreated datePublished" datetime="2021-03-04T13:48:50+08:00">2021-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-05 19:07:58" itemprop="dateModified" datetime="2021-03-05T19:07:58+08:00">2021-03-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          
            <span id="/2021/03/04/Java%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/" class="post-meta-item leancloud_visitors" data-flag-title="Java面试准备" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2021/03/04/Java%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/03/04/Java%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java面试准备"><a href="#Java面试准备" class="headerlink" title="Java面试准备"></a>Java面试准备</h1><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="String、StringBuilder、StringBuffer"><a href="#String、StringBuilder、StringBuffer" class="headerlink" title="String、StringBuilder、StringBuffer"></a>String、StringBuilder、StringBuffer</h3><blockquote>
<p>String 类中使用 final 关键字修饰字符数组来保存字符串，<code>private final char value[]</code>，所以 String 对象是不可变的。补充（来自<a href="https://github.com/Snailclimb/JavaGuide/issues/675" target="_blank" rel="noopener">issue 675</a>）：在 Java 9 之后，String 类的实现改用 byte 数组存储字符串 <code>private final byte[] value</code>。</p>
<p>而 StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串<code>char[] value</code> 但是没有用 final 关键字修饰，所以这两种对象都是可变的。</p>
</blockquote>
<p><strong>线程安全性</strong></p>
<blockquote>
<p>String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p>
</blockquote>
<p><strong>性能</strong></p>
<blockquote>
<p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
</blockquote>
<p><strong>对于三者使用的总结：</strong></p>
<blockquote>
<p>操作少量的数据: 适用 String</p>
<p>单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder</p>
<p>多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer</p>
</blockquote>
<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(xxx);</span><br><span class="line">Integer i = xxx;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在通过valueOf方法创建Integer对象的时候，如果数值在[-128,127]之间，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。</p>
</blockquote>
<blockquote>
<p>同时：Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的。而Double、Float的valueOf方法的实现是类似的。而对于Boolean类，则是通过两个静态变量实现的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean TRUE = <span class="keyword">new</span> Boolean(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean FALSE = <span class="keyword">new</span> Boolean(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Integer a = <span class="number">1</span>;</span><br><span class="line">        Integer b = <span class="number">2</span>;</span><br><span class="line">        Integer c = <span class="number">3</span>;</span><br><span class="line">        Integer d = <span class="number">3</span>;</span><br><span class="line">        Integer e = <span class="number">321</span>;</span><br><span class="line">        Integer f = <span class="number">321</span>;</span><br><span class="line">        Long g = <span class="number">3L</span>;</span><br><span class="line">        Long h = <span class="number">2L</span>;</span><br><span class="line">    </span><br><span class="line">        System.out.println(c==d); <span class="comment">// true</span></span><br><span class="line">        System.out.println(e==f); <span class="comment">// false</span></span><br><span class="line">        System.out.println(c==(a+b)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(c.equals(a+b)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(g==(a+b)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(g.equals(a+b)); <span class="comment">// false</span></span><br><span class="line">        System.out.println(g.equals(a+h)); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第一个和第二个输出结果没有什么疑问。第三句由于 a+b包含了算术运算，因此会触发自动拆箱过程（会调用intValue方法），因此它们比较的是数值是否相等。而对于c.equals(a+b)会先触发自动拆箱过程，再触发自动装箱过程，也就是说a+b，会先各自调用intValue方法，得到了加法运算后的数值之后，便调用Integer.valueOf方法，再进行equals比较。同理对于后面的也是这样，不过要注意倒数第二个和最后一个输出的结果（如果数值是int类型的，装箱过程调用的是Integer.valueOf；如果是long类型的，装箱调用的Long.valueOf方法）。</p>
</blockquote>
<h3 id="equals-和hashCode-方法"><a href="#equals-和hashCode-方法" class="headerlink" title="equals()和hashCode()方法"></a>equals()和hashCode()方法</h3><blockquote>
<p>没重写了equals的类调用equals方法和使用<code>==</code>等价，比较两个对象的地址是否相同<br>重写equals方法时，需要注意满足其原生的一些特点，可参考下面代码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(obj == <span class="keyword">null</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果是同一个对象返回true，反之返回false</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span> == obj)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//判断是否类型相同</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.getClass() != obj.getClass())&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 最后制定自己想要的规则进行重写</span></span><br><span class="line">      Person person = (Person)obj;</span><br><span class="line">      <span class="keyword">return</span> name.equals(person.name) &amp;&amp; age == person.age;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>hashCode方法获取对象的一个哈希码，即一个整数值。且<strong>hashCode() 在散列表中才有用，在其它情况下没用。</strong>在散列表中hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。</p>
</blockquote>
<blockquote>
<p>由此可知，若两个元素相等，它们的散列码一定相等；但反过来确不一定。在散列表中，<br>1、如果两个对象相等，那么它们的hashCode()值一定要相同；<br>2、如果两个对象hashCode()相等，它们并不一定相等。<br>注意：这是在散列表中的情况。在非散列表中一定如此！</p>
</blockquote>
<p><strong>为什么重写 <code>equals</code> 时必须重写 <code>hashCode</code> 方法？</strong></p>
<blockquote>
<p>本质：为了遵守2个对象equals，那么其hashCode一定相同的规则。</p>
<p>如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等，对两个对象分别调用 equals 方法都返回 true。但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 。<strong>因此，equals 方法被覆盖过，则 <code>hashCode</code> 方法也必须被覆盖。</strong></p>
</blockquote>
<blockquote>
<p>且<code>hashCode()</code>的默认行为是对堆上的对象产生独特值。如果没有重写 <code>hashCode()</code>，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p>
</blockquote>
<h3 id="Java值传递"><a href="#Java值传递" class="headerlink" title="Java值传递"></a>Java值传递</h3><blockquote>
<p>Java 程序设计语言对对象采用的不是引用调用，实际上，对象引用也是按值传递的。</p>
<p>下面再总结一下 Java 中方法参数的使用情况：</p>
<ul>
<li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。</li>
<li>一个方法可以改变一个对象参数的状态。</li>
<li>一个方法不能让对象参数引用一个新的对象。</li>
</ul>
<p>可参考下面的代码理解</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person();</span><br><span class="line">        p1.name = <span class="string">"1"</span>;</span><br><span class="line">        p2.name = <span class="string">"2"</span>;</span><br><span class="line">        change(p1, p2);</span><br><span class="line">        System.out.println(p1.name);</span><br><span class="line">        <span class="comment">// 输出 1</span></span><br><span class="line">        changeName(p1, p2);</span><br><span class="line">        System.out.println(p1.name);</span><br><span class="line">        <span class="comment">// 输出 2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(Person p1, Person p2)</span> </span>&#123;</span><br><span class="line">        p1 = p2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changeName</span><span class="params">(Person p1, Person p2)</span> </span>&#123;</span><br><span class="line">        p1.name = p2.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>final 关键字主要用在三个地方：变量、方法、类。</p>
<blockquote>
<p>对于一个 final 变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</p>
<p>当用 final 修饰一个类时，表明这个类不能被继承。final 类中的所有成员方法都会被隐式地指定为 final 方法。</p>
<p>使用 final 方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的 Java 实现版本中，会将 final 方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的 Java 版本已经不需要使用 final 方法进行这些优化了）。类中所有的 private 方法都隐式地指定为 final。</p>
</blockquote>
<h3 id="I-O流"><a href="#I-O流" class="headerlink" title="I/O流"></a>I/O流</h3><p>流的种类：</p>
<blockquote>
<p>按照流的流向分，可以分为输入流和输出流；</p>
<p>按照操作单元划分，可以划分为字节流和字符流；</p>
<p>按照流的角色划分为节点流和处理流。</p>
</blockquote>
<p>对于所有相关类，都由下方四个抽象基类进行派生</p>
<blockquote>
<p>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</p>
<p>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</p>
</blockquote>
<p>BIO、NIO、AIO</p>
<blockquote>
<p><strong>BIO (Blocking I/O):</strong> 同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机 1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</p>
<p><strong>NIO (Non-blocking/New I/O):</strong> NIO 是一种同步非阻塞的 I/O 模型，在 Java 1.4 中引入了 NIO 框架，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 NIO 提供了与传统 BIO 模型中的 <code>Socket</code> 和 <code>ServerSocket</code> 相对应的 <code>SocketChannel</code> 和 <code>ServerSocketChannel</code> 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞 I/O 来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发</p>
<p><strong>AIO (Asynchronous I/O):</strong> AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步 IO 的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO 操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</p>
</blockquote>
<h2 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>ArrayList和LinkedList</p>
<blockquote>
<p>均不同步，均不保证线程安全。</p>
<p>ArrayList：底层由Object数组实现。插入元素到末尾O(1)，插入元素到指定位置O(n-i)。且支持高效的随机访问。</p>
<p>LinkedList：底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环)，插入元素到末尾O(1)，插入元素到指定位置O(n)，需要移动指针。</p>
<p>补充：<code>RandomAccess</code> 接口。里面没有任何定义，仅仅作为标识，是否支持快速随机访问。ArrayList实现了该接口而LinkedList没有。</p>
<p>Vector：List的古老实现类，底层使用Object数组实现，且保证线程安全。</p>
</blockquote>
<p>ArrayList扩容机制</p>
<blockquote>
<p>对于空参构造时，会初始化一个空数组，直到第一个元素被添加时，才会扩容到10。懒加载(但在jdk7及以前会直接初始化一个容量为10的数组)</p>
<p>对于需要扩容的过程。则是<code>ensureCapacityInternal()</code> -&gt; <code>ensureExplicitCapacity()</code> -&gt; <code>grow()</code></p>
<p>对于前两个方法，主要就是处理容量初始化和判断是否需要扩容。</p>
<p>对于核心<code>grow()</code>方法，需要扩容时，会首先扩容置原容量的1.5倍左右(<code>new = old + old &gt;&gt; 1</code>)，然后如果new满足需求，则会直接用new作为新容量，否则会将当前所需容量作为新容量。如果new已经大于了所给的<code>MAX_ARRAY_SIZE</code>即<code>Integer.MAX_VALUE - 8</code>，则会根据当前所需容量和<code>MAX_ARRAY_SIZE</code>进行比较吗，从而决定取<code>MAX_ARRAY_SIZE</code>或者<code>Integer.MAX_VALUE</code>。</p>
<p>tips：向 ArrayList 添加大量元素之前最好先使用<code>ensureCapacity</code> 方法，以减少增量重新分配的次数。</p>
</blockquote>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>HashMap vs HashTable</p>
<blockquote>
<p>HashMap: 线程不安全。支持<code>null</code>作为键和值，但只允许存在一个以<code>null</code>为键的键值对，允许多个键值对以<code>null</code>作为值。</p>
<p>HashTable: 线程安全(现在基本使用ConcurrentHashMap保证线程安全)，HashTable基本已经被淘汰。HashTable不允许<code>null</code>作为键或者值，会抛出<code>NullPointerException</code>异常。</p>
<p>① 创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证）。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</p>
</blockquote>
<p>HashSet</p>
<blockquote>
<p>底层由HashMap实现。</p>
<p>添加元素机制：当你把对象加入<code>HashSet</code>时，<code>HashSet</code> 会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p>
</blockquote>
<p>HashMap底层实现</p>
<blockquote>
<p>JDK1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。<strong>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</strong></p>
<p>JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</p>
</blockquote>
<p>HashMap长度为2的幂次方</p>
<blockquote>
<p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648到2147483647，前后加起来大概40亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个40亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ <code>(n - 1) &amp; hash</code>”。（n代表数组长度）。这也就解释了 HashMap 的长度为什么是2的幂次方。</p>
<p><code>(n - 1) &amp; hash</code>也就是<code>hash % (n - 1)</code>的快速版本。</p>
</blockquote>
<p>HashMap多线程情况下死循环的问题</p>
<blockquote>
<p>详情请查看：<a href="https://coolshell.cn/articles/9606.html" target="_blank" rel="noopener">https://coolshell.cn/articles/9606.html</a></p>
</blockquote>
<p>ConcurrentHashMap 和 Hashtable 的区别]</p>
<blockquote>
<p><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别主要体现在实现线程安全的方式上不同。</p>
<p><strong>底层数据结构：</strong> JDK1.7 的 <code>ConcurrentHashMap</code> 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，数组+链表/红黑二叉树。<code>Hashtable</code> 和 JDK1.8 之前的 <code>HashMap</code> 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</p>
<p><strong>实现线程安全的方式（重要）：</strong> ① <strong>在 JDK1.7 的时候，<code>ConcurrentHashMap</code>（分段锁）</strong> 对整个桶数组进行了分割分段(<code>Segment</code>)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 <strong>到了 JDK1.8 的时候已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。（JDK1.6 以后 对 <code>synchronized</code> 锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② <strong><code>Hashtable</code>(同一把锁)</strong> :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</p>
</blockquote>
<p>ConcurrentHashMap线程安全的具体实现方式/底层具体实现</p>
<blockquote>
<p>jdk1.7：首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p>
<p><strong><code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成</strong>。</p>
<p>Segment 实现了 <code>ReentrantLock</code>,所以 <code>Segment</code> 是一种可重入锁，扮演锁的角色。<code>HashEntry</code> 用于存储键值对数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个 <code>ConcurrentHashMap</code> 里包含一个 <code>Segment</code> 数组。<code>Segment</code> 的结构和 <code>HashMap</code> 类似，是一种数组和链表结构，一个 <code>Segment</code> 包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 是一个链表结构的元素，每个 <code>Segment</code> 守护着一个 <code>HashEntry</code> 数组里的元素，当对 <code>HashEntry</code> 数组的数据进行修改时，必须首先获得对应的 <code>Segment</code> 的锁。</p>
</blockquote>
<blockquote>
<p>jdk1.8：<code>ConcurrentHashMap</code> 取消了 <code>Segment</code> 分段锁，采用 CAS 和 <code>synchronized</code> 来保证并发安全。数据结构跟 HashMap1.8 的结构类似，数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）。<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>List</p>
<ul>
<li><code>Arraylist</code>： <code>Object[]</code>数组</li>
<li><code>Vector</code>：<code>Object[]</code>数组</li>
<li><code>LinkedList</code>： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</li>
</ul>
<p>Set</p>
<ul>
<li><code>HashSet</code>（无序，唯一）: 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素</li>
<li><code>LinkedHashSet</code>：<code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。有点类似于我们之前说的 <code>LinkedHashMap</code> 其内部是基于 <code>HashMap</code> 实现一样，不过还是有一点点区别的</li>
<li><code>TreeSet</code>（有序，唯一）： 红黑树(自平衡的排序二叉树)</li>
</ul>
<p>再来看看 <code>Map</code> 接口下面的集合。</p>
<p>Map</p>
<ul>
<li><code>HashMap</code>： JDK1.8 之前 <code>HashMap</code> 由数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li>
<li><code>LinkedHashMap</code>： <code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：<a href="https://www.imooc.com/article/22931" target="_blank" rel="noopener">《LinkedHashMap 源码详细分析（JDK1.8）》</a></li>
<li><code>Hashtable</code>： 数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的</li>
<li><code>TreeMap</code>： 红黑树（自平衡的排序二叉树</li>
</ul>
<h2 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h2><p>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</p>
<blockquote>
<p> new 一个 Thread，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<p><strong>总结： 调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</strong></p>
</blockquote>
<h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><p><strong>synchronized 关键字最主要的三种使用方式：</strong></p>
<blockquote>
<p><strong>1.修饰实例方法:</strong> 作用于当前对象实例加锁，进入同步代码前要获得 <strong>当前对象实例的锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.修饰静态方法:</strong> 也就是给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 <strong>当前 class 的锁</strong>。因为静态成员不属于任何一个实例对象，是类成员（ _static 表明这是该类的一个静态资源，不管 new 了多少个对象，只有一份_）。所以，如果一个线程 A 调用一个实例对象的非静态 <code>synchronized</code> 方法，而线程 B 需要调用这个实例对象所属类的静态 <code>synchronized</code> 方法，是允许的，不会发生互斥现象，<strong>因为访问静态 <code>synchronized</code> 方法占用的锁是当前类的锁，而访问非静态 <code>synchronized</code> 方法占用的锁是当前实例对象锁</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> staic <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.修饰代码块</strong> ：指定加锁对象，对给定对象/类加锁。<code>synchronized(this|object)</code> 表示进入同步代码库前要获得<strong>给定对象的锁</strong>。<code>synchronized(类.class)</code> 表示进入同步代码前要获得 <strong>当前 class 的锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">  <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ul>
<li><code>synchronized</code> 关键字加到 <code>static</code> 静态方法和 <code>synchronized(class)</code> 代码块上都是是给 Class 类上锁。</li>
<li><code>synchronized</code> 关键字加到实例方法上是给对象实例上锁。</li>
<li>尽量不要使用 <code>synchronized(String a)</code> 因为 JVM 中，字符串常量池具有缓存功能！</li>
</ul>
</blockquote>
<h3 id="MESI缓存一致性协议"><a href="#MESI缓存一致性协议" class="headerlink" title="MESI缓存一致性协议"></a>MESI缓存一致性协议</h3><p>多个cpu从主内存读取同一个数据到各自的高速缓存，当其中某个cpu修改了缓存里的数据，该数据会马上同步回主内存，其它cpu通过<strong>总线嗅探机制</strong>可以感知到数据的变化从而将自己缓存里的数据失效。从而使得cpu重新到主存中读取已经被更新的数据。</p>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><blockquote>
<p>是一种轻量级的同步机制，保证了可见性和有序性，通过内存屏障能够防止指令重排。</p>
</blockquote>
<p>保证可见性的原理：</p>
<blockquote>
<p>可见性：总线嗅探机制。</p>
<p>当volatile修饰的变量发生改变时，线程A会立刻将该变量从工作内存同步到共享内存中且强迫其他拥有该变量副本的线程(线程B)中的该变量失效，使其必须重新从主存中拷贝更新后的变量。</p>
<p>且有volatile修饰的共享变量进行写操作的时候多出一条带<code>lock</code>前缀的指令，且lock前缀的指令在多核处理器下会引发两件事情：</p>
<ol>
<li>将当前处理器缓存行的数据写回到系统内存。</li>
<li>这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。</li>
</ol>
</blockquote>
<p><strong>内存屏障</strong></p>
<p>内次屏障分为以下4类</p>
<table>
<thead>
<tr>
<th align="left">屏障类型</th>
<th align="left">指令示例</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">LoadLoad Barries</td>
<td align="left">Load1;LoadLoad;Load2</td>
<td align="left">确保Load1数据的装载先于Load2以及后续装载指令的装载。</td>
</tr>
<tr>
<td align="left">StoreStore Barries</td>
<td align="left">Store1;StoreStore;Store2</td>
<td align="left">确保Store1数据刷新到内存先于Store2以及后续存储指令的存储。</td>
</tr>
<tr>
<td align="left">LoadStore Barries</td>
<td align="left">Load1;LoadStore;Store2</td>
<td align="left">确保Load1数据的装载先于Store2数据刷新到内存以及后续存储指令的存储。</td>
</tr>
<tr>
<td align="left">StoreLoad Barries</td>
<td align="left">Store1;StoreLoad;Load2</td>
<td align="left">确保Store1数据刷新到内存先于Load2数据的装载以及后续装载指令的装载。</td>
</tr>
</tbody></table>
<p>volatile实现有序性：</p>
<blockquote>
<ul>
<li>在每个volatile写操作的前面插入一个StoreStore屏障。禁止前面的普通写和下面的volatile写重排序。</li>
<li>在每个volatile写操作的后面插入一个StoreLoad屏障。禁止前面的volatile写和下面可能有的volatile读的重排序。</li>
<li>在每个volatile读操作的后面插入一个LoadLoad屏障。禁止前面的volatile读和下面的普通读重排序。</li>
<li>在每个volatile读操作的后面再插入一个LoadStore屏障。禁止前面的volatile读和下面的普通写重排序。</li>
</ul>
</blockquote>
<p>synchronized保证可见性和有序性原理：</p>
<blockquote>
<p>可见性：</p>
<p>JMM关于synchronized的两条规定：</p>
<p>1）线程解锁前，必须把共享变量的最新值刷新到主内存中</p>
<p>2）线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新获取最新的值</p>
<p>（注意：加锁与解锁需要是同一把锁）</p>
<p>有序性：</p>
<p>因为synchronized是一种排他锁，所以同一时刻只有一个线程执行，保证加锁的代码是单线程的，遵循as-if-serial语义，因此能够保证有序性。</p>
</blockquote>
<p>volatile和synchronized同步使用的原因</p>
<blockquote>
<p>关于这个问题有一个很经典的例子，就是单例模式中的双重检查加锁对象初始化可能为null的问题，这个问题就是指令重排引起的。</p>
<p>具体来说就是synchronized虽然保证了原子性，但却没有保证指令重排序的正确性； </p>
<p>volatile使共享变量在线程的工作内存中修改后的值能够立即更新到进程主内存，即 volitile 可以保证共享变量值对所有线程的“可见性”，但是它不能保证原子性，</p>
<p>而且他还有一个很好的附加功能，那就是禁止指令重排。</p>
<p>将 synchronized 与 volatile 联合使用就可以解决这个问题</p>
</blockquote>
<h3 id="CAS-compare-and-swap"><a href="#CAS-compare-and-swap" class="headerlink" title="CAS(compare and swap)"></a>CAS(compare and swap)</h3><p>CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。</p>
<p>更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。</p>
<blockquote>
<p>缺点：会一直循环，开销较大。</p>
<p>对于一个共享变量执行操作时，可以通过循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS无法保证原子性，需要通过锁来保证原子性。</p>
</blockquote>
<h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><p>所谓ABA问题，就是CAS算法实现需要取出内存中某时刻的数据并在当下时刻比较并替换，这里存在一个时间差，使用AtomicStampedReference类可以解决ABA问题。这个类维护了一个“版本号”Stamp，在进行CAS操作的时候，不仅要比较当前值，还要比较版本号。只有两者都相等，才执行更新操作。</p>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><h2 id="MySQL调优"><a href="#MySQL调优" class="headerlink" title="MySQL调优"></a>MySQL调优</h2><p>redo log、undo log、binlog</p>
<p><img src="https://i.loli.net/2021/03/04/K8chDsaJLgeWFpU.png" alt="image.png"></p>
<ul>
<li>redo log是属于innoDB层面，binlog属于MySQL Server层面的，这样在数据库用别的存储引擎时可以达到一致性的要求。</li>
<li>redo log是物理日志，记录该数据页更新的内容；binlog是逻辑日志，记录的是这个更新语句的原始逻辑</li>
<li>redo log是循环写，日志空间大小固定；binlog是追加写，是指一份写到一定大小的时候会更换下一个文件，不会覆盖。</li>
<li>binlog可以作为恢复数据使用，主从复制搭建，redo log作为异常宕机或者介质故障后的数据恢复使用。</li>
</ul>
<p>事务特性：ACID。</p>
<p>事务隔离界别：</p>
<ol>
<li>读未提交（READ UNCOMMITTED）</li>
<li>读提交 （READ COMMITTED）</li>
<li>可重复读 （REPEATABLE READ）-&gt; 默认</li>
<li>串行化 （SERIALIZABLE）</li>
</ol>
<p>三范式：</p>
<p>1、不可分割    2、依赖于主键 主键约束    3、外键约束    BF、消除传递依赖</p>
<h3 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h3><p>存储引擎是针对<strong>表</strong>而言的，而不是针对<strong>整个数据库</strong>。即每个表可拥有不同的存储引擎。</p>
<p>种类：</p>
<blockquote>
<p>MyISAM：高速，在MySQL5.5版本前是作为默认存储引擎，但不支持事务。</p>
<p>InnoDB：作为MySQL 5.5版本后的默认存储引擎，支持事务和行级锁(行锁才能产生死锁)，比MyISAM稍慢。</p>
<p>Memory：内存存储引擎，效率很高，但数据容易丢失，用于临时表使用。</p>
</blockquote>
<p>顺序IO：追加操作。传输时间</p>
<p>随机IO：随机操作，可能写在随机的扇区。寻道时间+旋转时间+传输时间</p>
<p>MyISAM引擎：</p>
<blockquote>
<p><code>.frm</code>文件：存储表的结构定义</p>
<p><code>.MYD</code>文件：存储数据的文件</p>
<p><code>.MYI</code>文件：存储索引的文件</p>
<p>支持表锁，不支持行锁。不支持事务。</p>
<p>计算count：有专门存储count的地方。</p>
<p>主键索引为非聚集索引(索引文件和数据文件分离)</p>
</blockquote>
<p>InnoDB引擎：</p>
<blockquote>
<p><code>.frm</code>文件：存储表的结构定义</p>
<p><code>.ibd</code>文件：数据和索引均存储在该文件</p>
<p>支持表锁和行锁，也支持事务。</p>
<p>计算count：需要扫表。</p>
<p>因为数据文件本身就是按照B+树组织的索引结构文件。</p>
<p>主键索引为聚集索引。</p>
</blockquote>
<p>MyISAM索引B+树中的叶节点存储的data为：该索引对应数据的<strong>磁盘文件指针</strong></p>
<p>InnoDB索引B+树中的叶节点存储的data为：直接为该索引对应的数据，而不用再多一步指针</p>
<h3 id="MySQL性能分析"><a href="#MySQL性能分析" class="headerlink" title="MySQL性能分析"></a>MySQL性能分析</h3><ol>
<li>使用【慢查询功能】，获取查询时间较长的sql语句</li>
<li>【查看执行计划】，查看有问题的sql的执行计划</li>
<li>使用【<code>show profiles</code>】查看有问题的sql语句的性能使用情况</li>
</ol>
<h3 id="MySQL索引优化"><a href="#MySQL索引优化" class="headerlink" title="MySQL索引优化"></a>MySQL索引优化</h3><p>索引也很大，存储在磁盘上，且索引也就是一种数据结构(B+树)。</p>
<p>索引优劣</p>
<blockquote>
<p>优点：① 提高数据检索效率，降低IO成本；② 通过索引列对数据进行排序，降低排序成本和CPU消耗。(被索引的列会自动排序，对于<code>order by</code>等语句效率也会提高)</p>
<p>缺点：① 索引会占据磁盘空间；② 能提高查询效率但是会降低更新表的效率。比如每次对表进行增删改，需要对索引结构进行变更。</p>
</blockquote>
<p>常用索引：单列索引和组合索引。</p>
<blockquote>
<p>单列索引：<br>① 普通索引：MySQL基本索引类型，允许重复值和空值。<br>② 唯一索引：索引列值唯一，可包含空值。<br>③ 主键索引：特殊唯一索引，允许空值。</p>
<p>组合索引：<br>在表的多个字段组合上创建的一个索引。<br>组合索引的使用需要遵循最左前缀原则(最左匹配原则)。<br>且一般情况建议使用组合索引代替单列索引(主键索引除外)。</p>
</blockquote>
<p>MySQL的索引实现</p>
<blockquote>
<p><code>HASH</code>：无法进行范围查找，很少的存储引擎支持。Memory存储引擎支持。</p>
<p><code>B+ tree</code>：几乎都使用该数据结构存储索引。</p>
</blockquote>
<h4 id="聚集索引-IOT索引组织表-——InnoDB"><a href="#聚集索引-IOT索引组织表-——InnoDB" class="headerlink" title="聚集索引(IOT索引组织表)——InnoDB"></a>聚集索引(IOT索引组织表)——InnoDB</h4><p><strong>聚集索引即表数据和索引在一起的。</strong></p>
<p>MySQL在执行查询时，一般情况是通过<strong>优化器</strong>选择<strong>一个</strong>索引来进行使用的。</p>
<p>主键索引(聚簇索引)的叶子节点存储数据行，辅助索引只会存储主键值(不是地址值)。辅助索引可以有多个，主键索引有且只有一个。</p>
<p>即如果是非主键查询，需要搜索两次索引树(一次是辅助索引树，一次是主键索引树)，最终取得数据。</p>
<p>若没有主键：</p>
<blockquote>
<p>先寻找一个唯一非空列作为主键索引，如果还是没有。则自动生成一个隐藏列用作主键索引。</p>
</blockquote>
<p>InnoDB表为何必须要主键，且推荐使用整型自增主键而非UUID</p>
<blockquote>
<p>因为InnoDB需要<code>B+ tree</code>来存储数据，而<code>B+ tree</code>依赖于主键索引。</p>
<p>① <code>UUID</code>占据空间更大<br>② 查找或者插入时，<code>UUID</code>之间的比较和整型之间的比较相比效率较低<br>③ 当自增主键插入到<code>B+ tree</code>时，可以直接添加在叶子节点最右方，方便快捷分裂的可能也很小，而<code>UUID</code>插入时则可能会导致已经存储满的节点分裂和树的自动平衡，效率低。</p>
</blockquote>
<h4 id="非聚集索引-堆组织表-——MyISAM"><a href="#非聚集索引-堆组织表-——MyISAM" class="headerlink" title="非聚集索引(堆组织表)——MyISAM"></a>非聚集索引(堆组织表)——MyISAM</h4><p>由索引得到数据的地址然后从磁盘中进行读取。</p>
<h3 id="组合索引的使用"><a href="#组合索引的使用" class="headerlink" title="组合索引的使用"></a>组合索引的使用</h3><h4 id="为何使用组合索引"><a href="#为何使用组合索引" class="headerlink" title="为何使用组合索引"></a>为何使用组合索引</h4><p>为了<strong>节省mysql索引存储空间以及提升搜索性能</strong>，可建立组合索引(能使用组合索引就不使用单例索引)</p>
<p>例如：创建如下的一个组合索引，相当于建立了<code>col1 | col1 col2 | col1 col2 col3</code>三个索引∶</p>
<p>以下语句会创建—棵<code>B+ Tree</code> ，但是它相当于三棵索引树的功效</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">'table_name'</span> <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_name(<span class="string">'col1'</span>,<span class="string">'col2'</span>,<span class="string">'col3'</span>)</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<blockquote>
<p><strong>当查询条件为<code>... where col2 = xxx</code>时，是不会走索引的。</strong></p>
<p><strong>而查询条件为<code>... where col2 = xxx and col1 = xxx and col3 = xxx</code>是会由优化器优化查询条件的顺序从而走<code>col1 col2 col3</code>这个索引的。</strong></p>
</blockquote>
<h4 id="如何创建组合索引"><a href="#如何创建组合索引" class="headerlink" title="如何创建组合索引"></a>如何创建组合索引</h4><p>如何选择哪些列用来创建组合索引 ?</p>
<p>1．常出现在where条件中的列，建议用来创建组合索引，至于组合索引中的顺序，是很重要的。使用到最左前缀原则。但是因为MySQL中存在查询优化器，所以你的书写SQL条件的顺序，不一定是where条件顺序。</p>
<p>2．常出现在order by和group by语句中的列。最后按照顺序去创建组合索引。</p>
<p>3．常出现在select语句中的列，也建议按照顺序，创建组合索引。</p>
<h4 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h4><p>顾名思义，就是最左优先，这个最左是针对于组合索引和前缀索引，理解如下∶</p>
<ol>
<li><p>最左前缀匹配原则，非常重要的原则，MySQL会一直向右匹配直到遇到范围查询<code>(&gt;、&lt;、between、like)</code>就停止匹配，比如<code>a = 1 and b = 2 and c &gt; 3 and d = 4</code> 如果建立<code>(a, b, c, d)</code>顺序的索引，<code>d</code>是用不到索引的，如果建立<code>(a, b, d, c)</code>的索引，则都可以用到，<code>a, b, d</code>的顺序可以任意调整。</p>
</li>
<li><p><code>=</code>和<code>in</code>可以乱序，比如<code>a = 1 and b = 2 and c = 3</code>建立<code>(a, b, c)</code>索引可以任意顺序，MySQL的查询优化器会帮你优化成索引可以识别的形式</p>
</li>
</ol>
<h3 id="如何使用索引"><a href="#如何使用索引" class="headerlink" title="如何使用索引"></a>如何使用索引</h3><h4 id="哪些情况需要创建索引"><a href="#哪些情况需要创建索引" class="headerlink" title="哪些情况需要创建索引"></a>哪些情况需要创建索引</h4><ol>
<li>主键自动建立唯一索引</li>
<li>频繁作为查询条件的字段应该创建索引（业务）</li>
<li>多表关联查询中，关联字段应该创建索引</li>
<li>查询中统计或者分组字段，应该创建索引</li>
<li>查询中排序的字段，应该创建索引</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql创建组合索引的规先会对组合索引的最左边的，也就是第一个name字段的数据进行排序，在第一个字段的排序基础上，然后再对后面第二个的cid字段进行排序。其实就相当于实现了类似 order by name cid这样一种排序规则。</span><br></pre></td></tr></table></figure>

<h4 id="哪些情况不需要创建索引"><a href="#哪些情况不需要创建索引" class="headerlink" title="哪些情况不需要创建索引"></a>哪些情况不需要创建索引</h4><ol>
<li>表记录太少</li>
<li>经常进行增删改操作的表</li>
<li>更新的字段</li>
<li>where条件里使用频率不高的字段</li>
</ol>
<h3 id="查看执行计划"><a href="#查看执行计划" class="headerlink" title="查看执行计划"></a>查看执行计划</h3><h4 id="建表语句"><a href="#建表语句" class="headerlink" title="建表语句"></a>建表语句</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">create table user(</span><br><span class="line">	id int primary key,</span><br><span class="line">	name varchar(100),</span><br><span class="line">	age int,</span><br><span class="line">	sex char(1),</span><br><span class="line">	address varchar(100)</span><br><span class="line">);</span><br><span class="line">alter table user add index idx_name_age(name(10), age);</span><br><span class="line">alter table user add index idx_sex(sex);</span><br><span class="line"></span><br><span class="line">insert into user(id, name, age, sex, address) values (1, &apos;zhangsan&apos;, 20, &apos;0&apos;, &apos;致真大厦&apos;);</span><br></pre></td></tr></table></figure>

<p>特别说明</p>
<blockquote>
<p>name列的长度是varchar(100),但是创建索引的时候，指定的长度却是10，这是使用了<strong>前缀索引</strong>这个概念。</p>
<p>前缀索引一般是针对字符串。</p>
</blockquote>
<h5 id="MySQL前缀索引和索引选择性"><a href="#MySQL前缀索引和索引选择性" class="headerlink" title="MySQL前缀索引和索引选择性"></a>MySQL前缀索引和索引选择性</h5><p>有时候需要索引很长的字符列，这会让索引变得大且慢。通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但这样也会降低<strong>索引的选择性</strong>。<strong>索引的选择性是指不重复的索引值（也称为基数，cardinality)和数据表的记录总数的比值，范围从1/#T到1之间。</strong>索引的选择性越高则查询效率越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的行。唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p>
<p>一般情况下某个前缀的选择性也是足够高的，足以满足查询性能。对于BLOB，TEXT，或者很长的VARCHAR类型的列，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度。</p>
<p>诀窍在于要选择足够长的前缀以保证较高的选择性，同时又不能太长（以便节约空间）。前缀应该足够长，以使得前缀索引的选择性接近于索引的整个列。换句话说，前缀的”基数“应该接近于完整的列的”基数“。</p>
<p>前缀索引是一种能使索引更小，更快的有效办法，但另一方面也有其缺点：</p>
<p><strong>mysql无法使用其前缀索引做ORDER BY和GROUP BY，也无法使用前缀索引做覆盖扫描。</strong></p>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>MySQL提供了一个<code>EXPLAIN</code>命令，它可以对SELECT语句的执行计划进行分析，并输出SELECT执行的详细信息，以供开发人员针对性优化。</p>
<p>使用explain这个命令来查看一个这些SQL语句的执行计划，查看该SQL语句有没有使用上了索引，有没有做全表扫描，这都可以通过explain命令来查看。</p>
<p>可以通过explain命令深入了解MySQL的基于开销的优化器，还可以获得很多可能被优化器考虑到的访问策略的细节，以及当运行SQL语句时哪种策略预计会被优化器采用。</p>
<p>EXPLAIN命令用法十分简单，在SELECT语句前加上explain就可以了，例如:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><p>EXPLAIN命令的输出内容大致如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from user where id = 2\G</span><br><span class="line">******************** 1. row ************************</span><br><span class="line">id: 1</span><br><span class="line">select_type: SIMPLE</span><br><span class="line">table: user_info</span><br><span class="line">partitions: NULL</span><br><span class="line">type: const</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">key: PRIMARY</span><br><span class="line">key_len: 8</span><br><span class="line">ref: const</span><br><span class="line">row: 1</span><br><span class="line">filtered: 100.00</span><br><span class="line">Extra: NULL</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>各列含义</p>
<ul>
<li>id: SELECT查询的标识符．每个SELECT都会自动分配一个唯一的标识符.</li>
<li>select_type: SELECT查询的类型.</li>
<li>table: 查询的是哪个表</li>
<li>partitions: 匹配的分区</li>
<li>type: join类型</li>
<li>possible_keys: 此次查询中可能选用的索引</li>
<li>key: 此次查询中确切使用到的索引.</li>
<li>ref: 哪个字段或常数与key一起被使用</li>
<li>rows: 显示此查询一共扫描了多少行．这个是一个估计值.</li>
<li>filtered: 表示此查询条件所过滤的数据的百分比</li>
<li>extra: 额外的信息</li>
</ul>
<h5 id="type"><a href="#type" class="headerlink" title="type"></a>type</h5><p>显示的是单位查询的连接类型或者理解为访问类型，访问性能依次从好到差：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">system</span><br><span class="line">const</span><br><span class="line">eq_ref</span><br><span class="line">ref</span><br><span class="line">fulltext</span><br><span class="line">ref_or_null</span><br><span class="line">unique_subquery</span><br><span class="line">index_subquery</span><br><span class="line">range</span><br><span class="line">index_merge</span><br><span class="line">index</span><br><span class="line">ALL</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<blockquote>
<p>除了<code>All</code>之外，其他的<code>type</code>都可以用到索引<br>除了<code>index_merge</code>之外，其他的<code>type</code>只能用到一个索引<br>最少要使用到<code>range</code>级别</p>
</blockquote>
<h6 id="system"><a href="#system" class="headerlink" title="system"></a>system</h6><blockquote>
<p>只有一行数据，或者是空表时</p>
</blockquote>
<h6 id="const-重要"><a href="#const-重要" class="headerlink" title="const(重要)"></a>const(重要)</h6><blockquote>
<p>使用唯一索引或者主键，返回记录一定是1行记录的等值where条件时，通常type是const。其他数据库也叫做唯一索引扫描。</p>
</blockquote>
<h6 id="eq-ref-重要"><a href="#eq-ref-重要" class="headerlink" title="eq_ref(重要)"></a>eq_ref(重要)</h6><blockquote>
<p>此类型通常出现在多表的join查询，表示对于前表的每一个结果，都只能匹配到后表的一行结果．并且查询的比较操作通常是<code>=</code>，查询效率较高。</p>
<p>和<code>ref</code>相比，<code>eq_ref</code>主要针对唯一索引。</p>
</blockquote>
<h6 id="ref-重要"><a href="#ref-重要" class="headerlink" title="ref(重要)"></a>ref(重要)</h6><blockquote>
<p>针对非唯一性索引或者组合索引；使用等值( <code>=</code>)查询。或者是使用了最左前缀规则索引的查询。</p>
</blockquote>
<h6 id="fulltext"><a href="#fulltext" class="headerlink" title="fulltext"></a>fulltext</h6><blockquote>
<p>全文索引检索，要注意，全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql不管代价，优先选择使用全文索引</p>
</blockquote>
<h6 id="ref-or-null"><a href="#ref-or-null" class="headerlink" title="ref_or_null"></a>ref_or_null</h6><blockquote>
<p>与ref方法类似，只是增加了null值的比较。实际用的不多。</p>
</blockquote>
<h6 id="unique-subquery"><a href="#unique-subquery" class="headerlink" title="unique_subquery"></a>unique_subquery</h6><blockquote>
<p>用于where中的in形式子查论查询返回不重复值唯一值</p>
</blockquote>
<h6 id="index-subquery"><a href="#index-subquery" class="headerlink" title="index_subquery"></a>index_subquery</h6><blockquote>
<p>用于in形式子查询使用到了辅助索引或者in常数列表，子查询可能返回重复值，可以使用索引将子查询去重,</p>
</blockquote>
<h6 id="range-重要"><a href="#range-重要" class="headerlink" title="range(重要)"></a>range(重要)</h6><blockquote>
<p>索引范围扫描，常见于使用&gt;,&lt;,is null, between ,in ,like等运算符的查询中。</p>
</blockquote>
<h6 id="index-merge"><a href="#index-merge" class="headerlink" title="index_merge"></a>index_merge</h6><blockquote>
<p>表示查询使用了两个以上的索引，最后取交集或者并集，常见and , or的条件使用了不同的索引，官方排序这个在ref_or_null之后，但是实际上由于要读取所个索引，性能可能大部分时间都不如range</p>
</blockquote>
<h6 id="index-重要"><a href="#index-重要" class="headerlink" title="index(重要)"></a>index(重要)</h6><blockquote>
<p>select结果列中使用到了索引，type会显示为index。即查询的结果列就是索引列，可以直接从索引树上获得，而不用再回表查询。</p>
<p>索引扫描，把索引从头到尾扫一遍，常见于使用索引列就可以处理不需要读取数据文件的查询、可以使用索引排序或者分组的查询。</p>
</blockquote>
<h6 id="all-重要）"><a href="#all-重要）" class="headerlink" title="all(重要）"></a>all(重要）</h6><blockquote>
<p>这个就是全表扫描数据文件，然后再在server层进行过滤返回符合要求的记录。</p>
</blockquote>
<h5 id="extra-重要"><a href="#extra-重要" class="headerlink" title="extra(重要)"></a>extra(重要)</h5><p>这个列包含不适合在其他列中显示但十分重要的额外的信息，这个列可以显示的信息非常多，有几十种。</p>
<h6 id="using-index-重要）"><a href="#using-index-重要）" class="headerlink" title="using index(重要）"></a>using index(重要）</h6><blockquote>
<p>查询时不需要回表查询，直接通过索引就可以获取查询的结果数据。</p>
<ul>
<li>表示相应的SELECT查询中使用到了<strong>覆盖索引(Covering Index)</strong>，避免访问表的数据行，效率不错!（这也是为何大多公司要求尽量不使用<code>select *</code>的原因，因为无法做到索引覆盖，会导致回表查询）</li>
<li>如果同时出现<code>Using Where</code>，说明索引被用来执行查找素引键值</li>
<li>如果没有同时出现<code>Using Where</code>，表明索引用来读取教据而非执行查找动作。</li>
</ul>
</blockquote>
<h6 id="using-where-重要"><a href="#using-where-重要" class="headerlink" title="using where(重要)"></a>using where(重要)</h6><blockquote>
<p>表示Mysql将对storage engine提取的结果进行过滤，过滤条件字段无索引;</p>
<p>如下图，对于该查询语句，使用到了主键索引，所以在innodb存储引擎中会进行第一步过滤，然后对于<code>name = &#39;lisi&#39;</code>则是在MySQL server层进行的第二次过滤，如果在server层进行了第二次过滤，则会显示——<code>using where</code>。</p>
<p>也可以将这两层分别对应数据库的逻辑分页和物理分页进行理解。</p>
</blockquote>
<blockquote>
<p>同时在5.6版本之后，推出了ICP索引下推，即如果下图中<code>name</code>也有索引，则会将其过滤也放在底层进行过滤，进而增大效率。</p>
</blockquote>
<p><img src="https://i.loli.net/2021/02/05/6zs9MQZ4KPrLpFc.png" alt="image.png"></p>
<h6 id="using-index-condition-重要"><a href="#using-index-condition-重要" class="headerlink" title="using index condition(重要)"></a>using index condition(重要)</h6><blockquote>
<p>Using index condition 会先条件过滤索引，过滤完索引后找到所有符合索引条件的数据行，随后用WHERE 子句中的其他条件去过滤这些数据行;</p>
<p>因为MySQL的架构原因，分成了server层和引擎层，才有所谓的“下推”的说法。所以ICP ( Index ConditionPushdown，索引下推）其实就是实现了index filter技术，将原来的在server层进行的table filter中可以进行index filter的部分，在引擎层面使用index filter进行处理，不再需要回表进行table filter。</p>
<p>查询条件中分为限制条件和检查条件，5.6之前，存储引擎只能根据限制条件扫描数据并返回，然后server层根据检查条件进行过滤再返回真正符合查询的数据。5.6.x之后支持<strong>ICP</strong>特性，可以把检查条件也下推到存储引擎层，不符合检查条件和限制条件的数据，直接不读取，这样就大大减少了存储引擎扫描的记录数星。</p>
</blockquote>
<h6 id="using-filesort-重要"><a href="#using-filesort-重要" class="headerlink" title="using filesort(重要)"></a>using filesort(重要)</h6><blockquote>
<ul>
<li>排序时无法使用到索引时，就会出现这个。常见于order by和group by语句中。</li>
<li>说明MySQL会使用一个外部的索引排序，而不是按照索引顺序进行读取。</li>
<li>MySQL中无法利用索引完成的排序操作称为“文件排序”。</li>
</ul>
</blockquote>
<h6 id="using-temporary"><a href="#using-temporary" class="headerlink" title="using temporary"></a>using temporary</h6><blockquote>
<ul>
<li>表示使用了临时表存储中问结果。</li>
<li>MySQL在对查询结果order by和group by时使用临时表</li>
<li>临时表可以是内存临时表和磁盘临时表，执行计划中看不出来，需要查看status变量，used_tmp_table，used_tmp_disk_table才能看出来。</li>
</ul>
</blockquote>
<h6 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h6><blockquote>
<p>在select部分使用了distinct关键字</p>
</blockquote>
<h6 id="no-tables-used"><a href="#no-tables-used" class="headerlink" title="no tables used"></a>no tables used</h6><blockquote>
<p>不带from字句的查询或者From dual查询</p>
</blockquote>
<h3 id="索引失效分析"><a href="#索引失效分析" class="headerlink" title="索引失效分析"></a>索引失效分析</h3><h4 id="案例环境"><a href="#案例环境" class="headerlink" title="案例环境"></a>案例环境</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">staffs员工表 三条记录</span><br><span class="line">+----+------+-----+---------+---------------------+</span><br><span class="line">| id | name | age | pos     | add_time            |</span><br><span class="line">+----+------+-----+---------+---------------------+</span><br><span class="line">| 1  | z3   | 22  | manager | 2016-12-09 09:31:34 |</span><br><span class="line">| 2  | July | 23  | dev     | 2016-12-09 09:31:34 |</span><br><span class="line">| 3  | 2000 | 23  | dev     | 2016-12-09 09:31:34 |</span><br><span class="line">+----+------+-----+---------+---------------------+</span><br><span class="line"></span><br><span class="line">索引:</span><br><span class="line">主键索引(id)和联合索引(name, age, pos)</span><br></pre></td></tr></table></figure>

<h4 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h4><blockquote>
<p>1、全值匹配我最爱(等值匹配且为全值)<br>2、最佳左前缀法则<br>3、不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描<br>4、存储引擎不能使用索引中范围条件右边的列，即在<code>where</code>语句中范围条件右边的列，无法使用索引。<br>5、尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致))，减少<code>select *</code><br>6、mysql在使用不等于(<code>!=</code>或者<code>&lt;&gt;</code>)的时候无法使用索引会导致全表扫描|<br>7、<code>is null ,is not null</code>也无法使用索引<br>8、<code>like</code>以通配符开头(<code>&#39;%abc...&#39;</code>)Mysql索引失效会变成全表扫描的操作<br>9、字符串不加单引号索引失效<br>10、少用<code>or</code>，用它来连接时会索引失效</p>
</blockquote>
<h3 id="MySQL性能优化"><a href="#MySQL性能优化" class="headerlink" title="MySQL性能优化"></a>MySQL性能优化</h3><h4 id="服务器层面优化"><a href="#服务器层面优化" class="headerlink" title="服务器层面优化"></a>服务器层面优化</h4><p>将数据保存在内存中，保证从内存读取数据。</p>
<ul>
<li><p>设置足够大的<code>innodb_buffer_pool_size</code>，将数据读到内存中(建议设置为总内存的3/4或者4/5)</p>
</li>
<li><pre><code>可通过下面命令查看
show global status like &apos;innodb_buffer_pool_pages_%&apos;
若innodb_buffer_pool_pages_free为0则表示buffer pool已被用光
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### 内存预热</span><br><span class="line">将磁盘数据在MysQL Server启动的时候，读取到内存中。</span><br><span class="line"></span><br><span class="line">##### 降低磁盘写入次数</span><br><span class="line"></span><br><span class="line">* 对于生产环境来说，很多日志是不需要开启的，比如∶通用查询日志、慢查询日志、错误日志</span><br><span class="line"></span><br><span class="line">* 使用足够大的写入缓存**innodb_log_file_size**</span><br></pre></td></tr></table></figure>
推荐 innodb_log_file_size设置为0.25 * innodb_buffer_pool_size
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 设置合适的**innodb_flush_log_at_trx_commit**，和日志落盘有关系。</span><br><span class="line"></span><br><span class="line">##### 提高磁盘读写</span><br><span class="line"></span><br><span class="line">* 可以考虑使用SSD硬盘，不过得考虑成本是否合适。</span><br><span class="line"></span><br><span class="line">#### SQL设计层面优化</span><br><span class="line"></span><br><span class="line">具体优化方案如下:</span><br><span class="line"></span><br><span class="line">* 设计中间表，一般针对于统计分析功能，或者实时性不高的需求( OLTP、OLAP )</span><br><span class="line">* 为减少关联查询，创建合理的冗余字段(考虑数据库的三范式和查询性能的取舍，创建冗余字段还需要注意数据—致性问题)</span><br><span class="line">* 对于字段太多的大表，考虑垂直拆表(比如一个表有100多个字段)</span><br><span class="line">* 对于表中经常不被使用的字段或者存储数据比较多的字段，考虑拆表（比如商品表中会存储商品介绍，此时可以将商品介绍字段单独拆解到另一个表中，使用商品ID关联)</span><br><span class="line">* 每张表建议都要有一个主键(主键索引），而且主键类型最好是int类型，建议自增主键(不考虑分布式系统的情况下)。</span><br><span class="line"></span><br><span class="line">#### SQL语句优化(开发人员)</span><br><span class="line"></span><br><span class="line">##### 索引优化</span><br><span class="line"></span><br><span class="line">* 为搜索字段(where中的条件)、排序字段、 select查询列，创建合适的索引，不过要考虑数据的业务场景∶查询多还是增删多?</span><br><span class="line">* 尽量建立组合索引并注意组合索引的创建顺序，按照顺序组织查询条件、尽量将筛选粒度大的查询条件放到最左边。</span><br><span class="line">* 尽量使用覆盖索引，SELECT语句中尽量不要使用\*。</span><br><span class="line">* order by、group by语句要尽量使用到索引</span><br><span class="line"></span><br><span class="line">##### 其他优化</span><br><span class="line"></span><br><span class="line">* 尽量不使用count(\*)、尽量使用count(主键)</span><br></pre></td></tr></table></figure>
COUNT(*): 查询行数，是会遍历所有的行、所有的列。
</code></pre></li>
</ul>
<p>COUNT(列): 查询指定列不为null的行数(过滤null)，如果列可以为空，则COUNT (<em>)不等于COUNT(列)，除非指定的列是非空的列才会让COUNT (</em>)等于COUNT(列)</p>
<p>COUNT(伪列): 比如COUNT (1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* JOIN两张表的关联字段建立索引，而且最好字段类型是一样的。</span><br></pre></td></tr></table></figure>
<p>SELECT * FROM orders o LEFT OIN user u on o.user_id = u.id</p>
<p>orders表中的user_id和user表中的id，类型要一致</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* WHERE条件中尽量不要使用1=1、not in语句（建议使用not exists ) .</span><br><span class="line">* 不用MySQL内置的函数，因为内置函数不会建立查询缓存。</span><br></pre></td></tr></table></figure>
<p>SQL查询语句和查询结果都会在第一次查询只会存储到MySQL的查询缓存中，如果需要获取到查询缓存中的查询结果，查询的SQL语句必须和第一次的查询SQL语句一致。</p>
<p>SELECT * FROM user where birthday = now()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 分布式事务</span><br><span class="line"></span><br><span class="line">两个基本场景</span><br><span class="line"></span><br><span class="line">&gt; 多数据源：多个数据库之间的一个事务操作。跨库事务指的是，一个应用某个功能需要操作多个库，不同的库中存储不同</span><br><span class="line">&gt; 的业务数据。在真实应用场景下，一个业务操作多个库也是比较常见的，那么多个数据库是之间是互相不可见的，如何保证数据库的一致性呢?此时就必须使用分布式事务的解决方案。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 多服务：多台服务器之间的事务操作。事务分布在不同服务器上，要求不同服务器事务要么都成功要么都失败，称为分布式事务。</span><br><span class="line"></span><br><span class="line">分布式事务就是为了保证不同资源服务器的数据一致性。</span><br><span class="line"></span><br><span class="line">### 分布式事务事务模型——DTP模型</span><br><span class="line"></span><br><span class="line">1)应用程序(Application Program : AP): 定义事务边界(事务开始，结束)</span><br><span class="line"></span><br><span class="line">2)资源管理器(Resource Manager: RM): 任何用来存储数据的服务。</span><br><span class="line"></span><br><span class="line">3)事务管理器(Transaction Manager : TM ): 监控事务进度，负责事务提交，回滚。</span><br><span class="line"></span><br><span class="line">4)通信资源管理(Communcation Resource Manager : CRM )</span><br><span class="line"></span><br><span class="line">5)通信协议(负责事务模型之间的通信协议)</span><br><span class="line"></span><br><span class="line">当一个DTP模型中，存在多个模型实例时，会形成一种树形调用关系，叫做**全局事务树形结构(GlobalTransaction Tree Structure)**。</span><br><span class="line"></span><br><span class="line">### 分布式事务事务模型-XA规范</span><br><span class="line">XA规范的最主要的作用是，就是定义了RM-TM的交互接口</span><br><span class="line"></span><br><span class="line">XA∶定义了TM和RM交互接口的规范。（事务注册，开始，回滚，事务结束...)</span><br><span class="line"></span><br><span class="line">XA标准∶存储数据的服务都开发了支持分布式事务接口规范:XA(MySQL，RocketMQ)</span><br><span class="line"></span><br><span class="line">TM事务管理器也必须按照XA规范来进行调用事务控制接口。</span><br><span class="line"></span><br><span class="line">### 分布式事务事务模型-2PC(2阶段提交)</span><br><span class="line"></span><br><span class="line">两阶段提交协议(Two Phase Commit )，XA规范对其进行了优化。而从字面意思来理解，TwoPhase Commit，就是将提交(commit)过程划分为2个阶段(Phase):</span><br><span class="line"></span><br><span class="line">[![https://img.rruu.net/image/601e3519d55f7](https://img.rruu.net/image/601e3519d55f7)](https://img.rruu.net/image/601e3519d55f7)</span><br><span class="line"></span><br><span class="line">### 分布式事务事务模型-3PC(3阶段提交)</span><br><span class="line"></span><br><span class="line">三阶段提交（3PC)[Three-phase commit]，是二阶段提交（2PC)的改进版本。与两阶段提交不同的是，三阶段提交有两个改动点</span><br><span class="line"></span><br><span class="line">* 引入超时机制。同时在协调者和参与者中都引入超时机制。</span><br><span class="line">* 在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。也就是说，除了引入超时机制之外，3PC把2PC的准备阶段再次一分为二，这样三阶段提交就有CanCommit、PreCommit、DoCommit三个阶段</span><br><span class="line"></span><br><span class="line">### 分布式事务解决方案-JTA</span><br><span class="line"></span><br><span class="line">Java事务APl ( JTA : Java Transaction APl ）和它的同胞Java事务服务（JTS : Java Transaction Service )，为J2EE平台提供了分布式事务服务(distributed transaction)的能力。某种程度上，可以认为JTA规范是XA规范的Java版，其把XA规范中规定的DTP模型交互接口抽象成Java接口中的方法，并规定每个方法要实现什么样的功能。</span><br></pre></td></tr></table></figure>
<p>Java事务JTA分布式事务控制规范:<br>JTA是XA接口规范的Java版本。控制分布式事务。<br>1、AP<br>2、Application Server (Jboss,weblogic,websphere等等)<br>3、TM<br>4、RM</p>
<p>Java分布式事务:Application Server 实现XA接口的规范，在服务内部自己根据XA规范，开发了一套分布式事务控逻辑TM,把TM集成到jboss,weblogic</p>
<p>问题:TOMCAT服务器没有实现XA接口规范，不能自己控制分布式事务?<br>    第三方框架: atomikos —- xa</p>
<p>Atomiko主要用来控制多数据源这样的分布式事务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 分布式事务解决方案-LCN</span><br><span class="line"></span><br><span class="line">TX-LCN由两大模块组成，TxClient、TxManager，TxClient作为模块的依赖框架，提供TX-LCN的标准支持，TxManager作为分布式事务的控制器.</span><br><span class="line"></span><br><span class="line">事务发起方或者参与都由TxClient端来控制</span><br><span class="line"></span><br><span class="line">原理:</span><br><span class="line"></span><br><span class="line">&gt; LCN模式是通过代理Connection的方式实现对本地事务的操作，然后在由TxManager统一协调控制事务。当本地事务提交回滚或者关闭连接时将会执行假操作，该代理的连接将由LCN连接池管理。</span><br><span class="line"></span><br><span class="line">特点:</span><br><span class="line"></span><br><span class="line">&gt; 该模式对代码的嵌入性为低。</span><br><span class="line">&gt; 该模式仅限于本地存在连接对象且可通过连接对象控制事务的模块。</span><br><span class="line">&gt; 该模式下的事务提交与回滚是由本地事务方控制，对于数据一致性上有较高的保障。该模式缺陷在于代理的连接需要随事务发起方一起释放连接，增加了连接占用的时间。</span><br><span class="line"></span><br><span class="line">### 分布式事务解决方案-TCC</span><br><span class="line"></span><br><span class="line">TCC——事务补偿机制，控制分布式事务的实现。</span><br><span class="line"></span><br><span class="line">TCC事务机制相对于传统事务机制(X/Open XA Two-Phase-Commit)，其特征在于它不依赖资源管理器(RM)对XA的支持，而是通过对(由业务系统提供的）业务逻辑的调度来实现分布式事务。</span><br><span class="line"></span><br><span class="line">主要由三步操作∶</span><br><span class="line"></span><br><span class="line">&gt; Try:尝试执行业务</span><br><span class="line">&gt; Confirm:确认执行业务</span><br><span class="line">&gt; Cancel:取消执行业务。</span><br><span class="line"></span><br><span class="line">特点:</span><br><span class="line"></span><br><span class="line">&gt; 该模式对代码的嵌入性高，要求每个业务需要写三种步骤的操作。该模式对有无本地事务控制都可以支持使用面广。</span><br><span class="line">&gt; 数据一致性控制几乎完全由开发者控制，对业务开发难度要求高。</span><br><span class="line"></span><br><span class="line">### 分布式事务解决方案-RocketMQ</span><br><span class="line">实际系统的开发过程中，可能服务间的调用是异步的(MQ消息中间件异步通知)、那么如何保证这种异步的各个服务间的分布式事务呢?</span><br><span class="line"></span><br><span class="line">### 分布式事务解决方案-尽最大可能通知</span><br><span class="line"></span><br><span class="line">最大努力通知型(Best-effort delivery)是最简单的一种柔性事务，适用于一些最终一致性时间敏感度低的业务，且被动方处理结果不影响主动方的处理结果。典型的使用场景∶如银行通知、商户通知等。最大努力通知型的实现方案，一般符合以下特点:</span><br><span class="line"></span><br><span class="line">&gt; 不可靠消息∶业务活动主动方，在完成业务处理之后，向业务活动的被动方发送消息，直到通知N次后不再通知，允许消息丢失(不可靠消息)。</span><br><span class="line">&gt; 定期校对∶业务活动的被动方，根据定时策略，向业务活动主动方查询(主动方提供查询接口)，恢复丢失的业务消息。</span><br><span class="line"></span><br><span class="line">### CAP</span><br><span class="line"></span><br><span class="line">C和A无法同时存在。</span><br><span class="line"></span><br><span class="line">因为在保证强一致性的时候，主节点会将从节点锁定并进行同步来保证一致性，此时用户请求则无法立刻得到结果，违反可用性。</span><br><span class="line"></span><br><span class="line">因此存在的组合只有CP和AP模型。因此选型也就只有强一致性(2PC)和最终一致性(MQ、TCC)两种选择。</span><br><span class="line"></span><br><span class="line">### BASE理论</span><br><span class="line">BASE是Basically Available (基本可用)、Soft state(软状态）和Eventually consistent (最终一致性)三个短语的缩写。</span><br><span class="line"></span><br><span class="line">* 基本可用(Basically Available )：指分布式系统在出现不可预知故障的时候，允许损失部分可用性。</span><br><span class="line">* 软状态( Soft State )：指允许系统中的数据存在中间状态，并认该中间状态的存在不会影响系统的整体可用性。</span><br><span class="line">* 最终一致(Eventual Consistency )：强调的是所有的数据更新操作，在经过一段时间的同步之后，最终都能够达到一个一致的状态</span><br><span class="line"></span><br><span class="line">### 柔性事务</span><br><span class="line"></span><br><span class="line">&gt; 最大努力通知（非可靠消息、定期校对)</span><br><span class="line">&gt;</span><br><span class="line">&gt; 可靠消息最终一致性（异步确保型)</span><br><span class="line">&gt;</span><br><span class="line">&gt; TCC(两阶段型、补偿型)</span><br><span class="line"></span><br><span class="line">## IO多路复用</span><br><span class="line"></span><br><span class="line">### select</span><br><span class="line"></span><br><span class="line">非多线程，是单线程，多线程存在上下文切换的开销。</span><br><span class="line"></span><br><span class="line">简单思路：死循环中遍历所有fd文件描述符，获得其中有数据的部分进行读取和处理。</span><br><span class="line"></span><br><span class="line">具体实现：</span><br><span class="line"></span><br><span class="line">&gt; ①首先获得所有的fd</span><br><span class="line">&gt; ②在一个死循环中，将所有fd拷入一个rset中(rset是一个位图bitmap)，将fd对应的编号置为1</span><br><span class="line">&gt; ③调用select函数，从用户态拷贝rset到内核态，并进行阻塞等待，监听所有fd，直到有对应的有数据到来</span><br><span class="line">&gt; ④将有数据到来的fd(可能会有多个)进行置位，是在rset中置位，fd本身没有变化</span><br><span class="line">&gt; ⑤再次遍历rset，读取其中被置位的fd的数据，并进行相应处理。再次进入死循环</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line"></span><br><span class="line">&gt; 位图的大小是有限的，默认1024位</span><br><span class="line">&gt;</span><br><span class="line">&gt; rset不能重用，内核态对其进行了改变，导致每次需要重置rset并重新拷贝fd</span><br><span class="line">&gt;</span><br><span class="line">&gt; 用户态到内核态的转换和拷贝开销较大</span><br><span class="line">&gt;</span><br><span class="line">&gt; 在内核态监听完成并置位rset后，还需要再次遍历rset，时间开销较大</span><br><span class="line"></span><br><span class="line">### poll</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">struct pullfd &#123;</span><br><span class="line">	int fd;</span><br><span class="line">	short events; // 初始化为需要监听的事件 如 PULLIN</span><br><span class="line">	short revents; // 用于置位使用 </span><br><span class="line">&#125;</span><br><span class="line">// 不再使用bitmap，而是采用自定义结构体</span><br></pre></td></tr></table></figure>

<p>具体实现和select类似，相同点和区别在于：</p>
<blockquote>
<p>相同点：①都是需要从用户态拷贝到内核态并由内核进行监听处理，开销较大②都需要对存储fd的数据结构进行二次遍历③也是阻塞调用</p>
<p>①未使用bitmap进行存储，而是采用pullfd[]数组进行存储<br>②内核监听到数据时，不再对pullfd[]整体置位，只对revents成员置位，这样使得pullfd[]可以重用。<br>③内核监听完成后，对pullfd进行遍历时，如果revents被置位，则进行数据读取和处理，同时将revents重新赋值为0。<br>④存储的数量远大于bitmap的限制1024位。</p>
</blockquote>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p><img src="https://i.loli.net/2021/03/04/Y3mdEcJ64DyvZe2.png" alt="image.png"></p>
<p>同样存在一个结构体epoll_event，包含fd和event数据，但不包含revents</p>
<p>具体实现：</p>
<blockquote>
<p>①准备数据，通过epoll_ctl将fd和events拷贝进入一个由epoll_create创建的白板中，同时还会在内核创建一个红黑树和一个链表<br>②同样通过死循环，然后调用epoll_wait方法，同时上文提到的白板是并不是用户态和内核态共享的<strong>(b站视频有误)</strong><br>③通过epoll_wait方法，内核通过监听，将fd进行”置位”，这里的置位是指重排序，将有数据的fd放到链表前面，然后返回有数据的fd数量<br>④通过返回值再进行遍历，省去了之前O(n)复杂度的再次遍历，然后对数据进行读取和处理</p>
</blockquote>
<p>两种工作模式</p>
<blockquote>
<p>LT模式</p>
<p>fd可读之后，如果服务程序读走一部分就结束此次读取，LT模式下该文件描述符仍然可读<br>fd可写之后，如果服务程序写了一部分就结束此次写入，LT模式下该文件描述符也仍然可写</p>
<p>ET模式</p>
<p>fd可读之后，如果服务程序读走一部分就结束此次读取，ET模式下该文件描述符是不可读，需要等到下次有数据到达时才可变为可读，所有我们要保证循环读取数据，以确保把所有数据读出<br>fd可写之后，如果服务程序写了一部分就结束此次写入，ET模式下该文件描述符是不可写的，我们要保证写入数据，确保把数据写满</p>
</blockquote>
<p>redis和nginx、java的nio在linux下都是通过epoll实现。</p>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="JVM常识"><a href="#JVM常识" class="headerlink" title="JVM常识"></a>JVM常识</h3><h4 id="程序的执行方式"><a href="#程序的执行方式" class="headerlink" title="程序的执行方式"></a>程序的执行方式</h4><blockquote>
<p>静态编译、动态编译和动态解释执行。</p>
<p>注意：此处的编译是指编译成OS能直接运行的机器码。</p>
</blockquote>
<h4 id="JVM的运行模式"><a href="#JVM的运行模式" class="headerlink" title="JVM的运行模式"></a>JVM的运行模式</h4><p>JVM有两种运行模式: Server模式与Client棒式。</p>
<p>两种模式的区别在于:</p>
<ul>
<li>Client模式启动速度较快，Server模式启动较慢;</li>
<li>但是启动进入稳定期长期运行之后Server模式的程序运行速度比Client要快很多。</li>
<li>因为Server模式启动的JVM采用的是重量级的虚拟机，对程序采用了更多的优化;而Client模式启动的VM采用的是轻量级的虚拟机。所以Server启动慢，但稳定后速度比Client远远要快。</li>
</ul>
<h3 id="JVM架构理解"><a href="#JVM架构理解" class="headerlink" title="JVM架构理解"></a>JVM架构理解</h3><p><img src="https://img.rruu.net/image/601e6713dd864" alt></p>
<h3 id="JVM-程序执行流程"><a href="#JVM-程序执行流程" class="headerlink" title="JVM 程序执行流程"></a>JVM 程序执行流程</h3><p>java编译成字节码、动态编译和解释为机器码的过程分析</p>
<p><img src="https://img.rruu.net/image/601e6e43cd20a" alt></p>
<p>编译器和解释器的协调工作流程：</p>
<p><img src="https://img.rruu.net/image/601e6ec3e78e5" alt></p>
<p>在部分商用虚拟机中(如HotSpot),Java程序最初是通过解释器(Interpreter)进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为”热点代码”。为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器(Just In Time Compiler，下文统称IT编译器)。</p>
<p>由于Java虚拟机规范并没有具体的约束规则去限制即使编译器应该如何实现，所以这部分功能完全是与虚拟机具体实现相关的内容，如无特殊说明，我们提到的编译器、即时编译器都是指Hotspot虚拟机内的即时编译器，虚拟机也是特指HotSpot虚拟机。</p>
<p>我们的JIT是属于动态编译方式的，动态编译（dynamic compilation)指的是”在运行时进行编译”;与之相对的是事前编译(ahead-of-time compilation，简称AOT)，也叫静态编译(static compilation)。</p>
<p>JIT编译(just-in-time compilation)狭义来说是当某段代码即将第一次被执打时进行编译，因而叫”即时编译”。JIT编译是动态编译的一种特例。]JIT编译一词后来被泛化，时常与动态编译等价;但要注意广义与狭义的JIT编译所指的区别。</p>
<h3 id="JIT的使用"><a href="#JIT的使用" class="headerlink" title="JIT的使用"></a>JIT的使用</h3><ul>
<li>为何HotSpot需要使用解释器和编译器并存的架构?</li>
<li>JVM为什么要实现两个不同的即时编译器?</li>
<li>程序何时会使用解释器执行?何时会使用编译器执行?</li>
<li>哪些程序代码会被编译成为本地代码?如何编译?</li>
<li>JAVA代码的执行效率就一定比C,C++静态执行的执行差?JAVA代码解析执行有何优势?</li>
</ul>
<h4 id="为什么要使用解释器与编译器并存的架构"><a href="#为什么要使用解释器与编译器并存的架构" class="headerlink" title="为什么要使用解释器与编译器并存的架构"></a>为什么要使用解释器与编译器并存的架构</h4><p>尽管并不是所有的Java虚拟机都采用解释器与编译器并存的架构，但许多主流的商用虚拟机(如HotSpot)，都同时包含解释器和编译器。</p>
<p><strong>解释器与编译器特点</strong></p>
<ul>
<li>当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取更高的执行效率</li>
<li>当程序运行环境中内存资源限制较大(如部分嵌入式系统中)，可以使用解释器执行节约内存，反之可以使用编译执行来提升效率。</li>
</ul>
<p><strong>编译的时间开销</strong></p>
<p>解释器的执行，抽象的看是这样的:<br><strong><em>输入的代码-&gt;[解释器解释执行]-&gt;执行结果</em></strong></p>
<p>而要JIT编译然后再执行的话，抽象的看则是:<br><strong><em>输入的代码→&gt;[编译器编译]-&gt;编译后的代码→&gt;[执行]-&gt;执行结果</em></strong></p>
<p>说JIT比解释快，其实说的是”执行编译、代码”比”解释器解释执行”要快，并不是说”编译”这个动作比”解释”这个动作快。JIT编译再怎么快，至少也比解释执行一次略慢一些，而要得到最后的执行结果还得再经过一个”执行编译后的代码”的过程。所以，对“只执行一次””的代码而言，解释执行其实总是比JIT编译执行要快。</p>
<p>怎么算是”只执行一次的代码”呢?粗略说，下面两个条件同时满足时就是严格的“只执行一次”<br>1、只被调用一次，例如类的构造器(class initializer，<clinit>())<br>2、没有循环<br>对只执行一次的代码做JIT编译再执行，可以说是得不偿失。<br>对只执行少量次数的代码，JIT编译带来的执行速度的提升也未必能抵消掉最初编译带来的开销。</clinit></p>
<p><strong><em>只有对频繁执行的代码，JIT编译才能保证有正面的收益。</em></strong></p>
<p><strong>编译的空间开销</strong></p>
<p>对一般的Java方法而言，编译后代码的大小相对于字节码的大小，膨胀比达到10x是很正常的。同上面说的时间开销一样，这里的空间开销也是，只有对执行频繁的代码才值得编译，如果把所有代码都编译则会显著增加代码所占空间，导致”代码爆炸”。</p>
<p><strong><em>这也就解释了为什么有些VM会选择不总是做JIT编译，而是选择用解释器 + JIT编译器的混合执行引擎。</em></strong></p>
<h4 id="为何要实现两个不同的即时编译器"><a href="#为何要实现两个不同的即时编译器" class="headerlink" title="为何要实现两个不同的即时编译器"></a>为何要实现两个不同的即时编译器</h4><p><font color="red">HotSpot虚拟机中内置了两个即时编译器:Client Complier和Server Complier0，简称为C1、C2编译器，分别用在客户端和服务端。</font></p>
<p>目前主流的HotSpot虚拟机中默认是采用解释器与其中一个编译器直接配合的方式工作。程序使用哪个编译器，取决于<strong>虚拟机运行的模式</strong>。HotSpot虚拟机会根据自身版本与宿主机器的硬件性能自动选择运行模式，用户也可以使用”-client”或”-server”参数去强制指定虚拟机运行在Client模式或Server模式。</p>
<p>用Client Complier获取更高的<strong>编译速度</strong>，用Server Complier来获取更好的<strong>编译质量</strong>。为什么提供多个即时编译器与为什么提供多个垃圾收集器类似，都是为了适应不同的应用场景。</p>
<h4 id="哪些程序代码会被即时编译"><a href="#哪些程序代码会被即时编译" class="headerlink" title="哪些程序代码会被即时编译"></a>哪些程序代码会被即时编译</h4><p>程序中的代码只有是热点代码时，才会编译为本地代码，那么什么是<strong>热点代码</strong>呢?</p>
<p>运行过程中会被即时编译器编译的“热点代码”有两类:</p>
<ol>
<li>被多次调用的方法。</li>
<li>被多次执行的循环体。</li>
</ol>
<p>两种情况，编译器都是以<strong>整个方法</strong>作为编译对象。这种编译方法因为编译发生在方法执行过程之中，因此形象的称之为栈上替换(On Stack Replacement，oSR)，即方法栈帧还在栈上，方法就被替换了。</p>
<h4 id="如何判断热点代码呢"><a href="#如何判断热点代码呢" class="headerlink" title="如何判断热点代码呢"></a>如何判断热点代码呢</h4><p>要知道方法或一段代码是不是热点代码，是不是需要触发即时编译，需要进行Hot Spot Detection(热点探测)。</p>
<p>目前主要的热点探测方式有以下两种:</p>
<ul>
<li>基于采样的热点探测<br><strong>采用这种方法的虚拟机会周期性地检查各个线程的栈顶，如果发现某些方法经常出现在栈顶，那这个方法就是”热点方法”。</strong>这种探测方法的好处是实现简单高效，还可以很容易地获取方法调用关系（将调用堆栈展开即可)，缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测。</li>
<li>基于计数器的热点探测<br><strong>采用这种方法的虚拟机会为每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的阀值，就认为它是”热点方法”</strong>，这种统计方法实现复杂一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系L它的统计结果相对更加精确严谨。</li>
</ul>
<h4 id="热点检测方式"><a href="#热点检测方式" class="headerlink" title="热点检测方式"></a>热点检测方式</h4><p>在HotSpot虚拟机中使用的是第二种―—基于计数器的热点探测方法，因此它为每个方法准备了两个计数器︰方法调用计数器和回边计数器。在确定虚拟机运行参数的前提下，这两个计数器都有一个确定的阈值，当计数器超过阈值溢出了，就会触发JIT编译。</p>
<p><strong>方法调用计数器</strong></p>
<p>顾名思义，这个计数器用于统计方法被调用的次数。</p>
<p><strong>回边计数器</strong></p>
<p>它的作用就是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为”回边”。</p>
<h3 id="JIT优化"><a href="#JIT优化" class="headerlink" title="JIT优化"></a>JIT优化</h3><h4 id="公共子表达式的消除"><a href="#公共子表达式的消除" class="headerlink" title="公共子表达式的消除"></a>公共子表达式的消除</h4><p>javac编译器不会对公共子表达式进行消除。进入即时编译器后，JIT会对公共子表达式进行消除，且还有可能进行代数替换，即将可以计算出的结果直接计算得到，进行优化。</p>
<h4 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h4><p>指的是：在JIT即时编译时，将方法调用直接使用方法体内的代码进行替换，从而减少方法调用过程中的压栈和入栈的开销。</p>
<p>当JVM检测到一些小方法频繁调用时，会使用方法内联进行优化。</p>
<h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h4><p>逃逸分析(Escape Analysis)是目前Java虚拟机中比较前沿的优化技术。这是一种可以有效减少]ava程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析. Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p>
<blockquote>
<p>个人理解：如果对象逃逸了，则无法对其进行优化，只能分配到堆上，如果没有逃逸，则可以将其分配到栈上。</p>
</blockquote>
<p><strong>逃逸分析的基本行为就是分析对象动态作用域:当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸。</strong></p>
<p>逃逸分析包括:</p>
<ul>
<li>全局变量赋值逃逸</li>
<li>方法返回值逃逸</li>
<li>实例引用发生逃逸</li>
<li>线程逃逸:赋值给类变量或可以在其他线程中访问的实例变量</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object object;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">globalVariableEscape</span><span class="params">()</span> </span>&#123;<span class="comment">//全局变量赋值逃逸</span></span><br><span class="line">	object =<span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">methodEscape</span><span class="params">()</span> </span>&#123; <span class="comment">//方法返回值逃逸</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">instancePassEscape</span><span class="params">()</span> </span>&#123;<span class="comment">//实例引用发生逃逸</span></span><br><span class="line">	<span class="keyword">this</span>.speak(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">(EscapeAna1ysis escapeAna1ysis)</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"Escape He11o"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法逃逸案例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title">createStringBuffer</span><span class="params">(String s1，String s2)</span> </span>&#123;</span><br><span class="line">	StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">	sb.append(s1);</span><br><span class="line">	sb.append(s2);</span><br><span class="line">	<span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>StringBuffer sb是一个方法内部变量，上述代码中直接将sb返回，这样这个StringBuffer有可能被其他方法所改变，这样它的作用域就不只是在方法内部，虽然它是一个局部变量，称其逃逸到了方法外部。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。</p>
</blockquote>
<p>上述代码如果想要StringBuffer sb不逃出方法，可以这样写:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createStringBuffer</span><span class="params">(String s1，String s2)</span> </span>&#123;</span><br><span class="line">	StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">	sb.append(s1);</span><br><span class="line">	sb.append(s2);</span><br><span class="line">	<span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不直接返回StringBuffer，那么StringBuffer将不会逃逸出方法。</p>
<p>使用逃逸分析，编译器可以对代码做如下优化:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一、同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</span><br><span class="line"></span><br><span class="line">二、将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分</span><br><span class="line">配的候选，而不是堆分配。</span><br><span class="line"></span><br><span class="line">三、分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分(或全</span><br><span class="line">部）可以不存储在内存，而是存储在CPU寄存器中。</span><br></pre></td></tr></table></figure>

<p>在Java代码运行时，通过JVM参数可指定是否开启逃逸分析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+DoEscapeAnalysis: open</span><br><span class="line">-XX:-DoEscapeAnalysis: close</span><br></pre></td></tr></table></figure>

<p>从jdk1.7开始默认开启逃逸分析。</p>
<h4 id="对象上的栈分配"><a href="#对象上的栈分配" class="headerlink" title="对象上的栈分配"></a>对象上的栈分配</h4><p>我们知道，在一般情况下，对象和数组元素的内存分配是在堆内存上进行的。但是随着JIT编译器的日渐成熟，很多优化使这种分配策略并不绝对。<strong>JIT编译器就可以在编译期间根据逃谗分析的结果，来决定是否可以将对象的内存分配从堆转化为栈。</strong></p>
<h4 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h4><p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存在类A</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 存在一方法使用类里的a和b</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getAB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	A x = <span class="keyword">new</span> A();</span><br><span class="line">	x.a;</span><br><span class="line">	x.b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译时JVM会直接编译成这样</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getAB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	a = <span class="number">1</span>;</span><br><span class="line">	b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这就是标量替换 */</span></span><br></pre></td></tr></table></figure>

<h4 id="同步锁消除"><a href="#同步锁消除" class="headerlink" title="同步锁消除"></a>同步锁消除</h4><p>同样基于逃逸分析，当加锁的变量不会发生逃逸，是线程私有的完全没有必要加锁。在JIT编译时期就可以将同步锁去掉，以减少加锁与解锁造成的资源开销。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLockEliminate</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">(String s1，String s2)</span> </span>&#123;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        sb.append(s1);</span><br><span class="line">        sb.append(s2);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> tsStart = System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">			getString( <span class="string">""</span>TestLockE1iminate <span class="string">"， "</span>suffix<span class="string">""</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"一共耗费: "</span>+ (System.currentTimeMillis() - tsStart) + <span class="string">"ms"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>getString()方法中的StringBuffer数以函数内部的局部变量，进作用于方法内部，不可能逃逸出该方法，因此他就不可能被多个线程同时访问，也就没有资源的竞争，但是StringBuffer的append操作却需要执行同步操作，代码如下:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">       toStringCache = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">super</span>.append(str);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>逃逸分析和锁消除分别可以使用参数-xX:+DOEscapeAnalysis和-XX:+EliminateLocks(锁消除必须在-server模式下)开启。</p>
<h3 id="带你认识一下class文件"><a href="#带你认识一下class文件" class="headerlink" title="带你认识一下class文件"></a>带你认识一下class文件</h3><h4 id="class文件概述"><a href="#class文件概述" class="headerlink" title="class文件概述"></a>class文件概述</h4><p>内容为16进制。开头为<code>CAFEBABE</code>魔数</p>
<p><img src="https://img.rruu.net/image/6021434267a6b" alt></p>
<h5 id="常量池数据区"><a href="#常量池数据区" class="headerlink" title="常量池数据区"></a>常量池数据区</h5><p><img src="https://img.rruu.net/image/6021439fcabec" alt></p>
<p>双亲委派：当类加载器碰到一个类时，需要交给其父类加载器加载，只有当其父类加载器无法加载时，自己才去尝试加载。</p>
<p>破坏双亲委派</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/07/antlr/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Bcutty Kmy">
      <meta itemprop="description" content="NO DEPENDENCE ONLY PRIDE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BBBBBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/07/antlr/" class="post-title-link" itemprop="url">ANTLR4 解析语法树 以及IDEA相关插件使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-12-07 13:40:20 / Modified: 13:37:42" itemprop="dateCreated datePublished" datetime="2020-12-07T13:40:20+08:00">2020-12-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/" itemprop="url" rel="index"><span itemprop="name">学习篇</span></a>
                </span>
            </span>

          
            <span id="/2020/12/07/antlr/" class="post-meta-item leancloud_visitors" data-flag-title="ANTLR4 解析语法树 以及IDEA相关插件使用" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2020/12/07/antlr/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/12/07/antlr/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ANTLR4-解析语法树-以及IDEA相关插件使用"><a href="#ANTLR4-解析语法树-以及IDEA相关插件使用" class="headerlink" title="ANTLR4 解析语法树 以及IDEA相关插件使用"></a>ANTLR4 解析语法树 以及IDEA相关插件使用</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先，写这篇博文主要是为了记录下我在用antlr+idea开发时遇到的坑点来帮助大家，希望大家不要走我的弯路，同时也是记录自己的一个写编译器历程。</p>
<h2 id="ANTLR简介"><a href="#ANTLR简介" class="headerlink" title="ANTLR简介"></a>ANTLR简介</h2><p>在这就给大家用我自己的话简单介绍一下antlr，就功能需求而言，其就是一个在你给定文法的前提下，能将输入串转换成语法树的工具。</p>
<p>也就是，你给定一个文法，再给定一个输入串，他能判断该输入串是否符合该文法，如果符合，就能将其生成为一棵语法树供你进一步使用。</p>
<h2 id="IDEA插件"><a href="#IDEA插件" class="headerlink" title="IDEA插件"></a>IDEA插件</h2><p>在idea的plugins中进行搜索ANTLR4应该就能搜到该插件，进行下载重启即可，如下图所示。</p>
<p><img src="https://i.loli.net/2020/12/07/ZjAPoifHLBvqDbg.png" alt="antlr.png"></p>
<p>重启后就能在下方工具栏看到ANTLR Preview和Tool Output两栏，也就是插件提供的功能。如何使用该插件在下文会提到。</p>
<h2 id="如何使用ANTLR"><a href="#如何使用ANTLR" class="headerlink" title="如何使用ANTLR"></a>如何使用ANTLR</h2><p>如何来使用该工具呢，首先当然是配置环境，因为本人是使用Java语言来进行开发的，所以只能配置一下maven的依赖即可，请一定注意，<strong>版本号应和上文下载的插件对应的最新版本号吻合</strong>，否则可能会有bug</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.antlr<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>antlr4-runtime<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后配置好环境后，下一步就是开始写文法。ANTLR专门的.g4后缀文件，用于写文法，在IDEA中随便找个目录新建一个xxx.g4文件即可，这里推荐大家将xxx的第一个字母大写，因为后面会根据该文件名生成对应的类，所以首字母大写会好一些。</p>
<p>在创建好.g4文件后，它的图标应该长这样，如下图</p>
<p><img src="https://i.loli.net/2020/12/07/MbxTp8vC4UH5qlP.png" alt="g4.png"></p>
<p>当然也有可能它不长那样(比如我自己的)，可能就是IDEA本身的问题了，像这样</p>
<p><img src="https://i.loli.net/2020/12/07/Hh6bC7vE9mzt8Q4.png" alt="c0.png"></p>
<p>如果遇到图标无法正常显示，那么插件的功能也就无法正常使用了，因为它没法在该文件中进行相关文法的检验。所以怎么解决呢？</p>
<p>我本人是通过在项目src/main/java目录里新建一个<strong>Scratch File</strong>，如下图：</p>
<p><img src="https://i.loli.net/2020/12/07/WQtogHCeP9EnZNA.png" alt="ss.png"></p>
<p><img src="https://i.loli.net/2020/12/07/NZO8ymUQhvTWpMg.png" alt="sss.png"></p>
<p>然后里面就应该有这样的画面，然后点击第一个创建，应该就能拿到正常图标显示的文件了，也可以进行相关插件的使用了。</p>
<p>然后在该文件中进行相关文法的书写，文法的书写规范这里就不再赘述了，大家可以自行找相关博客来学习，在我们成功完成文法的书写后，我们就可以开始生成相应的parser和lexer了。</p>
<p><strong>但是需要注意的是，ANTLR是不支持直接左递归文法的，需要进行改写。</strong></p>
<p>我们在g4文件处右键首先进行配置，选择Configure ANTLR</p>
<p><img src="https://i.loli.net/2020/12/07/D2Ff1sRdVTNa9hj.png" alt="sssss.png"></p>
<p>就应该会有这个页面</p>
<p><img src="https://i.loli.net/2020/12/07/MvTyVJp5UxXfZnC.png" alt="2s.png"></p>
<p>然我们在第一个框里选择想要导出的位置，一般是选择在项目中新建一个包，并选择该包，然后选择OK就行。</p>
<p>然后我们就可以点击上图的Generate ANTLR Recognizer进行类的生成了。生成成功应该如下图所示：</p>
<p><img src="https://i.loli.net/2020/12/07/D4RrNLZdokMqAWY.png" alt="cc.png"></p>
<p>其中Parser是语法分析的类，Lexer是词法分析的类，此时我们就已经可以开始通过输入一些字符串来检查是否符合我们的文法了。</p>
<p>我们就在一个Main方法中输入以下语句即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, RecognitionException </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">"xxx"</span>); <span class="comment">// 自行选择路径</span></span><br><span class="line">    InputStream in = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">    ANTLRInputStream input = <span class="keyword">new</span> ANTLRInputStream(in);</span><br><span class="line">    C0Lexer lex = <span class="keyword">new</span> C0Lexer(input);</span><br><span class="line">    CommonTokenStream tokens = <span class="keyword">new</span> CommonTokenStream(lex);</span><br><span class="line">    C0Parser parser = <span class="keyword">new</span> C0Parser(tokens);</span><br><span class="line">    C0Parser.ProgramContext tree = parser.program();</span><br><span class="line">    System.out.println(tree.toStringTree(parser));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果输入的字符串符合文法，那么就能正常输出一个生成的语法树了，如果不符合，那么插件也会自动帮你打印出错的位置，并且不会报错。</p>
<p><strong>如果想要它报错该怎么办呢？</strong>这也是当时困扰我很久的问题，想要其报错，我们就需要为其自己设计一个Listener来自定义错误处理。</p>
<p>我们就自己新建一个类，并继承BaseErrorListener类，并重载syntaxError方法即可，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyErrorListener</span> <span class="keyword">extends</span> <span class="title">BaseErrorListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syntaxError</span><span class="params">(Recognizer&lt;?, ?&gt; recognizer,</span></span></span><br><span class="line"><span class="function"><span class="params">                            Object offendingSymbol,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> line,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> charPositionInLine,</span></span></span><br><span class="line"><span class="function"><span class="params">                            String msg,</span></span></span><br><span class="line"><span class="function"><span class="params">                            RecognitionException e)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样在我们的Parser遇到不符合我们定义的文法时，就能报错并输出了。</p>
<h2 id="如何测试-g4文件"><a href="#如何测试-g4文件" class="headerlink" title="如何测试.g4文件"></a>如何测试.g4文件</h2><p>即通过插件我们可以测试自己设计的文法中的一个parser，而不用每次都执行main方法，我们只用在g4文件中选择一个parser，并右键选择Test Rule xxx即可，在idea下方就会自动出现一个弹窗用于测试了。</p>
<h2 id="拿到语法树下一步怎么办"><a href="#拿到语法树下一步怎么办" class="headerlink" title="拿到语法树下一步怎么办"></a>拿到语法树下一步怎么办</h2><p>我们经过一系列努力后，终于成功生成语法树了，那我们应该怎么处理这棵树呢？</p>
<p>antlr为我们提供了两种遍历语法树的方式，分别为Listener方式和Visitor方式。这两种方式的不同点在于，listener是其已经为你定义好怎么遍历了，而Visitor则需要你自己定义怎么去遍历。且listener的所有返回类型都为void，即不能通过方法返回值传参，而visitor可以自定义一个返回值类型，当然所有方法的返回值类型都是一样的。</p>
<p>不管要使用listener还是visitor方式，方法都是去继承对应antlr为我们生成的类，有xxxlistener和xxxvisitor，继承就可以了，然后选择自己想要重载的方法进行重载，进而就能实现自己想要的功能了。</p>
<p>对于listener和visitor，想要用其遍历自己生成的语法树，就通过以下代码即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, RecognitionException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    C0Parser.ProgramContext tree = parser.program();</span><br><span class="line">    <span class="comment">// visitor方式</span></span><br><span class="line">    YourVisitor visitor = <span class="keyword">new</span> YourVisitor();</span><br><span class="line">    visitor.visit(tree);</span><br><span class="line">    <span class="comment">// listener方式</span></span><br><span class="line">    ParseTreeWalker walker = <span class="keyword">new</span> ParseTreeWalker();</span><br><span class="line">    walker.walk(<span class="keyword">new</span> YourListener(), tree);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>

<p>如果上文存在谬误请一定不吝指出。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/29/%E5%8C%BA%E5%9D%97%E9%93%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Bcutty Kmy">
      <meta itemprop="description" content="NO DEPENDENCE ONLY PRIDE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BBBBBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/29/%E5%8C%BA%E5%9D%97%E9%93%BE/" class="post-title-link" itemprop="url">区块链普及</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-09-29 00:10:25 / Modified: 00:11:11" itemprop="dateCreated datePublished" datetime="2020-09-29T00:10:25+08:00">2020-09-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AF%87/" itemprop="url" rel="index"><span itemprop="name">学习篇</span></a>
                </span>
            </span>

          
            <span id="/2020/09/29/%E5%8C%BA%E5%9D%97%E9%93%BE/" class="post-meta-item leancloud_visitors" data-flag-title="区块链普及" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2020/09/29/%E5%8C%BA%E5%9D%97%E9%93%BE/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/09/29/%E5%8C%BA%E5%9D%97%E9%93%BE/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="区块链从零开始完全明白"><a href="#区块链从零开始完全明白" class="headerlink" title="区块链从零开始完全明白"></a>区块链从零开始完全明白</h1><p>写这篇博文是以一个大三学生的角度，以一些通俗一点的语言给大家普及一下什么是区块链，可能文章中很多说法存在错误以及问题，希望能包含并且提出，以便尽快改正。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>首先我们要了解什么是区块链以及为何需要区块链这个东西。</p>
<p>为了方便大家理解，这里先说用途，很简单，就是用来记账，也就是账本。为什么用区块链记账呢，好处是什么呢？好处是这个账本人手一个，且大家都一样并且无法被改变，并且每一笔账都能被找到。无法被改变就是其最厉害的地方。具体怎么实现的呢，我们后面会说到，大家先有个印象，不要将区块链想得太复杂，就是一个无法被改变的且无限大可以溯源的账本而已。</p>
<p>然后是什么是区块链，顾名思义，由区块组成的链。为什么能够记账呢，就是将交易的记录放在区块里罢了，然后再把区块用链连起来，就形成了区块链。</p>
<p>区块链还有一些好处，也就是分布式、去中心化。就如同不让一个人保存账本，要是这个人私自改了也没人知道，也就形成了麻烦。使用区块链就能避免这个问题。</p>
<h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>在详细了解区块链的知识之前，我们需要先了解一些加密相关的知识。</p>
<p>加密分为两类，对称加密和非对称加密。</p>
<p>什么是对称加密呢，通俗来讲就是一把锁，开锁和解锁是同一把钥匙，这就是对称加密。</p>
<p>那什么是非对称加密呢，加锁和解锁的钥匙不同，且需要成对使用，这就是非对称加密，同时，非对称加密加锁的钥匙称为公钥而解锁的钥匙称为私钥。公钥可以公开给所有人，但私钥需要自己保存。</p>
<p>这两种加密方式各有优缺点，对称加密，速度快，但是存在一个密钥如何传输的问题，我这上锁了，我要怎么把密钥安全的给你呢？而对于非对称加密则是安全性非常高但速度很慢。</p>
<p>所以区块链则将这两种技术结合起来，用非对称加密进行密钥的分发而对称加密用于数据传输。将传输的数据使用对称加密，然后将对称加密的密钥用交易的人提供的非对称加密的公钥加密，然后再传输给交易的人，然后交易的人拿到后通过自己的私钥解密获得密钥后，再解密得到相应的数据。从而结合两者优势，安全也迅速的完成数据的传输。</p>
<p>还有一个需要说明的地方，非对称加密中公钥和私钥除了用于加锁和解锁外，还有一个功能。即私钥用于签名，公钥用于验证。什么是签名呢，即表明这个东西是你提供的，你签了名，且这个签名被验证成功了，就表示这个东西就是你提供的。比如你要向你的老板给一份数据，但老板不知道这份数据是你给的，因为可能你把数据给你老板的中途被调换之类的，所以你就用你的私钥在这份数据上进行签名(签名不会暴露自己的私钥)，然后将公钥给你的老板，你的老板用公钥来验证这份数据上的签名，验证成功后，就能放心打开数据了。所以在区块链交易中，签名也是必不可少的一部分。</p>
<p>最后很重要的一部分就是加密的算法，我们这里就介绍哈希加密算法，常见的有MD5和SHA256/512，MD5已经比较过时了，现在用的基本是后者，256和512代表的是加密后的比特位，任何数据经过SHA256/512哈希算法加密后，都会形成256或者512位数据，且无法反推，且任何两个不同的数据会经过hash后得到的肯定是两个不同的256/512位的数据(哈希冲突在该算法中可以认为不存在)。然后这里再提一下签名，签名是将数据的哈希值通过一些算法进行签名，即和数据本身无关，因为签名只用证明发送方即可，和具体的数据无关。</p>
<h3 id="区块具体实现"><a href="#区块具体实现" class="headerlink" title="区块具体实现"></a>区块具体实现</h3><p>我们这里就开始正题说一下区块到底是什么。一个区块就可以看作一个矩形，分为两个部分，头部和身体部分，前面说到过区块里存交易记录，这个记录就存放在区块的身体部分里，存着一条又一条的记录。如下图</p>
<p><img src="https://i.loli.net/2020/09/28/NCYDgW7BO2KvAxL.png" alt="1.png"></p>
<p>那头部存什么东西呢，首先需要存这些所有交易记录的哈希值，即保证如果有一条记录发生任何改变，哈希值肯定发生变化，所以这就保证了交易记录的不可更改。其次需要存一个区块高度，什么是区块高度呢，也就是区块的编号，我们说过区块链是将区块一个个链起来，所以就存在前后顺序，即存在编号，所以还需要存一个编号。然后还需要存一个版本号，这个就不是很重要。同时交易记录的哈希值具体怎么得出的，我们后面还会具体说到和一个merkle tree相关。其次头部里还要存一个值，前面所有区块的总哈希值，即保证如果一个想要改变一个区块的记录，需要将其前面所有区块记录都改变，因为哈希值是唯一的，所以这也保证了所有区块中记录的不可改变且可溯源。最后头部里还要存一个很关键的值，nounce值，一个随机值，具体用来干嘛我们后面会一一道来。</p>
<p>所以区块链就可以简单看作下图</p>
<p><img src="https://i.loli.net/2020/09/28/3bc8JyBXvutlaj9.png" alt="2.png"></p>
<h3 id="比特币"><a href="#比特币" class="headerlink" title="比特币"></a>比特币</h3><p>将区块链肯定离不开比特币这个东西，也正是这个东西推动区块链的发展。</p>
<p>首先我们从一笔交易开始，假设这样一个场景，A从B处买了一台电脑，3500元，A付给B5000元，B找给A1400元，还剩下100元作为小费。(小费可以这样理解，你这笔交易想要尽快完成即想尽快A拿货B拿钱，就需要付小费，这笔小费是给矿工的)，这就是一次交易，但这样的交易在区块链中形成的交易记录是这样的，如下图</p>
<p><img src="https://i.loli.net/2020/09/28/B47WtFnpRbPaNcs.png" alt="3.png"></p>
<p>我们可以看到，其中小费的部分没有在其中体现出来，为什么呢，这就牵扯到下一个重要的点——矿工。</p>
<p>我们经常听到挖矿挖矿，所以到底什么是挖矿，什么又是矿呢？</p>
<p>首先我们需要明确，我们的交易，不是立马就完成的，只有当这笔交易记录在区块链上，也就是存在于某一个区块上，这笔交易才算完成。那区块是如何形成的呢，是算出来的，谁来算呢？怎么算呢？</p>
<p>矿工来算。矿工可以选择一些交易记录来形成区块，形成区块后，小费就归矿工了，所以矿工肯定会选择小费高的交易记录了，这也解释了为何A一定要给一部分小费。</p>
<p>那怎么形成区块呢，我们前面说过，区块头部里存了该区块所有交易的哈希值，以及前面所有区块的总哈希值，所以这两部分是无法改变的，也是现成的，要形成区块，这两部分是必须的，因为保证了交易的不可改变且可溯源。然后除了这两部分，还有一个东西，就是前面说到的nounce值，这三者结合再哈希得到的值，满足前多少多少位为0，则代表成功，就代表算对了，这个区块就能形成了。所以矿工是干嘛的，就是耗费电力、算力来随机生成这个nounce值，来使得三者的哈希值满足条件，进而形成区块。这个过程，就叫做挖矿，也可以用POW(工作量证明)来表示，表示你浪费了电力、物力来算这个nounce值，有资格获得小费，也就是比特币。</p>
<h3 id="交易广播"><a href="#交易广播" class="headerlink" title="交易广播"></a>交易广播</h3><p>前面比较笼统的说了相关交易和比特币以及挖矿的问题，这里我们就具体说下其实现问题。</p>
<p>一笔交易，形成后(还没有进入区块，只是A付了钱)，会向全网进行广播，也就是所有节点都收到了这笔交易的记录，节点对这个记录进行验证，也就是验证A是不是付了钱、B的账户地址等等问题，验证成功后，节点就将这个记录，放进交易缓存池，这个池子里放了很多的交易记录，但还没有形成区块，等着矿工去里面选呢，选小费高的记录去形成区块。这就是广播的第一个使用的地方。让这笔交易进入全网。</p>
<p>因为矿工是很多的，所以当几个矿工同时在计算该链上下一个区块时，就存在先后顺序了。我们用下图来表示</p>
<p><img src="https://i.loli.net/2020/09/28/h1EqtTXrSnxuWmK.png" alt="4.png"></p>
<p>可以看到，ABC同时计算一个区块，此时A先算出来了，他就会立刻进行广播表示自己算出来了，然后BC收到广播后，就会停止计算并验证A是否计算正确，正确了的话，就将这个区块上链了，然后大家重新去缓存池里拿交易上链。这就是一个竞争的过程。</p>
<p>还有一种情况，就是两个人一起完成了计算，因为只要保证算出来前几位为0即可，情况是很多的，所以可能两个不一样的区块但都满足条件。我们考虑AB同时计算出来，此时，又会如何呢，我们看下图</p>
<p><img src="https://i.loli.net/2020/09/28/d5yiGButSOYo7P8.png" alt="5.png"></p>
<p>区块链会将两个区块都上链，然后让大家继续计算，因为两个区块后面的区块大家也都能进行计算，所以会存在某个链上(A和B链)先生成下一个区块C的情况，例如A后先计算出来一个区块C，此时C就会进行广播了，广播后，B就被抛弃了，A+C作为主链了。当然如果B上先生成也是同理。此时另一个区块被抛弃后，里面的交易记录就重新回到了缓存池，那矿工的小费呢，下面继续说。</p>
<p>这就牵扯到区块验证问题了，因为存在这种同时计算出区块的问题，所以区块链中规定了，当前区块形成后，在该区块后再追加6个区块后，这个区块里的交易才算真正完成，矿工才能拿到钱，即保证这个区块不会被抛弃。那为何是6个区块呢，因为根据相关计算，在领先6个区块的情况下，不可能存在一个新的链(从那个区块开始)替代该链，即不会存在一个比该链更长的链来替代。进而保证交易的完成，小费也能成功进入矿工手里。</p>
<h3 id="merkle-tree"><a href="#merkle-tree" class="headerlink" title="merkle tree"></a>merkle tree</h3><p>然后这里再说一下前面提到的merkle tree，这是可以看作一个数据结构，也就是一个二叉树，但这个树是一棵完美二叉树。</p>
<p>这棵树是怎么形成的呢，所有的交易作为叶节点，然后两两进行哈希形成父节点，如果是奇数个叶节点，则会复制一个叶节点，使其自身和自身哈希，然后父节点也同样两两哈希，一直到形成一个根节点。而区块头部信息里，就存的是该根节点的值。</p>
<p>具体的实现可以参考这篇博文<a href="https://www.cnblogs.com/fengzhiwu/p/5524324.html" target="_blank" rel="noopener">merkle tree</a></p>
<p>然后这棵树有什么用呢，可以用来验证，验证什么呢，验证某一笔交易是否存在于区块链中，具体的验证方法，也就是和merkle tree原理相关。参考上面博文。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>希望这篇博文能对大家有所帮助。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/27/ubuntu%E8%A3%85rabbitmq/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Bcutty Kmy">
      <meta itemprop="description" content="NO DEPENDENCE ONLY PRIDE">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BBBBBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/27/ubuntu%E8%A3%85rabbitmq/" class="post-title-link" itemprop="url">Ubuntu安装RabbitMQ教程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-27 23:59:45" itemprop="dateCreated datePublished" datetime="2020-09-27T23:59:45+08:00">2020-09-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-28 00:28:26" itemprop="dateModified" datetime="2020-09-28T00:28:26+08:00">2020-09-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%85%8D%E7%BD%AE%E7%AF%87/" itemprop="url" rel="index"><span itemprop="name">配置篇</span></a>
                </span>
            </span>

          
            <span id="/2020/09/27/ubuntu%E8%A3%85rabbitmq/" class="post-meta-item leancloud_visitors" data-flag-title="Ubuntu安装RabbitMQ教程" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2020/09/27/ubuntu%E8%A3%85rabbitmq/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/09/27/ubuntu%E8%A3%85rabbitmq/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Ubuntu安装RabbitMQ教程"><a href="#Ubuntu安装RabbitMQ教程" class="headerlink" title="Ubuntu安装RabbitMQ教程"></a>Ubuntu安装RabbitMQ教程</h1><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>本篇主要给大家介绍ubuntu安装rabbitmq的过程以及相关遇到的坑，同时也避免自己忘记，所以写下这篇博文供大家学习。</p>
<h3 id="相关版本"><a href="#相关版本" class="headerlink" title="相关版本"></a>相关版本</h3><p>操作系统：Linux阿里云服务器</p>
<p>ubuntu：18.04（root用户）</p>
<p>rabbitmq：3.8.8</p>
<p>erlang：23.0.3（Ubuntu Xenial 64bit）</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h4 id="erlang安装"><a href="#erlang安装" class="headerlink" title="erlang安装"></a>erlang安装</h4><p>因为rabbitmq由erlang语言编写，所以安装之前需要安装erlang语言环境，由于ubuntu本身使用的apt-get源里的erlang比较老，所以这里我们是直接去官网下载安装。</p>
<p>首先进入erlang官网下载页</p>
<p><a href="https://www.erlang-solutions.com/resources/download.html" target="_blank" rel="noopener">https://www.erlang-solutions.com/resources/download.html</a></p>
<p>然后往下找到自己想要下载的版本，erlang的版本是根据rabbitmq的版本来的，可以查看rabbitmq官网中的Erlang Versions，<a href="https://www.rabbitmq.com/which-erlang.html" target="_blank" rel="noopener">点这里</a>来查看自己想下载的rabbitmq对应所支持的erlang版本，然后再到下载页面进行下载，同时需要注意自己系统的版本和相应的指令集（amd还是arm），如下图</p>
<p><img src="https://i.loli.net/2020/09/28/5qZCA4xUKTIVoJW.png" alt="1.png"></p>
<p>然后下载到自己电脑后，就通过相关shell传到自己的服务器里去，进入相应的目录，然后通过下面命令进行解压就可以了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -i esl-erlang_版本号_ubuntu_artful_amd64.deb</span><br></pre></td></tr></table></figure>
<p>当然可能会存在缺少相关依赖的情况，可通过以下命令进行相应依赖的安装，然后重新执行上面↑的命令就可以了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get -f install</span><br></pre></td></tr></table></figure>

<p>安装完成后，可以通过命令行输入<code>erl</code>命令查看自己是否安装成功以及安装的版本。如下图</p>
<p><img src="https://i.loli.net/2020/09/28/3wYV67ZJ4fTHONh.png" alt="2.png"></p>
<h4 id="rabbitmq安装"><a href="#rabbitmq安装" class="headerlink" title="rabbitmq安装"></a>rabbitmq安装</h4><p>然后erlang安装完成后我们就直接进入rabbitmq的安装，为了安装的方便，这里我也是选择的对相应的包进行下载后再安装的方式。</p>
<p>首先在服务器上安装好相关依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 更新</span><br><span class="line">apt-get update</span><br><span class="line"></span><br><span class="line">apt-get -y install socat logrotate init-system-helpers adduser</span><br><span class="line">apt-get -y install wget</span><br><span class="line"></span><br><span class="line"># 下载包</span><br><span class="line">wget https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.8/rabbitmq-server_3.8.8-1_all.deb</span><br><span class="line"></span><br><span class="line"># 安装</span><br><span class="line">dpkg -i rabbitmq-server_3.8.8-1_all.deb</span><br></pre></td></tr></table></figure>

<p>上面<code>wget https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.8/rabbitmq-server_3.8.8-1_all.deb</code>命令中的版本号可自己指定，然后因为该网站是外网，所以可能下载速度很慢，也可以选择自己在本地电脑访问相应的地址下载好后再通过shell传输到服务器进行安装，会更快一下。</p>
<p>然后安装完成后就可以通过以下命令对rabbitmq服务进行启动和关闭了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service rabbitmq-server start # 启动服务</span><br><span class="line">service rabbitmq-server stop # 停止服务</span><br><span class="line">service rabbitmq-server restart # 重启服务</span><br></pre></td></tr></table></figure>

<p>然后为了操作rabbitmq的方便，我们还可以开启管理界面，使用以下命令即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure>

<p>然后可以访问ip:15672来查看该页面了，如下图</p>
<p><img src="https://i.loli.net/2020/09/28/zkW5bhGHVmvyPYJ.png" alt="3.png"></p>
<p>然后该页面提供默认的账号密码进行登录，账户密码都是guest，但是因为rabbitmq的配置问题，他只允许本机登录，所以会出现无法登录的情况，这时就需要进行相关配置文件的配置</p>
<p>因为这个是高版本，所以没有默认创建配置文件，所以需要我们自己创建rabbitmq.conf文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/rabbitmq/rabbitmq.conf</span><br></pre></td></tr></table></figure>

<p>然后在github上复制或者下载配置文件模板，<a href="https://github.com/rabbitmq/rabbitmq-server/blob/v3.7.x/docs/rabbitmq.conf.example" target="_blank" rel="noopener">点这里</a>，然后进行相应的修改，将<strong>loopback_users.guest = false</strong>这一行前的##进行去除即可，如下图，</p>
<p><img src="https://i.loli.net/2020/09/28/CypmLvHd6PjTfuB.png" alt="4.png"></p>
<p>然后再进行登录就能成功了</p>
<p>然后相关的其他操作就靠大家自己摸索了</p>
<hr>
<p><strong><em>如有谬误请不吝指正，方便立马修改以防止误导他人</em></strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Bcutty Kmy</p>
  <div class="site-description" itemprop="description">NO DEPENDENCE ONLY PRIDE</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bcutty Kmy</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              leancloudSelector(url).innerText = 'Counter not initialized! More info at console err msg.';
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"2z9X7Dx6RjzhCEydcpBXNAF5-gzGzoHsz","app_key":"d4qtySNKtCjyy1f975pQrdgB","server_url":null,"security":true};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : '2z9X7Dx6RjzhCEydcpBXNAF5-gzGzoHsz',
      appKey     : 'd4qtySNKtCjyy1f975pQrdgB',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
